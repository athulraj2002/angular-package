import * as i0 from '@angular/core';
import { Pipe, InjectionToken, isDevMode, Injectable, Inject, EventEmitter, Component, Input, Output, ElementRef, HostBinding, ViewChild, NgModule, ViewEncapsulation, Renderer2, ChangeDetectorRef, HostListener, Directive, ChangeDetectionStrategy, ViewContainerRef, Optional, ComponentFactoryResolver, Injector } from '@angular/core';
import * as i1$1 from '@angular/router';
import { Router, RouterModule, NavigationEnd, NavigationStart, ActivatedRoute } from '@angular/router';
import { CommonModule, PlatformLocation, Location } from '@angular/common';
import * as i1 from '@angular/common/http';
import { HttpClient, HttpHeaders, HttpParams, HttpBackend, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { MatMenuModule, MatMenuTrigger } from '@angular/material/menu';
import { MatIconModule, MatIconRegistry } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { __awaiter } from 'tslib';
import { map, catchError, tap, debounceTime, filter } from 'rxjs/operators';
import { forkJoin, of, BehaviorSubject, Observable, Subject } from 'rxjs';
import { FormControl, Validators, FormGroup, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import * as i2 from '@angular/material/snack-bar';
import { MAT_SNACK_BAR_DATA, MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatRippleModule, DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MatNativeDateModule } from '@angular/material/core';
import { MatListModule } from '@angular/material/list';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatCardModule } from '@angular/material/card';
import { MatDatepickerModule, MatCalendar, MatDatepicker, MatDateRangePicker } from '@angular/material/datepicker';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatPaginatorModule, MatPaginator } from '@angular/material/paginator';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatRadioModule } from '@angular/material/radio';
import { MatSelectModule } from '@angular/material/select';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatSortModule, MatSort } from '@angular/material/sort';
import * as i1$2 from '@angular/material/dialog';
import { MatDialog, MatDialogModule, MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { MatTableModule, MatTableDataSource } from '@angular/material/table';
import { MatTabsModule } from '@angular/material/tabs';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatSliderModule } from '@angular/material/slider';
import { Overlay, OverlayContainer } from '@angular/cdk/overlay';
import { NgxMaskModule } from 'ngx-mask';
import { trigger, state, style, transition, group, animate } from '@angular/animations';
import { SelectionModel } from '@angular/cdk/collections';
import { ScrollingModule } from '@angular/cdk/scrolling';
import { MatDividerModule } from '@angular/material/divider';
import * as spacetime from 'spacetime/builds/spacetime.min';
import { ComponentPortal, CdkPortalOutlet, PortalModule } from '@angular/cdk/portal';
import { moveItemInArray, transferArrayItem, DragDropModule } from '@angular/cdk/drag-drop';
import { DomSanitizer } from '@angular/platform-browser';

class PhonePipe {
    transform(val, args = null) {
        if (!args)
            args = '(XXX) XXX-XXXX';
        if (typeof val === 'string' && String(val).length) {
            let viewVal = String(val).trim();
            viewVal = viewVal.replace(/^\+/, '');
            viewVal = viewVal.replace(/[^0-9]/g, '');
            viewVal = viewVal.slice(0, (args.match(/X/g) || []).length);
            let number = args;
            const digits = viewVal.split('');
            let index = 0;
            digits.forEach(function (digit) {
                index = number.indexOf('X');
                if (index >= 0) {
                    number = number.substr(0, index) + digit + number.substr(index + 1);
                }
            });
            let limit = args.length;
            if (index != -1)
                limit = index + 1;
            return number.substr(0, limit);
        }
        return val;
    }
}
PhonePipe.decorators = [
    { type: Pipe, args: [{
                name: 'phone'
            },] }
];

class ToYesNoPipe {
    transform(value) {
        return value ? 'Yes' : 'No';
    }
}
ToYesNoPipe.decorators = [
    { type: Pipe, args: [{ name: 'toYesNo', pure: true },] }
];

let ServiceInjector;
function SetServiceInjector(injector) {
    if (!ServiceInjector)
        ServiceInjector = injector;
}
let PopEntity;
function SetPopEntity(entity) {
    if (!PopEntity)
        PopEntity = entity;
}
let PopHistory;
function SetPopHistory(history) {
    if (!PopHistory)
        PopHistory = history;
}
let PopPipe;
function SetPopPipe(pipe) {
    if (!PopPipe)
        PopPipe = pipe;
}
let PopDate;
function SetPopDate(date) {
    if (!PopDate)
        PopDate = date;
}
let PopLog;
function SetPopLogger(log) {
    if (!PopLog)
        PopLog = log;
}
let PopEnv;
function SetPopEnv(env) {
    if (!PopEnv)
        PopEnv = env;
}
let PopComponentResolver;
function SetPopComponentResolver(cfr) {
    if (!PopComponentResolver)
        PopComponentResolver = cfr;
}
let PopRequest;
function SetPopRequest(request) {
    if (!PopRequest)
        PopRequest = request;
}
let PopExternalApi;
function SetPopExternalApi(api) {
    if (!PopExternalApi)
        PopExternalApi = api;
}
let PopPortal;
function SetPopPortal(portal) {
    if (!PopPortal)
        PopPortal = portal;
}
let PopHref;
function SetPopHref(href) {
    if (href && typeof href === 'string') {
        PopHref = href;
    }
}
let PopMessage;
function SetPopMessage(message) {
    if (message && typeof message === 'string') {
        PopMessage = message;
    }
    else {
        PopMessage = undefined;
    }
}
let PopCacheRedirectUrl;
function SetPopCacheRedirectUrl(router = null, url = null) {
    if (router instanceof Router) {
        if (!url)
            url = router.url;
        PopCacheRedirectUrl = url;
        router.navigateByUrl('system/cache/clear', { skipLocationChange: true }).catch((e) => {
            console.log('e', e);
        });
    }
    else {
        PopCacheRedirectUrl = undefined;
    }
}
let PopAuth;
function SetPopAuth(auth) {
    if (auth && typeof auth === 'object' && auth !== null && Object.keys(auth).length) {
        PopAuth = JSON.parse(JSON.stringify(auth));
    }
}
let PopBusiness;
function SetPopBusiness(business) {
    if (business && typeof business === 'object' && business !== null && Object.keys(business).length) {
        PopBusiness = JSON.parse(JSON.stringify(business));
    }
}
let PopApp;
function SetPopApp(app) {
    if (app && typeof app === 'object' && app !== null && Object.keys(app).length) {
        PopApp = JSON.parse(JSON.stringify(app));
    }
}
let PopUser;
function SetPopUser(user) {
    if (user && typeof user === 'object' && user !== null && Object.keys(user).length) {
        PopUser = JSON.parse(JSON.stringify(user));
    }
}
let PopFilter = {};
function SetPopFilter(filter) {
    if (typeof filter === 'object' && filter !== null) {
        PopFilter = filter;
    }
}
let PopSchemeComponent;
function SetPopSchemeComponent(schemeComponent) {
    if (!PopSchemeComponent)
        PopSchemeComponent = schemeComponent;
}
let PopRouteAliasMap;
function SetPopRouteAliasMap(aliasMap) {
    if (aliasMap && typeof aliasMap === 'object')
        PopRouteAliasMap = aliasMap;
}
let PopAliasRouteMap = {};
function SetPopAliasRouteMap(routeMap) {
    if (routeMap && typeof routeMap === 'object')
        PopAliasRouteMap = routeMap;
}
let PopTemplate;
function SetPopTemplate(srv) {
    if (!PopTemplate)
        PopTemplate = srv;
}
const FIELD_CUSTOM_SETTING = new InjectionToken('Field Custom Setting', {
    providedIn: 'root',
    factory: () => ({})
});
class CoreConfig {
    constructor(params) {
        this.flag = {};
        this.resource = {};
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.metadata)
            this.metadata = {};
    }
}
class EntityParams {
    constructor(params) {
        this.api = ''; // the api path of this entityId http:server/app/<api>
        this.can_extend = false;
        this.path = '';
        this.param = '';
        this.refresh = false;
        this.blockAssets = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}
class EntityExtendInterface {
}
class SchemeComponentParams {
    constructor(params) {
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}
class SchemeComponentConfig {
    constructor(params) {
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}
class ResourceConfig {
    constructor(params) {
        this.defaultValue = null;
        this.api_cache = false;
        this.api_version = 1;
        this.api_path = '';
        this.api_path_vars = null;
        this.data_values = [];
        this.data_filter = null;
        this.data_when = null;
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}
// ********************* Fields *************************************************
class FieldItemInterface {
}
class FieldItemConfig {
    constructor(config) {
        this.custom_setting = {};
        this.setting = {};
        for (const i in config)
            this[i] = config[i];
    }
}
class FieldConfig {
    // onEvent: Subject<PopBaseEventInterface>;
    constructor(params) {
        this.canAdd = false;
        this.canRemove = false;
        this.custom_setting = {};
        this.data = {};
        this.data_keys = [];
        this.facade = false;
        this.entries = [];
        this.metadata = {};
        this.multiple = false;
        this.multiple_min = 1;
        this.multiple_max = 1;
        this.multiple_max_limit = 10;
        this.id = null;
        this.name = '';
        this.show_name = true;
        this.options = {};
        this.setting = {};
        this.sort = 99;
        this.state = 'template_edit';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.options)
            this.options = {};
    }
}
class FieldGroupConfig {
    constructor(params) {
        this.header = '';
        this.border = false;
        this.position = 'left';
        this.debug = false;
        this.layout = 'column';
        this.metadata = {}; // Any metadata desired.
        this.fields = [];
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}
class SectionConfig {
    constructor(params) {
        this.path = '';
        this.inputs = {};
        this.visible = true;
        this.require_refresh = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.name)
            this.name = this.id.replace(/_/g, ' ').replace(/(?:^|\s)\S/g, function (a) {
                return a.toUpperCase();
            });
        if (!this.path)
            this.path = this.id.replace(/_/g, '-').toLowerCase();
        if (!this.metadata)
            this.metadata = {};
    }
}
class TabSectionBarConfig {
    constructor(params) {
        this.access = {
            can_create: false,
            can_read: false,
            can_update: false,
            can_delete: false,
            can_destroy: false,
        };
        this.name = '';
        this.sections = [];
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.metadata)
            this.metadata = {};
    }
}
/**
 * Method to travel up dom of element until a height is found
 * @param el
 */
function ParentHeightSetter(el, className = null) {
    let height = 0;
    let maxHeight = 0;
    let attempts = 20;
    if (el && el.nativeElement && el.nativeElement.parentElement) {
        let parent = el.nativeElement.parentElement;
        while (!height && attempts) {
            if (parent.clientHeight) {
                if (parent.clientHeight > maxHeight) {
                    maxHeight = parent.clientHeight;
                }
                if (className) {
                    if (parent.classList && parent.classList.contains(className)) {
                        height = parent.clientHeight;
                    }
                }
                else {
                    height = parent.clientHeight;
                }
            }
            if (!height && parent.parentElement) {
                parent = parent.parentElement;
            }
            attempts--;
        }
    }
    if (!height && maxHeight)
        height = maxHeight;
    return height;
}

class ToActiveOrArchivedPipe {
    /**
     * If value is true, then that would indicate that is archived
     * @param value
     */
    transform(value) {
        if (value === 'true' || value === '1')
            value = true;
        if (value === 'false' || value === '0')
            value = false;
        return value && value !== null ? 'Archived' : 'Active';
    }
}
ToActiveOrArchivedPipe.decorators = [
    { type: Pipe, args: [{ name: 'toActiveOrArchived', pure: true },] }
];

class LabelPipe {
    constructor() {
        this.aliases = [];
    }
    /**
     * Provides the actual name we want displayed to the user.
     * text - The field name coming from the DB.
     * displayInfo - Either a string or object. If object then will look for property display or label. Takes aliases into account. IE: account:ID
     * set - If passed will look in the displayInfo object for this field before falling back to the display or label field.
     * returns {string}
     */
    transform(text, displayInfo = '', displayField = '') {
        let displayString = '';
        if (displayInfo && typeof displayInfo === 'string') {
            displayString = displayInfo;
        }
        else if (displayInfo && displayField && displayInfo[displayField]) {
            displayString = displayInfo[displayField];
        }
        else if (displayInfo && displayInfo.display) {
            displayString = displayInfo.display;
        }
        else if (displayInfo && displayInfo.label) {
            displayString = displayInfo.label;
        }
        // Check for aliases.
        if (displayString) {
            if (displayString.includes('alias:')) {
                const aliasArray = displayString.split(':');
                aliasArray.shift();
                const alias = this.getAlias(aliasArray.shift()).toLocaleLowerCase();
                displayString = alias.charAt(0).toUpperCase() + alias.slice(1) + ' ';
                let tempString = '';
                while (tempString = aliasArray.shift())
                    displayString += ' ' + tempString;
            }
        }
        else {
            // Format the string base on the field name.
            const words = text.split('_');
            for (const word of words) {
                if (word === 'id' || word === 'fk') {
                    displayString += 'ID ';
                }
                else {
                    displayString += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
                }
            }
        }
        return displayString.trim();
    }
    getAlias(entity) {
        return (this.aliases[entity] ? this.aliases[entity] : entity);
    }
}
LabelPipe.decorators = [
    { type: Pipe, args: [{ name: 'label', pure: true },] }
];

/************************************************************************************************
 *                                                                                              *
 *                                      Local Storage                                           *
 *                                                                                              *
 ************************************************************************************************/
/**
 * Store a value in localStorage for the site
 * @param siteVarPath - This should always follow a dot notation that represents the structure of an object App.Setting.value
 * @param siteVal
 */
function SetSiteVar(siteVarPath, siteVal) {
    if (IsString(siteVarPath, true) && siteVarPath.includes('.') && IsDefined(siteVal)) {
        // if( IsObject(siteVal) || IsArray(siteVal) ) siteVal = JSON.stringify(siteVal);
        const steps = siteVarPath.split('.');
        const basePath = steps.shift();
        if (basePath) {
            const baseStorage = JSON.parse(localStorage.getItem(basePath) || '{}');
            const key = steps.length ? steps.pop() : basePath;
            const pathStorage = steps.length ? StorageSetter(baseStorage, steps) : baseStorage;
            if (pathStorage && key) {
                if (siteVal === null) {
                    delete pathStorage[key];
                }
                else {
                    pathStorage[key] = siteVal;
                }
                localStorage.setItem(basePath, JSON.stringify(baseStorage));
            }
        }
    }
}
/**
 * Get stored value in localStorage for the site
 * @param siteVarPath - This should always follow a dot notation that represents the structure of an object App.Setting.value
 * @param defaultValue
 * @constructor
 */
function GetSiteVar(siteVarPath, defaultValue = null) {
    if (IsString(siteVarPath, true) && siteVarPath.includes('.')) {
        const steps = siteVarPath.split('.');
        const basePath = steps.shift();
        if (basePath) {
            const key = steps.length ? steps.pop() : basePath;
            // console.log('basePath ', basePath, ' key', key);
            const baseStorage = JSON.parse(localStorage.getItem(basePath) || '{}');
            // console.log('baseStorage', basePath, baseStorage);
            const pathStorage = steps.length ? StorageSetter(baseStorage, steps) : baseStorage;
            // console.log('pathStorage', pathStorage);
            if (pathStorage && key) {
                const value = typeof pathStorage[key] !== 'undefined' ? pathStorage[key] : defaultValue;
                // console.log('GetSiteVar', siteVarPath, value, typeof value);
                return value;
            }
            else {
                return defaultValue;
            }
        }
    }
    return defaultValue;
}
function GetRouteAlias(internal_name, type = 'plural') {
    if (IsString(internal_name, true)) {
        if (IsObject(PopRouteAliasMap, [internal_name])) {
            return PopRouteAliasMap[internal_name][type];
        }
        else {
            let alias = SnakeToPascal(internal_name);
            alias = SpaceToHyphenLower(alias);
            if (type === 'plural') {
                if (alias.slice(-1) !== 's')
                    alias = `${alias}s`;
            }
            return alias;
        }
    }
    return internal_name;
}
/************************************************************************************************
 *                                                                                              *
 *                                      Session Storage                                         *
 *                                                                                              *
 ************************************************************************************************/
/**
 * Set a session variable for the site
 * @param siteVarPath - This should always follow a dot notation that represents the structure of an object App.Setting.value
 * @param siteVal
 * @constructor
 */
function SetSessionSiteVar(siteVarPath, siteVal) {
    if (IsString(siteVarPath, true) && siteVarPath.includes('.') && IsDefined(siteVal)) {
        // if( IsObject(siteVal) || IsArray(siteVal) ) siteVal = JSON.stringify(siteVal);
        const steps = siteVarPath.split('.');
        const basePath = steps.shift();
        if (basePath) {
            const key = steps.length ? steps.pop() : basePath;
            const baseStorage = JSON.parse(sessionStorage.getItem(basePath) || '{}');
            const pathStorage = steps.length ? StorageSetter(baseStorage, steps) : baseStorage;
            if (pathStorage && key) {
                if (siteVal === null) {
                    delete pathStorage[key];
                }
                else {
                    pathStorage[key] = siteVal;
                }
                sessionStorage.setItem(basePath, JSON.stringify(baseStorage));
                // console.log('SetSessionSiteVar', basePath, baseStorage);
            }
        }
    }
}
/**
 * Get a stored session variable for the site
 * @param siteVarPath - This should always follow a dot notation that represents the structure of an object App.Setting.value
 * @param defaultValue - Return this value if a stored value is not found
 * @constructor
 */
function GetSessionSiteVar(siteVarPath, defaultValue = null) {
    if (IsString(siteVarPath, true) && siteVarPath.includes('.')) {
        const steps = siteVarPath.split('.');
        const basePath = steps.shift();
        if (basePath) {
            const key = steps.length ? steps.pop() : basePath;
            const baseStorage = JSON.parse(sessionStorage.getItem(basePath) || '{}');
            const pathStorage = steps.length ? StorageSetter(baseStorage, steps) : baseStorage;
            if (pathStorage && key) {
                const value = typeof pathStorage[key] !== 'undefined' ? pathStorage[key] : defaultValue;
                // console.log('GetSessionSiteVar', siteVarPath, value, typeof value);
                return value;
            }
            else {
                return defaultValue;
            }
        }
    }
    return defaultValue;
}
/**
 * Get a stored session variable for the site that has been base64 encoded
 * @param siteVarPath
 * @param defaultValue
 * @constructor
 */
function GetEncodedSessionSiteVar(siteVarPath, defaultValue = null) {
    let siteVar = GetSessionSiteVar(siteVarPath, defaultValue);
    if (IsString(siteVar, true)) {
        try {
            siteVar = JSON.parse(atob(siteVar));
        }
        catch (e) {
            siteVar = null;
        }
    }
    else {
        siteVar = null;
    }
    return siteVar;
}
/**
 * Deep Copy an Object
 * @param obj
 */
function DeepCopy(obj) {
    let copy;
    // Handle the 3 simple types, and null or undefined
    if (null == obj || 'object' != typeof obj)
        return obj;
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (let i = 0, len = obj.length; i < len; i++) {
            copy[i] = DeepCopy(obj[i]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (const attr in obj) {
            if (obj.hasOwnProperty(attr))
                copy[attr] = DeepCopy(obj[attr]);
        }
        return copy;
    }
    throw new Error('Unable to copy obj! Its type isn\'t supported.');
}
function RandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function JsonCopy(x) {
    return JSON.parse(JSON.stringify(x));
}
/**
 * Deep merge two objects.
 * @param target
 * @param ...sources
 */
function DeepMerge(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    if (IsObject(target) && IsObject(source)) {
        for (const key in source) {
            if (IsObject(source[key])) {
                if (!target[key])
                    Object.assign(target, { [key]: {} });
                DeepMerge(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return DeepMerge(target, ...sources);
}
/**
 * Helper Function to prepare an array to used as an option set for a field item
 * @param arr
 * @param params
 */
function ConvertArrayToOptionList(arr, params = {}) {
    if (!params.key)
        params.key = 'id';
    if (!params.setKey)
        params.setKey = 'value';
    if (!params.nameKey)
        params.nameKey = 'name';
    if (!params.tags)
        params.tags = null;
    if (!params.prevent)
        params.prevent = [];
    if (!params.parent)
        params.parent = null;
    if (!params.groupKey)
        params.groupKey = 'group';
    if (!params.activeKey)
        params.activeKey = 'active';
    if (!params.preserveKeys)
        params.preserveKeys = [];
    // if( typeof params.level === 'undefined') params.level = 1;
    if (params.converted)
        return arr.slice();
    let optionList = [];
    let listOption;
    let ensureOptionFound = false;
    if (Array.isArray(arr) && arr.length) {
        // check if this list has already be converted to the option list structure, so it does not get re-run
        let tmpArr = [...arr];
        const first = tmpArr[0];
        if (params.key === 'id' && typeof first.id === 'undefined' && typeof first.value !== 'undefined')
            params.key = 'value';
        if (typeof first[params.activeKey] !== 'undefined') {
            tmpArr = tmpArr.filter((item) => item[params.activeKey]);
        }
        if (typeof first[params.nameKey] === 'undefined' && first.name) {
            params.nameKey = 'name';
        }
        tmpArr.map((item) => {
            if (item && params.key in item && params.prevent.indexOf(item[params.key]) === -1) {
                if (params.parent) {
                    if (params.parent.field in item && +item[params.parent.field] === +params.parent.value) {
                        // continue
                    }
                    else {
                        return false;
                    }
                }
                listOption = { name: item[params.nameKey], sort_order: item.sort };
                listOption[params.setKey] = item[params.key];
                if (params.preserveKeys.length) {
                    params.preserveKeys.map(preserveKey => {
                        listOption[preserveKey] = item[preserveKey] ? item[preserveKey] : undefined;
                    });
                }
                if (typeof item['level'] === 'number') {
                    listOption.level = item['level'];
                }
                else if (params.level) {
                    listOption.level = params.level;
                }
                if (typeof item[params.groupKey] === 'string') {
                    listOption.group = item[params.groupKey] ? item[params.groupKey] : params.group ? item[params.groupKey] : '';
                }
                if (typeof params.groupFkKey === 'string') {
                    listOption.groupFk = item[params.groupFkKey] ? item[params.groupFkKey] : 0;
                }
                if (params.ensure && params.ensure.id && !ensureOptionFound && params.ensure[params.setKey] === item[params.setKey]) {
                    ensureOptionFound = true;
                }
                if (params.tags) {
                    params.tags.map((tag) => {
                        if (tag in item) {
                            listOption[tag] = item[tag];
                        }
                    });
                }
                if (listOption[params.setKey])
                    optionList.push(listOption);
            }
        });
        if (params.ensure && !ensureOptionFound) {
            optionList.push(params.ensure);
        }
        if (params.sort && optionList.length > 1) {
            if (typeof optionList[0].sort_order !== 'undefined') {
                optionList.sort((a, b) => {
                    if (a.sort_order < b.sort_order)
                        return -1;
                    if (a.sort_order > b.sort_order)
                        return 1;
                    return 0;
                });
            }
            else {
                optionList.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            }
        }
    }
    // add empty option only if the optionList is empty !IsArray(optionList,true)
    // remove any duplicates
    // return optionList;
    return [...new Map(optionList.map(item => [item['name'], item])).values()];
}
/**
 * Helper to get an nested value out of an object
 * @param storage - The base object you want to reach into
 * @param steps  - the nested path to the find the value you are looking for
 * @param defaultValue Set a default value to return if value is not found
 */
function StorageGetter(storage, steps, defaultValue = null) {
    if (IsObject(storage, true)) {
        let pathLength = steps.length;
        let path;
        while (pathLength) {
            path = steps.shift();
            if (!storage[path]) {
                return defaultValue;
            }
            storage = storage[path];
            pathLength--;
        }
        if (!storage) {
            return defaultValue;
        }
    }
    else {
        return defaultValue;
    }
    return storage;
}
/**
 * Helper to set a storage container into a nested location in an object
 * @param storage - The base object you want to reach into
 * @param steps  - the nested path to the find the value you are looking for
 * @param defaultValue Set a default value to return if value is not found
 */
function StorageSetter(storage, steps) {
    let pathLength = steps.length;
    let path;
    while (pathLength) {
        path = steps.shift();
        if (!storage[path]) {
            storage[path] = {};
        }
        storage = storage[path];
        pathLength--;
    }
    return storage;
}
function Sleep(milliseconds) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}
/**
 * Sort helper for a list of objects where the sort needs to be done on a specific property
 * @param key
 * @param order
 */
function DynamicSort(key, order = 'asc') {
    return function (a, b) {
        if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
            // property doesn't exist on either object
            return 0;
        }
        const varA = (typeof a[key] === 'string') ?
            a[key].toUpperCase() : a[key];
        const varB = (typeof b[key] === 'string') ?
            b[key].toUpperCase() : b[key];
        let comparison = 0;
        if (varA > varB) {
            comparison = 1;
        }
        else if (varA < varB) {
            comparison = -1;
        }
        return ((order == 'desc') ? (comparison * -1) : comparison);
    };
}
/**
 * Check if the values of two arrays contain the same items
 * This is way to get around the order not being the same, but the items are the same
 * @param arr1
 * @param arr2
 * @param field
 */
function ArraysMatch(arr1, arr2, field) {
    if (arr1.length !== arr2.length)
        return false;
    if (field) {
        for (let i = arr1.length; i--;) {
            if (arr1[i][field] !== arr2[i][field])
                return false;
        }
    }
    else {
        for (let i = arr1.length; i--;) {
            if (arr1[i] !== arr2[i])
                return false;
        }
    }
    return true;
}
/**
 * Check if an array contains a list of key:value pairs
 * @param needles
 * @param haystack
 * @param strict
 */
function ArrayContainsAll(needles, haystack, strict = false) {
    haystack = haystack.map(function (hay) {
        return String(hay).toLowerCase().trim();
    });
    if (strict) {
        for (let i = 0, len = needles.length; i < len; i++) {
            needles[i] = String(needles[i]).toLowerCase().trim();
            if (haystack.indexOf(needles[i]) === -1)
                return false;
        }
    }
    else {
        const need = needles.length;
        let match;
        let met = 0;
        needles.forEach(function (needle) {
            // loop over the blacklisted terms
            match = null;
            haystack.some(function (str) {
                if (String(str).toLowerCase().trim().indexOf(needle) > -1) {
                    match = true;
                    return true;
                }
            });
            if (match) {
                met++;
            }
        });
        return met >= need;
    }
    return true;
}
/**
 * Create a map of an array of objects using a specific property
 * @param arr
 * @param array_key_field
 */
function ArrayMapSetter(arr, array_key_field) {
    const map = {};
    if (Array.isArray(arr)) {
        arr.forEach((value, index) => {
            if (value[array_key_field])
                map[value[array_key_field]] = index;
        });
    }
    return map;
}
/**
 * Sort an array by a parent_id
 * @param arr
 * @param parentId
 * @param result
 * @param itemKey
 * @param parentKey
 * @constructor
 */
function ArrayParentSort(arr, parentId = 0, result = [], itemKey = 'id', parentKey = 'parent_id') {
    if (IsArray(arr, true)) {
        arr.map(item => {
            if (+item[parentKey] === +parentId) {
                result.push(item);
                ArrayParentSort(arr, item[itemKey], result, itemKey, parentKey);
            }
        });
    }
    return result;
}
/**
 * Convert an array to a nested array
 * @param data
 * @param itemKey
 * @param parentKey
 * @constructor
 */
function ArrayTreeList(data, itemKey = 'id', parentKey = 'parent_id') {
    const map = {};
    const roots = [];
    let node;
    let i;
    for (i = 0; i < data.length; i += 1) {
        map[data[i][itemKey]] = i; // initialize the map
        data[i].children = []; // initialize the children
    }
    for (i = 0; i < data.length; i += 1) {
        node = data[i];
        if (node[parentKey] !== 0) {
            // if you have dangling branches check that map[node.parentId] exists
            data[map[node[parentKey]]].children.push(node);
        }
        else {
            roots.push(node);
        }
    }
    return roots;
}
/**
 * Flatten an array that has parent/child relationship
 * @param list
 * @param result
 * @param level
 * @param itemKey
 * @param parentKey
 * @constructor
 */
function ArrayParentTreeFlatten(list, result = [], level = 0, itemKey = 'id', parentKey = 'parent_id') {
    let children;
    if (IsArray(list, true)) {
        list.map((item) => {
            children = item.children;
            delete item.children;
            item.level = level;
            result.push(item);
            if (IsArray(children, true)) {
                ArrayParentTreeFlatten(children, result, level + 1);
            }
        });
    }
    return result;
}
/**
 * Create an array with parent child relations
 * @param data
 * @param parentId
 * @param result
 * @param tree
 * @param itemKey
 * @param parentKey
 * @param flatten
 * @constructor
 */
function ArrayParentTree(data, parentId = 0, result = [], tree, itemKey = 'id', parentKey = 'parent_id', flatten = false) {
    data = ArrayParentSort(data, parentId, result, itemKey, parentKey);
    data = ArrayTreeList(data, itemKey, parentKey);
    return data;
}
/**
 * Create a map of list of object keyed by an object property
 * @param arr
 * @param array_key_field
 */
function ArrayKeyBy(arr, key) {
    const keyBy = {};
    if (IsArray(arr, true) && IsString(key, true)) {
        arr.map(x => {
            if (IsDefined(x[key]))
                keyBy[x[key]] = x;
        });
    }
    return keyBy;
}
/**
 * Determine if an object is an array
 * @param arr
 * @param requireLength - Requires that it is an array but also has values
 */
function IsArray(arr, requireLength = false) {
    if (Array.isArray(arr)) {
        if (requireLength) {
            if (arr.length) {
                return true;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
function IsArrayThrowError(arr, requireLength = false, throwError) {
    const isArray = IsArray(arr, requireLength);
    if (!isArray) {
        if (IsObject(PopLog)) {
            if (PopLog.enabled('error')) {
                console.log(PopLog.message(`IsArrayError: Fail`), PopLog.color('error'), {
                    data: arr,
                    requireLength: requireLength,
                    name: throwError
                });
            }
        }
        throw new Error(throwError);
    }
    return isArray;
}
/**
 * Convert an Object to an Array
 * @param obj
 */
function ToArray(obj) {
    if (typeof obj === 'object' && Object.keys(obj).length) {
        return Object.keys(obj).map(function (key) {
            return obj[key];
        });
    }
    return [];
}
/**
 * Check if a var is undefined
 * @param x
 */
function IsUndefined(x) {
    if (typeof x === 'undefined')
        return true;
    return false;
}
/**
 * Check if a var is defined
 * @param x
 */
function IsDefined(x, allowNull = true) {
    if (x === null && !allowNull)
        return false;
    if (typeof x === 'undefined')
        return false;
    return true;
}
/**
 * Convert an Array to an object
 * @param obj
 */
function ToObject(arr) {
    if (arr && Array.isArray(arr) && arr.length) {
        const rv = {};
        for (let i = 0; i < arr.length; ++i)
            rv[i] = arr[i];
        return rv;
    }
    return arr;
}
function ObjectsMatch(x, y) {
    if (x === null || x === undefined || y === null || y === undefined) {
        return x === y;
    }
    // after this just checking type of one would be enough
    if (x.constructor !== y.constructor) {
        return false;
    }
    // if they are functions, they should exactly refer to same one (because of closures)
    if (x instanceof Function) {
        return x === y;
    }
    // if they are regexps, they should exactly refer to same one (it is hard to better equality check on current ES)
    if (x instanceof RegExp) {
        return x === y;
    }
    if (x === y || x.valueOf() === y.valueOf()) {
        return true;
    }
    if (Array.isArray(x) && x.length !== y.length) {
        return false;
    }
    // if they are dates, they must had equal valueOf
    if (x instanceof Date) {
        return false;
    }
    // if they are strictly equal, they both need to be object at least
    if (!(x instanceof Object)) {
        return false;
    }
    if (!(y instanceof Object)) {
        return false;
    }
    // recursive object equality check
    const p = Object.keys(x);
    return Object.keys(y).every(function (i) {
        return p.indexOf(i) !== -1;
    }) &&
        p.every(function (i) {
            return ObjectsMatch(x[i], y[i]);
        });
}
/**
 * Check for a qualified object
 * @param value
 * @param requireKeys
 * @constructor
 */
function IsObject(value, requireKeys = false) {
    if (!Array.isArray(value) && value !== null && typeof value === 'object') {
        if (requireKeys) {
            if (typeof requireKeys === 'boolean' && Object.keys(value).length) {
                return true;
            }
            else if (IsArray(requireKeys, true)) {
                let pass = true;
                const keys = requireKeys;
                keys.some((key) => {
                    if (!(key in value))
                        pass = false;
                    return true;
                });
                if (!pass)
                    return false;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
/**
 * Check for a qualified function
 * @param value
 * @param requireKeys
 * @constructor
 */
function IsCallableFunction(fn) {
    return typeof fn === 'function';
}
/**
 * Remove empty values from an object
 * @param obj
 * @constructor
 */
function CleanObject(obj, options = {}) {
    if (!(IsArray(options.whitelist)))
        options.whitelist = [];
    if (!(IsArray(options.blacklist)))
        options.blacklist = [];
    if (!(IsObject(options.alias)))
        options.alias = {};
    for (const propName in obj) {
        if (!(options.whitelist.includes(propName)) && (obj[propName] === null || obj[propName] === undefined || options.blacklist.includes(propName))) {
            delete obj[propName];
        }
        if (propName in options.alias && IsString(options.alias[propName], true)) {
            obj[options.alias[propName]] = obj[propName];
            delete obj[propName];
        }
    }
    return obj;
}
/**
 * A helper function to determine if a variable is a qualified object
 *
 * @param value
 * @param requireKeys
 * @param throwError
 */
function IsObjectThrowError(value, requireKeys = false, throwError) {
    const isObject = IsObject(value, requireKeys);
    if (!isObject && throwError) {
        if (IsObject(PopLog)) {
            if (PopLog.enabled('error')) {
                if (PopTemplate) {
                    if (isDevMode() && !(IsObject(PopAuth, ['token']))) {
                        PopTemplate.error({ message: `${throwError}, this may be due to not being authenticated.`, code: 500 });
                    }
                }
                console.log(PopLog.message(`IsObjectError: Fail`), PopLog.color('error'), {
                    data: value,
                    requireKeys: requireKeys,
                    name: throwError
                });
            }
        }
        throw new Error(throwError);
    }
    return isObject;
}
/**
 * Check for a qualified number
 * @param value
 * @param requireTruthy
 * @constructor
 */
function IsNumber(value, requireTruthy) {
    if ((typeof value === 'number' || typeof value === 'string') && String(value).length && !isNaN(Number(value.toString()))) {
        if (requireTruthy) {
            if (+value) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    }
    return false;
}
/**
 * Check for a qualified string
 * @param value
 * @param requireLength
 * @constructor
 */
function IsString(value, requireLength = false) {
    if (value && typeof value === 'string' && !(IsNumber(value))) {
        if (requireLength) {
            if (String(value).length) {
                return true;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
/**
 *
 * A helper function to determine if a variable is a qualified string
 * @param value
 * @param requireLength
 * @param throwError
 */
function IsStringError(value, requireLength = false, throwError) {
    const isString = IsString(value, requireLength);
    if (!isString && throwError) {
        if (IsObject(PopLog)) {
            if (PopLog.enabled('error')) {
                console.log(PopLog.message(`IsStringError: Fail`), PopLog.color('error'), {
                    data: value,
                    requireLength: requireLength,
                    name: throwError
                });
            }
        }
        throw new Error(throwError);
    }
    return isString;
}
/**
 * Capitalize the first Letter of every word in a string
 * @param str
 * @returns str
 */
function TitleCase(str) {
    if (IsString(str, true)) {
        str = StringReplaceAll(str, '_', ' '); // convert underscores to spaces
        str = String(str).replace(/\w\S*/g, (txt) => {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); // capitalize first letter of words
        });
        str = str.replace(/(^|[\s-])\S/g, function (match) {
            return match.toUpperCase();
        });
    }
    return str;
}
/**
 * Capitalize the first Letter of every word in a string
 * @param str
 * @returns str
 */
function Capitalize(str) {
    if (IsString(str, true)) {
        str = str.trim();
        str = StringReplaceAll(str, '_', ' '); // convert underscores to spaces
        str = StringReplaceAll(str, '\'', ''); // convert ' to spaces
        str = str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }
    return str;
}
/**
 * Convert a string from snake case to Pascal Case
 * @param field
 * @returns string
 */
function SnakeToPascal(field) {
    if (IsString(field, true)) {
        const words = field.split('_');
        let validField = '';
        for (const word of words) {
            validField += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
        }
        return String(validField).trim();
    }
    return field;
}
/**
 * Convert a string with spaces to snake case .. 'this is snake case' to 'this_is_snake_case'
 * @param field
 * @returns string
 */
function SpaceToSnake(pascal) {
    const words = pascal.split(' ');
    for (let word of words) {
        word = String(word).toLowerCase();
    }
    return words.join('_');
}
/**
 * Convert a string with hyphens to Pascal Case
 * @param field
 * @returns string
 */
function HyphenToPascal(field) {
    const words = field.split('-');
    let validField = '';
    for (const word of words) {
        validField += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
    }
    return validField;
}
/**
 * Convert a string with spaces to Pascal Case
 * @param field
 * @returns string
 */
function SpaceToHyphenLower(str) {
    const tmp = str.trim();
    return String(StringReplaceAll(tmp, ' ', '-')).toLowerCase();
}
/**
 * String replace all
 * @param str
 * @param find
 * @param replace
 * @constructor
 */
function StringReplaceAll(str, find, replace) {
    return str.replace(new RegExp(find, 'g'), replace);
}
/**
 * Search filter helper to see if an object contains tags
 * @param obj
 * @param tags
 * @param match
 * @param values
 * @param has
 * @param not
 * @constructor
 */
function ObjectContainsTagSearch(obj, tags, match = null, values = null, has = null, not = null) {
    if (String(tags).length) {
        has = String(tags).toLowerCase().split(',').map(function (str) {
            return str.trim();
        }).filter(item => {
            return String(item).length && String(item).charAt(0) !== '!';
        });
        not = String(tags).toLowerCase().split(',').map((str) => {
            return str.trim();
        }).filter(item => {
            return String(item).length >= 2 && String(item).charAt(0) === '!';
        });
        not = not.map((tag) => {
            return StringReplaceAll(tag, '!', '');
        }).filter((tag) => {
            return tag.length >= 1;
        });
        match = true;
        values = Object.values(obj).filter(val => {
            return String(val).length > 0;
        });
        if (Array.isArray(not) && not.length) {
            match = true;
            not.some(tag => {
                values.some((val) => {
                    if (String(val).toLowerCase().indexOf(tag) > -1) {
                        match = null;
                        return true;
                    }
                });
                if (!match) {
                    return true;
                }
            });
        }
        if (match === true) {
            match = null;
            if (Array.isArray(has) && has.length) {
                has.some((tag) => {
                    if (tag.indexOf('&') > -1) {
                        const has2 = String(tag).toLowerCase().split('&').map((str) => {
                            return str.trim();
                        }).filter(item => {
                            return String(item).length && String(item).charAt(0) !== '!';
                        });
                        let not2 = String(tag).toLowerCase().split('&').map((str) => {
                            return str.trim();
                        }).filter(item => {
                            return String(item).length >= 1 && String(item).charAt(0) === '!';
                        });
                        not2 = not2.map(firstTag => {
                            return StringReplaceAll(firstTag, '!', '');
                        }).filter(nextTag => {
                            return nextTag.length >= 1;
                        });
                        match = true;
                        if (Array.isArray(not2) && not2.length) {
                            match = true;
                            not2.some((firstTag) => {
                                values.some((val) => {
                                    if (String(val).toLowerCase().indexOf(firstTag) > -1) {
                                        match = null;
                                        return true;
                                    }
                                });
                                if (!match) {
                                    return true;
                                }
                            });
                        }
                        if (match === true) {
                            match = null;
                            if (Array.isArray(has2) && has2.length) {
                                if (ArrayContainsAll(has2, values)) {
                                    match = true;
                                }
                                return match;
                            }
                        }
                        return match;
                    }
                    else {
                        values.some((val) => {
                            if (String(val).toLowerCase().indexOf(tag) > -1) {
                                match = true;
                                return true;
                            }
                        });
                    }
                    if (match) {
                        return true;
                    }
                });
            }
        }
        return match;
    }
    return true;
}
function ConvertDateToDateTimeFormat(value) {
    const dt = new Date(value);
    dt.setHours(dt.getHours() + Math.round(dt.getMinutes() / 60));
    dt.setMinutes(0);
    let date = dt.getDate();
    if (String(date).length === 1) {
        date = '0' + date;
    }
    let month = dt.getMonth() + 1;
    if (String(month).length === 1) {
        month = '0' + month;
    }
    const year = dt.getFullYear();
    let h = dt.getHours();
    if (String(h).length === 1) {
        h = '0' + h;
    }
    return year + '-' + month + '-' + date + ' ' + h + ':' + '00' + ':' + '00';
}
function ConvertDateFormat(value, format = 'yyyy-mm-dd') {
    const dt = new Date(value);
    let dateFormat;
    let date = dt.getDate();
    if (String(date).length === 1) {
        date = '0' + date;
    }
    let month = dt.getMonth() + 1;
    if (String(month).length === 1) {
        month = '0' + month;
    }
    const year = dt.getFullYear();
    switch (String(format).toLowerCase()) {
        case 'mm-dd-yyyy':
            dateFormat = month + '-' + date + '-' + year;
            break;
        case 'mm/dd/yyyy':
            dateFormat = month + '/' + date + '/' + year;
            break;
        case 'yyyy-mm-dd':
            dateFormat = year + '-' + month + '-' + date;
            break;
        default:
            dateFormat = year + '-' + month + '-' + date;
            break;
    }
    return dateFormat;
}
function ConvertDateToTimeFormat(value) {
    const dt = new Date(value);
    const h = dt.getHours().toString(10).padStart(2, '0');
    const m = dt.getMinutes().toString(10).padStart(2, '0');
    const s = dt.getSeconds().toString(10).padStart(2, '0');
    return h + ':' + m + ':' + s;
}
function PopUid() {
    return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
}
function ConvertObjectToUri(obj) {
    if (Array.isArray(obj)) {
        obj = ToObject(obj);
    }
    return Object.entries(obj).map(([key, val]) => `${key}=${encodeURIComponent(val)}`).join('&');
}
/**
 * Group a list of objects inside of an array
 * @param arr
 * @param key
 * @constructor
 */
function ArrayGroupBy(arr, key) {
    if (IsArray(arr, true)) {
        return arr.reduce(function (rv, x) {
            (rv[x[key]] = rv[x[key]] || []).push(x);
            return rv;
        }, {});
    }
    else {
        return arr;
    }
}
/**
 * Pick a random element from an array
 * @param arr
 * @constructor
 */
function RandomArrayElement(arr) {
    if (IsArrayThrowError(arr, true, `RandomArrayElement: Invalid Array`)) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
}
/**
 * Helper method to remove duplicate items from a  flat array [1,2,3,1,1], [['a','b','c','a']
 * @param arr
 */
function ArrayOnlyUnique(arr) {
    if (IsArray(arr, true)) {
        return arr.filter(function (elem, index, self) {
            return index === self.indexOf(elem);
        });
    }
    return arr;
}
function ArrayRemoveDupliates(array, prop) {
    return array.filter((obj, pos, arr) => {
        return arr.map(mapObj => mapObj[prop]).indexOf(obj[prop]) === pos;
    });
}
/**
 * Pass in a state verb to resolve to a color theme ... use case would be color of buttons, icons, and notifications
 * @param state
 */
function GetVerbStateTheme(stateVerb) {
    const successVerbs = ['active', 'success', 'on', '1'];
    const dangerVerbs = ['err', 'off', 'remove', '0', 'fail', 'archived'];
    const warningVerbs = ['warn', 'pend', 'remove'];
    const infoVerbs = ['new', 'info', 'add'];
    let theme = null;
    successVerbs.some((verb) => {
        if (String(stateVerb).toLowerCase().search(verb) > -1) {
            theme = 'success';
            return true;
        }
    });
    if (!theme) {
        dangerVerbs.some(function (verb) {
            if (String(stateVerb).toLowerCase().search(verb) > -1) {
                theme = 'danger';
                return true;
            }
        });
    }
    if (!theme) {
        warningVerbs.some(function (verb) {
            if (String(stateVerb).toLowerCase().search(verb) > -1) {
                theme = 'warn';
                return true;
            }
        });
    }
    if (!theme) {
        infoVerbs.some(function (verb) {
            if (String(stateVerb).toLowerCase().search(verb) > -1) {
                theme = 'info';
                return true;
            }
        });
    }
    if (!theme)
        theme = 'default';
    return theme;
}
/**
 * Helper for getting a message string from an http error
 * @param err
 * @constructor
 */
function GetHttpErrorMsg(err) {
    let errorMessage = '';
    let location = err;
    if (IsObject(location, true)) {
        if (IsObject(err.error, true)) {
            location = err.error;
            if (IsObject(location.errors, true)) {
                Object.keys(location.errors).map((key) => {
                    if (IsArray(location.errors[key], true)) {
                        location.errors[key].map((errorMsg, index) => {
                            if (index)
                                errorMessage += `<br/>`;
                            errorMessage += errorMsg + `<br/>`;
                        });
                    }
                    else if (IsString(location.errors[key])) {
                        errorMessage += err.errors[key] + `<br/>`;
                    }
                    errorMessage += `<br/>`;
                });
            }
            else if (IsString(location.message, true)) {
                errorMessage = location.message;
            }
        }
        else if (IsString(location.message, true)) {
            errorMessage = err.message;
        }
        else if (StorageGetter(location, ['data', 'message'])) {
            errorMessage = location.data.message;
        }
    }
    else if (IsObject(location, ['message'])) {
        errorMessage = location.message;
    }
    else if (IsString(location, true)) {
        errorMessage = String(location);
    }
    if (!errorMessage) {
        if (IsObject(PopLog)) {
            console.log(PopLog.message(`GetHttpErrorMsg: Fail`), PopLog.color('error'), {
                data: location,
            });
        }
        errorMessage = `Server Error: Code ${err.status + (err.statusText ? ' - ' + err.statusText : '') + '.'}`;
    }
    return errorMessage;
}
/**
 * Helper for getting an array from a response
 * @param err
 * @constructor
 */
function GetHttpResult(res) {
    if (res) {
        if (res.data)
            res = res.data;
    }
    else {
        console.log(`Undefined response: ${JSON.stringify(res)}`);
    }
    return res;
}
/**
 * Helper for getting an array from a response
 * @param err
 * @constructor
 */
function GetHttpArrayResult(res, requireLength = false) {
    let result = res;
    if (result && result.data) {
        result = result.data;
    }
    return IsArrayThrowError(result, requireLength, `Api Result was not an array as expected`) ? result : null;
}
/**
 * Helper for getting an object from a response
 * @param err
 * @constructor
 */
function GetHttpObjectResult(res, requireKeys = false) {
    let result = res;
    if (result && result.data) {
        result = result.data;
    }
    return IsObjectThrowError(result, requireKeys, `Api Result was not an object as expected`) ? result : null;
}
/**
 * Replace { var } in a string with the corresponding data value of an object
 * @param str
 * @param obj
 * @constructor
 */
function InterpolateString(str, obj) {
    if (typeof (str) === 'string' && str.includes('{') && IsObject(obj, true)) {
        const start = str.indexOf('{');
        const end = str.indexOf('}', start) !== -1 ? str.indexOf('}', start) : str.length;
        const fieldName = str.substring(start + 1, end);
        const varName = fieldName.trim();
        if (varName in obj) {
            str = str.replace('{' + fieldName + '}', obj[varName]);
            if (str && str.includes('{')) {
                str = InterpolateString(str, obj);
            }
        }
    }
    return str;
}
function GetStringAbbrv(str) {
    let abbrv = '';
    if (IsString(str, true)) {
        const strArray = String(str).trim().split(' ');
        let word;
        while (strArray.length) {
            word = strArray.shift();
            abbrv += String(word).trim().charAt(0).toLocaleUpperCase();
        }
    }
    return abbrv;
}
function PopTransform(value, transformation) {
    switch (String(transformation).toLowerCase()) {
        case 'toRelationName':
            if (IsObject(value)) {
                const val = value;
                const location = val.label ? 'label' : 'name';
                const name = StorageGetter(value, [location]);
                if (name)
                    value = name;
            }
            break;
        case 'totitlecase':
        case 'title':
            value = TitleCase(String(value));
            break;
        case 'tolowercase':
        case 'lower':
            value = String(value).toLowerCase();
            break;
        case 'label':
            const label = new LabelPipe();
            value = label.transform(value + '');
            break;
        case 'todigits':
        case 'digits':
            value = String(value).match(/\d+/g).map(Number).join('');
            break;
        case 'tophonepipe':
        case 'phone':
            const phone = new PhonePipe();
            value = phone.transform(value);
            break;
        case 'active':
        case 'archived':
        case 'toactiveararchived':
            const active = new ToActiveOrArchivedPipe();
            value = active.transform(value);
            break;
        case 'touppercase':
        case 'upper':
            value = String(value).toUpperCase();
            break;
        case 'convertemptytonull':
            if (!String(value).length)
                value = null;
            break;
        case 'convertemptyzero':
            if (!String(value).length)
                value = 0;
            break;
        case 'tocurrency':
        case 'currency':
        case 'dollar':
            if (IsNumber(value)) {
                value = new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 2
                }).format(Number(value));
            }
            break;
        case 'amount':
            value = IsNumber(value) ? parseFloat(String(value)).toFixed(2) : '0.00';
            break;
        default:
            break;
    }
    return value;
}

class TruncatePipe {
    transform(value, args) {
        if (IsString(value, true)) {
            const limit = args.length > 0 ? parseInt(args[0] + '', 10) : 20;
            const trail = args.length > 1 ? args[1] : '...';
            return String(value).length > limit ? String(value).substring(0, limit) + trail : value;
        }
        return value;
    }
}
TruncatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'truncate'
            },] }
];

function GetAuthStorage() {
    return {
        token: GetSiteVar('Auth.token', ''),
        popcxToken: GetSiteVar('Auth.popcx-token', ''),
        time: parseInt(GetSiteVar('Auth.time', 0), 10),
        auth: GetSiteVar('Auth.details', {}),
        businessId: parseInt(GetSessionSiteVar('Business.current', 0), 10)
    };
}

function GetServiceDom() {
    return {
        subscriber: {},
        delay: {},
        interval: {},
        handler: {},
        session: {},
        state: {},
    };
}
function DestroyServiceDom(dom) {
    if (typeof (dom.interval) === 'object') {
        Object.keys(dom.interval).map((name) => {
            if (dom.interval[name]) {
                clearInterval(dom.interval[name]);
            }
            if (dom.interval[name]) {
                clearInterval(dom.interval[name]);
            }
        });
    }
    if (typeof (dom.delay) === 'object') {
        Object.keys(dom.delay).map((name) => {
            if (dom.delay[name]) {
                clearTimeout(dom.delay[name]);
            }
            if (dom.delay[name]) {
                clearTimeout(dom.delay[name]);
            }
        });
    }
    if (typeof (dom.subscriber) === 'object') {
        Object.keys(dom.subscriber).map((name) => {
            if (dom.subscriber[name] && typeof dom.subscriber[name].unsubscribe === 'function') {
                dom.subscriber[name].unsubscribe();
            }
        });
    }
}
function GetServiceAssetContainer() {
    return {
        map: {}
    };
}
function GetServiceUiContainer() {
    return {
        state: { loaded: false, loading: true, refreshing: false },
        active: {},
        session: {},
        asset: {
            map: {},
        }
    };
}
/************************************************************************************************
 *                                                                                              *
 *                                          Service                                             *
 *                                      ( Handles Services )                                    *
 *                                                                                              *
 ************************************************************************************************/
function GetServiceContainer() {
    return {};
}
function GetComponentUiContainer() {
    return {
        error: {
            code: 0,
            message: ''
        },
        overhead: 0,
        height: {
            outer: null,
            inner: null,
            default: 0
        },
        width: {},
        state: {},
        resource: {
            map: {},
        },
        active: {
            map: {},
        },
        session: {},
        asset: {
            map: {},
        },
        contextMenu: {
            config: undefined,
            configure: undefined,
        }
    };
}
function AbstractUiMixin(Base = class {
}) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.ui = GetComponentUiContainer();
        }
    };
}
function GetComponentTraitContainer() {
    return {
        bubble: false
    };
}
function GetComponentAssetContainer() {
    return {
        map: {}
    };
}
function GetComponentDomContainer() {
    const dom = {
        /**
         * Service will preserve session, state, etc and allow all components on the core to communicate and share assets`
         */
        active: {},
        error: {
            code: 0,
            message: ''
        },
        overhead: 0,
        height: {
            outer: null,
            inner: null,
            default: 0
        },
        width: {},
        state: {},
        session: {},
        contextMenu: {
            config: undefined,
            configure: undefined,
        },
        repo: undefined,
        /**
         * Store all subscribers here
         */
        subscriber: {},
        /**
         * Store all time intervals here
         */
        interval: {},
        /**
         * Store all timeouts here
         */
        delay: {},
        handler: {},
    };
    return dom;
}
function AbstractDomMixin(Base = class {
}) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.dom = GetComponentDomContainer();
        }
    };
}
function DestroyComponentDom(dom) {
    if (typeof (dom.interval) === 'object') {
        Object.keys(dom.interval).map((name) => {
            if (dom.interval[name]) {
                clearInterval(dom.interval[name]);
            }
            if (dom.interval[name]) {
                clearInterval(dom.interval[name]);
            }
        });
    }
    if (typeof (dom.delay) === 'object') {
        Object.keys(dom.delay).map((name) => {
            if (dom.delay[name]) {
                clearTimeout(dom.delay[name]);
            }
            if (dom.delay[name]) {
                clearTimeout(dom.delay[name]);
            }
        });
    }
    if (typeof (dom.subscriber) === 'object') {
        Object.keys(dom.subscriber).map((name) => {
            if (dom.subscriber[name] && typeof dom.subscriber[name].unsubscribe === 'function') {
                dom.subscriber[name].unsubscribe();
            }
        });
    }
}
function GetComponentTemplateContainer() {
    const template = {
        container: undefined,
        refs: [],
        ref_events: []
    };
    return template;
}
function AbstractTemplateMixin(Base = class {
}) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.template = GetComponentTemplateContainer();
        }
    };
}
function DestroyComponentTemplate(template) {
    if (typeof template === 'object') {
        template.ref_events.map((subscription) => {
            if (subscription && typeof subscription.unsubscribe === 'function') {
                subscription.unsubscribe();
            }
        });
        template.refs = template.refs.map(function (componentRef) {
            if (componentRef && typeof componentRef.destroy === 'function') {
                componentRef.destroy();
            }
            componentRef = null;
            return null;
        });
        if (template.container)
            template.container.clear();
        template = null;
    }
}

class PopExtendService {
    // public ui = <ServiceUiContainerInterface>GetServiceUiContainer();
    constructor() {
        this.dom = GetServiceDom();
        this.id = PopUid();
        if (!this.asset)
            this.asset = GetServiceAssetContainer();
        this.dom = Object.assign(Object.assign({}, this.dom), {
            setSubscriber: (subscriptionKey, subscription = null) => {
                if (subscriptionKey && this.dom.subscriber && subscriptionKey in this.dom.subscriber && this.dom.subscriber[subscriptionKey] && typeof this.dom.subscriber[subscriptionKey].unsubscribe === 'function') {
                    this.dom.subscriber[subscriptionKey].unsubscribe();
                }
                if (subscription) {
                    this.dom.subscriber[subscriptionKey] = subscription;
                }
            },
            setTimeout: (timeoutKey, callback = null, delay = 250) => {
                if (timeoutKey && this.dom.delay && timeoutKey in this.dom.delay && this.dom.delay[timeoutKey]) {
                    clearTimeout(this.dom.delay[timeoutKey]);
                }
                if (typeof callback === 'function') {
                    this.dom.delay[timeoutKey] = setTimeout(callback, delay);
                }
            },
        });
    }
    ngOnDestroy() {
        DestroyServiceDom(this.dom);
    }
}
PopExtendService.prov = i0.defineInjectable({ factory: function PopExtendService_Factory() { return new PopExtendService(); }, token: PopExtendService, providedIn: "root" });
PopExtendService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopExtendService.ctorParameters = () => [];

class PopBaseService extends PopExtendService {
    constructor() {
        super();
        this.name = 'PopBaseService';
        this.asset = {
            sessionRoot: 'SiteVars',
            businessId: 0,
            authTime: undefined,
        };
        const authStorage = GetAuthStorage();
        this.auth = authStorage.auth;
        this.asset.businessId = authStorage.businessId;
        this.asset.authTime = authStorage.time;
        if (!this.asset.businessId) {
            const lastBusinessId = parseInt(GetSiteVar('Business.last') || '0', 10);
            if (lastBusinessId) {
                this.setCurrentBusinessId(lastBusinessId);
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Local Storage                                           *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Clear localStorage data
     */
    clearLocalStorage() {
        localStorage.clear();
        this.auth = null;
        this.asset.authTime = 0;
        this.asset.businessId = 0;
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Auth Details                                            *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Remove any user auth relics
     */
    clearAuthDetails(caller) {
        SetSessionSiteVar('Login.time', 0);
        this.clearLocalStorage();
        sessionStorage.clear();
    }
    /**
     * Clear the time when an auth was last completed
     */
    clearAuthTime() {
        this.asset.authTime = 0;
        SetSiteVar('Auth.time', 0);
        // localStorage.setItem('Auth-Time', '0');
    }
    /**
     * Return the entire Auth Object
     */
    getAuthDetails() {
        if (!IsObject(this.auth, true)) {
            const authStorage = GetAuthStorage();
            this.auth = authStorage.auth;
        }
        return this.auth;
    }
    /**
     * Extract the prime user/ root out of the auth details
     */
    getAuthPrimeUser() {
        if (IsObject(this.auth, ['id', 'email'])) {
            return {
                id: this.auth.id,
                name: this.auth.name,
                first_name: this.auth.first_name,
                last_name: this.auth.last_name,
                initials: this.auth.initials,
                avatarLink: StorageGetter(this.auth, ['profile', 'avatar_link'], null),
                email: this.auth.email,
                business_fk: this.auth.business_fk,
            };
        }
        return null;
    }
    /**
     * Return the time when the last authentication took place
     */
    getAuthTime() {
        return this.asset.authTime;
    }
    /**
     * Bearer token helper
     * The api will expect an auth token for any authenticated routes
     */
    getBearerToken() {
        if (IsObject(this.auth, ['token'])) {
            return 'Bearer ' + (this.auth.token ? this.auth.token : '123');
        }
        else {
            return '';
        }
    }
    /**
     * Get all the Business Users that belong to the auth user
     */
    getAuthUsers() {
        return JSON.parse(JSON.stringify(this.auth.users));
    }
    /**
     * Get the current business id that is in user
     */
    getCurrentBusinessId() {
        return this.asset.businessId;
    }
    /**
     * Return the business details for the current business
     */
    getCurrentBusinessUserId() {
        const businessId = this.getCurrentBusinessId();
        if (IsObject(this.auth.users, true) && businessId in this.auth.users) {
            return this.auth.users[businessId].id;
        }
        return 0;
    }
    /**
     * Determine if the last auth has expired
     */
    isAuthExpired() {
        let expired = false;
        if (!(IsObject(this.auth, ['token']))) {
            return true;
        }
        const currentTime = Math.round(new Date().getTime() / 1000);
        if (!this.asset.authTime || typeof this.auth.created_at == 'undefined' || !this.getBearerToken()) {
            expired = true;
        }
        else if (currentTime > ((+this.auth.created_at) + (this.auth.max_ttl * 60))) { // Check if token is passed max_ttl
            expired = true;
            return true;
        }
        else if (currentTime > (this.asset.authTime + (this.auth.max_ttl * 60))) { // Check if token has timed out.
            expired = true;
        }
        return expired;
    }
    /**
     * Stores a timestamp to track when the last authentication took place
     */
    setAuthTime() {
        // This gets set when there is a new token. It will calculate this and the tokendetails TTL / timeout to decide if the token
        // is expired without having to make an ajax call to know.
        this.asset.authTime = Math.round(new Date().getTime() / 1000);
        // localStorage.setItem('Auth-Time', this.asset.authTime.toString());
        SetSiteVar('Auth.time', this.asset.authTime.toString());
    }
    /**
     * Exposes the Auth Token at the root level of localStorage for convenience
     * @param token
     */
    setAuthToken(authToken) {
        // localStorage.setItem('Auth-Token', authToken);
        SetSiteVar('Auth.token', authToken);
    }
    /**
     * Store the auth object that the auth/user login route return to the app
     * @param authDetails
     */
    setAuthDetails(auth) {
        if (IsObject(auth, ['id', 'token'])) {
            const existingAuthDetailsDetails = this.auth;
            if (existingAuthDetailsDetails && +existingAuthDetailsDetails.id && +existingAuthDetailsDetails.id !== +auth.id) {
                // this.clearAuthDetails('setAuthDetails');
            }
            this.auth = auth;
            this.setAuthToken(this.auth.token);
            this.setAuthPopcxToken(this.auth.x_popcx_token);
            this.setAuthTime();
            SetPopAuth({
                id: auth.id,
                name: auth.name,
                first_name: auth.first_name,
                last_name: auth.last_name,
                initials: auth.initials,
                email: auth.email,
                email_verified_at: auth.email_verified_at,
                avatarLink: StorageGetter(this.auth, ['profile', 'avatar_link'], null),
                username: auth.username,
                created_at: auth.created_at
            });
            SetSiteVar('Auth.details', auth);
        }
    }
    /**
     * Exposes the Auth User at the root level of localStorage for convenience
     * @param token
     */
    setAuthUser(primeUser) {
        if (IsObject(primeUser, true)) {
            SetSiteVar('Auth.User', primeUser);
        }
    }
    /**
     * Exposes the Auth Popcx Token at the root level of localStorage for convenience
     * @param token
     */
    setAuthPopcxToken(token) {
        // localStorage.setItem('Auth-Popcx-Token', token);
        SetSiteVar('Auth.popcx-token', token);
    }
    /**
     * Track the current business that has been selected
     * @param id
     */
    setCurrentBusinessId(id) {
        this.asset.businessId = id;
        SetSessionSiteVar('Business.current', id);
        SetSiteVar('Business.last', id);
    }
    /**
     * Get all the Businesses that the auth user has access to
     */
    getAuthBusinesses() {
        return IsObject(this.auth, ['token']) && IsObject(this.auth.businesses) ? JSON.parse(JSON.stringify(this.auth.businesses)) : null;
    }
    /**
     * Switch to a different business
     * @param id
     */
    switchBusiness(id) {
        this.setCurrentBusinessId(id);
        this.redirect();
    }
    /**
     * Change to a different app with the current business
     * @param appPath
     */
    switchApps(appPath) {
        window.location.href = window.location.origin + appPath;
    }
    /**
     * Change to a different app with the current business
     * @param appPath
     */
    checkAppAccess(appName, redirect = false) {
        if (IsObject(PopBusiness, ['id', 'apps']) && IsObject(PopBusiness.apps, true)) {
            if (IsString(appName, true) && appName in PopBusiness.apps) {
                return true;
            }
        }
        if (redirect && !isDevMode()) {
            if (IsString(PopHref) && PopHref !== 'home')
                window.location.href = window.location.protocol + '//' + window.location.host + '/home';
        }
        return false;
    }
    /**
     * Determine the route after a user has authenticated
     */
    redirect() {
        const auth = this.getAuthDetails();
        let url = '';
        // First check if the redirect url was set. This is for if you want to over-ride and take priority over other redirects.
        url = GetSiteVar('App.redirect');
        if (url)
            SetSiteVar('App.redirect', '');
        // Check if the site was redirected due to a 401.
        if (!url) {
            url = GetSiteVar('App.redirectAfterLogin');
            if (url)
                SetSiteVar('App.redirectAfterLogin', '');
        }
        if (!auth.email_verified_at) {
            url = window.location.origin + '/user/confirm-email-resend';
        }
        // Check if there is a current business unit for this onSession and a corresponding default page.
        if (!url) {
            // const currentBuId = this.asset.businessId;
            // If their current B.U. is no longer available then make sure the settings are zero'd out.
            if (this.asset.businessId && IsObject(auth.businesses, true) && typeof auth.businesses[this.asset.businessId] === 'undefined') {
                this.setCurrentBusinessId(0);
            }
            else if (this.asset.businessId && IsObject(auth.businesses, true) && typeof auth.businesses[this.asset.businessId] !== 'undefined') {
                if (auth.businesses[this.asset.businessId].homepage) {
                    const business = auth.businesses[this.asset.businessId];
                    url = window.location.origin + business.homepage;
                }
                else {
                    if (isDevMode()) {
                        url = window.location.origin + '/';
                    }
                    else {
                        url = window.location.origin + '/home';
                    }
                }
            }
        }
        // Check if there is a home page set for the default business unit.
        if (!url) {
            if (IsObject(auth.businesses, true)) {
                if (auth.business_fk && typeof auth.businesses[auth.business_fk] !== 'undefined') {
                    if (auth.businesses[auth.business_fk].homepage) {
                        url = window.location.origin + auth.businesses[auth.business_fk].homepage;
                    }
                    else {
                        if (isDevMode()) {
                            url = window.location.origin + '/' + (IsString(PopHref, true) ? PopHref : '');
                        }
                        else {
                            url = window.location.origin + '/home';
                        }
                    }
                }
            }
        }
        if (url) {
            window.location.href = url;
        }
        else {
            // If still no url then redirect to the users profile page.
            if (isDevMode()) {
                window.location.href = window.location.origin + '/';
            }
            else {
                window.location.href = window.location.origin + '/home';
            }
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopBaseService.prov = i0.defineInjectable({ factory: function PopBaseService_Factory() { return new PopBaseService(); }, token: PopBaseService, providedIn: "root" });
PopBaseService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopBaseService.ctorParameters = () => [];

class PopMenuService {
    constructor() {
        this.srv = {
            base: ServiceInjector.get(PopBaseService),
        };
    }
    isAuthenticated() {
        return !this.srv.base.isAuthExpired();
    }
    changeBusiness(id) {
        this.srv.base.switchBusiness(id);
    }
}
PopMenuService.decorators = [
    { type: Injectable }
];

class PopCredentialService {
    constructor(base, backend, APP_GLOBAL, env) {
        this.base = base;
        this.backend = backend;
        this.APP_GLOBAL = APP_GLOBAL;
        this.env = env;
        this.name = 'PopCredentialService';
        if (!this.baseUrl) {
            const envUrl = isDevMode() && this.env && this.env.apiBaseUrl ? this.env.apiBaseUrl : null;
            this.baseUrl = (envUrl ? envUrl : `${window.location.protocol}//api.${window.location.host}`);
        }
        this.http = new HttpClient(this.backend); // bypass the default interceptors
    }
    /**
     * Main login function hit after they click the Login button.
     *
     * @param credentials
     * @returns {Observable<void>}
     */
    authenticate(credentials) {
        return new Promise(resolve => {
            this.base.clearAuthDetails(`${this.name}:authenticate`);
            this.http.post(`${this.baseUrl}/auth/login`, credentials).pipe(map((auth) => {
                auth = auth.data ? auth.data : auth;
                auth = this._transformAuthResponse(auth);
                // this.base.setAuthDetails( auth );
                SetSiteVar('Legacy.remember_me', credentials.remember_me);
                SetSiteVar('Legacy.remembered_username', (credentials.remember_me ? credentials.username : null));
                return auth;
            })).subscribe((auth) => __awaiter(this, void 0, void 0, function* () {
                auth = yield this._attachBusinesses(auth);
                this.base.setAuthDetails(auth);
                SetSessionSiteVar('Login.time', new Date().getTime());
                return resolve(auth);
            }), (err) => {
                return resolve(GetHttpErrorMsg(err));
            });
        });
    }
    /**
     * Reset login function hit after password reset
     *
     * @param credentials
     * @returns {Observable<void>}
     */
    reset(credentials, businessId = 0) {
        return new Promise((resolve, reject) => {
            this.base.clearLocalStorage();
            this.http.post(`${this.baseUrl}/auth/password/reset`, credentials).pipe(map((auth) => {
                auth = auth.data ? auth.data : auth;
                auth = this._transformAuthResponse(auth);
                this.base.setAuthDetails(auth);
                return auth;
            })).subscribe((auth) => __awaiter(this, void 0, void 0, function* () {
                if (IsObject(auth), ['token', 'id']) {
                    auth = auth.data ? auth.data : auth;
                    auth = yield this._attachBusinesses(auth, businessId);
                    this.base.setAuthDetails(auth);
                    return resolve(auth);
                }
                else {
                    return reject(auth);
                }
            }), err => {
                return resolve(GetHttpErrorMsg(err));
            });
        });
    }
    update(auth, businessId = 0) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.base.clearLocalStorage();
            auth = this._transformAuthResponse(auth);
            auth = yield this._attachBusinesses(auth, businessId);
            this.base.setAuthDetails(auth);
            return resolve(auth);
        }));
    }
    clear(storage = true) {
        return PopRequest.doPost(`auth/logout`, {}).pipe(map((res) => {
            res = res.data ? res.data : res;
            if (storage) {
                this.base.clearAuthDetails(`${this.name}:clear`);
            }
            return res;
        }));
    }
    clearAll(storage = true) {
        return PopRequest.doPost(`auth/logout`, { logoutAll: true }).pipe(map((res) => {
            res = res.data ? res.data : res;
            if (storage) {
                SetPopAuth(null);
                SetPopBusiness(null);
                this.base.clearAuthDetails(`${this.name}:clearAll`);
            }
            return res;
        }));
    }
    /**
     * Verify the current auth storage
     *
     * @param credentials
     * @returns {Observable<void>}
     */
    verify(businessId) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!businessId || this.base.isAuthExpired()) {
                return resolve(null);
            }
            let checkedPermission = false;
            const initRequests = [
                PopRequest.doGet(`/auth/user`).pipe(map((auth) => {
                    auth = auth.data ? auth.data : auth;
                    auth = this._transformAuthResponse(auth);
                    if (+businessId) {
                        let tmp = IsObject(auth.businesses[businessId], true) ? auth.businesses[businessId] : null;
                        auth.businesses = {};
                        if (tmp) {
                            auth.businesses[businessId] = tmp;
                        }
                        tmp = IsObject(auth.users[businessId], true) ? auth.users[businessId] : null;
                        auth.users = {};
                        if (tmp) {
                            auth.users[businessId] = tmp;
                        }
                    }
                    return auth;
                }))
            ];
            if (IsObject(PopUser, ['id']) && this.APP_GLOBAL.isPermissions()) {
                checkedPermission = true;
                initRequests.push(PopRequest.doPatch(`/businesses/${businessId}/users/${PopUser.id}/permissions`, {
                    with: ''
                }, 1, true));
            }
            forkJoin(initRequests).subscribe((results) => {
                const auth = results[0];
                const existing = this.base.getAuthDetails();
                existing.users = Object.assign(Object.assign({}, existing.users), auth.users);
                existing.businesses = Object.assign(Object.assign({}, existing.businesses), auth.businesses);
                if (checkedPermission) {
                    const user = GetHttpResult(results[1]);
                    if (businessId in existing.users) {
                        existing.users[businessId].permissions = user.permissions;
                    }
                }
                if (+businessId) {
                    forkJoin([
                        PopRequest.doGet(`/businesses/${businessId}`, { with: 'apps' }, 1, false, businessId).pipe(catchError(error => of(error)), map((res) => {
                            if (res.data)
                                res = res.data;
                            if (IsArray(res)) {
                                return res.pop();
                            }
                            else {
                                return res;
                            }
                        })),
                        PopRequest.doGet(`/apps/user/${auth.users[businessId].id}/settings`, {}, 1, false, businessId).pipe(catchError(error => of(error)), map((res) => {
                            if (res.data)
                                res = res.data;
                            return res;
                        })),
                    ]).subscribe((data) => {
                        if (!(IsObject(existing.businesses[businessId], true)) || !(existing.users[businessId])) {
                            return resolve(null);
                        }
                        existing.businesses[businessId] = data[0];
                        existing.users[businessId].setting = {};
                        if (IsArray(data[1], true)) {
                            data[1].map((item) => {
                                if (IsObject(item, true)) {
                                    existing.users[businessId].setting[item.name] = item.setting.value ? item.setting.value : item.defaultValue;
                                }
                            });
                        }
                        // existing.users[businessId] = auth.users[businessId];
                        // existing.businesses[businessId] = auth.businesses[businessId];
                        this.base.setAuthDetails(existing);
                        return resolve(existing);
                    }, () => {
                        return resolve(existing);
                    });
                }
                else {
                    this.base.setAuthDetails(existing);
                    return resolve(existing);
                }
            }, () => {
                return resolve(null);
            });
        }));
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _attachBusinesses(auth, defaultBusinessId = 0) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const businessIds = Object.keys(auth.users).map((id) => +id);
            if (!defaultBusinessId)
                defaultBusinessId = +auth.business_fk && businessIds.includes(+auth.business_fk) ? +auth.business_fk : (IsArray(businessIds, true) ? +businessIds[0] : 0);
            if (+defaultBusinessId > 0) {
                this.base.setCurrentBusinessId(defaultBusinessId);
                this.http.get(`${this.baseUrl}/businesses`, {
                    headers: new HttpHeaders({
                        'Authorization': `Bearer ${auth.token}`,
                        'X-Popcx-Business': defaultBusinessId + '',
                        'Content-Type': 'application/json',
                        'Api-Version': '1'
                    }),
                    params: this._setParams({
                        id: businessIds
                    })
                }).subscribe((res) => {
                    const businesses = res.data ? res.data : res;
                    auth.businesses = {};
                    if (IsArray(businesses, true)) {
                        businesses.map((business) => {
                            auth.businesses[business.id] = business;
                        });
                    }
                    // Check if this app was public facing, and turn it off
                    if (this.APP_GLOBAL.isOpen())
                        this.APP_GLOBAL.setOpen(false);
                    return resolve(auth);
                });
            }
            else {
                auth.businesses = {};
                auth.users = {};
                return resolve(auth);
            }
        }));
    }
    _setParams(body) {
        let params = new HttpParams();
        for (const key of Object.keys(body)) {
            if (body[key]) {
                if (body[key] instanceof Array) {
                    body[key].forEach((item) => {
                        params = params.append(`${key.toString()}[]`, item);
                    });
                }
                else {
                    params = params.append(key.toString(), body[key]);
                }
            }
        }
        return params;
    }
    _transformAuthResponse(auth) {
        const existingAuth = this.base.getAuthDetails();
        if (!(IsObject(auth.businesses))) {
            auth.businesses = {};
        }
        if (IsArray(auth.users, true)) {
            auth.users.map((user) => {
                auth.businesses[user.business_id] = user.business;
                delete user.business;
            });
            auth.users = ArrayKeyBy(auth.users, 'business_id');
        }
        if (IsString(auth.first_name, true) && IsString(auth.last_name, true)) {
            auth.initials = GetStringAbbrv(`${auth.first_name} ${auth.last_name}`);
        }
        else if (IsString(auth.name, true)) {
            auth.initials = GetStringAbbrv(auth.name);
        }
        else if (auth.first_name || auth.last_name) {
            if (auth.first_name) {
                auth.initials = GetStringAbbrv(auth.first_name);
            }
            else {
                auth.initials = GetStringAbbrv(auth.last_name);
            }
        }
        else {
            auth.initials = '?';
        }
        if (IsDefined(auth.created_at))
            auth.created_at = Math.floor((new Date(auth.created_at)).getTime() / 1000);
        if (IsDefined(auth.last_login_at))
            auth.last_login_at = Math.floor(new Date(auth.last_login_at).getTime() / 1000);
        if (IsString(auth.email_verified_at, true))
            auth.email_verified_at = Math.floor(new Date(auth.email_verified_at).getTime() / 1000);
        if (IsDefined(auth.token_created_at) && IsUndefined(auth.created_at))
            auth.created_at = auth.token_created_at;
        if (IsUndefined(auth.max_ttl))
            auth.max_ttl = 720;
        if (!(IsString(auth.token, true)) && IsObject(existingAuth, ['token']))
            auth.token = existingAuth.token;
        if (IsDefined(existingAuth.created_at))
            auth.created_at = existingAuth.created_at;
        return auth;
    }
}
PopCredentialService.prov = i0.defineInjectable({ factory: function PopCredentialService_Factory() { return new PopCredentialService(i0.inject(PopBaseService), i0.inject(i1.HttpBackend), i0.inject("APP_GLOBAL"), i0.inject("env")); }, token: PopCredentialService, providedIn: "root" });
PopCredentialService.decorators = [
    { type: Injectable },
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopCredentialService.ctorParameters = () => [
    { type: PopBaseService },
    { type: HttpBackend },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class TabConfig {
    constructor(params) {
        this.hidden = false;
        this.path = '';
        this.scheme = false;
        this.overhead = 0;
        this.sections = null;
        this.syncPositions = false;
        this.requireRefresh = false;
        this.when = null;
        this.wrap = true;
        this.columnWrap = true;
        this.groups = {};
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.name)
            this.name = this.id.replace(/_/g, ' ').replace(/(?:^|\s)\S/g, function (a) {
                return a.toUpperCase();
            });
        if (!this.path)
            this.path = this.id.replace(/_/g, '-').toLowerCase();
        if (!this.metadata)
            this.metadata = {};
        if (!this.syncPositionMap)
            this.syncPositionMap = {};
        if (!this.positions)
            this.positions = { 1: { flex: 1 } };
        Object.keys(this.positions).map((position) => {
            if (!this.positions[position].min)
                this.positions[position].multiple_min = null;
            if (!this.positions[position].max)
                this.positions[position].multiple_max = null;
            if (!this.positions[position].flex && this.positions[position].cols)
                this.positions[position].flex = this.positions[position].cols;
            delete this.positions[position].cols;
        });
    }
}
class TabMenuConfig {
    constructor(params) {
        this.name = '';
        this.goBack = true;
        this.tabs = [];
        this.buttons = [];
        this.portal = false;
        this.metadata = {};
        this.loaded = false;
        this.loading = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}

class SideBySideConfig {
    constructor(config) {
        this.name = 'name';
        this.bubble = false;
        this.hasLabelRow = false;
        this.hasFilterRow = false;
        this.hasHeader = false;
        this.assigned = []; // List of item ids of assigned items
        this.assignAll = false;
        this.assignedLabel = '';
        this.bucketLimit = 0;
        this.disabled = false;
        this.displayCircleID = true;
        this.displayHelper = true;
        this.displayTitle = true;
        this.facade = false;
        this.facadeEvent = false;
        this.optionsLabel = '';
        this.optionHtml = 'label';
        this.filter = true;
        this.filterBoth = false;
        this.route = '';
        this.metadata = null;
        this.options = { values: [] }; // List of all available items
        this.removeAll = false;
        this.display = '';
        this.patch = null;
        for (const i in config)
            this[i] = config[i];
        if (!this.patch)
            this.patch = {};
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (!this.patch.field)
            this.patch.field = 'option';
        if (!this.patch.assignMethod)
            this.patch.assignMethod = 'POST';
        if (!this.patch.removeMethod)
            this.patch.removeMethod = 'DELETE';
        if (!this.patch.businessId)
            this.patch.businessId = 0;
        if (!this.metadata)
            this.metadata = {};
        this.hasHeader = this.display && this.displayTitle;
        this.hasLabelRow = this.assignAll || this.removeAll || this.optionsLabel || this.assignedLabel ? true : false;
        this.hasFilterRow = this.filter || this.filterBoth ? true : false;
        if (this.route)
            this.optionHtml = 'route';
        if (this.displayHelper && !this.helpText)
            this.helpText = 'You have no ' + (this.display ? this.display.toLowerCase() : 'options');
        this.options = JSON.parse(JSON.stringify(this.options)); // make as deep copy of options so that options reference can be used elsewhere
        if (this.displayHelper && !this.helpTextRight)
            this.helpTextRight = ' No ' + (this.display ? this.display.toLowerCase() + ' available ' : 'data available ');
        this.options = JSON.parse(JSON.stringify(this.options)); // make as deep copy of options so that options reference can be used elsewhere
        if (this.sort && this.options.values.length > 1) {
            if (typeof this.options[0].sort_order !== 'undefined') {
                this.options.values.sort((a, b) => {
                    if (a.sort_order < b.sort_order)
                        return -1;
                    if (a.sort_order > b.sort_order)
                        return 1;
                    return 0;
                });
            }
            else {
                this.options.values.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            }
        }
    }
}

class SelectConfig {
    constructor(params) {
        this.bubble = false;
        this.disabled = false;
        this.displayErrors = true;
        this.facade = false;
        this.helpText = '';
        this.height = 240;
        this.label = '';
        this.message = '';
        this.mode = 'select';
        this.minimal = false;
        this.name = 'name';
        this.noInitialValue = false;
        this.options = { values: [] };
        this.readonly = false;
        this.showTooltip = false;
        this.sort = false;
        this.tooltip = '';
        this.value = null;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.sort && this.options.values.length > 1) {
            if (typeof this.options.values[0].sort_order !== 'undefined') {
                this.options.values.sort((a, b) => {
                    if (a.sort_order < b.sort_order)
                        return -1;
                    if (a.sort_order > b.sort_order)
                        return 1;
                    return 0;
                });
            }
            else {
                this.options.values.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            }
        }
        if (this.options.empty)
            this.options.values.unshift({ value: this.options.empty.value, name: this.options.empty.name });
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (!this.disabled)
            this.disabled = false;
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled
            ? new FormControl({ value: this.value, disabled: true })
            : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class SelectMultiConfig {
    constructor(params) {
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.facade = false;
        this.helpText = '';
        this.label = '';
        this.message = '';
        this.noInitialValue = false;
        this.name = 'name';
        this.showTooltip = false;
        this.tooltip = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        this.value = Array.isArray(this.value) ? this.value : [];
        if (!this.options)
            this.options = { values: [] };
        if (this.sort && this.options.values.length > 1) {
            if (typeof this.options.values[0].sort_order !== 'undefined') {
                this.options.values.sort((a, b) => {
                    if (a.sort_order < b.sort_order)
                        return -1;
                    if (a.sort_order > b.sort_order)
                        return 1;
                    return 0;
                });
            }
            else {
                this.options.values.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            }
        }
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = [];
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class InputConfig {
    constructor(params) {
        // Defaults
        this.autofocus = false;
        this.autoselect = false;
        this.bubble = false;
        this.conceal = false;
        this.displayErrors = true;
        this.disabled = false;
        this.dropSpecial = true;
        this.facade = false;
        this.helpText = '';
        this.hintText = '';
        this.hidden = false;
        this.hint = false;
        this.id = '';
        this.label = '';
        this.maxlength = 129;
        this.mask = null;
        this.minimal = false;
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.prefix = '';
        this.readonly = false;
        this.showMask = false;
        this.showTooltip = false;
        this.suffix = '';
        this.selectMode = false;
        this.selectModeOptionsDirection = 'down';
        this.specialChars = ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']'];
        this.tooltip = '';
        this.type = 'text';
        this.tabOnEnter = false;
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', path: '', duration: 750, disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (!this.readonly)
            this.readonly = false;
        if (this.selectMode)
            this.readonly = true; // input is mimicking a select box to a trigger  modal functionality
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
        if (this.mask) {
            this.maxlength = null;
            this.hint = false;
            this.pattern = null;
        }
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class NumberConfig {
    // No Defaults
    constructor(params) {
        // Defaults
        this.bubble = false;
        this.dropSpecial = true;
        this.displayErrors = true;
        this.disabled = false;
        this.facade = false;
        this.helpText = '';
        this.hidden = false;
        this.id = '';
        this.label = '';
        this.message = '';
        this.min = 1;
        this.max = 100;
        this.minimal = false;
        this.mask = '0*';
        this.name = 'name';
        this.noInitialValue = false;
        this.pattern = 'Numeric';
        this.prefix = '';
        this.readonly = false;
        this.showTooltip = false;
        this.specialChars = ['$', ' ', ',', '%'];
        this.showMask = false;
        this.suffix = '';
        this.step = 1;
        this.tooltip = '';
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (!this.readonly)
            this.readonly = false;
        if (this.min > this.max)
            this.min = this.max;
        if (this.max < this.min)
            this.max = this.min;
        this.maxlength = String(this.max).length;
        if (this.value) {
            if (this.value < this.min)
                this.value = this.min;
            if (this.value > this.max)
                this.value = this.max;
        }
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class DateConfig {
    constructor(params) {
        // Defaults
        this.type = 'Expanded';
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.filterPredicate = null;
        this.helpText = '';
        this.id = '';
        this.label = '';
        this.min = null;
        this.max = null;
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.showTooltip = false;
        this.tooltip = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.value)
            this.value = new Date(this.value);
        if (typeof this.min === 'string') {
            this.min = new Date(this.min);
        }
        if (typeof this.max === 'string') {
            this.max = new Date(this.max);
        }
        // if( isNaN( this.max ) === false ){
        //   const maxDate = new Date();
        //   // maxDate.setDate(maxDate.getDate() - 1);
        //   maxDate.setDate( maxDate.getDate() + parseInt( this.max, 10 ) );
        //   this.max = new Date( maxDate );
        // }
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class TimeConfig {
    // No Defaults
    constructor(params) {
        // Defaults
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.facade = false;
        this.helpText = '';
        this.id = '';
        this.label = '';
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.showTooltip = false;
        this.readonly = false;
        this.tooltip = '';
        this.time = 12;
        this.interval = 15;
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (!this.readonly)
            this.readonly = false;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class CheckboxConfig {
    constructor(params) {
        this.align = 'right';
        this.bubble = false;
        this.disabled = false;
        this.displayErrors = true;
        this.facade = false;
        this.helpText = '';
        this.id = '';
        this.label = '';
        this.labelPosition = 'after';
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.options = { values: [] };
        this.tabOnEnter = false;
        this.toolTipDirection = 'right';
        this.textOverflow = 'wrap';
        this.value = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.label) {
            this.toolTipDirection = this.labelPosition === 'after' ? 'right' : 'left';
        }
        else {
            this.toolTipDirection = 'above';
        }
        if (['left', 'center', 'right',].indexOf(this.align) === -1)
            this.align = 'center';
        if (!this.patch)
            this.patch = { field: '', path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = null;
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = this.disabled === true ? new FormControl({
            value: this.value,
            disabled: this.disabled
        }) : new FormControl(this.value, (this.validators ? this.validators : []));
    }
}

class SwitchConfig {
    constructor(params) {
        this.bubble = false;
        this.disabled = false;
        this.displayErrors = true;
        this.facade = false;
        this.helpText = '';
        this.label = '';
        this.labelPosition = 'after';
        this.message = '';
        this.noInitialValue = false;
        this.name = 'name';
        this.padding = '0';
        this.toolTipDirection = 'right';
        this.tabOnEnter = false;
        this.textOverflow = 'wrap';
        this.value = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
        this.value = +this.value === 1 ? true : false;
        this.labelPosition = ['before', 'after'].indexOf(this.labelPosition) >= 0 ? this.labelPosition : 'after';
        if (this.label) {
            if (this.labelPosition === 'after') {
                this.toolTipDirection = 'right';
            }
        }
        else {
            this.toolTipDirection = 'above';
        }
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (!this.disabled)
            this.disabled = false;
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = this.disabled === true ? new FormControl({
            value: this.value,
            disabled: this.disabled
        }) : new FormControl(this.value, (this.validators ? this.validators : []));
    }
}

class MinMaxConfig {
    // No Defaults
    constructor(params) {
        // Defaults
        this.allowNegative = false;
        this.bubble = false;
        this.disabled = false;
        this.facade = false;
        this.helpText = '';
        this.id = '';
        this.label = 'Min/Max';
        this.limit = 100;
        this.minValue = 1;
        this.maxValue = 10;
        this.min = 1;
        this.max = 10;
        this.minColumn = 'min';
        this.maxColumn = 'max';
        this.minReadonly = false;
        this.maxReadonly = false;
        this.minRequired = false;
        this.maxRequired = false;
        this.minDefaultValue = 1;
        this.maxDefaultValue = 1;
        this.minLabel = 'Minimum';
        this.maxLabel = 'Maximum';
        this.message = '';
        this.showTooltip = false;
        this.tooltip = '';
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        // const maxOptions = [];
        // let maxLimit = this.limit;
        // while( maxLimit ){
        //   maxOptions.push({ value: maxLimit, name: maxLimit, sort: maxLimit });
        //   maxLimit--;
        // }
        if (this.limit && this.maxValue > this.limit)
            this.maxValue = +this.limit;
        this.isMaxConfig = new SwitchConfig({
            label: this.maxLabel,
            value: +this.maxValue ? true : this.maxRequired ? true : false,
            disabled: this.maxRequired ? true : false,
            bubble: true,
            facade: false,
            labelPosition: 'after',
        });
        this.maxConfig = new NumberConfig({
            label: null,
            value: +this.maxValue,
            min: this.min,
            max: this.max,
            readonly: this.maxReadonly,
            facade: true,
            minimal: true,
            bubble: true,
        });
        if (this.minValue > this.maxValue)
            this.minValue = this.maxValue;
        // let minLimit = this.maxValue;
        // const minOptions = [];
        // while( minLimit ){
        //   minOptions.push({ value: minLimit, name: minLimit, sort: minLimit });
        //   minLimit--;
        // }
        this.isMinConfig = new SwitchConfig({
            label: this.minLabel,
            value: +this.minValue ? true : this.minRequired ? true : false,
            disabled: this.minRequired ? true : false,
            bubble: true,
            facade: false,
            labelPosition: 'after',
        });
        this.minConfig = new NumberConfig({
            label: null,
            value: +this.minValue,
            min: this.min,
            max: this.max,
            readonly: this.minReadonly,
            facade: true,
            minimal: true,
            bubble: true,
        });
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: { min: this.minValue, max: this.maxValue },
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class RadioConfig {
    constructor(params) {
        this.bubble = false;
        this.disabled = false;
        this.displayErrors = true;
        this.facade = false;
        this.helpText = '';
        this.label = '';
        this.labelPosition = 'above';
        this.layout = 'row';
        this.message = '';
        this.noInitialValue = false;
        this.name = 'name';
        this.reset = false;
        this.sort = false;
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.sort && this.options.values.length > 1) {
            if (typeof this.options.values[0].sort_order !== 'undefined') {
                this.options.values.sort((a, b) => {
                    if (a.sort_order < b.sort_order)
                        return -1;
                    if (a.sort_order > b.sort_order)
                        return 1;
                    return 0;
                });
            }
            else {
                this.options.values.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
            }
        }
        if (this.layout !== 'column')
            this.layout = 'row';
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (!this.disabled)
            this.disabled = false;
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        if (!this.control) {
            this.control = (this.disabled === true
                ? new FormControl({
                    value: this.value,
                    disabled: this.disabled
                })
                : new FormControl(this.value, (this.validators ? this.validators : [])));
        }
    }
}

class TextareaConfig {
    constructor(params) {
        this.autoSize = false;
        this.bubble = false;
        this._disabled = false;
        this.displayErrors = true;
        this.facade = false;
        this.helpText = '';
        this.height = 0;
        this.maxHeight = null;
        this.hint = false;
        this.message = '';
        this.maxlength = 1024;
        this.name = 'name';
        this.noInitialValue = false;
        this.readonly = false;
        this.showTooltip = false;
        this.tabOnEnter = false;
        this.tooltip = '';
        this.value = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        // if( this.height && !isNaN(Number(this.height)) ) this.height = this.height + 'px';
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
        if (value === true) {
            this.control.disable();
        }
        else if (value === false) {
            this.control.enable();
        }
    }
}

class LabelConfig {
    constructor(params) {
        this.bubble = false;
        this.button = false;
        this.border = false;
        this.copyValue = false;
        this.copyLabel = false;
        this.html = 'label';
        this.helpText = '';
        this.iconType = 'mat';
        this.name = 'name';
        this.label = 'Label';
        this.link = false;
        this.subLabel = '';
        this.subValue = '';
        this.tooltip = '';
        this.textOverflow = 'wrap';
        this.truncate = 0;
        this.value = '';
        this.valueButton = false;
        this.valueButtonDisabled = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.link || this.route)
            this.html = 'link';
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.icon) {
            if (this.icon.length === 1) {
                this.icon = this.icon.toUpperCase();
                this.iconType = 'sw';
            }
        }
    }
    setControl() {
        // meet requirement
    }
}
class MetadataConfig {
    constructor(name, value) {
        this.bubble = false;
        this.value = '';
        this.name = name;
        this.value = value;
        this.control = new FormControl(value);
    }
}

class ButtonConfig {
    constructor(params) {
        this.color = 'default';
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.event = 'click';
        this.helpText = '';
        this.hidden = false;
        this.icon = 'help_outline';
        this.iconColor = 'accent';
        this.id = '';
        this.label = '';
        this.message = '';
        this.name = 'name';
        this.radius = 2;
        this.size = 35;
        this.showTooltip = false;
        this.text = 26;
        this.tooltip = '';
        this.type = 'mat-button';
        this.value = 'Button';
        this.width = null;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.size < 10)
            this.size = 10;
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

const EmailFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
    disabled: {
        name: 'disabled',
        type: 'boolean',
        item: 'address',
        defaultValue: false,
    },
    address_pattern: {
        name: 'address_pattern',
        item: 'address',
        type: 'model',
        model: 'pattern',
        value: 'Email',
    },
    make_primary: {
        name: 'make_primary',
        type: 'fixed',
        defaultValue: false,
    },
    email_primary: {
        name: 'email_primary',
        type: 'trait',
        icon: 'email',
        defaultValue: false,
    },
};

class FieldSwitchParamComponent {
    constructor() {
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new SwitchConfig({
            name: this.config.name,
            label: this.config.label,
            labelPosition: 'after',
            value: IsDefined(this.config.value) ? this.config.value : this.config.defaultValue,
            patch: this.config.patch,
            facade: this.config.facade,
            metadata: this.config.metadata ? this.config.metadata : {}
        });
    }
}
FieldSwitchParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-switch-param',
                template: `
    <lib-pop-switch (events)="events.emit($event);" [config]=param></lib-pop-switch>`
            },] }
];
FieldSwitchParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

const AddressFieldSetting = {
    show_name: null,
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
    primary_can_text: {
        name: 'primary_can_text',
        label: 'Primary Text',
        type: 'primary',
        defaultValue: true,
    },
    primary_can_call: {
        name: 'primary_can_call',
        label: 'Primary Call',
        type: 'primary',
        defaultValue: true,
    },
    make_primary: {
        name: 'make_primary',
        type: 'fixed',
        defaultValue: false,
    },
    shipping_primary: {
        name: 'shipping_primary',
        type: 'trait',
        icon: 'local_shipping',
        defaultValue: false,
    },
    billing_primary: {
        name: 'billing_primary',
        type: 'trait',
        icon: 'local_post_office',
        component: FieldSwitchParamComponent,
        defaultValue: false,
    },
    allow_canada: {
        name: 'allow_canada',
        type: 'boolean',
        item: 'zip',
        defaultValue: false,
    },
    auto_fill: {
        name: 'auto_fill',
        type: 'boolean',
        item: 'zip',
        component: FieldSwitchParamComponent,
        defaultValue: true,
    },
};

const PhoneFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
    make_primary: {
        name: 'make_primary',
        type: 'fixed',
        defaultValue: false,
    },
    text_primary: {
        name: 'text_primary',
        type: 'trait',
        icon: 'sms',
        defaultValue: false,
    },
    call_primary: {
        name: 'call_primary',
        type: 'trait',
        icon: 'call',
        defaultValue: false,
    },
};

const NameFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
    disabled: {
        name: 'disabled',
        type: 'boolean',
        defaultValue: false,
    },
    make_primary: {
        name: 'make_primary',
        type: 'fixed',
        defaultValue: false,
    },
    name_primary: {
        name: 'name_primary',
        type: 'trait',
        icon: 'api',
        defaultValue: false,
    },
};

const InputFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
    transformation: {
        name: 'transformation',
        type: 'transformation',
        item: 'value',
        defaultValue: '',
        options: {
            empty: { value: '', name: '--- Select One ---' },
            values: [
                { value: 'toTitleCase', name: 'Title Case' },
                { value: 'toUpperCase', name: 'Upper Case' },
                { value: 'toLowerCase', name: 'Lower Case' },
                { value: 'toCurrency', name: 'Currency' },
                { value: 'date', name: 'Date' },
            ]
        }
    },
};

const RadioFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
};

const SwitchFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
};

const SelectFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
};

const CheckboxFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
};

const TextareaFieldSetting = {
    disabled: {
        name: 'disabled',
        type: 'boolean',
        item: 'address',
        defaultValue: false,
    },
};

class SelectFilterConfig {
    constructor(params) {
        this.allLabel = 'All';
        this.all = false;
        this.allowAll = true;
        this.bubble = false;
        this.displayErrors = true;
        this.collapsed = false;
        this.checkboxPosition = 'before';
        this.defaultMinHeight = 1;
        this.facade = false;
        this.float = false;
        this.filter = true;
        this.helpText = '';
        this.height = 200;
        this.levelGap = 35;
        this.minHeight = 50;
        this.multiple = false;
        this.name = 'name';
        this.noInitialValue = false;
        this.offset = null;
        this.offsetSession = null;
        this.patchGroupFk = false;
        this.strVal = '';
        this.setDefaultValues();
        if (params)
            for (const i in params)
                this[i] = params[i];
        this.value = this.multiple ? (Array.isArray(this.value) ? this.value : []) : (+this.value ? this.value : null);
        if (this.options.values.length > 1) {
            if (this.sort) {
                if (typeof this.options.values[0].sort_order !== 'undefined') {
                    this.options.values.sort((a, b) => {
                        if (a.sort_order < b.sort_order)
                            return -1;
                        if (a.sort_order > b.sort_order)
                            return 1;
                        return 0;
                    });
                }
                else {
                    this.options.values.sort((a, b) => {
                        if (a.name < b.name)
                            return -1;
                        if (a.name > b.name)
                            return 1;
                        return 0;
                    });
                }
            }
            if (this.options.values[0].group) {
                this.groups = this.getOptionGroups();
                if (this.groups.length < 2) {
                    this.allowAll = false;
                }
            }
            else {
                const str = [];
                this.selectedOptions = [];
                this.options.values.map((option) => {
                    if (this.all) {
                        option.selected = true;
                        this.selectedOptions.push(option.value);
                    }
                    else {
                        option.selected = IsArray(this.value) ? (this.value.includes(option.value) ? true : false) : false;
                        if (option.selected) {
                            this.selectedOptions.push(option.value);
                            str.push(option.name);
                        }
                    }
                    option.level = this.levelGap * option.level;
                });
                const defaultGroup = {
                    label: '',
                    options: this.options,
                    groupFk: 0,
                    open: true,
                };
                this.groups = [defaultGroup];
            }
        }
        if (!this.levelGap)
            this.levelGap = 35;
        this.defaultHeight = this.height;
        this.all = IsArray(this.value) ? (this.options.values.length === this.value.length) : false;
        if (!this.position)
            this.position = 'below';
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.groups.length === 1)
            this.collapsed = false;
        if (this.noInitialValue)
            this.value = this.multiple ? [] : '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
    setDefaultValues() {
        // this.helpText = '';
        this.label = '';
        this.message = '';
        this.options = { values: [] };
        this.disabled = false;
        this.sort = false;
        // this.showTooltip = false;
        // this.tooltip = '';
    }
    getOptionGroups() {
        this.selectedOptions = [];
        const groups = {};
        const list = [];
        let defaultGroup = this.options.values[0].group;
        this.options.values.map((option, index) => {
            if (typeof option.level === 'undefined')
                option.level = 0;
            option.level = this.levelGap * option.level;
            if (!option.group)
                option.group = defaultGroup;
            if (option.group in groups === false) {
                groups[option.group] = {
                    label: option.group,
                    groupFk: option.groupFk,
                    options: {
                        values: [],
                        filtered: []
                    },
                    all: false,
                    open: true,
                    indeterminate: false,
                };
                defaultGroup = option.group;
            }
            if (this.all) {
                option.selected = true;
                this.selectedOptions.push(option.value);
            }
            else {
                option.selected = IsArray(this.value) ? this.value.includes(option.value) : false;
                if (option.selected) {
                    this.selectedOptions.push(option.value);
                }
            }
            groups[option.group].options.values.push(option);
        });
        const count = Object.keys(groups).length;
        Object.keys(groups).map((key) => {
            const group = groups[key];
            // if(IsArray(group.options.values)){
            //   // ToDo:: allow ordering by a sort order property
            //   group.options.values = group.options.values.sort(DynamicSort('name'));
            // }
            if (count > 1 && this.collapsed)
                group.open = false;
            list.push(groups[key]);
        });
        return list;
    }
    resetSelection() {
        this.selectedOptions = [];
    }
    addSelectedOption(option) {
        this.selectedOptions.push(option);
    }
}

// export class CustomValidators{
function RegexPatterns(pattern) {
    switch (pattern) {
        case 'Alpha':
            return { tester: /^[ a-zA-Z\-\_]+/g, replacer: /[^ a-zA-Z\-\_]+/g };
        case 'AlphaNoSpace':
            return { tester: /^[a-zA-Z]+/g, replacer: /[^a-zA-Z\.\-\_]+/g };
        case 'AlphaNoSpaceOnlyDash':
            return { tester: /^[a-zA-Z]+/g, replacer: /[^a-zA-Z\-]+/g };
        case 'AlphaLowercaseNoSpace':
            return { tester: /^[a-z]+/g, replacer: /[^a-z\.\-\_]+/g };
        case 'AlphaNumeric':
            return { tester: /^[ a-zA-Z0-9\.\-\_]+/g, replacer: /[^ a-zA-Z0-9\.\-\_]+/g };
        case 'AlphaNumericNoUnderscore':
            return { tester: /^[ a-zA-Z0-9\.\-]+/g, replacer: /[^ a-zA-Z0-9\.\-]+/g };
        case 'AlphaNumericNoSpace':
            return { tester: /^[a-zA-Z0-9\.\-\_]+/g, replacer: /[^a-zA-Z0-9\.\-\_]+/g };
        case 'NumericNoSpace':
            return { tester: /^[0-9]+/g, replacer: /[^0-9]+/g };
        case 'NoSpace':
            return { tester: /[^ ]+/g, replacer: /[ ]+/g };
        case 'Default':
            return { tester: /^[a-zA-Z0-9\/\*\?\!\%\@\$\&\,\.\-\(\) ]+/g, replacer: /[^a-zA-Z0-9\/\*\?\!\%\@\$\&\,\.\-\(\) ]+/g };
        case 'NumericWithSpace':
            return { tester: /^[ 0-9]+/g, replacer: /[^ 0-9]+/g };
        case 'Numeric':
            return { tester: /^[0-9]+/g, replacer: /[^0-9]+/g };
        case 'Phone':
            return { tester: /@"^[\d-]+$"/, replacer: /[^\d-]+/g };
        case 'Email':
            return { tester: /^[^@]+@[a-zA-Z0-9._-]+\\.+[a-z._-]+$/, replacer: /[^@a-zA-Z0-9._-]+/g };
        case 'Password':
            return {
                tester: /^(?=.*[A-Za-z])(?=.*\d)(?=.*[$@$!%*#?&])[A-Za-z\d$@$!%*#?&]{8,}$/,
                replacer: /^(?=.*[A-Za-z])(?=.*\d)(?=.*[$@$!%*#?&])[A-Za-z\d$@$!%*#?&]{8,}$/
            };
        case 'Username':
            return {
                tester: /^\S[a-zA-Z0-9._\-]{2,}$/g,
                replacer: /[^a-zA-Z0-9._\-]+/g
            };
        case 'Url':
            return {
                tester: /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/,
                replacer: /[^\\:a-zA-Z0-9._\\-\\/\\?\\=\\#\\&]+/g
            };
        case 'Zip':
            return {
                tester: /^(\d{5}(-\d{4})?|[A-Z]\d[A-Z] *\d[A-Z]\d)$/,
                replacer: /[^[0-9][A-Z][A-Z]$]+/g
            };
        // case 'NumericSigned': return '^-?[^0-9]+[0-9]';
        // case 'float': return /[^.0-9]+/g;
        // case 'float': return /^(.(?!\d)|\D)+/;
        // case 'floatSigned': return '^-?[^0-9]+\.?[0-9]';
        default:
            return { tester: /^[a-zA-Z0-9\!\%\@\$\&\.\-\(\) ]+/g, replacer: /[^a-zA-Z0-9\!\%\@\$\&\.\-\(\) ]+/g }; // default
    }
}
function PatternValidation(pattern, response, value) {
    const regExPattern = RegexPatterns(pattern);
    if (response === 'test') {
        return regExPattern.tester.test(value.trim());
    }
    else if (response === 'value') {
        if (typeof value !== 'string')
            value = '';
        switch (pattern) {
            case 'Alpha':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaNoSpace':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaNoSpaceOnlyDash':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaLowercaseNoSpace':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaNumeric':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaNumericNoUnderscore':
                return value.replace(regExPattern.replacer, '');
            case 'AlphaNumericNoSpace':
                return value.replace(regExPattern.replacer, '');
            case 'NoSpace':
                return value.replace(regExPattern.replacer, '');
            case 'Numeric':
                return value.replace(regExPattern.replacer, '');
            case 'NumericNoSpace':
                return value.replace(regExPattern.replacer, '');
            case 'Phone':
                return value.replace(regExPattern.replacer, '');
            case 'Email':
                return value.replace(regExPattern.replacer, '');
            case 'Zip':
                return value.replace(regExPattern.replacer, '');
            case 'Url':
                return value.replace(regExPattern.replacer, '');
            default:
                return value.replace(regExPattern.replacer, '');
        }
    }
    else {
        switch (pattern) {
            case 'Alpha':
                return 'Only letters are allowed.';
            case 'AlphaNoSpace':
                return 'Only letters are allowed.';
            case 'AlphaLowercaseNoSpace':
                return 'Only lowercase letters are allowed.';
            case 'AlphaNumeric':
                return 'Only letters and Numbers are allowed.';
            case 'AlphaNumericNoUnderscore':
                return 'Only letters and Numbers are allowed.';
            case 'AlphaNumericNoSpace':
                return 'Only letters and Numbers are allowed.';
            case 'Blacklist':
                return 'Not allowed';
            case 'NoSpace':
                return 'Spaces not allowed.';
            case 'Numeric':
                return 'Only numbers are allowed.';
            case 'NumericNoSpace':
                return 'Only numbers are allowed.';
            case 'Phone':
                return 'Invalid Phone.';
            case 'Email':
                return 'Invalid Email.';
            case 'Password':
                return 'Must contain a number, letter, special and be > 8 characters.';
            case 'Username':
                return 'Must contain only A-Z 0-9 . - _';
            case 'Url':
                return 'Must be a valid url.';
            default:
                return 'Invalid characters.';
        }
    }
}
function ValidateBlacklist(blacklist) {
    return (control) => {
        let forbidden = false;
        for (const s of blacklist) {
            if (s === control.value) {
                forbidden = true;
            }
        }
        return forbidden ? { alpha: { message: PatternValidation('Blacklist', 'message') } } : null;
    };
}
function ValidateAlpha(control) {
    const pattern = RegexPatterns('Alpha');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('Alpha', 'message') } };
    return null;
}
function ValidateAlphaNoSpace(control) {
    const pattern = RegexPatterns('AlphaNoSpace');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('AlphaNoSpace', 'message') } };
    return null;
}
function ValidateAlphaLowercaseNoSpace(control) {
    const pattern = RegexPatterns('AlphaLowercaseNoSpace');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('AlphaLowercaseNoSpace', 'message') } };
    return null;
}
function ValidateAlphaNumeric(control) {
    const pattern = RegexPatterns('AlphaNumeric');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('AlphaNumeric', 'message') } };
    return null;
}
function ValidateAlphaNumericNoUnderscore(control) {
    const pattern = RegexPatterns('AlphaNumericNoUnderscore');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('AlphaNumericNoUnderscore', 'message') } };
    return null;
}
function ValidateAlphaNumericNoSpace(control) {
    const pattern = RegexPatterns('AlphaNumericNoSpace');
    if (!pattern.tester.test(control.value.trim()))
        return { alpha: { message: PatternValidation('AlphaNumericNoSpace', 'message') } };
    return null;
}
function ValidateNumeric(control) {
    const pattern = RegexPatterns('Numeric');
    if (!pattern.tester.test(control.value.trim()))
        return { numeric: { message: PatternValidation('Numeric', 'message') } };
    return null;
}
function ValidateNumericNoSpace(control) {
    const pattern = RegexPatterns('NumericNoSpace');
    if (!pattern.tester.test(control.value))
        return { numeric: { message: PatternValidation('NumericNoSpace', 'message') } };
    return null;
}
function ValidateUsername(control) {
    const pattern = RegexPatterns('Username');
    if (!pattern.tester.test(control.value))
        return { username: { message: PatternValidation('Username', 'message') } };
    return null;
}
function ValidateEmail(control) {
    const pattern = RegexPatterns('Email');
    if (!pattern.tester.test(control.value))
        return { email: { message: PatternValidation('Email', 'message') } };
    return null;
}
function ValidatePassword(control) {
    const pattern = RegexPatterns('Password');
    if (!pattern.tester.test(control.value))
        return { password: { message: PatternValidation('Password', 'message') } };
    return null;
}
function ValidatePhone(control) {
    const pattern = RegexPatterns('Phone');
    if (!pattern.tester.test(control.value))
        return { phone: { message: PatternValidation('Phone', 'message') } };
    return null;
}
function ValidateZip(control) {
    const pattern = RegexPatterns('Zip');
    if (!pattern.tester.test(control.value))
        return { zip: { message: PatternValidation('Zip', 'message') } };
    return null;
}
function ValidateUrl(control) {
    const pattern = RegexPatterns('Url');
    let value = control.value;
    if (IsString(value, true))
        value = value.trim();
    if (!pattern.tester.test(value))
        return { url: { message: PatternValidation('Url', 'message') } };
    return null;
}
function MatchPassword(control) {
    const password = control.get('password').value; // to get value in input tag
    const password_confirmation = control.get('password_confirmation').value; // to get value in input tag
    if (password !== password_confirmation) {
        control.get('password_confirmation').setErrors({ MatchPassword: true });
        if (control.get('password_confirmation').value) {
            control.get('password_confirmation').markAsDirty();
        }
    }
    else {
        return true;
    }
}
function MatchEmail(control) {
    const email = control.get('email').value; // to get value in input tag
    const email_confirmation = control.get('email_confirmation').value; // to get value in input tag
    if (email !== email_confirmation) {
        control.get('email_confirmation').setErrors({ MatchEmail: true });
        if (control.get('email_confirmation').value) {
            control.get('email_confirmation').markAsDirty();
        }
    }
    else {
        return true;
    }
}
function ValidationErrorMessages(validationError) {
    let message = '';
    for (const validation in validationError) {
        if (!validationError.hasOwnProperty(validation))
            continue;
        if (typeof validationError[validation].message === 'string') {
            message += validationError[validation].message + ' ';
        }
        else {
            switch (validation) {
                case 'min':
                    message += `Must be greater than or equal to ${validationError[validation].min}. `;
                    break;
                case 'max':
                    message += `Must be less than or equal to ${validationError[validation].max}. `;
                    break;
                case 'required':
                    message += 'Field is required.';
                    break;
                case 'email':
                    message += 'Invalid email. ';
                    break;
                case 'unique':
                    message += 'The current value is already in use.';
                    break;
                case 'minlength':
                    message += `To short, minimum ${validationError[validation].requiredLength} characters. `;
                    break;
                case 'maxlength':
                    message += `To long, maximum ${validationError[validation].requiredLength} characters. `;
                    break;
                case 'pattern':
                    message += 'Invalid characters. ';
                    break;
                case 'MatchPassword':
                    message = `This field must match the password.`;
                    break;
                case 'MatchEmail':
                    message = `This field must match the email.`;
                    break;
                default:
                    message += 'Invalid. ';
                    break;
            }
        }
    }
    return message.trim();
}
// }

class TextConfig {
    constructor(params) {
        this.border = false;
        this.className = 'theme-foreground-base';
        this.header = false;
        this.message = '';
        this.noInitialValue = false;
        this.name = 'name';
        this.padding = 5;
        this.textOverflow = 'wrap';
        this.value = false;
        this.warning = true;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = new FormControl(this.value);
    }
}

class SelectListConfig {
    constructor(params) {
        this.allLabel = 'All';
        this.allowAll = true;
        this.allowGroupAll = true;
        this.allOverlay = false;
        this.allOverlayEnabled = false;
        this.allOverlayLabel = '';
        this.allOverlayMessage = '';
        this.all = false;
        this.bubble = false;
        this.checkboxPosition = 'before';
        this.collapsed = false;
        this.column = 'column';
        this.displayErrors = true;
        this.defaultHeight = null;
        this.disabledIds = [];
        this.facade = false;
        this.filter = true;
        this.helpText = '';
        this.height = null;
        this.levelGap = 35;
        this.label = '';
        this.multiple = false;
        this.minHeight = null;
        this.noInitialValue = false;
        this.outline = true;
        this.patchGroupFk = false;
        this.strVal = '';
        this.setDefaultValues();
        if (params)
            for (const i in params)
                this[i] = params[i];
        const mode = this.mode;
        const hasMode = IsArray(this.mode, true) ? true : false;
        this.defaultMode = hasMode ? this.mode[0].value : 0;
        this.value = Array.isArray(this.value) ? this.value : [];
        if (this.options.values.length > 1) {
            if (this.sort) {
                if (typeof this.options.values[0].sort_order !== 'undefined') {
                    this.options.values.sort((a, b) => {
                        if (a.sort_order < b.sort_order)
                            return -1;
                        if (a.sort_order > b.sort_order)
                            return 1;
                        return 0;
                    });
                }
                else {
                    this.options.values.sort((a, b) => {
                        if (a.name < b.name)
                            return -1;
                        if (a.name > b.name)
                            return 1;
                        return 0;
                    });
                }
            }
            if (this.options.values[0].group) {
                this.groups = this.getOptionGroups();
            }
            else if (this.options.values.length) {
                let str = [];
                this.selectedOptions = [];
                this.options.values.map((option) => {
                    if (hasMode && IsUndefined(option.mode))
                        option.mode = this.defaultMode;
                    option.selected = this.value.includes(option.value) ? true : false;
                    if (option.selected) {
                        this.selectedOptions.push(option.value);
                        str.push(option.name);
                    }
                    option.indentation = (+this.levelGap) * (option.level + 1);
                    str = str.sort();
                    this.strVal = str.join(', ');
                });
                if (this.options.empty)
                    this.options.values.unshift({ value: this.options.empty.value, name: this.options.empty.name });
                const defaultGroup = {
                    label: '',
                    options: this.options,
                    open: true
                };
                this.groups = [defaultGroup];
            }
            else {
                this.groups = [];
            }
        }
        if (!this.groups)
            this.groups = [];
        if (!this.levelGap)
            this.levelGap = 35;
        this.defaultHeight = this.height;
        let allGroupsSelected = true;
        const selected = this.selectedOptions;
        let groupSelected;
        if (this.all) {
            this.selectedOptions = [];
            this.groups.map((group) => {
                group.all = true;
                this.selectedOptions = group.options.values.map((option) => {
                    option.selected = true;
                    this.selectedOptions.push(option.value);
                });
            });
            this.strVal = this.allLabel;
        }
        else {
            let str = [];
            this.selectedOptions = [];
            const isGroups = this.groups.length > 1;
            this.groups.map((group) => {
                if (group.all) {
                    if (isGroups) {
                        str.push(group.label + ' (All)');
                    }
                    else {
                        str.push('All');
                    }
                    group.options.values.filter(option => {
                        this.selectedOptions.push(option.value);
                    });
                }
                else {
                    groupSelected = group.options.values.filter((option) => {
                        return option.selected;
                    });
                    if (groupSelected && groupSelected.length) {
                        if (groupSelected.length === group.options.values.length)
                            group.all = true;
                        if (group.all) {
                            if (isGroups) {
                                str.push(group.label + ' (All)');
                            }
                            else {
                                str.push('All');
                            }
                            group.options.values.filter(option => {
                                this.selectedOptions.push(option.value);
                            });
                        }
                        else {
                            allGroupsSelected = false;
                            if (isGroups && groupSelected.length) {
                                str.push(group.label + ` (${groupSelected.length} of ${group.options.values.length})`);
                                groupSelected.map((option) => {
                                    this.selectedOptions.push(option.value);
                                });
                            }
                            else {
                                groupSelected.map((option) => {
                                    this.selectedOptions.push(option.value);
                                    str.push(option.name);
                                });
                            }
                        }
                    }
                    else {
                        group.all = false;
                        allGroupsSelected = false;
                    }
                }
            });
            if (!this.selectedOptions.length) {
                allGroupsSelected = false;
                if (this.emptyLabel) {
                    str = [this.emptyLabel];
                }
            }
            else if (!this.all && allGroupsSelected) {
                str = ['All'];
            }
            this.all = allGroupsSelected;
            str = str.sort();
            this.strVal = str.join(', ');
        }
        delete this.options;
        delete this.value;
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.groups.length === 1)
            this.collapsed = false;
        if (this.noInitialValue)
            this.value = this.multiple ? [] : '';
        if (!this.control)
            this.setControl();
        if (!(IsDefined(this.value, false)))
            this.value = this.multiple ? [] : '';
        if (this.allOverlay && !this.allOverlayLabel) {
            this.allOverlayLabel = 'All Access';
        }
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: false
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
    setDefaultValues() {
        // this.helpText = '';
        this.label = '';
        this.message = '';
        this.options = { values: [] };
        this.disabled = false;
        this.sort = false;
        // this.showTooltip = false;
        // this.tooltip = '';
    }
    getOptionGroups() {
        this.selectedOptions = [];
        const groups = {};
        const list = [];
        let defaultGroup = this.options.values[0].group;
        let defaultGroupFk = this.options.values[0].groupFk;
        this.options.values.map((option, index) => {
            if (typeof option.level === 'undefined')
                option.level = 0;
            if (this.mode && IsUndefined(option.mode))
                option.mode = this.defaultMode;
            option.indentation = (+this.levelGap) * (option.level + 1);
            if (!option.group)
                option.group = defaultGroup;
            if (option.group in groups === false) {
                groups[option.group] = {
                    label: option.group,
                    options: { values: [] },
                    all: false,
                    indeterminate: false,
                    open: true,
                    groupFk: option.groupFk,
                };
                defaultGroup = option.group;
                defaultGroupFk = option.groupFk;
            }
            option.selected = this.value.includes(option.value);
            if (option.selected) {
                this.selectedOptions.push(option.value);
            }
            groups[option.group].options.values.push(option);
        });
        const count = Object.keys(groups).length;
        Object.keys(groups).map((key) => {
            let indeterminate = false;
            let all = true;
            groups[key].options.values.some(option => {
                if (!option.selected) {
                    all = false;
                    indeterminate = true;
                    return true;
                }
            });
            groups[key].all = all;
            groups[key].indeterminate = indeterminate;
            if (count > 1 && this.collapsed)
                groups[key].open = false;
            list.push(groups[key]);
        });
        const countLabel = this.selectedOptions.length > 1 ? `[${this.selectedOptions.length}] ` : '';
        return list;
    }
    resetSelection() {
        this.selectedOptions = [];
    }
    addSelectedOption(option) {
        this.selectedOptions.push(option);
    }
}

class DatePickerConfig {
    constructor(params) {
        // Defaults
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.filterPredicate = null;
        this.helpText = '';
        this.id = '';
        this.label = '';
        this.min = null;
        this.max = null;
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.showTooltip = false;
        this.tooltip = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.value)
            this.value = new Date(this.value);
        if (typeof this.min === 'string') {
            this.min = new Date(this.min);
        }
        if (isNaN(this.max) === false) {
            const maxDate = new Date();
            // maxDate.setDate(maxDate.getDate() - 1);
            maxDate.setDate(maxDate.getDate() + parseInt(this.max, 10));
            this.max = new Date(maxDate);
        }
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class SelectModalConfig {
    constructor(params) {
        this.displayErrors = true;
        this.disabled = false;
        this.facade = false; // Sets a flag that says this fieldItems really does not exist in the backend, and just pretend to hit the api
        this.header = '';
        this.label = '';
        this.noInitialValue = false; // Set to true to always have an empty value on load
        if (params)
            for (const i in params)
                this[i] = params[i];
        // if( !this.label ) this.label = 'Options';
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, json: false };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.value = this.list.multiple ? [] : '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: false
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

/**
 * A helper method that will build out TabMenuConfig off of an entityConfig
 * @param entityConfig
 * @param tabs
 */
function GetTabMenuConfig(core, tabs = []) {
    const tabMenuConfig = new TabMenuConfig({
        name: DetermineEntityName(core.entity),
        goBack: true,
        portal: false,
        tabs: tabs,
        buttons: GetTabMenuButtons(core),
    });
    return tabMenuConfig;
}
/**
 * Determine the buttons that should be shown for this entity
 * @param core
 */
function GetTabMenuButtons(core) {
    let buttons = [];
    const defaultButtons = [
        { id: 'clone', name: 'Clone', accessType: 'can_update', hidden: false },
        // { id: 'archive', name: 'Archive', accessType: 'can_update', hidden: true },
        // { id: 'activate', name: 'Activate', accessType: 'can_update', hidden: true },
        { id: 'delete', name: 'Delete', accessType: 'can_delete', hidden: true },
        { id: 'close', name: 'Close', hidden: false },
    ];
    if (IsObject(core.repo.model.table.button, true)) {
        buttons = defaultButtons.filter((button) => {
            if (button.id === 'clone' && !core.repo.model.menu.button.clone)
                return false;
            // if( button.id === 'archive' && !core.repo.model.menu.button.archive ) return false;
            // if( button.id === 'activate' && !core.repo.model.menu.button.archive ) return false;
            if (button.id === 'delete' && !core.repo.model.menu.button.delete)
                return false;
            if (!button.accessType)
                return true;
            if (!core.access[button.accessType])
                return false;
            return true;
        });
    }
    return buttons;
}
/**
 * A helper method that sets up a FieldGroupConfig for a create/new pop-table-dialog
 * @param entityConfig
 * @param goToUrl
 */
function GetObjectVar(obj, path) {
    const steps = path.split('.');
    const key = steps.pop();
    const pathStorage = StorageGetter(obj, steps);
    if (pathStorage) {
        return typeof pathStorage[key] !== 'undefined' ? pathStorage[key] : undefined;
    }
    else {
        return undefined;
    }
}
/**
 * Get a list of the transformations that are within a field set
 * @param obj
 * @constructor
 */
function GetObjectTransformations(obj) {
    const transformations = [];
    Object.keys(obj).map((key) => {
        const field = obj[key];
        if (IsObject(field, ['model'])) {
            if (field.model && field.model.name && field.model.transformation) {
                transformations[field.model.name] = CleanObject({
                    type: field.model.transformation.type,
                    arg1: field.model.transformation.arg1 ? field.model.transformation.arg1 : null,
                    arg2: field.model.transformation.arg2 ? field.model.transformation.arg2 : null,
                    arg3: field.model.transformation.arg3 ? field.model.transformation.arg3 : null,
                });
            }
        }
        else if (IsObject(field, ['id', 'name'])) {
            console.log('with relation', key, obj[key]);
        }
        else {
            console.log('fail', key);
        }
    });
    return transformations;
}
function SetCoreValue(core, entity_path, value) {
    const steps = entity_path.split('.');
    const key = steps.pop();
    const pathStorage = StorageGetter(core, steps);
    if (value === null) {
        delete pathStorage[key];
    }
    else {
        pathStorage[key] = value;
    }
}
/**
 * Parse a value with any mutations that need to be applied
 * @param value
 * @param core
 * @param blockEntity
 * @constructor
 */
function ParseModelValue(value = '', core, blockEntity = false) {
    // console.log('ParseModelValue', value);
    let tmp = value;
    if (typeof tmp === 'undefined') {
        // console.log('zzz')
        return tmp;
    }
    if (tmp === 'null' || tmp === null) {
        // console.log( 'a', tmp );
        tmp = null;
    }
    else if (typeof tmp === 'boolean') {
        tmp = +tmp;
        // console.log( 'b', tmp );
    }
    else if (IsString(tmp, true)) {
        if (tmp.includes('/')) { // url
            if (core && core.params && IsString(tmp, true) && tmp.includes('#')) {
                tmp = ParseUrlForParams(tmp, core.params);
                // console.log( 'd', tmp );
            }
            if (!blockEntity && core && core.entity && IsString(tmp, true) && tmp.includes(':')) {
                const entityField = ParseStringForEntityField(tmp, core.entity);
                if (IsDefined(entityField, false)) {
                    tmp = entityField;
                }
                // console.log( 'e', tmp );
            }
            return tmp;
        }
        else {
            if (IsString(tmp, true) && tmp.includes('alias:')) {
                tmp = ParseForAlias(tmp);
                // console.log( 'f', tmp );
            }
            if (core) {
                if (tmp.includes('.') && !(tmp.includes('@')) && !(tmp.includes(' '))) { // object location
                    const coreVar = GetObjectVar(core, tmp);
                    if (typeof coreVar !== 'undefined')
                        tmp = coreVar;
                    // console.log( 'g', tmp );
                }
                if (core.params && IsString(tmp, true) && tmp.includes('#')) {
                    const paramsField = ParseStringForParams(tmp, core.params);
                    if (IsDefined(paramsField, false)) {
                        tmp = paramsField;
                    }
                    // console.log( 'h', tmp );
                }
                if (!blockEntity && core.entity && IsString(tmp, true) && tmp.includes(':')) {
                    const entityField = ParseStringForEntityField(tmp, core.entity);
                    if (IsDefined(entityField, false)) {
                        tmp = entityField;
                    }
                    // console.log( 'i', tmp );
                }
            }
        }
    }
    else if (IsNumber(tmp)) {
        // console.log( 'ca', tmp );
        tmp = Number(tmp);
        // console.log( 'c', tmp );
    }
    // console.log( 'after', tmp );
    return tmp;
}
/**
 * Look through an entire object and make the necessary mutations
 * @param obj
 * @param entityConfig
 * @constructor
 */
function ParseObjectDefinitions(obj, entityConfig) {
    const definitions = {};
    let value;
    if (typeof obj !== 'undefined') {
        if (obj && Array.isArray(obj))
            obj = ToObject(obj);
        if (typeof obj === 'object') {
            Object.keys(obj).map((key) => {
                value = ParseModelValue(obj[key], entityConfig);
                definitions[key] = value;
            });
        }
    }
    return definitions;
}
/**
 * A method to translate entityId fields out of a url /#app/#plural_name/:entityId, (#) indicates a entityId param, (:) indicates a entityId field
 */
function ParseUrlForEntityFields(url, entity) {
    if (url && url.includes(':')) {
        const start = url.indexOf(':');
        const end = url.indexOf('/', start) !== -1 ? url.indexOf('/', start) : url.length;
        const fieldName = url.substring(start + 1, end);
        url = url.replace(':' + fieldName, entity[fieldName]);
        if (url && url.includes(':')) {
            url = ParseUrlForEntityFields(url, entity);
        }
    }
    return url;
}
/**
 * Translate an aliases or mutations within a url
 * @param url
 * @param entity
 * @param ignore
 * @constructor
 */
function ParseLinkUrl(url, entity = null, ignore = []) {
    if (url) {
        return url.split('/').map((part) => {
            if (part.includes('alias:')) {
                part = PopPipe.label.getAlias((part.split(':')[1]));
            }
            else if (part.includes(':') && entity) {
                if (!(ignore.includes(part))) {
                    part = part.split(':')[1];
                    if (part in entity)
                        part = entity[part];
                }
            }
            return part;
        }).join('/');
    }
    return url;
}
/**
 * A method to translate entityId params out of a url /#app/#plural_name/:entityId, (#) indicates a entityId param, (:) indicates a entityId field
 */
function ParseUrlForParams(url, entityParams) {
    if (url && url.includes('#') && !(url.includes(' '))) {
        const start = url.indexOf('#');
        const end = url.indexOf('/', start) !== -1 ? url.indexOf('/', start) : url.length;
        const paramName = url.substring(start + 1, end);
        url = url.replace('#' + paramName, entityParams[paramName]);
        if (url && url.includes('#')) {
            url = ParseUrlForParams(url, entityParams);
        }
    }
    return url;
}
/**
 * A methid that replaces entityId aliases found in a string
 * @param string
 */
function ParseForAlias(string) {
    if (IsString(string, true)) {
        let alias = false;
        const parts = [];
        string.split(':').map((part) => {
            if (part.includes('alias')) {
                alias = true;
            }
            else {
                parts.push(alias ? TitleCase(PopPipe.label.getAlias((part))) : part);
                alias = false;
            }
            return part;
        });
        return parts.join(' ');
    }
    return string;
}
/**
 * A method to translate entityId fields out of a string ':entityId' (:) indicates a entityId field
 */
function ParseStringForEntityField(str, entity) {
    if (typeof (str) === 'string' && str.includes(':') && !(str.includes(' '))) {
        const start = str.indexOf(':');
        const end = str.indexOf('.', start) !== -1 ? str.indexOf('.', start) : str.length;
        const fieldName = str.substring(start + 1, end);
        if (IsDefined(entity[fieldName], false)) {
            str = str.replace(':' + fieldName, entity[fieldName]);
            if (str && str.includes(':')) {
                str = ParseStringForEntityField(str, entity);
            }
        }
    }
    else if (typeof (str) === 'string' && str.includes(':') && str.includes(' ')) {
        const parts = str.trim().split(' ');
        const partials = [];
        parts.map((part) => {
            const start = part.indexOf(':');
            const end = part.indexOf('.', start) !== -1 ? part.indexOf('.', start) : part.length;
            const fieldName = part.substring(start + 1, end);
            if (IsDefined(entity[fieldName], false)) {
                part = part.replace(':' + fieldName, entity[fieldName]);
                if (part && part.includes(':')) {
                    part = ParseStringForEntityField(part, entity);
                }
            }
            partials.push(part);
        });
        str = partials.join(' ').trim();
    }
    return str;
}
/**
 * A method that replaces entityId params found in a string
 * @param str
 * @param entityParams
 */
function ParseStringForParams(str, entityParams, separator = '.') {
    if (typeof (str) === 'string' && str.includes('#')) {
        const start = str.indexOf('#');
        const end = str.indexOf(separator, start) !== -1 ? str.indexOf(separator, start) : str.length;
        const paramName = str.substring(start + 1, end);
        if (entityParams[paramName]) {
            str = str.replace('#' + paramName, entityParams[paramName]);
            if (str && str.includes('#')) {
                str = ParseStringForParams(str, entityParams);
            }
        }
    }
    return str;
}
/**
 * Helper function to set routes for an entity
 * @param routes
 * @param params
 * @constructor
 */
function InterpolateEntityRoutes(routes, params) {
    if (IsObject(routes)) {
        const set = {};
        Object.keys(routes).map((method) => {
            set[method] = {};
            Object.keys(routes[method]).map((route) => {
                if (!set[method][route])
                    set[method][route] = {};
                set[method][route].path = String(ParseUrlForParams(routes[method][route].path, params)).trim();
                set[method][route].params = routes[method][route].params;
            });
        });
        return set;
    }
    else {
        return routes;
    }
}
/**
 * Helper function to set routes for an entity
 * @param routes
 * @param params
 * @constructor
 */
function InterpolateEntityRoute(route, obj) {
    let path = InterpolateString(route, obj);
    path = StringReplaceAll(path, '\\/\\/', '\\/');
    return path;
}
/**
 * Remove all the empty values from an object
 * @param model
 * @constructor
 */
function ClearEmptyValues(model) {
    const pointless = [null, undefined, ''];
    Object.getOwnPropertyNames(model).map((key) => {
        if (typeof key === 'string' && key.includes('_') == false && pointless.includes(model[key]) && key !== 'value') {
            delete model[key];
        }
        if (model[key] !== null && !Array.isArray(model[key]) && typeof model[key] === 'object') {
            model[key] = ClearEmptyValues(model[key]);
        }
    });
    return model;
}
/**
 * Get a name to display for an entity, use fall backs if necessary
 * @param entity
 * @constructor
 */
function DetermineEntityName(entity) {
    let name = '';
    if (entity) {
        if (IsString(entity.label, true)) {
            name = entity.label;
        }
        else if (IsString(entity.name, true)) {
            name = entity.name;
        }
        else if (IsString(entity.display_name, true)) {
            name = entity.display_name;
        }
        else if (IsString(entity.first_name, true)) { //code change by Chetu Development Team on 17-05-2021
            name = entity.first_name + ' ' + entity.last_name;
        }
        else if (IsString(entity.email, true)) {
            name = entity.email;
        }
        else if (typeof entity.id !== 'undefined') {
            name = String(entity.id);
        }
    }
    return name;
}
/**
 * Parse conditional logic of a when statement
 * [
 *    first level is OR statements
 *    [ ...Every thing in the second level is an AND statement..., ['name', '=', 'user'], ['age', '>', 21] ],
 *    [key, '=', 'value ],
 *    [key, 'in', [1,2,3,45] ],
 * ]
 * @param obj
 * @param when
 * @param core
 * @constructor
 */
function EvaluateWhenConditions(obj, when = null, core) {
    if (!when || when === null)
        return true;
    let pass = true;
    if (IsArray(when, true)) { // conditional logic to display fields
        let block;
        when = DeepCopy(when).filter((section) => IsArray(section, true));
        const isOrStatement = when.length > 1;
        if (isOrStatement) {
            // console.log('or check', obj, when, core);
            when.reverse();
            while (when.length) {
                block = when.pop().filter((section) => IsArray(section, true));
                pass = EvaluateWhenCondition(obj, block, core);
                if (pass)
                    break;
            }
        }
        else {
            // console.log('check', obj, when, core);
            pass = EvaluateWhenCondition(obj, when, core);
        }
    }
    else {
        pass = false;
    }
    return pass;
}
/**
 * Evaluate a single conditional block: [location, operator, value]
 * @param obj
 * @param block
 * @param core
 * @constructor
 */
function EvaluateWhenCondition(obj, block, core) {
    const operators = ['=', '>', '>=', '<', 'truthy', 'falsey', 'length', 'contains'];
    let pass = true;
    let location;
    let operator;
    let value;
    if (IsArray(block, true)) {
        // expects array of arrays
        block.some((section) => {
            section.some((rule) => {
                // console.log('rule', rule);
                // console.log('has core', core);
                if (IsArray(rule, true)) {
                    location = rule[0];
                    if (rule.length === 1) {
                        operator = 'truthy';
                        value = undefined;
                    }
                    else if (rule.length === 2) {
                        operator = '=';
                        value = rule[1];
                        if (['truthy', 'falsey', 'length'].includes(value)) {
                            operator = value;
                            value = undefined;
                        }
                    }
                    else if (rule.length >= 2) {
                        operator = rule[1];
                        value = rule[2];
                    }
                    if (location && operator && operators.includes(operator)) {
                        if (IsString(location, true) && location in obj && obj[location]) {
                            location = obj[location];
                        }
                        else if (IsString(location, true) && location.includes('.')) {
                            location = GetObjectVar(obj, location);
                        }
                        else {
                            location = ParseModelValue(location, core);
                        }
                        if (IsString(value, true) && IsObject(core, [value])) {
                            value = ParseModelValue(value, core);
                        }
                        else if (IsString(value, true) && IsObject(obj, [value])) {
                            value = GetObjectVar(obj, value);
                        }
                        // console.log('location', location);
                        // console.log('operator', operator);
                        // console.log('value', value);
                        switch (operator) {
                            case 'contains':
                                if (IsArray(location)) {
                                    if (!(location.includes(value))) {
                                        pass = false;
                                        return true;
                                    }
                                }
                                else if (IsString(location)) {
                                    if (!(location.search(value) > -1)) {
                                        pass = false;
                                        return true;
                                    }
                                }
                                else if (IsObject(location)) {
                                    if (!(value in location)) {
                                        pass = false;
                                        return true;
                                    }
                                }
                                else {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case 'length':
                                if (!(IsArray(location, true))) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case 'truthy':
                                if (!location) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case 'falsey':
                                if (location) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '=':
                                if (location != value) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '!=':
                                if (location == value) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '>':
                                if (!(location > value)) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '>=':
                                if (!(location >= value)) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '<':
                                if (!(location < value)) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            case '<=':
                                if (!(location <= value)) {
                                    pass = false;
                                    return true;
                                }
                                break;
                            default:
                                pass = false;
                                return true;
                                break;
                        }
                    }
                    else {
                        pass = false;
                        return true;
                    }
                }
                else {
                    pass = false;
                    return true;
                }
            });
            return pass === false;
        });
    }
    else {
        pass = false;
    }
    return pass;
}
/**
 * check if event matches the signature for a field patch
 * @param core
 * @param event
 * @constructor
 */
function IsValidFieldPatchEvent(core, event) {
    if (IsObject(event, true)) {
        if (event.type === 'field' && event.name === 'patch' && event.success) {
            return true;
        }
        if (event.type === 'field' && event.name === 'onChange' && event.config.facade) {
            return true;
        }
    }
    return false;
}
/**
 * check if event matches the signature for a field patch
 * @param core
 * @param event
 * @constructor
 */
function IsValidChangeEvent(core, event) {
    if (IsObject(event, true)) {
        if (event.type === 'field' && event.name === 'onChange') {
            return true;
        }
    }
    return false;
}
/**
 * Check if a event matches the same core signature of a core that belongs to a component
 * @param core
 * @param event
 * @constructor
 */
function IsValidCoreSignature(core, event = null) {
    console.log(' IsValidCoreSignature core', core);
    console.log(' IsValidCoreSignature event', event);
    if (IsObject(core, true) && IsObject(core.entity)) {
        if (IsObject(event, true) && IsObject(event.core)) {
            return core === event.core;
        }
        return true;
    }
    console.log('IsValidCoreSignature, fail');
    return false;
}
function GetCustomFieldSettings(field) {
    let fieldSettings = {};
    switch (String(field.fieldgroup.name).toLowerCase()) {
        case 'email':
            fieldSettings = EmailFieldSetting;
            break;
        case 'address':
            fieldSettings = AddressFieldSetting;
            break;
        case 'phone':
            fieldSettings = PhoneFieldSetting;
            break;
        case 'name':
            fieldSettings = NameFieldSetting;
            break;
        case 'textfield':
        case 'input':
            fieldSettings = InputFieldSetting;
            break;
        case 'radio':
            fieldSettings = RadioFieldSetting;
            break;
        case 'switch':
            fieldSettings = SwitchFieldSetting;
            break;
        case 'select':
            fieldSettings = SelectFieldSetting;
            break;
        case 'select-multi':
        case 'select_multi':
        case 'multi_selection':
            fieldSettings = SelectFieldSetting;
            break;
        case 'checkbox':
            fieldSettings = CheckboxFieldSetting;
            break;
        case 'textarea':
            fieldSettings = TextareaFieldSetting;
            break;
        default:
            fieldSettings = {};
    }
    return fieldSettings;
}
/**
 * Selection type fields require a list of options to present the user
 * The option values may be directly assigned on the field, point to a specific location in the entity data, or reference a resource that may exists in the entity models
 * ...
 * options:{
 *   ...
 *   values: FieldItemOptions[], resolve what is in this list
 *   ...
 * }
 * ...
 * @param core
 * @param options
 * @private
 */
function ModelOptionValues(core, options) {
    if (IsObject(options, true)) {
        if (IsString(options.resource, true)) {
            if (IsObject(core.resource, true) && options.resource in core.resource && IsObject(core.resource[options.resource], ['data_values']) && IsArray(core.resource[options.resource].data_values, true)) {
                options.converted = false;
                options.rawValues = DeepCopy(core.resource[options.resource].data_values);
                // options.values = DeepCopy( core.resource[ options.resource ].data_values );
            }
        }
        else if (IsArray(options.values, true)) {
            options.converted = false;
            const tmp = DeepCopy(options.values);
            options.values = null;
            options.rawValues = tmp;
        }
        else if (IsString(options.values)) {
            const tmpOptions = GetObjectVar(core, options.values);
            if (IsArray(tmpOptions)) {
                options.converted = false;
                options.rawValues = DeepCopy(tmpOptions);
            }
            else {
                const tmp = ParseModelValue(options.values, core);
                if (IsArray(tmp, true)) {
                    options.converted = false;
                    options.rawValues = DeepCopy(tmp);
                }
            }
        }
    }
    return options;
}
/**
 * Get the rules that should be applied on this field
 * @param fieldItem
 * @private
 */
function FieldItemRules(fieldItem) {
    const RuleSet = {};
    fieldItem.rule = {};
    const itemRules = IsArray(fieldItem.itemrules, true) ? fieldItem.itemrules : []; // default rules inherited from the field_item_id
    const fieldRules = IsArray(fieldItem.fieldrules, true) ? fieldItem.fieldrules : []; // rules specific to this field item
    // we want field rules to override items rules when there is overlap ie.. the item might come with a default rule but the items rules should override it
    itemRules.map((rule) => {
        if (IsArray(rule.validations, true)) {
            if (!(IsObject(rule.options)))
                rule.options = {};
            rule.options.values = ConvertArrayToOptionList(rule.validations, {
                nameKey: 'label',
            });
            rule.validationMap = ArrayKeyBy(rule.validations, 'id');
            rule.value = +rule.validation.id;
        }
        else {
            rule.value = rule.raw_value;
        }
        if (!rule.value && rule.default_value)
            rule.value = rule.default_value;
        RuleSet[rule.name] = rule;
    });
    fieldRules.map((rule) => {
        if (IsObject(RuleSet[rule.name])) {
            RuleSet[rule.name].id = rule.id;
            RuleSet[rule.name].value = IsArray(RuleSet[rule.name].validations, true) ? rule.validation.id : rule.raw_value;
            RuleSet[rule.name].field_id = rule.field_id;
        }
    });
    fieldItem.rules = Object.values(RuleSet);
    fieldItem.rules.map((rule) => {
        if (!rule.validation.fixed) {
            fieldItem.rule[rule.name] = ParseModelValue(rule.value);
        }
    });
    // delete fieldItem.fieldrules;
    // delete fieldItem.itemrules;
}
function FieldItemModel(core, fieldItem, checkAccess = true) {
    if (IsObject(fieldItem, true)) {
        let hasAccess = true;
        if (checkAccess) {
            hasAccess = core.access.can_update ? true : false;
            if (IsObject(core.entity, ['system']) && core.entity.system)
                hasAccess = false;
        }
        const showAsReadonly = +fieldItem.readonly ? true : (!hasAccess ? true : false);
        const allowPatch = IsObject(core.entity, ['id']) && IsObject(fieldItem.patch, ['path']) && !fieldItem.facade && hasAccess && !showAsReadonly ? true : false;
        if (!fieldItem.metadata) {
            fieldItem.metadata = {};
        }
        fieldItem.metadata = DeepMerge(fieldItem.metadata, { internal_name: core.params.internal_name });
        // ToDo:: Optimize this part, currently uses catch-all method to accommodate all field item types, need to run checks on some and not others which prevents simply merging
        let model = Object.assign({}, CleanObject({
            access: hasAccess,
            align: fieldItem.align,
            all: fieldItem.all,
            allValue: fieldItem.allValue,
            allowAll: fieldItem.allowAll,
            allowGroupAll: fieldItem.allowGroupAll,
            allOverlay: fieldItem.allOverlay,
            allOverlayEnabled: fieldItem.allOverlayEnabled,
            allOverlayLabel: fieldItem.allOverlayLabel,
            allOverlayMessage: fieldItem.allOverlayMessage,
            allOverlayCallback: fieldItem.allOverlayCallback,
            autoFill: +fieldItem.autoFill ? true : null,
            autoSize: +fieldItem.autoSize ? true : null,
            autofocus: +fieldItem.autofocus ? true : null,
            autoselect: +fieldItem.autoselect ? true : null,
            border: fieldItem.border,
            bubble: fieldItem.bubble,
            button: fieldItem.button,
            checkboxPosition: fieldItem.checkboxPosition,
            className: fieldItem.className,
            color: fieldItem.color,
            collapsed: fieldItem.collapsed,
            control: fieldItem.control,
            defaultHeight: fieldItem.defaultHeight,
            disabled: +fieldItem.disabled ? true : false,
            displayErrors: +fieldItem.displayErrors ? true : false,
            dropSpecial: fieldItem.dropSpecial,
            event: +fieldItem.event,
            empty: fieldItem.empty,
            facade: fieldItem.facade ? true : false,
            filterPredicate: fieldItem.filterPredicate,
            form: fieldItem.view ? String(fieldItem.view.name).toLowerCase() : fieldItem.form ? fieldItem.form : 'label',
            header: fieldItem.header,
            hidden: fieldItem.hidden,
            hint: fieldItem.hint,
            hintText: fieldItem.hintText,
            height: fieldItem.height,
            helpText: fieldItem.helpText,
            helper: fieldItem.helper,
            html: fieldItem.html,
            icon: fieldItem.icon,
            iconColor: fieldItem.iconColor,
            interval: fieldItem.interval,
            layout: fieldItem.setting && fieldItem.setting.layout,
            level: fieldItem.level,
            levelGap: fieldItem.levelGap,
            link: fieldItem.link,
            label: fieldItem.label,
            list: fieldItem.list,
            maxHeight: fieldItem.maxHeight,
            multiple: fieldItem.multiple,
            message: fieldItem.message,
            minimal: fieldItem.minimal,
            mode: fieldItem.mode,
            noInitialValue: fieldItem.noInitialValue,
            labelPosition: fieldItem.labelPosition,
            mask: fieldItem.mask,
            metadata: fieldItem.metadata ? fieldItem.metadata : {},
            min: fieldItem.min,
            max: fieldItem.max,
            minColumn: fieldItem.minColumn,
            maxColumn: fieldItem.maxColumn,
            minHeight: fieldItem.minHeight,
            minlength: IsObject(fieldItem.rule) && IsDefined(fieldItem.rule.minlength) ? fieldItem.rule.minlength : (fieldItem.minlength ? fieldItem.minlength : null),
            maxlength: IsObject(fieldItem.rule) && IsDefined(fieldItem.rule.maxlength) ? fieldItem.rule.maxlength : (fieldItem.maxlength ? fieldItem.maxlength : 128),
            minValue: fieldItem.minValue,
            maxValue: fieldItem.maxValue,
            name: fieldItem.name,
            options: ModelOptionValues(core, fieldItem.options),
            pattern: fieldItem.rule && fieldItem.rule.pattern ? fieldItem.rule.pattern : (fieldItem.pattern ? fieldItem.pattern : null),
            patch: allowPatch && fieldItem.patch ? fieldItem.patch : null,
            patchGroupFk: fieldItem.patchGroupFk,
            padding: fieldItem.padding,
            position: fieldItem.position,
            preserve: fieldItem.preserve,
            prevent: fieldItem.prevent,
            prefix: fieldItem.prefix ? fieldItem.prefix : null,
            suffix: fieldItem.suffix ? fieldItem.suffix : null,
            radius: fieldItem.radius,
            readonly: showAsReadonly,
            reset: fieldItem.reset,
            route: fieldItem.route,
            required: fieldItem.rule && fieldItem.rule.required ? true : fieldItem.required ? true : false,
            session: fieldItem.session,
            sessionPath: fieldItem.sessionPath,
            showMask: fieldItem.showMask,
            showTooltip: fieldItem.showTooltip,
            size: fieldItem.size,
            sort: fieldItem.sort,
            sort_order: fieldItem.sort_order,
            specialChars: fieldItem.specialChars,
            tooltip: fieldItem.tooltip,
            toolTipDirection: fieldItem.toolTipDirection,
            textOverflow: fieldItem.textOverflow,
            transformation: fieldItem.transformation,
            truncate: fieldItem.truncate,
            type: fieldItem.type,
            value: fieldItem.value,
            validators: fieldItem.validators,
            width: fieldItem.width,
            warning: fieldItem.warning,
            when: IsArray(fieldItem.when, true) ? fieldItem.when : null
        }));
        if (model.form === 'label') { // label specific params
            model = Object.assign(Object.assign({}, model), CleanObject({
                subLabel: fieldItem.subLabel ? fieldItem.subLabel : null,
                subValue: fieldItem.subValue ? fieldItem.subValue : null,
                truncate: fieldItem.truncate ? fieldItem.truncate : null,
                copyLabel: fieldItem.copyLabel ? fieldItem.copyLabel : null,
                labelButton: fieldItem.labelButton ? fieldItem.labelButton : null,
                valueButton: fieldItem.valueButton ? fieldItem.valueButton : null,
                copyLabelBody: fieldItem.copyLabelBody ? fieldItem.copyLabelBody : null,
                copyLabelDisplay: fieldItem.copyLabelDisplay ? fieldItem.copyLabelDisplay : null,
                valueButtonDisplay: fieldItem.valueButtonDisplay ? fieldItem.valueButtonDisplay : null,
                valueButtonDisabled: fieldItem.valueButtonDisabled ? fieldItem.valueButtonDisabled : null,
                valueButtonDisplayTransformation: fieldItem.valueButtonDisplayTransformation ? fieldItem.valueButtonDisplayTransformation : null,
            }));
        }
        delete fieldItem.patch;
        if (model.patch) {
            if (model.patch.path)
                model.patch.path = StringReplaceAll(ParseUrlForParams(model.patch.path, core.params), '//', '/');
            if (model.patch.metadata)
                model.patch.metadata = ParseObjectDefinitions(model.patch.metadata, core);
        }
        return model;
    }
    return {};
}
/**
 * When patches are made, we need to update the entity in the core config
 * ToDo:: Hoping to be able to improve this, and have each component be responsible to manage their own updates. My hesitation right now is I want the least amount of components as possible manipulating the core config
 * @param core
 * @param event
 */
function SessionEntityFieldUpdate(core, event, path = null) {
    PopLog.event(`SessionEntityFieldUpdate`, `Session Detected`, event);
    if (IsValidCoreSignature(core, event)) {
        if (IsValidFieldPatchEvent(core, event)) {
            let value;
            if (!(IsString(path, true)))
                path = 'entity';
            const session = StorageGetter(core, String(path).trim().split('.'));
            if (event.config.name in session || event.config.facade) {
                value = event.config.control ? event.config.control.value : event.data;
                value = ParseModelValue(value);
                console.log('SessionEntityFieldUpdate', session, event.config.name, value);
                session[event.config.name] = value;
                core.repo.clearCache('active', `SessionEntityFieldUpdate`);
                core.repo.clearCache('all', `SessionEntityFieldUpdate`);
                event.session = true;
            }
            return true;
        }
    }
    return false;
}
function GetSingularName(value) {
    if (IsString(value, true) && String(value).length > 3) {
        let tmp = SpaceToHyphenLower(String(value).toLowerCase().trim());
        if (String(tmp).slice(-3) === 'ies') {
            tmp = String(tmp).slice(0, -3);
            tmp += 'y';
        }
        else if (String(tmp).slice(-1) === 's') {
            tmp = String(tmp).slice(0, -1);
        }
        return tmp;
    }
    return value;
}
function IsAliasable(value) {
    if (IsString(value, true) && String(value).length > 3) {
        const tmp = SpaceToHyphenLower(String(value).toLowerCase().trim());
        if (IsObject(PopRouteAliasMap, true) && tmp in PopRouteAliasMap) {
            return true;
        }
    }
    return false;
}
function IsEntity(entityValue) {
    if (IsString(entityValue, true)) {
        if (IsObject(PopApp, ['entities']) && entityValue in PopApp.entities) {
            return true;
        }
    }
    return false;
}
function ParseModuleRoutes(parent, config, routes = []) {
    for (let i = 0; i < config.length; i++) {
        const route = config[i];
        // console.log(parent + '/' + route.path);
        routes.push(route);
        if (route.children) {
            const currentPath = route.path ? parent + '/' + route.path : parent;
            ParseModuleRoutes(currentPath, route.children, routes);
        }
    }
    return routes;
}
function ParseModuleRoutesForAliases(routes) {
    if (IsArray(routes, true)) {
        routes.map((route) => {
            if (IsObject(route.data, ['alias', 'internal_name'])) {
                const alias = route.data.alias;
                if (IsObject(alias, ['target', 'type']) && !route.data.masterPath) {
                    route.data.masterPath = route.path;
                    if (IsString(alias.target, true) && IsString(alias.type, true)) {
                        route.path = String(StringReplaceAll(route.path, alias.target, GetRouteAlias((IsString(alias.internal_name, true) ? alias.internal_name : route.data.internal_name), alias.type))).trim();
                        if (route.data.masterPath !== route.path)
                            routes.push({
                                path: route.data.masterPath,
                                redirectTo: route.path,
                                pathMatch: 'prefix'
                            });
                    }
                    if (IsObject(route.data.table, true)) {
                        if (IsString(route.data.table.route, true)) {
                            const tableRoute = route.data.table.route;
                            if (String(tableRoute).includes(alias.target)) {
                                route.data.table.route = String(StringReplaceAll(tableRoute, alias.target, GetRouteAlias((IsString(alias.internal_name, true) ? alias.internal_name : route.data.internal_name), alias.type))).trim();
                            }
                        }
                        if (IsString(route.data.table.goToUrl)) {
                            const goToUrl = route.data.table.goToUrl;
                            if (String(goToUrl).includes(route.data.alias)) {
                                route.data.table.goToUrl = String(StringReplaceAll(goToUrl, route.data.alias, GetRouteAlias((IsString(alias.internal_name, true) ? alias.internal_name : route.data.internal_name), alias.type))).trim();
                            }
                        }
                    }
                }
                else if (IsString(route.data.alias, true) && !route.data.masterPath) {
                    route.data.masterPath = route.path;
                    route.path = String(StringReplaceAll(route.path, route.data.alias, GetRouteAlias(route.data.internal_name, 'plural'))).trim();
                    if (route.data.masterPath !== route.path)
                        routes.push({
                            path: route.data.masterPath,
                            redirectTo: route.path,
                            pathMatch: 'prefix'
                        });
                    if (IsObject(route.data.table, true)) {
                        if (IsString(route.data.table.route, true)) {
                            const tableRoute = route.data.table.route;
                            if (String(tableRoute).includes(route.data.alias)) {
                                route.data.table.route = String(StringReplaceAll(tableRoute, route.data.alias, GetRouteAlias(route.data.internal_name, 'plural'))).trim();
                            }
                        }
                        if (IsString(route.data.table.goToUrl)) {
                            const goToUrl = route.data.table.goToUrl;
                            if (String(goToUrl).includes(route.data.alias)) {
                                route.data.table.goToUrl = String(StringReplaceAll(goToUrl, route.data.alias, GetRouteAlias(route.data.internal_name, 'plural'))).trim();
                            }
                        }
                    }
                }
            }
            if (IsArray(route.children, true)) {
                route.children = ParseModuleRoutesForAliases(route.children);
            }
            if (IsObject(route._loadedConfig, ['routes'])) {
                route._loadedConfig.routes = ParseModuleRoutesForAliases(route._loadedConfig.routes);
            }
        });
    }
    return routes;
}
function FieldItemView(view) {
    const tmp = IsObject(view) ? view : null;
    return CleanObject({
        id: tmp ? tmp.id : 0,
        name: tmp ? tmp.name : 'label',
        type: tmp && String(tmp.html).includes('[') ? String(tmp.html).split('[')[1].split(']')[0] : 'text',
        description: tmp ? tmp.description : null
    });
}
function FieldItemBooleanValue(model, core) {
    PopLog.debug('FieldItemBooleanValue', `convert:`, { name: name, model: model, core: core });
    let result;
    if (IsDefined(model.value, false)) {
        if (typeof model.value === 'boolean') {
            result = model.value;
        }
        else if (IsString(model.value, true)) {
            result = ParseModelValue(model.value, core);
        }
        else if (IsNumber(model.value, false)) {
            result = +core.entity[model.name] > 0;
        }
    }
    if (!(IsDefined(result, false)) && model.name && IsObject(core.entity, true) && IsDefined(core.entity[model.name])) {
        result = +core.entity[model.name] > 0;
    }
    if (!(IsDefined(result, false)))
        result = false;
    PopLog.debug('FieldItemBooleanValue', `result:`, { initial: model.value, result: result });
    return result;
}
function FieldItemTextValue(model, core) {
    let result;
    if (+model.value > 0) {
        result = model.value;
    }
    else if (IsDefined(model.value, false) && IsString(model.value, true)) {
        result = ParseModelValue(model.value, core);
        // console.log( 'belongs to parse', model.value, result );
    }
    if (!(IsDefined(result, false)) && model.name && IsObject(core.entity, true) && IsDefined(core.entity[model.name]) && IsString(core.entity[model.name], true)) {
        result = core.entity[model.name];
        // console.log( 'belongs to entity', model.value, result );
    }
    if (!(IsDefined(result, false)) || result === 'Null')
        result = '';
    return result;
}
function FieldItemArrayValue(model, core) {
    let result;
    if (IsDefined(model.value, false)) {
        if (IsArray(model.value, false)) {
            result = model.value;
        }
        else if (IsString(model.value, true)) {
            result = ParseModelValue(model.value, core);
        }
    }
    if (!(IsArray(result, false)) && model.name && IsObject(core.entity, true) && IsArray(core.entity[model.name], false)) {
        result = core.entity[model.name];
    }
    if (!(IsArray(result, false)))
        result = [];
    return result;
}
function GetPatternValidator(pattern) {
    // ToDo:: Add all of the options that are built for this, numeric, alpha, ....
    switch (String(pattern).toLowerCase()) {
        case 'url':
            return ValidateUrl;
            break;
        case 'phone':
            return ValidatePhone;
            break;
        case 'email':
            return Validators.email;
            break;
        case 'zip':
            return ValidatePhone;
            break;
        case 'password':
            return ValidatePassword;
            break;
        case 'username':
            return ValidateUsername;
            break;
        default:
            return null;
    }
}
function FieldItemOptionValues(model, core) {
    if (IsUndefined(model.options)) {
        model.options = {
            rawValues: [],
            values: []
        };
    }
    // console.log('model', model.options);
    if (!IsArray(model.options.rawValues, true)) {
        const optionValues = IsArray(model.options.values, true) ? model.options.values : [];
        model.options.rawValues = [...new Map(optionValues.map(item => [item['name'], item])).values()];
    }
    const list = ConvertArrayToOptionList(model.options.rawValues, {
        converted: model.options.converted ? true : false,
        // ensure that an option shows up in list in case other conditions remove it, aka it has been archived
        nameKey: model.options.nameKey ? model.options.nameKey : 'name',
        ensure: model.options.ensure && IsObject(core.entity, true) ? {
            name: core.entity[model.options.ensure.name],
            value: core.entity[model.name]
        } : undefined,
        prevent: IsArray(model.options.prevent, true) ? model.options.prevent : [],
        preserveKeys: IsArray(model.options.preserveKeys, true) ? model.options.preserveKeys : [],
        // parent means this options should all have a common field trait like client_fk, account_fk ....
        parent: model.options.parent && IsObject(core.entity, true) ? {
            field: model.options.parent,
            value: core.entity[model.options.parent]
        } : undefined,
        // empty is the blank or null option that you want to have
        empty: null,
        sort: IsDefined(model.options.sort) ? model.options.sort : true,
    });
    return list;
}
/**
 * Generatea form config from the field item model;
 * @param core
 * @param model
 * @constructor
 */
function FieldItemModelConfig(core, model) {
    let value;
    let assigned;
    let configInterface;
    let validators;
    //   const isDialogLimit = this.srv.dialog.openDialogs.length > 3;
    const isDialogLimit = false;
    let config = null;
    // const metadata = { ...GetCoreParamsAsMetadata(core.params), ...model.metadata };
    switch (model.form) {
        case 'sidebyside':
            assigned = Array.isArray(model.options.assigned) && model.options.assigned.length ? model.options.assigned : typeof model.options.assigned === 'string' && IsObject(core.entity.assignments, true) && Array.isArray(core.entity.assignments[model.options.assigned]) ? core.entity.assignments[model.options.assigned] : [];
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                assigned: assigned,
                assignAll: typeof model.assign_all === 'boolean' ? model.assign_all : false,
                assignedLabel: typeof model.assignedLabel === 'string' ? model.assignedLabel : 'Assigned',
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                displayHelper: typeof model.displayHelper === 'boolean' ? model.displayHelper : false,
                displayTitle: typeof model.displayTitle === 'boolean' ? model.displayTitle : false,
                facade: true,
                filter: typeof model.filter === 'boolean' ? model.filter : true,
                helpText: typeof model.helpText === 'string' ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                metadata: model.metadata,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                name: model.name ? model.name : null,
                optionsLabel: typeof model.optionsLabel === 'string' ? model.optionsLabel : 'Available',
                options: model.options,
                // bucketHeight: typeof model.bucketHeight === 'string' ? model.bucketHeight : undefined,
                parentHeight: 'mat-grid-tile',
                patch: model.patch,
                route: typeof model.route === 'string' ? model.route : undefined,
                removeAll: typeof model.removeAll === 'boolean' ? model.removeAll : false,
                session: model.session,
                sessionPath: model.sessionPath,
                validators: model.required ? [Validators.required] : undefined,
            };
            config = new SideBySideConfig(CleanObject(configInterface));
            break;
        case 'select':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                autoFill: model.autoFill,
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                empty: model.empty ? model.empty : null,
                facade: model.facade ? true : false,
                height: model.height ? model.height : undefined,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                mode: model.mode ? model.mode : 'select',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                required: model.required ? true : false,
                validators: model.required ? [Validators.required] : undefined,
                value: typeof model.value !== 'undefined' && model.value !== null ? ParseModelValue(model.value, core) : IsObject(core.entity, true) && typeof core.entity[(model.name ? model.name : null)] !== 'undefined' ? core.entity[(model.name ? model.name : null)] : null,
            };
            config = new SelectConfig(CleanObject(configInterface));
            break;
        case 'select-modal':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            const configListInterface = {
                autoFill: model.autoFill,
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                empty: model.empty ? model.empty : null,
                facade: model.facade ? true : false,
                height: model.height ? model.height : undefined,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.subLabel ? ParseForAlias(model.subLabel) : '',
                mode: model.mode ? model.mode : 'select',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                required: model.required,
                validators: model.required ? [Validators.required] : undefined,
                value: typeof model.value !== 'undefined' && model.value !== null ? ParseModelValue(model.value, core) : IsObject(core.entity, true) && typeof core.entity[(model.name ? model.name : null)] !== 'undefined' ? core.entity[(model.name ? model.name : null)] : null,
            };
            config = new SelectModalConfig({
                facade: false,
                header: model.header ? model.header : null,
                label: model.label ? model.label : null,
                metadata: {},
                name: model.name,
                required: model.required,
                validators: model.required ? [Validators.required] : undefined,
                list: new SelectListConfig(CleanObject(configListInterface))
            });
            break;
        case 'select-filter':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                autoFill: model.autoFill,
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                height: model.height ? model.height : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                mode: model.mode ? model.mode : 'select',
                minHeight: model.minHeight ? model.minHeight : undefined,
                multiple: model.multiple ? true : false,
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                validators: model.required ? [Validators.required] : undefined,
                value: typeof model.value !== 'undefined' && model.value !== null ? ParseModelValue(model.value, core) : IsObject(core.entity, true) && typeof core.entity[(model.name ? model.name : null)] !== 'undefined' ? core.entity[(model.name ? model.name : null)] : null,
            };
            config = new SelectFilterConfig(CleanObject(configInterface));
            break;
        case 'select-list':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                autoFill: model.autoFill,
                all: model.all,
                allowAll: model.allowAll,
                allowGroupAll: model.allowGroupAll,
                allOverlay: model.allOverlay,
                allOverlayEnabled: model.allOverlayEnabled,
                allOverlayLabel: model.allOverlayLabel,
                allOverlayMessage: model.allOverlayMessage,
                allOverlayCallback: model.allOverlayCallback,
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                height: model.height ? model.height : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                mode: model.mode ? model.mode : null,
                multiple: model.multiple ? true : false,
                minHeight: model.minHeight ? model.minHeight : undefined,
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                required: model.required,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                validators: model.required ? [Validators.required] : undefined,
                value: typeof model.value !== 'undefined' && model.value !== null ? ParseModelValue(model.value, core) : IsObject(core.entity, true) && typeof core.entity[(model.name ? model.name : null)] !== 'undefined' ? core.entity[(model.name ? model.name : null)] : null,
            };
            config = new SelectListConfig(CleanObject(configInterface));
            break;
        case 'select-multi':
        case 'select_multi':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                validators: model.required ? [Validators.required] : undefined,
                value: FieldItemArrayValue(model, core),
            };
            model.options.converted = true;
            config = new SelectMultiConfig(CleanObject(configInterface));
            break;
        case 'textfield':
        case 'text':
        case 'input':
            validators = [];
            if (!model.mask)
                validators.push(Validators.maxLength(+model.maxlength || 64));
            if (model.mask)
                model.maxlength = null;
            if (model.required)
                validators.push(Validators.required);
            if (model.pattern) {
                const patternValidator = GetPatternValidator(model.pattern);
                if (patternValidator) {
                    validators.push(patternValidator);
                }
            }
            if (+model.minlength)
                validators.push(Validators.minLength(+model.minlength));
            configInterface = {
                autofocus: model.autofocus ? true : null,
                autoselect: model.autoselect ? true : null,
                bubble: model.bubble ? true : false,
                disabled: model.disabled ? true : false,
                empty: model.empty ? model.empty : null,
                facade: model.facade ? true : null,
                hint: model.hint ? true : null,
                hintText: model.hintText ? model.hintText : null,
                helpText: model.helpText ? model.helpText : null,
                hidden: model.hidden ? true : false,
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                metadata: model.metadata,
                maxlength: model.maxlength || 64,
                mask: typeof model.mask === 'string' && model.mask.length ? model.mask : null,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                patch: model.patch,
                pattern: typeof model.pattern === 'string' && model.pattern.length ? model.pattern : null,
                prefix: IsString(model.prefix, true) ? model.prefix : null,
                prevent: IsArray(model.prevent, true) ? model.prevent : null,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                suffix: typeof model.suffix === 'string' && model.suffix.length ? model.suffix : null,
                transformation: IsString(model.transformation, true) ? model.transformation : null,
                validators: validators,
                value: FieldItemTextValue(model, core),
            };
            config = new InputConfig(CleanObject(configInterface));
            break;
        case 'number':
            validators = [];
            if (model.min)
                validators.push(Validators.max(model.min));
            if (model.max)
                validators.push(Validators.max(model.max));
            if (model.required)
                validators.push(Validators.required);
            configInterface = {
                bubble: model.bubble ? true : false,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : null,
                hidden: model.hidden ? true : false,
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                metadata: model.metadata,
                min: typeof model.min !== 'undefined' ? model.min : 1,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                name: model.name ? model.name : null,
                prefix: IsString(model.prefix, true) ? model.prefix : '',
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                suffix: typeof model.suffix === 'string' && model.suffix.length ? model.suffix : '',
                step: typeof model.step ? model.step : 1,
                transformation: IsString(model.transformation, true) ? model.transformation : null,
                validators: validators,
                value: FieldItemTextValue(model, core),
            };
            config = new NumberConfig(CleanObject(configInterface));
            break;
        case 'date':
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : null,
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                min: IsString(model.min, true) ? model.min : null,
                // min: isNaN( model.min ) === false ? model.min : null,
                max: isNaN(model.max) === false ? model.max : null,
                metadata: model.metadata,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                name: model.name ? model.name : null,
                patch: model.patch,
                required: model.required,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                transformation: IsString(model.transformation, true) ? model.transformation : null,
                type: IsString(model.type, true) ? model.type : "Basic",
                value: FieldItemTextValue(model, core),
                validators: model.required ? [Validators.required] : undefined,
            };
            configInterface = CleanObject(configInterface);
            if (IsDefined(model.filterPredicate))
                configInterface.filterPredicate = model.filterPredicate;
            config = new DateConfig(configInterface);
            break;
        case 'datepicker':
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : null,
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                min: IsString(model.min, true) ? model.min : null,
                // min: isNaN( model.min ) === false ? model.min : null,
                max: isNaN(model.max) === false ? model.max : null,
                metadata: model.metadata,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                name: model.name ? model.name : null,
                patch: model.patch,
                required: model.required,
                transformation: IsString(model.transformation, true) ? model.transformation : null,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                value: FieldItemTextValue(model, core),
                validators: model.required ? [Validators.required] : undefined,
            };
            configInterface = CleanObject(configInterface);
            if (IsDefined(model.filterPredicate))
                configInterface.filterPredicate = model.filterPredicate;
            config = new DatePickerConfig(configInterface);
            break;
        case 'time':
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : null,
                interval: model.interval ? model.interval : 15,
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                metadata: model.metadata,
                min: typeof model.min === 'string' ? model.min : null,
                max: typeof model.max === 'string' ? model.max : null,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                time: model.time ? model.time : 12,
                transformation: IsString(model.transformation, true) ? model.transformation : null,
                value: FieldItemTextValue(model, core),
                validators: model.required ? [Validators.required] : undefined,
            };
            config = new TimeConfig(CleanObject(configInterface));
            break;
        case 'checkbox':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                labelPosition: typeof model.labelPosition !== 'undefined' ? model.labelPosition : 'after',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                session: model.session,
                sessionPath: model.sessionPath,
                textOverflow: model.textOverflow ? model.textOverflow : 'wrap',
                value: FieldItemBooleanValue(model, core),
            };
            config = new CheckboxConfig(CleanObject(configInterface));
            break;
        case 'switch':
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                labelPosition: typeof model.labelPosition !== 'undefined' ? model.labelPosition : 'after',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                patch: model.patch,
                session: model.session,
                sessionPath: model.sessionPath,
                textOverflow: model.textOverflow ? model.textOverflow : 'wrap',
                value: FieldItemBooleanValue(model, core),
            };
            config = new SwitchConfig(CleanObject(configInterface));
            break;
        case 'minmax':
            const minColumn = model.minColumn ? model.minColumn : 'min';
            const maxColumn = model.maxColumn ? model.maxColumn : 'max';
            const minValue = typeof model.minValue !== 'undefined' && model.minValue !== null ? ParseModelValue(model.minValue, core) : IsObject(core.entity, true) && typeof core.entity[minColumn] !== 'undefined' ? core.entity[minColumn] : 1;
            const maxValue = typeof model.maxValue !== 'undefined' && model.maxValue !== null ? ParseModelValue(model.maxValue, core) : IsObject(core.entity, true) && typeof core.entity[maxColumn] !== 'undefined' ? core.entity[maxColumn] : 10;
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                label: model.label ? ParseForAlias(model.label) : '',
                minColumn: model.minColumn ? model.minColumn : 'min',
                maxColumn: model.maxColumn ? model.maxColumn : 'max',
                minValue: minValue,
                maxValue: maxValue,
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                patch: model.patch,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
            };
            config = new MinMaxConfig(CleanObject(configInterface));
            break;
        case 'radio':
            model.options.values = FieldItemOptionValues(model, core);
            model.options.converted = true;
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                helpText: model.helpText ? model.helpText : '',
                id: model.id ? model.id : undefined,
                labelPosition: typeof model.labelPosition !== 'undefined' ? model.labelPosition : 'above',
                label: model.label ? ParseForAlias(model.label) : '',
                layout: typeof model.layout !== 'undefined' ? model.layout : 'row',
                metadata: model.metadata,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                options: model.options,
                patch: model.patch,
                reset: model.reset ? true : false,
                readonly: model.readonly ? true : false,
                session: model.session,
                sessionPath: model.sessionPath,
                sort: typeof model.labelPosition !== 'undefined' ? model.sort : false,
                value: FieldItemTextValue(model, core),
            };
            model.options.converted = true;
            config = new RadioConfig(CleanObject(configInterface));
            break;
        case 'textarea':
            configInterface = {
                autoSize: model.autoSize ? true : false,
                bubble: model.bubble ? true : false,
                facade: model.facade ? true : false,
                height: model.height || 70,
                helpText: model.helpText ? model.helpText : '',
                id: model.id ? model.id : undefined,
                label: ParseForAlias(model.label),
                maxlength: model.maxlength || 255,
                metadata: model.metadata,
                maxHeight: model.maxHeight || null,
                name: model.name ? model.name : null,
                noInitialValue: model.noInitialValue ? model.noInitialValue : false,
                pattern: typeof model.pattern === 'string' && model.pattern.length ? model.pattern : null,
                patch: model.patch,
                readonly: model.readonly,
                session: model.session,
                sessionPath: model.sessionPath,
                validators: model.required ? [Validators.required, Validators.maxLength(model.maxlength || 255)] : [Validators.maxLength(model.maxlength || 255)],
                value: FieldItemTextValue(model, core),
            };
            config = new TextareaConfig(CleanObject(configInterface));
            break;
        case 'label':
            value = typeof model.value !== 'undefined' && model.value !== null ? ParseModelValue(model.value, core) : IsObject(core.entity, true) && IsObject(core.entity, true) && typeof core.entity[(model.name ? model.name : null)] !== 'undefined' ? core.entity[(model.name ? model.name : null)] : '';
            if (model.transformation && typeof (value) !== 'undefined') {
                value = PopTransform(value, model.transformation);
            }
            if (typeof (model.copyLabelDisplay) !== 'undefined') {
                model.copyLabelDisplay = ParseModelValue(model.copyLabelDisplay, core);
                if (model.copyLabelDisplay && model.copyLabelDisplayTransformation) {
                    model.copyLabelDisplay = PopTransform(model.copyLabelDisplay, model.copyLabelDisplayTransformation);
                }
            }
            if (typeof (model.copyLabelBody) !== 'undefined') {
                model.copyLabelBody = ParseModelValue(model.copyLabelBody, core);
                if (model.copyLabelBody && model.copyLabelBodyTransformation) {
                    model.copyLabelBody = PopTransform(model.copyLabelBody, model.copyLabelBodyTransformation);
                }
            }
            if (typeof (model.copyValueDisplay) !== 'undefined') {
                model.copyValueDisplay = model.copyValueDisplay !== null ? ParseModelValue(model.copyValueDisplay, core) : '';
                if (model.copyValueDisplay && model.copyValueDisplayTransformation) {
                    model.copyValueDisplay = PopTransform(model.copyValueDisplay, model.copyValueDisplayTransformation);
                }
            }
            if (typeof (model.copyValueBody) !== 'undefined') {
                model.copyValueBody = model.copyValueBody !== null ? ParseModelValue(model.copyValueBody, core) : '';
                if (model.copyValueBody && model.copyValueBodyTransformation) {
                    model.copyValueBody = PopTransform(model.copyValueBody, model.copyValueBodyTransformation);
                }
            }
            if (typeof (model.valueButtonDisplay) !== 'undefined') {
                model.valueButtonDisplay = ParseModelValue(model.valueButtonDisplay, core);
                if (model.valueButtonDisplay && model.valueButtonDisplayTransformation) {
                    model.valueButtonDisplay = PopTransform(model.valueButtonDisplay, model.valueButtonDisplayTransformation);
                }
            }
            configInterface = CleanObject({
                name: model.name ? model.name : null,
                label: ParseForAlias(model.label),
                button: model.button,
                border: model.border,
                icon: model.icon,
                iconType: model.iconType,
                html: model.html,
                textOverflow: model.textOverflow ? model.textOverflow : 'wrap',
                labelButton: !!model.labelButton,
                copyLabel: !!model.copyLabel,
                copyLabelBody: model.copyLabelBody ? model.copyLabelBody : null,
                copyLabelBodyTransformation: model.copyLabelBodyTransformation ? model.copyLabelBodyTransformation : null,
                copyLabelDisplay: model.copyLabelDisplay ? model.copyLabelDisplay : null,
                copyLabelDisplayTransformation: model.copyLabelDisplayTransformation ? model.copyLabelDisplayTransformation : null,
                copyValue: !!model.copyValue,
                copyValueBody: model.copyValueBody ? model.copyValueBody : null,
                copyValueBodyTransformation: model.copyValueBodyTransformation ? model.copyValueBodyTransformation : null,
                copyValueDisplay: model.copyValueDisplay ? model.copyValueDisplay : null,
                copyValueDisplayTransformation: model.copyValueDisplayTransformation ? model.copyValueDisplayTransformation : null,
                valueButton: !!model.valueButton,
                valueButtonDisabled: !!model.valueButtonDisabled,
                valueButtonDisplay: model.valueButtonDisplay ? model.valueButtonDisplay : null,
                valueButtonDisplayTransformation: model.valueButtonDisplayTransformation ? model.valueButtonDisplayTransformation : null,
                value: value,
                link: model.link || false,
                helpText: model.helpText ? model.helpText : undefined,
                route: model.route && !isDialogLimit ? ParseModelValue(model.route, core) : '',
                metadata: model.metadata,
            });
            config = new LabelConfig(CleanObject(configInterface));
            break;
        case 'textstring':
            configInterface = {
                border: model.border,
                className: model.className,
                header: model.header,
                id: model.id ? model.id : undefined,
                name: model.name ? model.name : null,
                size: model.size,
                textOverflow: model.textOverflow,
                value: model.value ? model.value : '',
                warning: model.warning
            };
            config = new TextConfig(CleanObject(configInterface));
            break;
        case 'button':
            configInterface = {
                bubble: model.bubble ? true : false,
                disabled: model.disabled,
                facade: model.facade ? true : false,
                icon: model.icon ? model.icon : 'help_outline',
                helpText: model.helpText ? model.helpText : undefined,
                id: model.id ? model.id : undefined,
                metadata: model.metadata,
                name: model.name ? model.name : null,
                patch: model.patch,
                value: FieldItemTextValue(model, core),
            };
            config = new ButtonConfig(CleanObject(configInterface));
            break;
        case 'metadata':
            const val = IsDefined(model.value) ? model.value : IsObject(core.entity, true) && model.name in core.entity ? core.entity[model.name] : null;
            config = new MetadataConfig(model.name, val);
            break;
        default:
            PopLog.warn(`FieldItemModelConfig`, `buildCoreFieldItemConfig`, model.form);
            break;
    }
    return config;
}

class PopExtendComponent {
    constructor() {
        this.position = 1;
        this.core = {};
        this.events = new EventEmitter();
        this.when = null;
        this.hidden = false;
        this.id = 1;
        this.trait = GetComponentTraitContainer();
        if (!this.asset)
            this.asset = GetComponentAssetContainer();
        if (!this.ui)
            this.ui = GetComponentAssetContainer();
        this.log = this._initializeLogSystem();
        this.dom = this._initializeDom();
    }
    ngOnInit() {
        this.dom.loading();
        const init = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            yield this.dom._extend();
            yield this.dom.configure();
            yield this.dom.register();
            yield this.dom.proceed();
            if (IsCallableFunction(this.onLoad)) {
                yield this.onLoad(this.core, {
                    source: this.name,
                    type: 'component',
                    name: 'onLoad',
                    data: this
                }, this.dom);
            }
            this.dom.ready();
            return resolve(true);
        }));
        init.then(() => {
            this.log.init();
        });
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        const destroy = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsCallableFunction(this.onUnload)) {
                yield this.onUnload(this.core, {
                    source: this.name,
                    type: 'component',
                    name: 'onUnload',
                    data: this
                });
            }
            yield this.dom.unload();
            if (this.dom.repo)
                this.dom.store();
            this.dom.destroy();
            return resolve(true);
        }));
        destroy.then(() => {
            this.log.destroy();
        });
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _initializeDom() {
        return Object.assign(Object.assign({}, GetComponentDomContainer()), {
            /**
             * Initialize the component in a loading state
             */
            loading: () => {
                this.dom.error = { code: 0, message: '' };
                this.dom.state.loading = true;
                this.dom.state.loader = false;
                this.dom.setTimeout('delay-loader-trigger', () => {
                    this.dom.state.loader = true;
                }, 500);
            },
            /**
             * Configure the component tailored to its specific needs
             */
            _extend: () => {
                return new Promise((resolve) => {
                    const repos = Object.keys(this).filter((key) => String(key).startsWith('_') && String(key).endsWith('Repo') && String(key).length > 6 && IsObject(this[key], true));
                    if (IsArray(repos, true)) {
                        if (!(IsObject(this.srv)))
                            this.srv = {};
                        repos.map((repoName) => {
                            const srvName = repoName.replace('_', '').replace('Repo', '');
                            // this.log.info( `Transferred ${repoName} to srv container as ${srvName}` );
                            if (srvName === 'dom') {
                                this.dom.repo = this[repoName];
                            }
                            else {
                                this.srv[srvName] = this[repoName];
                            }
                            delete this[repoName];
                        });
                    }
                    return resolve(true);
                });
            },
            /**
             * Configure the component tailored to its specific needs
             */
            configure: () => {
                return new Promise((resolve) => {
                    return resolve(true);
                });
            },
            /**
             * Configure the component tailored to its specific needs
             */
            proceed: () => {
                return new Promise((resolve) => {
                    return resolve(true);
                });
            },
            /**
             * Trigger the view to render
             */
            ready: () => {
                this.dom.setTimeout('delay-loader-trigger', null);
                this.dom.state.loading = false;
                this.dom.state.loaded = true;
                this.dom.state.loader = false;
                this.dom.state.refresh = false;
                if (IsArray(this.when, true)) {
                    this.log.info(`eval when`, this.when);
                    this.hidden = !EvaluateWhenConditions(this.core, this.when, this.core);
                }
            },
            /**
             * Trigger the view to refresh
             */
            refreshing: () => {
                this.dom.state.refresh = true;
            },
            /**
             * Register this component in the PopDomService so that session, state, etc can be preserved
             * It will also bind events to the appropriate handlers
             * CoreConfig is obviously something that you must have for any of this to work
             */
            register: () => {
                return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    if (this.el && !this.dom.width.outer)
                        this.dom.width.outer = this.el.nativeElement.getBoundingClientRect().width;
                    if (IsObject(this.core, true)) {
                        if (IsObject(this.core.access, true))
                            this.dom.access = JsonCopy(this.core.access);
                        if (typeof this.dom.handler.core === 'function' || IsArray(this.when, true)) {
                            this.dom.setSubscriber('on-core-event', this.core.channel.subscribe((event) => __awaiter(this, void 0, void 0, function* () {
                                // if( event.source !== this.name ){
                                if (IsValidFieldPatchEvent(this.core, event) && IsArray(this.when)) {
                                    this.log.info('eval when', this.when);
                                    this.dom.setTimeout('eval-when', () => {
                                        this.hidden = !EvaluateWhenConditions(this.core, this.when, this.core);
                                    }, 50);
                                }
                                if (event.source && event.target) {
                                    if (event.source && event.source === this.name)
                                        return;
                                    if (event.target && String(event.target).search(this.name) === -1)
                                        return;
                                }
                                if (IsCallableFunction(this.dom.handler.core))
                                    this.dom.handler.core(IsObject(this.core, true) ? this.core : null, event);
                                // }
                            })));
                        }
                    }
                    if (this.name && typeof this.id !== 'undefined') {
                        if (this.dom.repo && typeof this.dom.repo.onRegister === 'function') {
                            this.dom.repo.onRegister(this);
                        }
                    }
                    if (IsCallableFunction(this.onEvent)) {
                        this.dom.setSubscriber(`on-event`, this.events.subscribe((event) => __awaiter(this, void 0, void 0, function* () {
                            yield this.onEvent(this.core, event, this.dom);
                            this.log.event(this.name, event);
                        })));
                    }
                    return resolve(true);
                }));
            },
            find: (assetType, name, id = 1) => {
                let asset = null;
                if (assetType === 'field') {
                    const fieldRepo = StorageGetter(this.dom, ['repo', 'ui', 'fields']);
                    asset = fieldRepo.get(name);
                    asset = StorageGetter(asset, ['inputs', 'config']);
                }
                else if (assetType === 'component') {
                    asset = StorageGetter(this.dom, ['repo', 'components', String(name)]);
                    if (IsObject(asset) && id in asset) {
                        asset = asset[id];
                    }
                    else {
                        asset = null;
                    }
                }
                else if (this.el && assetType === 'el') {
                    asset = this.el.nativeElement.querySelector(name);
                }
                return asset;
            },
            focus: (querySelector, delay) => {
                if (this.el && IsString(querySelector, true)) {
                    this.dom.setTimeout('focus-child-element-delay', () => {
                        this.dom.setTimeout('focus-child-element', () => {
                            const childEl = this.el.nativeElement.querySelector(querySelector);
                            if (childEl) {
                                childEl.focus();
                            }
                        }, 0);
                    }, delay);
                }
            },
            setError(err = null, modal = false) {
                if (IsObject(err)) {
                    if (modal) {
                        PopTemplate.error({ code: (err.status ? err.status : 422), message: GetHttpErrorMsg(err) });
                    }
                    else {
                        this.dom.error.code = err.status ? err.status : 422;
                        this.dom.error.message = GetHttpErrorMsg(err);
                    }
                }
                else {
                    this.dom.error.message = '';
                }
            },
            /**
             * Configure operations that need to happen when this component is going to be destroyed
             */
            unload: () => {
                return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    return resolve(true);
                }));
            },
            /**
             * Preferred method of setting a subscriber
             * @param subscriptionKey
             * @param subscription
             */
            setSubscriber: (subscriptionKey, subscription = null) => {
                if (subscriptionKey && this.dom.subscriber && subscriptionKey in this.dom.subscriber && this.dom.subscriber[subscriptionKey] && typeof this.dom.subscriber[subscriptionKey].unsubscribe === 'function') {
                    this.dom.subscriber[subscriptionKey].unsubscribe();
                }
                if (subscription) {
                    this.dom.subscriber[subscriptionKey] = subscription;
                }
            },
            /**
             * Preferred method of setting a timeout
             * @param timeoutKey
             * @param callback
             * @param delay
             */
            setTimeout: (timeoutKey, callback = null, delay = 250) => {
                if (timeoutKey && this.dom.delay && timeoutKey in this.dom.delay && this.dom.delay[timeoutKey]) {
                    clearTimeout(this.dom.delay[timeoutKey]);
                }
                if (typeof callback === 'function') {
                    this.dom.delay[timeoutKey] = setTimeout(callback, delay);
                }
            },
            setHeight: (parentHeight, overhead) => {
                if (this.name && parentHeight > 0) {
                    this.dom.overhead = overhead;
                    this.dom.height = {
                        outer: parentHeight,
                        inner: parentHeight - overhead,
                        split: +((parentHeight - overhead) / 2),
                        default: 0
                    };
                }
            },
            setHeightWithParent: (parentClassName = null, overhead = 0, defaultHeight) => {
                return new Promise((resolve) => {
                    if (this.el) {
                        this.dom.waitForParent(this.el, parentClassName, 10, 10).then((parentEl) => {
                            if (parentEl) {
                                this.dom.waitForParentHeight(parentEl).then((parentHeight) => {
                                    if (parentHeight < defaultHeight)
                                        parentHeight = defaultHeight;
                                    if (parentHeight) {
                                        this.dom.setHeight(+parentHeight, overhead);
                                        resolve(true);
                                    }
                                    else {
                                        this.dom.setHeight(defaultHeight, overhead);
                                        resolve(true);
                                    }
                                });
                            }
                            else {
                                this.dom.setHeight(defaultHeight, overhead);
                                resolve(true);
                            }
                        });
                    }
                    else {
                        resolve(false);
                    }
                });
            },
            focusNextInput(el) {
                if (el) {
                    let limit = 5;
                    let input = null;
                    let next = el.nativeElement.nextElementSibling;
                    while (limit && !input) {
                        input = next.querySelector('input[type=text]');
                        if (!input) {
                            input = next.querySelector('input[type=checkbox]');
                        }
                        if (!input) {
                            input = next.querySelector('mat-select');
                        }
                        if (!input) {
                            input = next.querySelector('button');
                        }
                        if (!input) {
                            if (next.nativeElement && next.nativeElement.nextElementSibling) {
                                next = next.nativeElement.nextElementSibling;
                            }
                            else if (next.nextElementSibling) {
                                next = next;
                                next = next.nextElementSibling;
                            }
                            else {
                                limit = 0;
                            }
                        }
                        limit--;
                    }
                    if (input) {
                        if (input instanceof ElementRef) {
                            input.nativeElement.focus();
                        }
                        else if (IsCallableFunction(next.focus)) {
                            input.focus();
                        }
                    }
                }
            },
            setWithComponentInnerHeight: (component, componentId = 1, overhead, defaultHeight) => {
                return new Promise((resolve) => {
                    if (this.dom.repo) {
                        let height = this.dom.repo.getComponentHeight(component);
                        if (height && height.inner) {
                            height = height.inner;
                        }
                        else {
                            height = defaultHeight;
                        }
                        this.dom.setHeight(+height, overhead);
                        resolve(this.dom.height.inner);
                    }
                    else {
                        this.dom.setHeight(+defaultHeight, overhead);
                        resolve(this.dom.height.inner);
                    }
                });
            },
            waitForParent: (el, className = null, time = 50, counter = 5) => {
                let interval;
                let parentEl;
                return new Promise((resolve) => {
                    interval = setInterval(() => {
                        parentEl = this.dom.findParentElement(el, className);
                        if (!counter || (parentEl)) {
                            clearInterval(interval);
                            return resolve(parentEl);
                        }
                        counter--;
                    }, time);
                });
            },
            waitForParentHeight: (el, time = 5, counter = 10) => {
                return new Promise((resolve) => {
                    const interval = setInterval(() => {
                        if (!counter || (el && el.clientHeight)) {
                            clearInterval(interval);
                            return resolve(el.clientHeight);
                        }
                        counter--;
                    }, time);
                });
            },
            findParentElement: (el, className = null) => {
                let attempts = 10;
                let found;
                if (el && el.nativeElement && el.nativeElement.parentElement) {
                    let parent = el.nativeElement.parentElement;
                    while (!found && attempts) {
                        if (parent) {
                            if (className) {
                                if (parent.classList && parent.classList.contains(className)) {
                                    found = parent;
                                }
                            }
                            else {
                                found = parent;
                            }
                            if (!found) {
                                parent = parent.parentElement;
                            }
                        }
                        attempts--;
                    }
                }
                return found;
            },
            store: (key = null) => {
                if (this.dom.repo && this.name && this.id) {
                    return this.dom.repo.onSession(this, key);
                }
            },
            destroy: () => {
                if (this.dom)
                    DestroyComponentDom(this.dom);
            }
        });
    }
    _initializeLogSystem() {
        return {
            repo: {
                message: (message) => {
                    return `%c${message}`;
                },
                color: (type) => {
                    let color = 'aqua';
                    switch (type) {
                        case 'warn':
                            color = 'orange';
                            break;
                        case 'force':
                        case 'error':
                        case 'destroy':
                            color = 'red';
                            break;
                        case 'info':
                            color = 'aqua';
                            break;
                        case 'event':
                            color = 'yellow';
                            break;
                        case 'onSession':
                        case 'event-trigger':
                            color = 'gold';
                            break;
                        case 'cache-in':
                            color = 'green';
                            break;
                        case 'cache-out':
                            color = 'darkgreen';
                            break;
                        case 'dom':
                            color = 'brown';
                            break;
                        case 'debug':
                            color = 'pink';
                            break;
                        case 'api':
                            color = 'darkgreen';
                            break;
                        case 'config':
                            color = 'pink';
                            break;
                        case 'theme':
                            color = 'purple';
                            break;
                        default:
                            color = 'aqua';
                            break;
                    }
                    return `color: ${color}`;
                },
                enabled: (type = '', component = null) => {
                    if (IsObject(PopEnv, true) && PopEnv.debug) {
                        if (type && Array.isArray(PopEnv.debugTypes)) {
                            if (PopEnv.debugTypes.includes(type))
                                return true;
                        }
                        if (typeof PopEnv.debugLevel === 'number') {
                            if (['error', 'onSession'].includes(type) && PopEnv.debug >= 1) {
                                return true;
                            }
                            if (['warning', 'info'].includes(type) && PopEnv.debug >= 2) {
                                return true;
                            }
                            if (['events'].includes(type) && PopEnv.debug >= 2) {
                                return true;
                            }
                        }
                        if (component && typeof PopEnv.debugComponents === 'string') {
                            return PopEnv.debugComponents.search(component) > -1;
                        }
                    }
                    return false;
                },
                init: (componentName, message, data = '', force = false) => {
                    const type = 'init';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                },
                debug: (componentName, message, data = '', force = false) => {
                    const type = 'debug';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                },
                cache: (componentName, message, set = true, force = false) => {
                    let type = 'cache';
                    if (this.log.repo.enabled(type, componentName) || force) {
                        type = set ? 'cache-in' : 'cache-out';
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)));
                    }
                },
                warn: (componentName, message, data = '', force = false) => {
                    const type = 'warn';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                },
                info: (componentName, message, data = '', force = false) => {
                    const type = 'info';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                },
                theme: (componentName, message, data = '', force = false) => {
                    const type = 'theme';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                },
                event: (componentName, message, event, force = false) => {
                    const type = 'event';
                    if (this.log.repo.enabled(type, componentName) || force)
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), event);
                },
                error: (componentName, message, data = '', force = false) => {
                    const type = 'error';
                    if (this.log.repo.enabled(type, componentName) || force) {
                        console.log(this.log.repo.message(`${componentName}:${message}`), this.log.repo.color((force ? 'force' : type)), data);
                        // throw new Error('message');
                    }
                }
            },
            init: () => {
                if (this.log.repo.enabled('init', this.name))
                    console.log(this.log.repo.message(`${this.name}:init`), this.log.repo.color('init'), this);
            },
            debug: (msg = 'Debug', data = '') => {
                if (this.log.repo.enabled('debug', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('debug'), data);
            },
            error: (msg = 'Error', error = '') => {
                if (this.log.repo.enabled('error', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('error'), error);
            },
            warn: (msg = 'Warning', data = '') => {
                if (this.log.repo.enabled('warn', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('error'), data);
            },
            info: (msg = 'info', data = '') => {
                if (this.log.repo.enabled('event', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('info'), data);
            },
            event: (msg = 'event', event) => {
                if (this.log.repo.enabled('event', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('event'), event);
            },
            config: (msg = 'config', config = '') => {
                if (this.log.repo.enabled('config', this.name))
                    console.log(this.log.repo.message(`${this.name}:${msg}`), this.log.repo.color('config'), config);
            },
            destroy: () => {
                if (this.log.repo.enabled('destroy', this.name))
                    console.log(this.log.repo.message(`${this.name}:destroy`), this.log.repo.color('destroy'));
            },
        };
    }
}
PopExtendComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-base-component',
                template: `Base Component`
            },] }
];
PopExtendComponent.ctorParameters = () => [];
PopExtendComponent.propDecorators = {
    position: [{ type: Input }],
    core: [{ type: Input }],
    events: [{ type: Output }],
    extension: [{ type: Input }],
    onLoad: [{ type: Input }],
    onEvent: [{ type: Input }],
    onUnload: [{ type: Input }],
    when: [{ type: Input }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

class PopMenuComponent extends PopExtendComponent {
    constructor(APP_GLOBAL) {
        super();
        this.APP_GLOBAL = APP_GLOBAL;
        this.name = 'PopMenuComponent';
        this.asset = {
            existingBusinesses: undefined
        };
        this.ui = {
            alternate_businesses: [],
            menus: {
                all: [],
                more: []
            },
            user: undefined
        };
        this.srv = {
            base: ServiceInjector.get(PopBaseService),
            credential: ServiceInjector.get(PopCredentialService),
            menu: ServiceInjector.get(PopMenuService),
            router: ServiceInjector.get(Router),
        };
        this.dom.configure = () => {
            // this component set the outer height boundary of this view
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([
                    this._setInitialConfig()
                ]);
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (!this.dom.state.checkedContent && this.mmNavRef) {
                    this.onUpdateMenus();
                    this.dom.state.checkedContent = true;
                }
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The user click to a app nav menu
     * @param appPath
     */
    onChangeApp(appPath) {
        if (isDevMode() && IsString(PopHref)) { // Auto Login/Logout since there is no access to the prime-user-app
            if (appPath === '/login') {
                if (PopEnv.username && PopEnv.password) {
                    PopTemplate.lookBusy(30);
                    this.srv.credential.authenticate({
                        username: PopEnv.username,
                        password: PopEnv.password
                    }).then((auth) => {
                        if (IsObject(auth, true)) {
                            return window.location.reload();
                        }
                        else {
                            PopTemplate.error({ message: String(auth), code: 500 });
                        }
                    });
                }
            }
            else if (appPath === '/logout') {
                PopTemplate.goodbye();
                setTimeout(() => {
                    this.srv.credential.clear().subscribe(() => {
                        this.srv.base.switchApps(`/` + (IsString(PopHref, true) ? PopHref : ''));
                    });
                }, 0);
            }
            else {
                PopTemplate.notify(`You Shall not Pass! Actually this link will take you to nowhere, so its been disabled.`);
            }
        }
        else {
            this.srv.base.switchApps(appPath);
        }
    }
    /**
     * Temporary fx to help test if the menu can auto update itself to external changes
     */
    onAuthVerification() {
        PopTemplate.verify();
    }
    /**
     * A user can select from a list of businesses that their prime user has access to
     * @param appPath
     */
    onChangeBusiness(id) {
        let slugs = window.location.href.split(PopHref + '/').pop().trim();
        slugs = slugs.split('/');
        slugs = slugs.slice(0, 1);
        const path = slugs.join('/');
        const redirect = `${window.location.origin}/${PopHref}/${slugs.join('/')}`;
        const originalRoute = IsObject(PopAliasRouteMap, true) && path in PopAliasRouteMap ? PopAliasRouteMap[path] : null;
        SetSiteVar('App.redirect', (originalRoute ? originalRoute : redirect));
        this.srv.menu.changeBusiness(id);
    }
    /**
     * Determine the presentation of the nav menus
     */
    onUpdateMenus() {
        if (!this.dom.state.authenticated) {
            this.ui.menus.all = [];
            this.ui.menus.more = [];
        }
        else {
            const moreMenus = [];
            let talliedMenuSize = 0;
            const children = this.mmNavRef.nativeElement.children;
            const maxWidth = this.mmNavRef.nativeElement.offsetWidth - 15;
            for (let i = 0; i < children.length; i++) {
                talliedMenuSize += children[i].offsetWidth;
                if (talliedMenuSize < maxWidth) {
                    children[i].style.visibility = 'visible';
                }
                else {
                    children[i].style.visibility = '';
                    moreMenus.push(this.ui.menus.all[i]);
                }
            }
            this.ui.menus.more = moreMenus;
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config for this component
     * @private
     */
    _setInitialConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.active.path = `/${window.location.pathname.split('/')[1]}`;
            this.dom.active.business = undefined;
            this.dom.state.authenticated = false;
            this.dom.state.checkedContent = false;
            this.dom.state.isDevMode = isDevMode();
            this._initialize();
            this.dom.setSubscriber('init', this.APP_GLOBAL.init.subscribe((val) => {
                if (val) {
                    this.dom.setTimeout(`init`, () => {
                        this._initialize();
                    }, 100);
                }
            }));
            return resolve(true);
        }));
    }
    /**
     * Initialize the component
     * This is designed so that at any time a verification event can be fired from the Initializer module, and the menu can respond to the business(app)s that is stored in the new Auth Token
     * Future:  A web socket will be able to detect a change in security+access of apps and trigger the menu to auto update
     */
    _initialize() {
        this.dom.state.authenticated = this.srv.menu.isAuthenticated();
        this.ui.user = this.srv.base.getAuthPrimeUser();
        this._loadBusiness();
        setTimeout(() => {
            this.onUpdateMenus();
        }, 0);
    }
    /**
     * Set the menus for the current business, apps across the top
     * @param business
     */
    _loadBusiness() {
        // Token details should contain all the info to populate the menu bar.
        const businesses = this.srv.base.getAuthBusinesses();
        if (IsObject(businesses, true) && !(ObjectsMatch(this.asset.existingBusinesses, businesses))) { // check to see if an update is really required
            this.asset.existingBusinesses = businesses;
            // Set non-business unit stuff.
            // Get the current buId from onSession storage.
            const businessId = this.srv.base.getCurrentBusinessId();
            this.ui.alternate_businesses = [];
            // If a business unit has been found then populate the necessary objects.
            if (businessId) {
                Object.keys(businesses).map((buId) => {
                    const business = businesses[buId];
                    if (business.id === businessId) {
                        this.dom.active.business = {
                            id: business.id,
                            name: business.name,
                            short_name: business.short_name,
                            logo_main_url: business.logo_main_url,
                            logo_small_url: business.logo_small_url,
                        };
                        this._setBusinessAppMenus(business);
                    }
                    else {
                        this.ui.alternate_businesses.push({
                            id: business.id,
                            name: business.name,
                            short_name: business.short_name,
                            logo_main_url: business.logo_main_url,
                            logo_small_url: business.logo_small_url,
                        });
                    }
                });
            }
        }
    }
    /**
     * This set the nav menu across the top of template
     * @param business
     */
    _setBusinessAppMenus(business) {
        if (business) {
            if (IsArray(business.apps, true)) {
                this.ui.menus.all = business.apps.filter((app) => {
                    return +app.active;
                }).sort(function (a, b) {
                    if (a.sort < b.sort)
                        return -1;
                    if (a.sort > b.sort)
                        return 1;
                    return 0;
                }).map((app) => {
                    return this._extractAppMenu(app);
                });
            }
            else if (IsObject(business.apps, true)) {
                this.ui.menus.all = Object.keys(business.apps).map((appKey) => {
                    return this._extractAppMenu(business.apps[appKey]);
                });
            }
        }
    }
    /**
     * This fx will extract the necessary data out of the app data
     * @param app
     * @private
     */
    _extractAppMenu(app) {
        return {
            name: app.label ? app.label : app.name,
            path: `/${String(app.name).toLowerCase()}`,
            description: '',
            short_description: '',
            sort: app.sort,
            icon: '',
        };
    }
}
PopMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-menu',
                template: "<div class=\"mm-sticky-container\" (window:resize)=\"onUpdateMenus()\">\n  <!-- User Not Logged In -->\n  <div *ngIf=\"!dom.state.authenticated\" class=\"mm-container pt-bg-1\">\n    <div class=\"mm-bu\">\n      <div class=\"mm-bu-selected\">\n        <a href=\"/public/\" onclick=\"window.location.reload()\">PopCX</a>\n      </div>\n    </div>\n\n    <div class=\"mm-public\">\n      <div class=\"mm-buttons\">\n        <button mat-raised-button (click)=\"onChangeApp('/login')\" role=\"button\">Login</button>\n      </div>\n      <div class=\"mm-buttons\">\n        <button mat-raised-button (click)=\"onChangeApp('/signup')\" role=\"button\">Sign Up</button>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- User Logged In -->\n  <div class=\"mm-container pt-bg-1\" [ngClass]=\"{'sw-hidden': !dom.state.authenticated}\">\n\n    <div *ngIf=\"!dom.active.business\" class=\"mm-bu\">\n      <div class=\"mm-bu-selected\">\n        <a onclick=\"window.location.reload()\">Welcome to PopCX</a>\n      </div>\n    </div>\n\n    <div *ngIf=\"dom.active.business\" class=\"mm-bu active-business\" >\n      <div *ngIf=\"ui.alternate_businesses.length\" [matMenuTriggerFor]=\"businessUnitMenu\" class=\"mm-bu-more\" >\n        <img *ngIf=\"dom.active.business.logo_main_url\" class=\"mm-bu-selected-img\" src=\"{{dom.active.business.logo_main_url}}\">\n        <span *ngIf=\"!dom.active.business.logo_main_url\" class=\"mm-bu-selected\">{{dom.active.business.name}}</span>\n        <mat-menu #businessUnitMenu=\"matMenu\" [overlapTrigger]=\"false\" class=\"mm-bu-list\">\n          <div *ngFor=\"let business of ui.alternate_businesses\" (click)=\"onChangeBusiness(business.id)\">\n            <img *ngIf=\"business.logo_main_url\" class=\"mm-nav-item-img\" src=\"{{business.logo_main_url}}\">\n            <span *ngIf=\"!business.logo_main_url\" class=\"mm-bu-list-item\">{{business.name}}</span>\n          </div>\n        </mat-menu>\n      </div>\n      <div *ngIf=\"!ui.alternate_businesses.length\">\n        <img *ngIf=\"dom.active.business.logo_main_url\" class=\"mm-bu-selected-img\" src=\"{{dom.active.business.logo_main_url}}\">\n        <span *ngIf=\"!dom.active.business.logo_main_url\" class=\"mm-bu-selected\">{{dom.active.business.name}}</span>\n      </div>\n    </div>\n\n\n\n    <div class=\"mm-nav\" #mmNavRef>\n      <div *ngFor=\"let menu of ui.menus.all\" class=\"mm-nav-item-hidden\">\n        <!-- Fake Div is here to stablize the nav buttons so they do not expand in size when hover trasition is applied-     -->\n        <div class=\"mm-nav-item-fake\"><span>{{menu.name}}</span></div>\n        <div class=\"mm-nav-item mat-h4\" [ngClass]=\"{'mm-nav-item-active' : menu.path == dom.active.path}\" (click)=\"onChangeApp(menu.path)\">\n          <span >{{menu.name}}</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"mm-misc\" >\n      <div *ngIf=\"ui.menus.more.length\">\n        <div class=\"mm-misc-more\" [matMenuTriggerFor]=\"moreMenus\">\n          <mat-icon>more_vert</mat-icon>\n        </div>\n        <mat-menu #moreMenus=\"matMenu\" [overlapTrigger]=\"false\" class=\"\">\n          <div *ngFor=\"let menu of ui.menus.more\" class=\"\" (click)=\"onChangeApp(menu.path)\">\n            <span class=\"mm-more-menu-item\">{{menu.name}}</span>\n          </div>\n        </mat-menu>\n      </div>\n\n\n      <div class=\"search-control mm-misc\">\n        <div >\n          <mat-form-field class=\"sw-search\" appearance=\"outline\" >\n            <span matPrefix class=\"search-icon\">\n              <mat-icon>search</mat-icon>\n            </span>\n            <input  matInput placeholder=\"Search\">\n          </mat-form-field>\n        </div>\n      </div>\n\n      <mat-icon class=\"mm-misc-notification\">notifications</mat-icon>\n    </div>\n\n    <div class=\"mm-profile\" [matMenuTriggerFor]=\"profileMenu\" >\n\n      <div class=\"mm-profile-avatar\" *ngIf=\"ui.user\">\n        <img *ngIf=\"ui.user.avatarLink\" class=\"mm-avatar-img\" [src]=\"ui.user.avatarLink\"/>\n        <div *ngIf=\"!ui.user.avatarLink\" class=\"sw-circle-ID\">\n          {{ui.user.initials}}\n        </div>\n      </div>\n\n      <mat-menu #profileMenu=\"matMenu\" [overlapTrigger]=\"false\" class=\"mm-profile-menu\">\n        <!--<div *ngIf=\"dom.state.isDevMode\" class=\"mm-profile-list-item\" (click)=\"onAuthVerification();\">Verify Auth (Temp)</div>-->\n        <div class=\"mm-profile-list-item\" (click)=\"onChangeApp('/user/profile');\">Profile</div>\n        <div class=\"mm-profile-list-item\" (click)=\"onChangeApp('/logout');\">Logout</div>\n      </mat-menu>\n    </div>\n\n  </div>\n</div>\n",
                styles: [".mm-sticky-container{position:fixed;width:100%;z-index:111}.mm-buttons{margin-right:10px}.mm-container{display:flex;flex-wrap:nowrap;justify-content:center;align-items:center;height:48px;margin:0;color:var(--background-base)}.search-icon{color:var(--foreground-base)}.mm-container a{color:var(--background-base)}.mm-public{order:2;flex:1 1 auto;justify-content:flex-end;padding-right:10px}.mm-bu,.mm-public{height:100%;align-items:center;display:inline-flex}.mm-bu{flex:0 0 257px;width:257px;overflow:hidden;flex-wrap:nowrap;justify-content:left;background-color:var(--primary-700);border-bottom:1px solid;border-bottom-color:var(--disabled);border-right:1px solid;border-right-color:var(--disabled);box-sizing:border-box}.active-business,.mm-profile{border:1px ridge var(--primary)}.mm-bu-selected{display:inline-block;font-size:16px;line-height:95%;padding:0 20px;padding:0 0 0 var(--gap-m);color:#fff}.mm-bu-selected a{text-decoration:none}.mat-icon,.mm-bu,.mm-profile-text{transition:font-weight .4s,color .4s;-webkit-transition:font-weight .4s,color .4s}.mm-bu-more{cursor:pointer;height:100%;display:flex;align-items:center}.mm-bu-selected-img{width:216px;padding:0 20px}.mm-bu-list-item,.mm-profile-list-item{width:216px}.mm-bu-list-item,.mm-more-menu-item,.mm-profile-list-item{display:block;padding:10px 20px;font-size:1rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:font-weight .4s,background-color .4s}.mm-bu-list-item:hover,.mm-more-menu-item:hover,.mm-nav-item-img:hover,.mm-profile-list-item:hover{font-weight:500;background-color:var(--darken1);cursor:pointer}.mm-nav{display:flex;flex:1 1 auto;height:100%;align-items:center;overflow:hidden;white-space:nowrap;background-color:var(--background-main-menu);border-bottom:1px solid;border-bottom-color:var(--disabled);box-sizing:border-box}.mm-nav-item{text-align:left;padding:15px 0 15px var(--gap-lm);white-space:nowrap;cursor:pointer;transition:font-weight .4s,color .4s;color:var(--foreground-base)}.mm-nav-item-hidden{visibility:hidden}.mm-nav-item-fake{margin-top:-20px;font-size:1.1rem;padding-left:15px;padding-right:15px;white-space:nowrap;font-weight:500;visibility:hidden}.mm-nav-item-img{width:216px;padding:6px 20px;display:block;transition:background-color 1s}.mm-nav-item-active{color:var(--primary);font-weight:700}.mm-nav-item:hover{font-weight:700}.mm-nav-item:active{font-weight:500;color:var(--primary-700)}.mm-misc{height:100%;display:flex;flex-wrap:nowrap;justify-content:flex-end;align-items:center;background-color:var(--background-main-menu);color:var(--text-2);border-bottom:1px solid;border-bottom-color:var(--disabled);box-sizing:border-box}.mm-misc-notification{font-size:1.25rem;text-align:right;padding:5px var(--gap-m) 0 0;cursor:pointer}.mm-misc-more{display:flex;align-items:center;height:48px;padding-right:10px;cursor:pointer}.mm-misc-more .mat-icon{font-size:2.3em;cursor:pointer;margin-bottom:10px}.mm-profile{max-width:80px;height:100%;display:flex;flex-wrap:nowrap;justify-content:flex-end;align-items:center;cursor:pointer;background-color:var(--primary-700);box-sizing:border-box}.mm-profile-text{width:137px;font-size:1rem;flex:1 1 auto;padding-left:10px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mm-profile-avatar{display:flex;align-items:center;justify-content:center;width:40px;height:40px;overflow:hidden;background-color:var(--disabled);border-radius:50%;margin:0 var(--gap-m)}.mm-profile-avatar path{fill:var(--primary-text)}.mm-avatar-img{max-width:50px;max-height:50px;border-radius:50%}.mm-profile-menu{display:flex;flex-direction:column}.mm-line-break{flex:none;width:1px;background-color:var(--lighten-50);height:65%}.search-control{flex-grow:0.5;padding-right:var(--gap-lm);border-bottom:0!important}:host ::ng-deep .search-control .mat-form-field .mat-form-field-infix{width:200px}"]
            },] }
];
PopMenuComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];
PopMenuComponent.propDecorators = {
    mmNavRef: [{ type: ViewChild, args: ['mmNavRef',] }]
};

class PopMenuModule {
}
PopMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    MatMenuModule,
                    MatIconModule,
                    MatTooltipModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    MatInputModule
                ],
                declarations: [
                    PopMenuComponent,
                ],
                providers: [
                    PopMenuService,
                ],
                exports: [
                    PopMenuComponent
                ]
            },] }
];

class PopTemplateAjaxLoaderComponent {
    constructor() {
        const greetings = [
            `Just a sec ...`,
            `Git \'Er Done`,
            `This may take a while ...`,
            `No Problemo`,
        ];
        this.expression = RandomArrayElement(greetings);
    }
}
PopTemplateAjaxLoaderComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="pop-template-ajax-loader">
      <div class="pop-template-ajax-row">
        <h5>{{expression}}</h5>
      </div>
      <div class="pop-template-ajax-row">
        <lib-main-spinner
          [options]="{strokeWidth:10, color:'primary', diameter:40}">
        </lib-main-spinner>
      </div>
    </div>
  `,
                styles: [`
    .pop-template-ajax-loader {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
    }

    .pop-template-ajax-row {
      display: flex;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      clear: both;
    }
  `]
            },] }
];
PopTemplateAjaxLoaderComponent.ctorParameters = () => [];

class PopTemplateGoodByeComponent {
    constructor() {
        const name = ServiceInjector.get(PopBaseService).getAuthPrimeUser().first_name;
        const greetings = [
            `Audios Amigo`,
            `See Ya Later, ${name}`,
            `Hasta la vista`,
            `Later Hater`,
            `Done so soon?`,
            `GoodBye`,
            `Thanks for all you have done, ${name}`
        ];
        this.expression = RandomArrayElement(greetings);
    }
}
PopTemplateGoodByeComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="pop-template-goodbye">
      <div class="pop-template-goodbye-row">
        <h4>{{expression}}</h4>
      </div>
    </div>
  `,
                styles: [`
    .pop-template-goodbye {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      font-size: 1.5em;
    }

    .pop-template-goodbye-row {
      display: flex;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      clear: both;
    }
  `]
            },] }
];
PopTemplateGoodByeComponent.ctorParameters = () => [];

class PopTemplateWelcomeComponent {
    constructor() {
        const name = ServiceInjector.get(PopBaseService).getAuthPrimeUser().first_name;
        const greetings = [
            `Hola!`,
            `Welcome Back, ${name}`,
            `Howd, partner`,
            `Good to see you, ${name}`,
            `Hello, ${name}`,
            `Lets do this!`,
            `Alright, Alright, Alright ...`
        ];
        this.expression = RandomArrayElement(greetings);
    }
}
PopTemplateWelcomeComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="pop-template-welcome">
      <div class="pop-template-welcome-row">
        <h4>{{expression}}</h4>
      </div>
    </div>
  `,
                styles: [`
    .pop-template-welcome {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      font-size: 1.5em;
      background: var(--background-2);
    }

    .pop-template-welcome-row {
      display: flex;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      clear: both;
    }
  `]
            },] }
];
PopTemplateWelcomeComponent.ctorParameters = () => [];

class PopTemplateErrorComponent {
    constructor() {
        if (!IsObject(this.error))
            this.error = { message: 'Something went wrong!', code: 500 };
    }
}
PopTemplateErrorComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="pop-template-error">
      <div class="pop-template-error-row">
        <h5>{{error.code}} - {{error.message}}</h5>
      </div>
    </div>
  `,
                styles: [`
    .pop-template-error {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      font-size: 1em;
      color: white;
      padding: 10px;
      background: red;
      box-sizing: border-box;
    }

    .pop-template-error-row {
      display: flex;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      clear: both;
      word-wrap: break-word;
      box-sizing: border-box;
    }
  `]
            },] }
];
PopTemplateErrorComponent.ctorParameters = () => [];
PopTemplateErrorComponent.propDecorators = {
    error: [{ type: Input }]
};

class PopTemplateBufferComponent {
    constructor(data) {
        this.data = data;
        this.color = 'primary';
        this.mode = 'buffer';
        this.bufferValue = 100;
        this.value = 0;
    }
    ngOnInit() {
        this._meterProgress();
    }
    ngOnDestroy() {
        if (this.interval)
            clearInterval(this.interval);
    }
    _meterProgress() {
        this.interval = setInterval(() => {
            this.bufferValue -= 5;
            this.value += 5;
            if (this.value >= 100)
                clearInterval(this.interval);
        }, 175, 50);
    }
}
PopTemplateBufferComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="pop-template-buffer">
      <div class="pop-template-ajax-row" *ngIf="data.expression">
        <h5>{{data.expression}}</h5>
      </div>
      <div class="pop-template-buffer-row">
        <mat-progress-bar
          [color]="color"
          [mode]="mode"
          [value]="value"
          [bufferValue]="bufferValue">
        </mat-progress-bar>
      </div>
    </div>
  `,
                styles: [`
    .pop-template-buffer {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      font-size: 1.5em;
      background: var(--background-code);
    }

    .pop-template-buffer-row {
      display: flex;
      width: 100%;
      min-height: 30px;
      justify-content: center;
      align-items: center;
      clear: both;
    }
  `]
            },] }
];
PopTemplateBufferComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_SNACK_BAR_DATA,] }] }
];

class CacFilterBarConfig {
    constructor(params) {
        this.archived = false;
        this.active = false;
        this.display = 'default';
        this.loader = false;
        this.view = ['client', 'account', 'campaign'];
        this.sortToTop = false;
        this.invalid = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!(['default', 'static', 'float'].includes(this.display)))
            this.display = 'default';
    }
}
class CacFilterBarEntityConfig {
    constructor(params) {
        /**/
        this.allSelected = false;
        this.checkAll = false;
        this.indeterminate = false;
        this.single = true;
        this.selected = {};
        this.display = {};
        this.hidden = {};
        this.filter = [];
        this.selectedText = '';
        this.displaySelectedText = '';
        this.totalText = '';
        this.mode = false;
        this.visible = false;
        for (const i in params)
            this[i] = params[i];
        this.feed = new BehaviorSubject([]);
    }
}

class PopEntityEventService {
    constructor() {
        this.events = new EventEmitter();
    }
    sendEvent(event) {
        this.events.emit(event);
    }
}
PopEntityEventService.prov = i0.defineInjectable({ factory: function PopEntityEventService_Factory() { return new PopEntityEventService(); }, token: PopEntityEventService, providedIn: "root" });
PopEntityEventService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];

/**
 * Cache Service is an observables based in-memory cache implementation
 * Keeps track of in-flight observables and sets a default expiry for cached values
 */
class PopCacheService {
    constructor() {
        this.name = 'PopCacheService';
        this.cache = {};
        this.inFlightObservables = new Map();
        this.DEFAULT_MAX_AGE = 60000; // 1 minute
    }
    /**
     * Gets the value from cache if the key is provided.
     * If no value exists in cache, then check if the same call exists
     * in flight, if so return the subject. If not create a new
     * Subject inFlightObservable and return the source observable.
     */
    get(type, key, fallback, maxAge) {
        if (this.hasValidCachedValue(type, key)) {
            return of(this.cache[type].get(key).value);
        }
        if (!maxAge) {
            maxAge = this.DEFAULT_MAX_AGE;
        }
        if (fallback && fallback instanceof Observable) {
            if (this.inFlightObservables.has(key)) {
                const sub = this.inFlightObservables.get(key);
                if (sub) {
                    sub.complete();
                    sub.unsubscribe();
                }
            }
            this.inFlightObservables.set(key, new Subject());
            return fallback.pipe(tap((value) => {
                this.set(type, key, value, maxAge);
            }));
        }
        else {
            return of(null);
            // return throwError('Requested key is not available in Cache');
        }
    }
    clear(cacheType, cacheKey) {
        if (IsString(cacheType, true)) {
            if (IsString(cacheKey, true)) {
                if (this.cache[cacheType] && this.has(cacheType, cacheKey)) {
                    this.cache[cacheType].delete(cacheKey);
                }
            }
            else {
                if (this.cache[cacheType])
                    delete this.cache[cacheType];
            }
        }
    }
    clearAll() {
        this.cache = {};
    }
    /**
     * Sets the value with key in the cache
     * Notifies all observers of the new value
     */
    set(type, key, value, maxAge = this.DEFAULT_MAX_AGE) {
        if (!this.cache[type])
            this.cache[type] = new Map();
        this.cache[type].set(key, { value: value, expiry: Date.now() + maxAge });
        this.notifyInFlightObservers(key, value);
    }
    /**
     * Checks if the a key exists in cache
     */
    has(type, key) {
        if (this.cache[type]) {
            return this.cache[type].has(key);
        }
        return false;
    }
    /**
     * Publishes the value to all observers of the given
     * in progress observables if observers exist.
     */
    notifyInFlightObservers(key, value) {
        if (this.inFlightObservables.has(key)) {
            const inFlight = this.inFlightObservables.get(key);
            const observersCount = inFlight.observers.length;
            if (observersCount) {
                inFlight.next(value);
            }
            inFlight.complete();
            this.inFlightObservables.delete(key);
        }
    }
    /**
     * Checks if the key exists and  has not expired.
     */
    hasValidCachedValue(type, key) {
        if (this.cache[type] && this.cache[type].has(key)) {
            if (this.cache[type].get(key).expiry < Date.now()) {
                this.cache[type].delete(key);
                return false;
            }
            return true;
        }
        else {
            return false;
        }
    }
}
PopCacheService.prov = i0.defineInjectable({ factory: function PopCacheService_Factory() { return new PopCacheService(); }, token: PopCacheService, providedIn: "root" });
PopCacheService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopCacheService.ctorParameters = () => [];

class PopResourceService extends PopExtendService {
    constructor() {
        super();
        this.name = 'PopResourceService';
        this.cache = new PopCacheService();
    }
    /**
     * This fx will map the api calls for a collection of resources
     * @param collection
     * @param core
     */
    setCollection(collection, core) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const api_requests = [];
            const request_map = [];
            let resource;
            if (IsObject(collection, true)) {
                Object.keys(collection).map((resourceKey) => {
                    resource = collection[resourceKey];
                    if (resource.api_path) {
                        if (!resource.can_read || PopEntity.checkAccess(resource.can_read, 'can_read')) {
                            // break;
                            let path = resource.api_path;
                            if (IsArray(resource.api_when, true) && IsObject(core, true)) {
                                const when = EvaluateWhenConditions(core, resource.api_when);
                                if (!when) {
                                    PopLog.info(this.name, `setCollection: condition not met`, resource);
                                    return false;
                                }
                            }
                            request_map.push(resourceKey);
                            if (IsObject(resource.api_path_vars, true) && core) {
                                Object.keys(resource.api_path_vars).map((varKey) => {
                                    let value = '';
                                    if (String(resource.api_path_vars[varKey]).includes('.')) {
                                        value = StorageGetter(core, String(resource.api_path_vars[varKey]).split('.'));
                                    }
                                    if (!value)
                                        value = ParseModelValue(String(resource.api_path_vars[varKey]));
                                    if (value) {
                                        path = StringReplaceAll(path, `:${varKey}`, value);
                                    }
                                });
                            }
                            const body = IsObject(resource.api_params, true) ? resource.api_params : {};
                            if (IsObject(body)) {
                                Object.keys(body).map((key) => {
                                    body[key] = ParseModelValue(body[key], core);
                                });
                            }
                            if (+resource.api_cache) {
                                PopLog.info(this.name, `cached resource`, resource);
                                api_requests.push(this.cache.get('resource', path, PopRequest.doGet(path, body, resource.api_version), 3600000));
                            }
                            else {
                                api_requests.push(PopRequest.doGet(path, body, resource.api_version));
                            }
                        }
                    }
                });
            }
            if (api_requests.length) {
                forkJoin(api_requests).subscribe((results) => {
                    results.map((res, index) => {
                        res = res.data ? res.data : res;
                        resource = collection[request_map[index]];
                        let dataTarget;
                        if (IsArray(res, false)) {
                            dataTarget = resource.data_storage ? resource.data_storage : 'data_values';
                            if (IsObject(collection[request_map[index]].data_filter, true)) {
                                try {
                                    Object.keys(resource.data_filter).map((filterKey) => {
                                        res = res.filter((item) => {
                                            let filterKeyValue = resource.data_filter[filterKey];
                                            if (String(filterKeyValue).includes('.')) {
                                                filterKeyValue = StorageGetter(core, String(filterKeyValue).split('.'));
                                            }
                                            if (!filterKeyValue)
                                                filterKeyValue = ParseModelValue(String(resource.data_filter[filterKey]));
                                            return item[filterKey] == filterKeyValue;
                                        });
                                    });
                                }
                                catch (e) {
                                    PopLog.warn(this.name, `setCollection`, e);
                                }
                            }
                            res = IsCallableFunction(resource.data_decorator) ? res.map(x => resource.data_decorator(core, x)) : res;
                            if (IsArray(resource.data_when, true)) {
                                // EvaluateModelConditionals();
                                try {
                                    res = res.filter((item) => {
                                        return EvaluateWhenConditions(item, resource.data_when, core);
                                    });
                                }
                                catch (e) {
                                    PopLog.warn(this.name, `setCollection`, e);
                                }
                            }
                            if (IsCallableFunction(resource.data_setter))
                                res = resource.data_setter(core, res);
                            resource[dataTarget] = res;
                        }
                        else {
                            dataTarget = resource.data_storage ? resource.data_storage : 'data';
                            resource[dataTarget] = IsCallableFunction(resource.data_decorator) ? resource.data_decorator(core, res) : res;
                            if (IsCallableFunction(resource.data_setter))
                                resource[dataTarget] = resource.data_setter(core, resource[dataTarget]);
                        }
                    });
                    resolve(true);
                }, err => {
                    resolve(false);
                });
            }
            else {
                resolve(true);
            }
        }));
    }
    /**
     * This fx will extract the data from a resource collection
     * @param collection
     * @param core
     */
    getCollection(collection) {
        const store = {};
        if (IsObject(collection, true)) {
            Object.keys(collection).map((resourceKey) => {
                const resource = collection[resourceKey];
                store[resource.name] = CleanObject(new ResourceConfig(resource));
            });
        }
        return store;
    }
    /**
     * This fx will reload a single existing resource
     * @param collection
     */
    reloadResource(core, resource) {
        return new Promise((resolve) => {
            if (IsObject(resource, ['api_path'] && resource.api_path && IsString(resource.api_path, true))) {
                let path = resource.api_path;
                if (resource.can_read && !PopEntity.checkAccess(resource.can_read, 'can_read')) {
                    PopLog.debug(this.name, `reloadResource: Cannot read resource:${resource.can_read}`);
                    return resolve(resource);
                }
                if (IsArray(resource.api_when, true) && IsObject(core, true)) {
                    const when = EvaluateWhenConditions(core, resource.api_when);
                    if (!when) {
                        PopLog.debug(this.name, 'reloadResource: condition not met');
                        return resolve(resource);
                    }
                }
                if (IsObject(resource.api_path_vars, true) && core) {
                    Object.keys(resource.api_path_vars).map((varKey) => {
                        let value = '';
                        if (String(resource.api_path_vars[varKey]).includes('.')) {
                            value = StorageGetter(core, String(resource.api_path_vars[varKey]).split('.'));
                        }
                        if (!value)
                            value = ParseModelValue(String(resource.api_path_vars[varKey]));
                        if (value) {
                            path = StringReplaceAll(path, `:${varKey}`, value);
                        }
                    });
                }
                const body = IsObject(resource.api_params, true) ? resource.api_params : {};
                if (IsObject(body)) {
                    Object.keys(body).map((key) => {
                        body[key] = ParseModelValue(body[key], core);
                    });
                }
                PopRequest.doGet(path, body, resource.api_version).subscribe((res) => {
                    res = GetHttpResult(res);
                    let dataTarget;
                    PopLog.debug(this.name, 'reloadResource: pass 4');
                    if (IsArray(res, false)) {
                        dataTarget = resource.data_storage ? resource.data_storage : 'data_values';
                        if (IsObject(resource.data_filter, true)) {
                            try {
                                Object.keys(resource.data_filter).map((filterKey) => {
                                    res = res.filter((item) => {
                                        let filterKeyValue = resource.data_filter[filterKey];
                                        if (String(filterKeyValue).includes('.')) {
                                            filterKeyValue = StorageGetter(core, String(filterKeyValue).split('.'));
                                        }
                                        if (!filterKeyValue)
                                            filterKeyValue = ParseModelValue(String(resource.data_filter[filterKey]));
                                        return item[filterKey] == filterKeyValue;
                                    });
                                });
                            }
                            catch (e) {
                                PopLog.warn(this.name, `setCollection`, e);
                            }
                        }
                        if (IsArray(resource.data_when, true)) {
                            // EvaluateModelConditionals();
                            try {
                                res = res.filter((item) => {
                                    return EvaluateWhenConditions(item, resource.data_when, core);
                                });
                            }
                            catch (e) {
                                PopLog.warn(this.name, `setCollection`, e);
                            }
                        }
                        resource[dataTarget] = IsCallableFunction(resource.data_decorator) ? res.map(x => resource.data_decorator(core, x)) : res;
                        if (IsCallableFunction(resource.data_setter))
                            resource[dataTarget] = resource.data_setter(core, resource[dataTarget]);
                    }
                    else {
                        dataTarget = resource.data_storage ? resource.data_storage : 'data';
                        resource[dataTarget] = IsCallableFunction(resource.data_decorator) ? resource.data_decorator(core, res) : res;
                    }
                    return resolve(resource);
                }, () => {
                    return resolve(resource);
                });
            }
            else {
                return resolve(resource);
            }
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopResourceService.prov = i0.defineInjectable({ factory: function PopResourceService_Factory() { return new PopResourceService(); }, token: PopResourceService, providedIn: "root" });
PopResourceService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopResourceService.ctorParameters = () => [];

class PopPipeService {
    constructor(resource) {
        this.resource = resource;
        this.name = 'PopPipeService';
        this.loaded = false;
        this.resources = {
            timezone: {
                name: 'timezone',
                defaultValue: null,
                data_type: 'api_records',
                api_path: 'records/timezone-values',
                api_cache: 1,
            },
            country: {
                name: 'country',
                defaultValue: null,
                data_type: 'api_records',
                api_path: 'records/countries',
                api_cache: 1,
            },
            state: {
                name: 'state',
                defaultValue: null,
                data_type: 'api_records',
                api_path: 'records/u-s-states',
                api_cache: 1,
            },
            entity: {
                name: 'entity',
                defaultValue: null,
                data_type: 'api_records',
                api_path: `entities?select=id,name,internal_name,alias&with=alias`,
                api_cache: 1,
            }
        };
        this.asset = {
            business: {},
            country: {},
            timezone: {},
            state: {},
            client: {},
            campaign: {},
            account: {},
            entity: {},
        };
        this.assetMap = {
            entity: {}
        };
        this.active = new ToActiveOrArchivedPipe();
        this.yesno = new ToYesNoPipe();
        this.truncate = new TruncatePipe();
        this.phone = new PhonePipe();
        this.label = new LabelPipe();
    }
    /**
     * Mutate a value with a specified transformation
     * @param value
     * @param transformation
     * @param core
     */
    transform(value, transformation, core = null) {
        if (IsObject(transformation, true)) {
            switch (transformation.type) {
                case 'toRelationName':
                    if (IsObject(value)) {
                        if (transformation.arg1) { // core storage path
                            const location = IsString(transformation.arg1, true) ? transformation.arg1 : 'name';
                            const steps = String(location).split('.');
                            // steps.push(value);
                            const name = StorageGetter(value, steps);
                            if (name)
                                value = name;
                            if (IsString(transformation.arg2, true)) { // alias
                                if (IsAliasable(GetSingularName(String(value)))) {
                                    value = StorageGetter(PopApp.entities[TitleCase(String(value))], ['alias', String(transformation.arg2).toLowerCase()], value);
                                }
                            }
                        }
                    }
                    else {
                        value = transformation.arg2 ? transformation.arg2 : value; // transformations[ field ].arg2 is default value
                    }
                    break;
                case 'toResourceName':
                    if (IsNumber(value)) {
                        let resource;
                        let key = 'name';
                        let resourceName;
                        let id;
                        if (IsString(transformation.arg1, true)) { // resource name
                            resourceName = String(transformation.arg1).trim();
                            if (IsObject(core, ['resource']) && resourceName in core.resource) {
                                resource = core.resource[resourceName];
                                if (IsArray(core.resource[resourceName].data_values, true)) {
                                    if (IsString(transformation.arg2, true))
                                        key = transformation.arg2;
                                    const item = core.resource[resourceName].data_values.find((i) => +i.id === value);
                                    if (IsObject(item, [key]) && IsDefined(item[key])) {
                                        value = item[key];
                                    }
                                }
                                if (IsString(transformation.arg2, true)) { // alias
                                    if (IsAliasable(GetSingularName(String(value)))) {
                                        value = StorageGetter(PopApp.entities[TitleCase(String(value))], ['alias', String(transformation.arg2).toLowerCase()], value);
                                    }
                                }
                            }
                            else if (resourceName in this.asset) {
                                id = +value;
                                resourceName = String(transformation.arg1).trim();
                                if (IsString(transformation.arg1, true)) { // alternate value
                                    key = transformation.arg1;
                                }
                                if (resourceName in this.asset && id in this.asset[resourceName] && IsDefined(this.asset[resourceName][id][key])) {
                                    value = this.asset[transformation.type][id][key];
                                }
                            }
                        }
                    }
                    else {
                        value = transformation.arg3 ? transformation.arg3 : value; // transformations[ field ].arg2 is default value
                    }
                    break;
                case 'entity':
                    if (value) {
                        let key;
                        if (IsString(value, true) && transformation.arg1 === 'alias') {
                            const id = this.assetMap.entity[value + ''];
                            const alias = transformation.arg2 ? (transformation.arg2 !== 'plural' ? 'name' : 'plural') : 'name';
                            if (id in this.asset.entity && this.asset.entity[id]) {
                                const entity = this.asset.entity[id];
                                if (IsObject(entity.alias) && alias in entity.alias) {
                                    value = TitleCase(entity.alias[alias]);
                                }
                                else {
                                    if (alias === 'plural') {
                                        value = entity.name;
                                    }
                                    else {
                                        value = TitleCase(value + '');
                                    }
                                }
                            }
                            else {
                                value = TitleCase(value + '');
                            }
                        }
                        else if (IsString(value, true)) {
                            const id = this.assetMap.entity[value + ''];
                            key = 'name';
                            if (IsString(transformation.arg1, true)) {
                                key = transformation.arg1;
                            }
                            if (id in this.asset.entity && this.asset.entity[id] && IsDefined(this.asset.entity[id][key])) {
                                value = this.asset.entity[id][key];
                            }
                            else {
                                value = TitleCase(value + '');
                            }
                        }
                        else if (IsNumber(value, true)) {
                            const id = +value;
                            key = 'name';
                            if (IsString(transformation.arg1, true)) { // alternate value
                                key = transformation.arg1;
                            }
                            if (id in this.asset.entity && IsString(this.asset.entity[id][key])) {
                                value = this.asset[transformation.type][id][key];
                            }
                        }
                    }
                    break;
                case 'client':
                case 'account':
                case 'campaign':
                case 'state':
                case 'country':
                case 'timezone':
                    if (value) {
                        const id = +value;
                        let key = 'name';
                        if (IsString(transformation.arg1, true)) { // alternate value
                            key = transformation.arg1;
                        }
                        if (transformation.type in this.asset && id in this.asset[transformation.type] && IsDefined(this.asset[transformation.type][id][key])) {
                            value = this.asset[transformation.type][id][key];
                        }
                    }
                    break;
                case 'toDigits':
                    value = String(value).match(/\d+/g).map(Number).join('');
                    break;
                case 'toYesNoPipe':
                    value = this.yesno.transform(+value > 0);
                    break;
                case 'toPhonePipe':
                    value = this.phone.transform(value);
                    break;
                case 'toActiveOrArchived':
                    value = this.active.transform(value);
                    break;
                case 'toTitleCase':
                    value = TitleCase(value + '');
                    break;
                case 'toUpperCase':
                    value = String(value).toUpperCase();
                    break;
                case 'toLowerCase':
                    value = String(value).toLowerCase();
                    break;
                case 'date':
                    value = PopDate.transform(value, transformation.arg1);
                    break;
                case 'toCurrency':
                    value = new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 2
                    }).format(Number(value));
                    break;
                default:
                    break;
            }
        }
        else if (IsString(transformation, true)) {
            return PopTransform(value, transformation);
        }
        return value;
    }
    loadResources(allowCache = true) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.loaded)
                return resolve(true);
            let resources;
            if (allowCache && IsObject(PopBusiness, ['id'])) {
                try {
                    resources = GetSessionSiteVar(`App.${PopBusiness.id}.Resource`);
                    resources = JSON.parse(atob(resources));
                }
                catch (e) {
                }
            }
            if (IsObject(resources, Object.keys(this.resources))) {
                Object.keys(resources).map((key) => {
                    const values = resources[key].data_values;
                    this.asset[key] = {};
                    values.map((item) => {
                        this.asset[key][item.id] = item;
                    });
                });
                this._setAssetMap();
                return resolve(true);
            }
            else {
                this.resource.setCollection(this.resources).then(() => {
                    resources = this.resource.getCollection(this.resources);
                    if (IsObject(resources, true)) {
                        try {
                            SetSessionSiteVar(`App.${PopBusiness.id}.Resource`, btoa(JSON.stringify(resources)));
                        }
                        catch (e) {
                        }
                        Object.keys(resources).map((key) => {
                            const values = resources[key].data_values;
                            this.asset[key] = {};
                            values.map((item) => {
                                this.asset[key][item.id] = item;
                            });
                        });
                        this._setAssetMap();
                        this.loaded = true;
                        return resolve(true);
                    }
                    else {
                        this.loaded = true;
                        return resolve(true);
                    }
                }, () => {
                    return resolve(false);
                });
            }
        }));
    }
    setAsset(assetName, data) {
        if (assetName in this.asset && IsObject(data, true)) {
            this.asset[assetName] = data;
        }
    }
    updateEntityAlias(entityId, alias) {
        if (entityId in this.asset.entity && IsObject(this.asset.entity[entityId])) {
            this.asset.entity[entityId].alias = alias;
        }
    }
    /**
     * A helper method to prepareTableData
     * @param row
     * @param transformations
     */
    transformObjectValues(obj, transformations, core = null) {
        for (const field in transformations) {
            if (!transformations.hasOwnProperty(field))
                continue;
            obj[field] = this.transform(obj[field], transformations[field], core);
        }
        return obj;
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setAssetMap() {
        if (IsObject(this.asset.entity, true)) {
            Object.keys(this.asset.entity).map(entityId => {
                const entity = this.asset.entity[entityId];
                this.assetMap.entity[entity.internal_name] = entityId;
            });
        }
    }
}
PopPipeService.prov = i0.defineInjectable({ factory: function PopPipeService_Factory() { return new PopPipeService(i0.inject(PopResourceService)); }, token: PopPipeService, providedIn: "root" });
PopPipeService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopPipeService.ctorParameters = () => [
    { type: PopResourceService }
];

class PopCacFilterBarService extends PopExtendService {
    constructor(crud, pipe, APP_GLOBAL) {
        super();
        this.crud = crud;
        this.pipe = pipe;
        this.APP_GLOBAL = APP_GLOBAL;
        this.loading = false;
        this.name = 'PopClientFilterBarService';
        this.config = new CacFilterBarConfig({
            active: false
        });
        this.asset = {
            lookup: {},
            el: undefined,
            client: new Map(),
            account: new Map(),
            campaign: new Map(),
            triggerFields: ['name', 'archived', 'deleted_at', 'client_id', 'account_id', 'campaign_id'],
            views: ['client', 'account', 'campaign']
        };
        this.event = {
            data: new Subject(),
            config: new Subject(),
            bubble: new Subject()
        };
        this.filter = {};
        this.entities = [
            new CacFilterBarEntityConfig({
                sort_order: 0,
                internal_name: 'client',
                name: 'Client(s)',
                options: [],
                parent_link: null,
                child_link: 'client_id',
                single: false,
                visible: true
            }),
            new CacFilterBarEntityConfig({
                sort_order: 1,
                internal_name: 'account',
                name: 'Account(s)',
                options: [],
                parent_link: 'client_id',
                child_link: 'account_id',
                single: false,
                visible: true,
            }),
            new CacFilterBarEntityConfig({
                sort_order: 2,
                internal_name: 'campaign',
                name: 'Campaigns(s)',
                options: [],
                parent_link: 'account_id',
                child_link: null,
                single: false,
                visible: true
            }),
        ];
        this._init().then(() => true);
    }
    _init() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            yield this.APP_GLOBAL.isVerified();
            if (IsObject(PopBusiness, ['id']) && IsObject(PopUser, ['id'])) {
                this._getFilterStorage(); // retrieve any session data
            }
            else {
                this.config.active = false;
                return resolve(false);
            }
            this.dom.setSubscriber(`crud-events`, this.crud.events.subscribe((event) => {
                if (IsValidFieldPatchEvent({}, event)) {
                    const internalName = StorageGetter(event.config, ['metadata', 'internal_name'], null);
                    if (internalName && this.asset.views.includes(internalName) && this.asset.triggerFields.includes(event.config.name)) {
                        this._triggerDataRefresh('Patch');
                    }
                }
                else {
                    if (event.internal_name && event.type === 'entity' && this.asset.views.includes(event.internal_name)) {
                        if (event.method === 'archive') {
                            const entity = this.entities.find((e) => e.internal_name);
                            const filter = this.filter[entity.internal_name];
                            const archive = event.data;
                            if (archive) {
                                let id;
                                if (IsString(event.id, true)) {
                                    if (String(event.id).includes(',')) {
                                        id = String(event.id).split(',').map(x => +x);
                                    }
                                    else {
                                        id = [+event.id];
                                    }
                                }
                                else if (IsNumber(event.id)) {
                                    id = [+event.data.id];
                                }
                                let setFilter = false;
                                id.map((x) => {
                                    delete entity.hidden[x];
                                    delete entity.display[x];
                                    delete entity.selected[x];
                                    if (IsArray(filter, true)) {
                                        const index = filter.indexOf(String(x), 0);
                                        if (index > -1) {
                                            setFilter = true;
                                            filter.splice(index, 1);
                                        }
                                    }
                                });
                                if (setFilter) {
                                    this.setFilter(this.filter);
                                }
                            }
                            this._triggerDataRefresh('archive', 1);
                        }
                        if (event.method === 'create') {
                            const entity = this.entities.find((e) => e.internal_name);
                            this._triggerDataRefresh('create', 1);
                        }
                    }
                }
            }));
            return resolve(false);
        }));
    }
    register(el) {
        this.asset.el = el;
    }
    getEntities() {
        return this.entities;
    }
    getFilter() {
        return this.filter;
    }
    /**
     * Return the filter bar config
     */
    getConfig() {
        return this.config;
    }
    setFilter(filter) {
        this.filter = {};
        if (IsObject(PopBusiness, ['id'])) {
            if (IsArray(filter.client, true))
                this.filter.client = filter.client;
            if (this.config.view.includes('account') && IsArray(filter.account, true)) {
                this.filter.account = filter.account;
            }
            else {
                if (IsArray(filter.client, true)) {
                    const clients = filter.client.map(c => +c);
                    filter.account = this.entities[1].options.filter((account) => {
                        return +account.client_id && clients.includes(account.client_id);
                    }).map(a => String(a.id));
                    this.filter.account = filter.account;
                }
            }
            if (this.config.view.includes('campaign') && IsArray(filter.campaign, true)) {
                this.filter.campaign = filter.campaign;
            }
            else {
                if (IsArray(filter.account, true)) {
                    const accounts = filter.account.map(c => +c);
                    filter.campaign = this.entities[2].options.filter((campaign) => {
                        return +campaign.account_id && accounts.includes(campaign.account_id);
                    }).map(c => String(c.id));
                    console.log('filter.campaign', filter.campaign);
                    this.filter.campaign = filter.campaign;
                }
            }
            SetSessionSiteVar(`Business.${PopBusiness.id}.Filter.Entities`, filter);
            SetPopFilter(filter);
        }
    }
    getElHeight() {
        if (this.asset.el) {
            return this.asset.el.nativeElement.lastChild.clientHeight;
        }
        return 0;
    }
    getHeight() {
        if (IsObject(PopBusiness, ['id'])) {
            const open = GetSessionSiteVar(`Business.${PopBusiness.id}.Filter.open`, false);
            if (+open) {
                return 281;
            }
            else {
                return 101;
            }
        }
        return 0;
    }
    /**
     * Clear any existing filters
     * @param app
     */
    clearFilters() {
        this.setFilter({});
    }
    /**
     * Trigger update trigger
     * @param type strings
     * @returns void
     */
    onChange(event) {
        setTimeout(() => {
            this.event.bubble.next(event);
        }, 0);
    }
    /**
     * Ask whether the filter bar is active or not
     */
    isActive() {
        return this.config.active;
    }
    refresh() {
        this.event.bubble.next({
            source: 'PopFilterBarService',
            type: 'filter',
            name: 'refresh',
        });
    }
    /**
     * Toggle whether to include archived records
     * @param active
     */
    setArchived(archived) {
        if (this.config) {
            this.config.archived = archived;
            this.event.bubble.next({
                source: 'PopFilterBarService',
                type: 'filter',
                name: 'archived',
                data: archived
            });
        }
    }
    /**
     * Toggle the filer bar on and off
     * @param active
     */
    setActive(active) {
        if (this.config) {
            this.config.active = active;
            this.event.bubble.next({
                source: 'PopFilterBarService',
                type: 'filter',
                name: 'state',
                model: 'active'
            });
        }
    }
    /**
     * Toggle the Loader
     * @param loader
     */
    setLoader(loader) {
        if (this.config) {
            this.config.loader = loader;
        }
    }
    /**
     * Change the display state of the filter bar
     * @param display
     */
    setDisplay(display) {
        if (this.config) {
            if (!['default', 'static', 'float'].includes(display))
                display = 'default';
            this.config.display = display;
        }
    }
    /**
     * Change the display state of the filter bar
     * @param display
     */
    setView(view) {
        if (IsArray(view)) {
            this.config.view = view;
            this.entities.map((entity) => {
                entity.visible = this.config.view.includes(entity.internal_name);
            });
        }
    }
    getAsset(internal_name, id) {
        if (internal_name in this.asset) {
            return this.asset[internal_name].get(+id);
        }
        return null;
    }
    setData(caller, allowCache = true) {
        PopLog.info(this.name, `setData`, caller);
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let cache;
            if (allowCache && IsObject(PopBusiness, ['id'])) {
                try {
                    cache = GetSessionSiteVar(`Business.${PopBusiness.id}.Filter.Data`);
                    cache = JSON.parse(atob(cache));
                }
                catch (e) {
                }
            }
            if (IsArray(cache, true)) {
                this._transFormData(cache);
                this._triggerDataRefresh('init');
                return resolve(true);
            }
            else {
                // this.config.loader = true;
                const url = `clients?select=id,name,client_id,account_id,campaign_id,allaccounts,allcampaigns&archived=0&with=allaccounts.allcampaigns&limit=500`;
                this.dom.setSubscriber(`data-fetch`, PopRequest.doGet(url, {}, 1, false).subscribe((x) => {
                    if (x.data)
                        x = x.data;
                    if (IsObject(PopBusiness, ['id'])) {
                        try {
                            SetSessionSiteVar(`Business.${PopBusiness.id}.Filter.Data`, btoa(JSON.stringify(x)));
                        }
                        catch (e) {
                        }
                    }
                    this._transFormData(x);
                    // this.config.loader = false;
                    return resolve(true);
                }, () => {
                    return resolve(false);
                }));
            }
        }));
    }
    setConfigAliases() {
        this.entities.map((entity) => {
            entity.name = PopPipe.transform(entity.internal_name, { type: 'entity', arg1: 'alias', arg2: 'singular' }) + '(s)';
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    _triggerDataRefresh(caller, seconds = 10) {
        this.dom.setTimeout('lazy-load-filter-data', () => {
            this.setData(`_triggerDataRefresh`, false).then(() => {
                this.event.data.next(caller);
            });
        }, (seconds * 1000));
    }
    _transFormData(x) {
        const data = this._setDataStructure(x);
        Object.keys(data).map(key => {
            this.pipe.setAsset(key, data[key]);
            PopLog.init(this.name, `Transfer asset to PipeService: ${key}`);
        });
        this.entities[0].options = Object.values(data.client).sort((a, b) => {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
        this.entities[1].options = Object.values(data.account).sort((a, b) => {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
        this.entities[2].options = Object.values(data.campaign).sort((a, b) => {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Retrieves any filter settings from session storage
     */
    _getFilterStorage() {
        let filter = {};
        if (IsObject(PopBusiness, ['id'])) {
            filter = GetSessionSiteVar(`Business.${PopBusiness.id}.Filter.Entities`, {});
            if (IsArray(filter.client, true)) {
                const client = this.entities[0];
                if (!IsObject(client.selected))
                    client.selected = {};
                filter.client.map((c) => {
                    client.selected[c.id] = true;
                });
            }
            if (IsArray(filter.account, true)) {
                const account = this.entities[1];
                if (!IsObject(account.selected))
                    account.selected = {};
                filter.account.map((a) => {
                    account.selected[a.id] = true;
                });
            }
            if (IsArray(filter.campaign, true)) {
                const campaign = this.entities[2];
                if (!IsObject(campaign.selected))
                    campaign.selected = {};
                filter.campaign.map((c) => {
                    campaign.selected[c.id] = true;
                });
            }
            // this.asset.views.map((internal_name: string) => {
            //   if( !IsArray(filter[ internal_name ], true) ) delete filter[ internal_name ];
            // });
            SetPopFilter(filter);
        }
        this.filter = filter;
    }
    _setDataStructure(res) {
        const data = {
            client: {},
            account: {},
            campaign: {}
        };
        if (IsArray(res, true)) {
            res.map((client) => {
                data.client[+client.id] = {
                    id: +client.id,
                    name: client.name,
                    archived: client.archived,
                };
                // this.asset.client.set(+client.id, data.client[ +client.id ]);
                if (IsArray(client.allaccounts, true)) {
                    client.allaccounts.map((account) => {
                        if (IsObject(account)) {
                            data.account[+account.id] = {
                                id: +account.id,
                                name: account.name,
                                client_id: +account.client_id,
                                archived: +account.archived,
                            };
                            // this.asset.account.set(+account.id, data.account[ +account.id ]);
                            if (IsArray(account.allcampaigns, true)) {
                                account.allcampaigns.map((campaign) => {
                                    if (IsObject(campaign)) {
                                        data.campaign[+campaign.id] = {
                                            id: +campaign.id,
                                            name: campaign.name,
                                            client_id: +client.id,
                                            account_id: +campaign.account_id,
                                            archived: +campaign.archived,
                                        };
                                        // this.asset.campaign.set(+campaign.id, data.campaign[ +campaign.id ]);
                                    }
                                });
                            }
                        }
                    });
                }
            });
        }
        return data;
    }
}
PopCacFilterBarService.prov = i0.defineInjectable({ factory: function PopCacFilterBarService_Factory() { return new PopCacFilterBarService(i0.inject(PopEntityEventService), i0.inject(PopPipeService), i0.inject("APP_GLOBAL")); }, token: PopCacFilterBarService, providedIn: "root" });
PopCacFilterBarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopCacFilterBarService.ctorParameters = () => [
    { type: PopEntityEventService },
    { type: PopPipeService },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];

class PopTemplateService {
    constructor(filter, snackbar, APP_GLOBAL, env) {
        this.filter = filter;
        this.snackbar = snackbar;
        this.APP_GLOBAL = APP_GLOBAL;
        this.env = env;
        this.asset = {
            notification: undefined,
            contentEl: undefined
        };
    }
    turnOffFilter() {
        this.filter.setActive(false);
    }
    welcome() {
        this.asset.notification = this.snackbar.openFromComponent(PopTemplateWelcomeComponent, {
            panelClass: 'pop-template-center',
            duration: 5 * 1000
        });
    }
    buffer(expression = null, duration = 4) {
        if (isDevMode()) {
            this.asset.notification = this.snackbar.openFromComponent(PopTemplateBufferComponent, {
                panelClass: 'pop-template-center',
                duration: duration * 1000,
                data: {
                    expression: expression,
                }
            });
        }
    }
    error(error, duration = 5) {
        if (isDevMode()) {
            this.asset.notification = this.snackbar.openFromComponent(PopTemplateErrorComponent, {
                panelClass: 'pop-template-center',
                duration: duration * 1000
            });
            this.asset.notification.instance.error = error;
        }
    }
    goodbye() {
        this.asset.notification = this.snackbar.openFromComponent(PopTemplateGoodByeComponent, {
            panelClass: 'pop-template-center',
            duration: 5 * 1000
        });
    }
    lookBusy(duration = 5) {
        if (isDevMode()) {
            this.asset.notification = this.snackbar.openFromComponent(PopTemplateAjaxLoaderComponent, {
                panelClass: 'pop-template-center',
                duration: duration * 1000
            });
        }
    }
    notify(message, action = null, duration = 3) {
        this.asset.notification = this.snackbar.open(message, action, {
            panelClass: 'pop-template-center',
            duration: duration * 1000
        });
    }
    clear() {
        if (IsObject(this.asset.notification, ['dismiss'])) {
            this.asset.notification.dismiss();
        }
    }
    setContentEl(el) {
        if (el)
            this.asset.contentEl = el;
    }
    verify() {
        if (this.APP_GLOBAL.isVerified()) {
            this.APP_GLOBAL.verification.next();
        }
    }
    getContentHeight(modal = false, overhead = 60) {
        let height = window.innerHeight;
        if (this.asset.contentEl && this.asset.contentEl.nativeElement.offsetTop)
            height = (height - this.asset.contentEl.nativeElement.offsetTop);
        if (modal)
            height -= 100;
        if (overhead)
            height -= overhead;
        return height;
    }
}
PopTemplateService.prov = i0.defineInjectable({ factory: function PopTemplateService_Factory() { return new PopTemplateService(i0.inject(PopCacFilterBarService), i0.inject(i2.MatSnackBar), i0.inject("APP_GLOBAL"), i0.inject("env")); }, token: PopTemplateService, providedIn: "root" });
PopTemplateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopTemplateService.ctorParameters = () => [
    { type: PopCacFilterBarService },
    { type: MatSnackBar },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class PopTemplateComponent extends PopExtendComponent {
    constructor(el, router, template, renderer, APP_GLOBAL, APP_THEME) {
        super();
        this.el = el;
        this.router = router;
        this.template = template;
        this.renderer = renderer;
        this.APP_GLOBAL = APP_GLOBAL;
        this.APP_THEME = APP_THEME;
        this.backdrop = true;
        this.menus = [];
        this.widgets = [];
        this.filter = true;
        this.left = true;
        this.right = true;
        this.displayMenu = true;
        this.name = 'PopTemplateComponent';
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.setSubscriber('theme', this.APP_THEME.init.subscribe((val) => {
                    this.dom.setTimeout(`remove-backdrop`, () => {
                        this.renderer.removeClass(document.body, 'site-backdrop-dark');
                    }, 0);
                    if (val)
                        this.backdrop = !val;
                }));
                this.dom.setSubscriber('init', this.APP_GLOBAL.init.subscribe((val) => {
                    if (val)
                        this._initialize();
                }));
                window.onbeforeunload = () => {
                    try {
                        this.APP_GLOBAL._unload.next(true);
                    }
                    catch (e) {
                        console.log(e);
                    }
                };
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.template.setContentEl(this.content);
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _initialize() {
        return true;
    }
}
PopTemplateComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-template',
                template: "<div class=\"pop-template\">\n  <header class=\"pop-template-header\" #header *ngIf=\"displayMenu\">\n    <lib-pop-menu></lib-pop-menu>\n  </header>\n  <section class=\"pop-template-section\">\n    <aside class=\"pop-template-aside-left\">\n      <lib-pop-left-menu [hidden]=!left [entityMenus]=\"menus\"></lib-pop-left-menu>\n    </aside>\n    <div class=\"pop-template-main\">\n      <lib-pop-cac-filter #filter></lib-pop-cac-filter>\n      <div class=\"sw-outlet-target pop-template-content-overflow\">\n        <router-outlet></router-outlet>\n      </div>\n    </div>\n    <aside class=\"pop-template-aside-right\">\n      <lib-pop-widget-bar  [hidden]=!right [widgets]=\"widgets\"></lib-pop-widget-bar>\n    </aside>\n  </section>\n  <footer class=\"pop-template-footer\"></footer>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [":host{height:100%;display:flex;flex-direction:column;position:absolute;top:0;bottom:0;left:0;right:0}:host ::ng-deep .mat-form-field .mat-form-field-infix{width:0}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-flex{margin-top:0}.pop-template{width:100%;height:100vh;margin:0;display:flex;flex-direction:column;overflow-y:hidden}.pop-template-backdrop{background:pink}.pop-template-footer{height:0}.pop-template-section{flex:1;justify-content:space-between;display:flex;flex-direction:row;margin-top:48px}.pop-template-main{position:relative;flex:5}.pop-template-content-overflow{position:absolute!important;height:calc(100vh - 55px)!important;left:0;right:0;overflow-y:auto;overflow-x:auto}.pop-template-aside-left{border-right:1px solid var(--disabled);background:var(--background-main-menu)}.pop-template-aside-left,.pop-template-aside-right{flex:0;border-bottom:1px solid var(--disabled);box-sizing:border-box}.pop-template-aside-right{border-left:1px solid var(--disabled)}.pop-template-center{display:flex;align-items:center;justify-content:center}.pop-template-center div{text-align:center}"]
            },] }
];
PopTemplateComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Router },
    { type: PopTemplateService },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_THEME',] }] }
];
PopTemplateComponent.propDecorators = {
    header: [{ type: ViewChild, args: ['header',] }],
    content: [{ type: ViewChild, args: ['content',] }],
    backdrop: [{ type: HostBinding, args: ['class.pop-template-backdrop',] }, { type: Input }],
    menus: [{ type: Input }],
    widgets: [{ type: Input }],
    filter: [{ type: Input }],
    left: [{ type: Input }],
    right: [{ type: Input }],
    displayMenu: [{ type: Input }]
};

class EntityMenu {
    constructor(args) {
        this.id = args.id || 0;
        this.description = args.description || '';
        this.name = args.name;
        this.entity_id = args.entity_id || null;
        this.path = args.path;
        this.short_description = args.short_description || '';
        this.sort = args.sort || 0;
        this.internal_name = args.internal_name || null;
        this.hasAlias = args.hasAlias ? true : false;
        this.originalPath = args.originalPath;
        this.originalName = args.originalName;
        if (IsString(args.icon, true)) {
            this.icon = args.icon;
            this._setIcon();
        }
        else {
            this._setCharacters();
        }
    }
    _setPath() {
        const pathSet = this.path.split("/");
        this.path = '/' + pathSet[pathSet.length - 1];
    }
    _setIcon() {
        const iconSet = this.icon.split(":");
        if (iconSet.length === 2) {
            [this.iconType, this.icon] = iconSet;
        }
    }
    _setCharacters() {
        this.character_icon = "";
        const nameArray = this.name.split(" ");
        if (nameArray.length >= 2) {
            this.character_icon += nameArray[0].charAt(0).toLocaleUpperCase();
            this.character_icon += nameArray[1].charAt(0).toLocaleUpperCase();
        }
        else {
            this.character_icon += this.name.charAt(0).toLocaleUpperCase();
            this.character_icon += this.name.charAt(1).toLocaleLowerCase();
        }
    }
}

class PopEntityUtilParamService {
    constructor() {
        this.store = new Map();
        this.mapById = new Map();
        this.mapByRoute = new Map();
        this.setEntityParams({
            id: 0,
            alias: null,
            access: {
                can_create: 1,
                can_read: 1,
                can_update: 1,
                can_delete: 0,
                can_destroy: 0,
            },
            can_extend: false,
            path: '/auth/user',
            param: '',
            api: '/auth/user',
            internal_name: 'prime_user',
            name: 'Prime User',
        });
    }
    getEntityParamsWithPath(path, entityId = null) {
        let entity;
        let entityParams = undefined;
        const internal_name = this.mapByRoute.get(path);
        if (internal_name && this.store.has(internal_name))
            entity = this.store.get(internal_name);
        if (entity) {
            entityParams = {
                alias: entity.alias,
                api: entity.api,
                app: entity.app,
                id: entity.id,
                can_extend: entity.can_extend,
                internal_name: entity.internal_name,
                name: entity.name,
                path: entity.path,
                param: entity.param,
            };
            if (entityId)
                entityParams.entityId = entityId;
        }
        return entityParams;
    }
    setEntityParams(params) {
        if (IsObject(params, true)) {
            if (!(IsObject(params.access, true))) {
                params.access = { can_create: 0, can_read: 0, can_update: 0, can_delete: 0, can_destroy: 0 };
            }
            else {
                Object.keys(params.access).map((accessName) => {
                    params.access[accessName] = +params.access[accessName];
                });
            }
            this.mapById.set(+params.id, params.internal_name);
            this.mapByRoute.set(SpaceToHyphenLower(params.name), params.internal_name);
            if (this.store.has(params.internal_name)) {
                let existingParams = this.store.get(params.internal_name);
                existingParams = DeepMerge(existingParams, params);
                this.store.set(params.internal_name, existingParams);
            }
            else {
                this.store.set(params.internal_name, params);
            }
        }
    }
    getEntityParams(internal_name, entityId = null) {
        let entityParams = undefined;
        if (IsNumber(internal_name)) {
            internal_name = this.mapById.get(+internal_name);
        }
        const entity = this.store.get(internal_name + '');
        if (entity) {
            entityParams = {
                alias: entity.alias,
                api: entity.api,
                app: entity.app,
                id: entity.id,
                can_extend: entity.can_extend,
                internal_name: entity.internal_name,
                name: entity.name,
                path: entity.path,
                param: entity.param,
            };
            if (entityId)
                entityParams.entityId = entityId;
        }
        return entityParams;
    }
    getAccess(internal_name, accessType) {
        let access = null;
        if (IsNumber(internal_name))
            internal_name = this.mapById.get(+internal_name);
        if (this.store.has(internal_name + '')) {
            const entity = this.store.get(internal_name + '');
            if (accessType && accessType in entity.access) {
                access = entity.access[accessType];
            }
            else {
                access = entity.access;
            }
        }
        return access;
    }
    getAlias(internal_name, accessType) {
        let alias = null;
        if (IsNumber(internal_name))
            internal_name = this.mapById.get(+internal_name);
        if (this.store.has(internal_name + '')) {
            const entity = this.store.get(internal_name + '');
            if (IsObject(entity.alias, true)) {
                alias = entity.alias;
            }
        }
        return alias;
    }
    /**
     * Checks if the user has permissons to the specific type of an entity depending upon the local token details.
     *
     * @param appName - The name of the app to check. IE: admin, cis, etc...
     * @param entityName - The name of the entity inside the app to check: IE: For the admin app, users.
     * @param accessType - The type of permissons to check. Enum [can_create, can_read, can_update, can_delete]
     */
    checkAccess(internal_name, accessType) {
        if (IsNumber(internal_name))
            internal_name = this.mapById.get(+internal_name);
        if (this.store.has(internal_name + '')) {
            const entity = this.store.get(internal_name + '');
            return !!entity.access[accessType];
        }
        return false;
    }
}
PopEntityUtilParamService.prov = i0.defineInjectable({ factory: function PopEntityUtilParamService_Factory() { return new PopEntityUtilParamService(); }, token: PopEntityUtilParamService, providedIn: "root" });
PopEntityUtilParamService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntityUtilParamService.ctorParameters = () => [];

class PopLeftMenuComponent extends PopExtendComponent {
    constructor(router, APP_GLOBAL, APP_MENUS) {
        super();
        this.router = router;
        this.APP_GLOBAL = APP_GLOBAL;
        this.APP_MENUS = APP_MENUS;
        this.entityMenus = [];
        this.hidden = false;
        this.name = 'PopLeftMenuComponent';
        this.srv = {
            param: ServiceInjector.get(PopEntityUtilParamService)
        };
        this.asset = {
            siteVar: 'App.LeftMenu.open',
        };
        this.ui = {};
        if (APP_GLOBAL.isOpen()) {
            PopLog.init(this.name, `Public App`, this.entityMenus);
            this.hidden = ((this.APP_GLOBAL.isEntities() && !(IsObject(PopAuth))) || !(this.entityMenus.length)) ? true : false;
        }
        else {
            this._initialize();
            this.dom.setSubscriber('init', this.APP_GLOBAL.init.subscribe((val) => __awaiter(this, void 0, void 0, function* () {
                if (val) {
                    this.dom.state.verified = yield this.APP_GLOBAL.isVerified();
                    this._initialize();
                }
            })));
        }
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this._setState();
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This fx will open/close the left side nav
     */
    onToggleMenu() {
        this.dom.state.open = !this.dom.state.open;
        this.dom.state.closed = !this.dom.state.open;
        SetSiteVar(this.asset.siteVar, this.dom.state.open);
        window.dispatchEvent(new Event('onWindowResize'));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx will build out the menus for this component
     * @private
     */
    _initialize() {
        this.dom.setTimeout(`init`, () => __awaiter(this, void 0, void 0, function* () {
            const menus = yield this._setMenus();
            PopLog.init(this.name, `Private App`, this.entityMenus);
            if (IsArray(menus, true) && this._isVerifiedMenusDifferent(menus)) {
                this.entityMenus = menus;
            }
            this.hidden = ((this.APP_GLOBAL.isEntities() && !(IsObject(PopAuth))) || !(this.entityMenus.length)) ? true : false;
            if (this.dom.state.verified) {
                yield this._checkDefaultRoute();
            }
        }), 5);
    }
    /**
     * Determine the state of this component
     * The component should be open or closed base of the users latest session setting, or should default to open
     * @private
     */
    _setState() {
        const open = GetSiteVar(this.asset.siteVar, true);
        this.dom.state.open = typeof open === 'boolean' ? open : false;
        this.dom.state.closed = !this.dom.state.open;
    }
    /**
     * Create a list of the menus needed for the current app
     * @private
     */
    _setMenus() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let menus = [];
            const routeAliasMap = {};
            if (this.APP_GLOBAL.isEntities() && IsObject(PopApp, ['menu'])) {
                for (const menuEntity in PopApp.menu) {
                    if (IsObject(PopApp.menu[menuEntity])) {
                        const menu = PopApp.menu[menuEntity];
                        menu.originalPath = menu.path;
                        menu.originalName = menu.name;
                        if (menu.entity_id) {
                            const params = this.srv.param.getEntityParams(menu.entity_id);
                            if (IsObject(params, ['id', 'internal_name']) && this.srv.param.checkAccess(params.internal_name, 'can_read')) {
                                menu.id = +menu.entity_id;
                                menu.internal_name = params.internal_name;
                                if (this.APP_GLOBAL.isAliases() && IsObject(params.alias, ['name', 'plural'])) {
                                    const alias = params.alias;
                                    menu.hasAlias = true;
                                    menu.name = TitleCase(alias.plural);
                                    menu.path = SpaceToHyphenLower(alias.plural);
                                    routeAliasMap[SpaceToHyphenLower(alias.plural)] = menu.originalPath;
                                }
                                else {
                                    menu.hasAlias = false;
                                }
                                menus.push(new EntityMenu(menu));
                            }
                            else {
                                PopLog.warn(this.name, `Cannot view menu:`, menu);
                            }
                        }
                        else {
                            menus.push(new EntityMenu(menu));
                        }
                    }
                }
                if (IsCallableFunction(this.APP_MENUS.init)) {
                    menus = this.APP_MENUS.init(menus);
                }
                SetPopAliasRouteMap(routeAliasMap);
                this.APP_MENUS.set(menus);
                return resolve(menus);
            }
            else {
                return resolve(menus);
            }
        }));
    }
    /**
     * Set a default route for the project
     * @param parent
     * @param config
     * @param routes
     * @private
     */
    _checkDefaultRoute() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.router.config.length && IsArray(this.entityMenus, true)) {
                const defaultRoute = this.router.config.find((route) => route.path === '**');
                if (!defaultRoute && this._isValidRoute(this.entityMenus[0].path)) {
                    this.router.config.push({ path: '**', 'redirectTo': this.entityMenus[0].path });
                    PopLog.init(this.name, `Default Route Wildcard **`, this.entityMenus[0].path);
                }
                // const activeRouteUrl = ( !this.router.url || this.router.url === '/' ) ? false : true;
                // if( !activeRouteUrl ){
                const currentPath = window.location.href.split(`${PopHref}`)[1];
                if (this._isValidRoute(currentPath)) {
                    this._fallBackUrlRoute();
                }
                else {
                    this._fallBackMenuRoute();
                }
                // }
            }
            else {
            }
            return resolve(true);
        }));
    }
    /**
     * This fx will try to use the first menu item as the default route
     * @private
     */
    _fallBackMenuRoute() {
        PopLog.init(this.name, `Fallback Menu Route`, this.entityMenus[0].path);
        if (IsArray(this.entityMenus, true) && this._isValidRoute(this.entityMenus[0].path)) {
            this.log.info(`Fallback Menu Route`, this.entityMenus[0].path);
            this.router.navigate([this.entityMenus[0].path]).catch((e) => {
                this.log.info(`Could not find route`);
                this._fallbackSystemRoute();
            });
        }
        else {
            this._fallbackSystemRoute();
        }
    }
    /**
     * This fx will attempt to use the current url as the default route
     * @private
     */
    _fallBackUrlRoute() {
        let currentPath = window.location.href.split(PopHref)[1];
        currentPath = currentPath.split('?')[0];
        if (this._isValidRoute(currentPath)) {
            PopLog.init(this.name, `Current Route`, currentPath);
            this.router.navigate([currentPath], { queryParams: this._getUrlParams() }).catch((e) => {
                this._fallbackSystemRoute();
            }).then(() => {
                if (!(this.router.url.includes(currentPath))) {
                    this._fallbackSystemRoute();
                }
            });
        }
        else {
            this._fallbackSystemRoute();
        }
    }
    /**
     * This fx will temp redirect and try to find a valid route
     * @private
     */
    _fallbackSystemRoute() {
        if (this.dom.state.verified) {
            this.router.navigate(['/system/route'], { skipLocationChange: true });
        }
        else {
            this.router.navigate(['/']);
        }
    }
    /**
     * This fx determines if there is a difference between tow sets of menus(existing, new)
     * @param menus
     * @private
     */
    _isVerifiedMenusDifferent(menus) {
        return !(ObjectsMatch(this.entityMenus, menus));
    }
    /**
     * This fx determines if a path is a valid route
     * @param path
     * @private
     */
    _isValidRoute(path) {
        return IsDefined(path, false) && IsString(path, true) && path !== '/' && path !== 'null' && !(String(path).includes('/error/'));
    }
    _getUrlParams() {
        const params = {};
        window.location.search.slice(1).split('&').forEach(elm => {
            if (elm === '')
                return;
            const spl = elm.split('=');
            const d = decodeURIComponent;
            params[d(spl[0])] = (spl.length >= 2 ? d(spl[1]) : true);
        });
        return params;
    }
}
PopLeftMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-left-menu',
                template: "<div class=\"pop-left-menu\" [ngClass]=\"{'pop-left-menu-closed': dom.state.closed, 'pop-left-menu-open': dom.state.open}\">\n  <mat-nav-list>\n    <div class=\"pop-left-menu-item\" *ngFor=\"let menu of entityMenus\">\n      <a class=\"pop-left-menu-item-header\" [routerLink]=\"menu.path\" matRipple routerLinkActive=\"pop-left-menu-item-header-active\">\n        <div class=\"pop-left-menu-icon-container\">\n          <mat-icon *ngIf=\" menu.iconType && menu.iconType === 'materials'\" [matTooltip]=menu.name [matTooltipPosition]=\"'right'\" [matTooltipDisabled]=\"dom.state.open\">\n            {{menu.icon}}\n          </mat-icon>\n          <span *ngIf=\" menu.iconType && menu.iconType === 'pop'\" class=\"sw-pop-icon\" [matTooltip]=menu.name [matTooltipPosition]=\"'right'\" [matTooltipDisabled]=\"dom.state.open\">\n              {{menu.icon}}\n          </span>\n          <div class=\"sw-circle-ID mat-body-2\" *ngIf=\"!menu.iconType && menu.character_icon\" [matTooltip]=menu.name [matTooltipPosition]=\"'right'\" [matTooltipDisabled]=\"dom.state.open\">\n            {{menu.character_icon}}\n          </div>\n        </div>\n        <div class=\"pop-left-menu-label-container\">\n          <span class=\"mat-body\">{{menu.name}}</span>\n        </div>\n      </a>\n    </div>\n  </mat-nav-list>\n  <lib-main-spinner *ngIf=\"dom.state.loader\"></lib-main-spinner>\n  <button class=\"pop-left-menu-toggle\" mat-icon-button (click)=\"onToggleMenu();\">\n    <span class=\"sw-pop-icon\" *ngIf=\"dom.state.open\" id=\"left-nav-open\">H</span>\n    <span class=\"sw-pop-icon\" *ngIf=\"dom.state.closed\" id=\"left-nav-close\">I</span>\n  </button>\n</div>\n",
                styles: [".pop-left-menu{height:100vh;padding:20px 0 0;margin:0;overflow-x:hidden;overflow-y:auto}.pop-left-menu-open{width:256px;transition:width .5s}.pop-left-menu-closed{width:80px;transition:width .5s}.pop-left-menu-item{position:relative;display:block;min-height:var(--gap-xl);padding:0;margin:0;cursor:pointer;outline:0;white-space:nowrap;overflow:hidden}.pop-left-menu-item-header{position:relative;display:flex;height:var(--gap-xl);width:256px;padding:0;margin:0;align-items:center;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;clear:both;border-left:4px solid transparent;transition:background-color .35s,border-color .35s;border-left:var(--gap-xxs) solid transparent}.pop-left-menu-item-header-active{border-left-width:var(--gap-xxs);border-left-style:solid;border-left-color:var(--primary-500)!important;background-color:var(background-item-menu)!important;height:var(--gap-xl)}.pop-left-menu-item-header-active span.mat-body{font-weight:700}.pop-left-menu-label-container{flex-grow:1;padding:12px 0 0;text-align:left;color:var(--text)}.pop-left-menu-icon-container,.pop-left-menu-label-container{position:relative;height:40px;margin:0;box-sizing:border-box;overflow:hidden;float:left}.pop-left-menu-icon-container{width:80px;padding-left:var(--gap-lm);padding-right:var(--gap-s)}.pop-left-menu-icon-container .sw-circle-ID{position:absolute;top:4px}.pop-left-menu-item-header:hover{background:var(--background-item-menu)!important}.pop-left-menu-toggle{position:fixed;width:40px;height:40px;padding:10px 30px 30px 26px;margin:0 0 30px;box-sizing:border-box;overflow:hidden;float:left;bottom:0;border-radius:50%;background:transparent}"]
            },] }
];
PopLeftMenuComponent.ctorParameters = () => [
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_MENUS',] }] }
];
PopLeftMenuComponent.propDecorators = {
    entityMenus: [{ type: Input }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

class MaterialModule {
    static forRoot() {
        return {
            ngModule: MaterialModule,
            providers: [MatDialog, Overlay]
        };
    }
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MatAutocompleteModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatCheckboxModule,
                    MatCardModule,
                    MatDatepickerModule,
                    MatDialogModule,
                    MatExpansionModule,
                    MatFormFieldModule,
                    MatGridListModule,
                    MatInputModule,
                    MatIconModule,
                    MatListModule,
                    MatMenuModule,
                    MatPaginatorModule,
                    MatProgressBarModule,
                    MatProgressSpinnerModule,
                    MatRadioModule,
                    MatRippleModule,
                    MatSelectModule,
                    MatSidenavModule,
                    MatSlideToggleModule,
                    MatSortModule,
                    MatTableModule,
                    MatTabsModule,
                    MatToolbarModule,
                    MatTooltipModule,
                    MatSliderModule
                ],
                exports: [
                    MatAutocompleteModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatCheckboxModule,
                    MatCardModule,
                    MatDatepickerModule,
                    MatDialogModule,
                    MatExpansionModule,
                    MatFormFieldModule,
                    MatGridListModule,
                    MatInputModule,
                    MatIconModule,
                    MatListModule,
                    MatMenuModule,
                    MatPaginatorModule,
                    MatProgressBarModule,
                    MatProgressSpinnerModule,
                    MatRadioModule,
                    MatRippleModule,
                    MatSelectModule,
                    MatSidenavModule,
                    MatSlideToggleModule,
                    MatSortModule,
                    MatTableModule,
                    MatTabsModule,
                    MatToolbarModule,
                    MatTooltipModule,
                    MatSliderModule,
                ],
                providers: [],
            },] }
];

class MainSpinnerComponent {
    ngOnInit() {
        if (!this.options)
            this.options = {};
        this.color = this.options.color ? this.options.color : 'primary';
        this.mode = this.options.mode ? this.options.mode : 'indeterminate';
        this.diameter = this.options.diameter ? this.options.diameter : 75;
        this.strokeWidth = this.options.strokeWidth ? this.options.strokeWidth : 12;
    }
}
MainSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-main-spinner',
                template: "<div class=\"spinner-box\">\n  <mat-progress-spinner [color]=color [mode]=mode [diameter]=diameter [strokeWidth]=strokeWidth [value]=options.value></mat-progress-spinner>\n</div>\n\n",
                styles: [".spinner-box{width:100%;height:100%;display:inline-flex}.mat-progress-spinner{margin:auto;align-self:center}"]
            },] }
];
MainSpinnerComponent.propDecorators = {
    options: [{ type: Input }]
};

class PopIndicatorsModule {
}
PopIndicatorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [MainSpinnerComponent],
                imports: [MaterialModule],
                exports: [MainSpinnerComponent],
            },] }
];

class PopLeftMenuModule {
}
PopLeftMenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopLeftMenuComponent,
                ],
                imports: [
                    CommonModule,
                    RouterModule,
                    MatRippleModule,
                    MatIconModule,
                    MatTooltipModule,
                    MatListModule,
                    MatButtonModule,
                    PopIndicatorsModule
                ],
                exports: [
                    PopLeftMenuComponent,
                ],
                providers: [],
            },] }
];

class PopExtendDynamicComponent extends PopExtendComponent {
    constructor() {
        super();
        this.template = GetComponentTemplateContainer();
        this.template = Object.assign(Object.assign({}, this.template), {
            attach: (container) => {
                if (IsString(container, true)) {
                    if (this[container]) {
                        this.template.container = this[container];
                        delete this[container];
                    }
                    else {
                    }
                }
                else {
                    this.template.container = container;
                }
            },
            render: (list, transfer = ['core', 'position'], bypassTransfer = false) => {
                this.template.ref_events.map((subscription) => {
                    if (subscription && typeof subscription.unsubscribe === 'function') {
                        subscription.unsubscribe();
                    }
                });
                this.template.refs = this.template.refs.map(function (componentRef) {
                    if (componentRef && typeof componentRef.destroy === 'function') {
                        componentRef.destroy();
                    }
                    componentRef = null;
                    return null;
                });
                this.template.transfer = {};
                if (!bypassTransfer) {
                    transfer.map((transferKey) => {
                        if (typeof this[transferKey] !== 'undefined') {
                            this.template.transfer[transferKey] = this[transferKey];
                        }
                    });
                }
                if (this.template && this.template.container) {
                    this.template.container.clear();
                    if (Array.isArray(list)) {
                        list.map((component) => {
                            if (IsObject(component, true) && IsDefined(component.type)) {
                                const factory = PopComponentResolver.resolveComponentFactory(component.type);
                                const componentRef = this.template.container.createComponent(factory);
                                if (componentRef.instance.events) {
                                    this.template.ref_events.push(componentRef.instance.events.subscribe((event) => {
                                        if (typeof this.dom.handler.bubble === 'function') {
                                            this.dom.handler.bubble(this.core, event);
                                        }
                                        else {
                                            if (this.trait.bubble)
                                                this.events.emit(event);
                                        }
                                    }));
                                }
                                if (typeof (component.inputs) === 'object') {
                                    Object.keys(component.inputs).map((key) => {
                                        if (typeof (key) === 'string' && typeof (component.inputs[key]) !== 'undefined') {
                                            componentRef.instance[key] = component.inputs[key];
                                        }
                                    });
                                }
                                Object.keys(this.template.transfer).map((transferKey) => {
                                    componentRef.instance[transferKey] = this.template.transfer[transferKey];
                                });
                                componentRef.changeDetectorRef.detectChanges();
                                this.template.refs.push(componentRef);
                            }
                        });
                    }
                }
            },
            clear: () => {
                if (this.template.container)
                    this.template.container.clear();
            },
            destroy: () => {
                if (this.template)
                    DestroyComponentTemplate(this.template);
            },
        });
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngOnDestroy() {
        this.template.destroy();
        super.ngOnDestroy();
    }
}
PopExtendDynamicComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-template-component',
                template: `Template Component`
            },] }
];
PopExtendDynamicComponent.ctorParameters = () => [];

class PopWidgetBarComponent extends PopExtendDynamicComponent {
    constructor(APP_GLOBAL, APP_WIDGETS) {
        super();
        this.APP_GLOBAL = APP_GLOBAL;
        this.APP_WIDGETS = APP_WIDGETS;
        this.hidden = false;
        this.widgets = [];
        this.name = 'PopWidgetBarComponent';
        this.ui = {};
        this.asset = {};
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.state.open = false;
                this.dom.state.closed = true;
                this.dom.setSubscriber('init', this.APP_GLOBAL.init.subscribe((val) => {
                    if (val)
                        this._initialize();
                }));
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    onToggleMenu() {
        this.dom.state.open = !this.dom.state.open;
        this.dom.state.closed = !this.dom.state.open;
        window.dispatchEvent(new Event('onWindowResize'));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    _initialize() {
        this.hidden = ((this.APP_GLOBAL.isEntities() && !(IsObject(PopAuth))) || !(this.widgets.length)) ? true : false;
        return true;
    }
}
PopWidgetBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-widget-bar',
                template: "<div class=\"pop-widget-bar-container \" [ngClass]=\"{'pop-widget-bar-open': dom.state.open, 'pop-widget-bar-closed': dom.state.closed}\">\n  <div class=\"pop-widget-bar-layout\">\n    <p class=\"pop-widget-bar-icon-container\"></p>\n    <div class=\"pop-widget-item\">\n\n    </div>\n  </div>\n  <!--<button class=\"pop-widget-bar-toggle\" mat-icon-button (click)=\"onToggleMenu()\">-->\n    <!--<span class=\"sw-pop-icon\" *ngIf=\"dom.state.closed\">H</span>-->\n    <!--<span class=\"sw-pop-icon\" *ngIf=\"dom.state.open\">I</span>-->\n  <!--</button>-->\n</div>\n\n",
                styles: [".pop-widget-bar-container{overflow-x:hidden;overflow-y:hidden;height:100vh;margin:0}.pop-widget-bar-open{width:255px;transition:width .5s}.pop-widget-bar-closed{width:79px;transition:width .5s;background-color:var(--background-main-menu)}.pop-widget-bar-layout{overflow:hidden}.pop-widget-bar-icon-container{width:79px;position:relative;display:block;float:right}.pop-widget-item{width:196px;position:relative;display:block;overflow:hidden;float:left}.pop-widget-bar-toggle{position:fixed;width:40px;height:40px;padding:10px 30px 30px 26px;margin:0 0 30px;box-sizing:border-box;overflow:hidden;float:left;bottom:0;border-radius:50%}.pop-widget-bar-toggle .mat-icon-button{background-color:var(--bg-3)}"]
            },] }
];
PopWidgetBarComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_WIDGETS',] }] }
];
PopWidgetBarComponent.propDecorators = {
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }],
    widgets: [{ type: Input }]
};

class PopWidgetBarModule {
}
PopWidgetBarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MatButtonModule
                ],
                declarations: [
                    PopWidgetBarComponent,
                ],
                exports: [
                    PopWidgetBarComponent,
                ],
                providers: [],
            },] }
];

class PopFieldItemComponent extends PopExtendComponent {
    constructor() {
        super();
        this.position = 1;
        this.when = null;
        this.hidden = false;
        this.dom.state.helper = false;
        this.dom.state.tooltip = false;
        this.dom.state.hint = false;
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * On Link Click
     */
    onLinkClick() {
        console.log('LINK STUB: Link to Entity', this.config);
    }
    /**
     * On Blur Event
     */
    onBlur() {
        if (IsObject(this.config, true)) {
            let value = this.config.control.value;
            if (IsString(value)) {
                value = String(value).trim();
                this.config.control.setValue(value);
            }
            else if (IsNumber(value)) {
                value = +String(value).trim();
                this.config.control.setValue(value);
            }
            this.onBubbleEvent('onBlur');
            if (this._isChangeValid()) {
                if (this._isFieldPatchable()) {
                    this.onChange();
                }
                else {
                    this._applyTransformation(value);
                }
            }
        }
    }
    /**
     * On Change event
     * @param value
     * @param force
     */
    onChange(value, force = false) {
        if (IsObject(this.config, ['control'])) {
            this.log.info(`onChange`, value);
            const control = this.config.control;
            if (typeof value !== 'undefined') {
                control.setValue(value);
                control.markAsDirty();
                control.updateValueAndValidity();
            }
            if (this._isChangeValid()) {
                value = typeof value !== 'undefined' ? value : this.config.control.value;
                value = this._applyTransformation(value);
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    this._onPatch(value, force);
                }
                else {
                    this.onBubbleEvent('onChange');
                }
            }
            else {
                // console.log( 'invalid change', this.config.control.value );
                this.onBubbleEvent('onInvalidChange');
            }
        }
    }
    /**
     * On Focus event
     */
    onFocus() {
        if (IsObject(this.config, ['control'])) {
            const control = this.config.control;
            if (!control.dirty)
                this.asset.storedValue = this.config.control.value;
            this.config.message = '';
            this.onBubbleEvent('onFocus');
        }
    }
    /**
     * This will bubble an event up the pipeline
     * @param eventName
     * @param message
     * @param extend
     * @param force
     */
    onBubbleEvent(eventName, message = null, extend = {}, force = false) {
        if (IsObject(this.config, true)) {
            const event = {
                type: 'field',
                name: eventName,
                source: this.name
            };
            if (this.config)
                event.config = this.config;
            if (message)
                event.message = message;
            Object.keys(extend).map((key) => {
                event[key] = extend[key];
            });
            this.log.event(`onBubbleEvent`, event);
            if (this.config.bubble || force) {
                this.events.emit(event);
            }
            return event;
        }
    }
    ngOnDestroy() {
        this._clearState();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *               These are protected instead of private so that they can be overridden          *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Hook that is called on destroy to reset the field
     */
    _clearState() {
        const patch = this.config.patch;
        const control = this.config.control;
        if (patch.running) {
            control.enable();
            patch.running = false;
        }
    }
    /**
     * Hook that is called right before a patch
     */
    _beforePatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.disable();
            patch.running = true;
            this._clearMessage();
            return resolve(true);
        });
    }
    /**
     * Hook that is called right after the api response returns
     */
    _afterPatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.enable();
            patch.running = false;
            return resolve(true);
        });
    }
    /**
     * Prepare to make an api call to the server
     * @param value
     * @param force
     */
    _onPatch(value, force = false) {
        const patch = this.config.patch;
        if (!force) {
            if (!this.config.control.valid)
                return false;
            if (value === this.asset.storedValue)
                return false;
            if (patch.trigger === 'manual')
                return false;
        }
        this._beforePatch().then(() => {
            if (this.config.facade && !force) {
                this.dom.setTimeout('api-facade', () => {
                    this._onPatchSuccess({}).then(() => this._afterPatch());
                }, (this.config.patch.duration || 0));
            }
            else {
                this.log.info(`onPatch`);
                this._doPatch(this._getPatchBody(value));
            }
        });
    }
    /**
     * This fx will make the actual api call to the server
     * @param body
     * @private
     */
    _doPatch(body) {
        const method = this.config.patch.method ? this.config.patch.method : 'PATCH';
        const patch = this.config.patch;
        const ignore401 = (patch.ignore401 ? true : null);
        const version = (patch.version ? patch.version : 1);
        if (IsString(this.config.patch.path, true)) {
            const request = method === 'PATCH' ? PopRequest.doPatch(this.config.patch.path, body, version, ignore401, this.config.patch.businessId) : PopRequest.doPost(this.config.patch.path, body, version, ignore401, this.config.patch.businessId);
            this.dom.setSubscriber('api-patch', request.subscribe(res => {
                this._onPatchSuccess(res).then(() => this._afterPatch());
            }, err => {
                this._onPatchFail(err).then(() => this._afterPatch());
            }));
        }
        else {
            this._onPatchSuccess(body).then(() => this._afterPatch());
        }
    }
    /**
     * Determine if a change is valid
     */
    _isChangeValid() {
        const control = this.config.control;
        if (control.invalid) {
            if (this.config.displayErrors)
                this._setMessage(ValidationErrorMessages(control.errors));
            return false;
        }
        return this._checkPrevent();
    }
    /**
     * Determine if a field should be patched
     */
    _isFieldPatchable() {
        if (this.config.facade) {
            return true;
        }
        else if (this.config.patch && this.config.patch.path) {
            return true;
        }
        return false;
    }
    /**
     * Helper to determine if an event is related to a field update
     * @param event
     */
    _isFieldChange(event) {
        return event.type === 'field' && (event.name === 'onChange' || event.name === 'patch');
    }
    /**
     * Transformations can be applied to a value before it is sent to the api server
     * @param value
     */
    _applyTransformation(value) {
        if (IsString(this.config.transformation, true)) {
            value = PopTransform(value, this.config.transformation);
            if (value !== this.config.control.value)
                this.config.control.setValue(value);
        }
        return value;
    }
    /**
     * Handle an api call success
     * @param res
     */
    _onPatchSuccess(res) {
        return new Promise((resolve) => {
            this.log.info(`onPatchSuccess`);
            const patch = this.config.patch;
            const control = this.config.control;
            this.asset.storedValue = control.value;
            patch.success = true;
            patch.running = false;
            const event = this.onBubbleEvent(`patch`, 'Patched.', {
                success: true,
                response: res.data ? res.data : res
            }, true);
            if (IsObject(this.core, ['channel'])) {
                if (this.config.session) {
                    if (SessionEntityFieldUpdate(this.core, event, this.config.sessionPath)) {
                        if (!event.channel) {
                            event.channel = true;
                            this.core.channel.emit(event);
                        }
                        this.core.repo.clearCache('table', 'data');
                    }
                    else {
                        this.log.error(`SessionEntityFieldUpdate:${event.config.name}`, `Session failed`);
                    }
                }
                ServiceInjector.get(PopEntityEventService).sendEvent(event);
            }
            if (typeof patch.callback === 'function') { // allows developer to attach a callback when this field is updated
                patch.callback(this.core, event);
                this._onPatchSuccessAdditional();
            }
            this.dom.setTimeout('patch-success', () => {
                patch.success = false;
            }, (this.config.patch.duration || 0));
            return resolve(true);
        });
    }
    _onPatchSuccessAdditional() {
        return true;
    }
    /**
     * Handle an http failure
     * @param err
     */
    _onPatchFail(err) {
        return new Promise((resolve) => {
            this.log.info(`onPatchFail`);
            const patch = this.config.patch;
            const control = this.config.control;
            patch.running = false;
            control.markAsDirty();
            control.setValue(this.asset.storedValue);
            control.setErrors({ server: true });
            this.config.message = GetHttpErrorMsg(err);
            this.onBubbleEvent(`patch`, this.config.message, {
                success: false,
                response: err
            }, true);
            this._onPatchFailAdditional();
            return resolve(true);
        });
    }
    _onPatchFailAdditional() {
        return true;
    }
    /**
     * Set up the body of the api patch
     * @param value
     * @private
     */
    _getPatchBody(value) {
        let body = {};
        const patch = this.config.patch;
        value = typeof value !== 'undefined' ? value : this.config.control.value;
        if (IsObject(value)) {
            const val = value;
            body = Object.assign(Object.assign({}, body), val);
        }
        else if (IsArray(value)) {
            body[this.config.patch.field] = value;
        }
        else {
            body[this.config.patch.field] = value;
            if (this.config.empty && !body[this.config.patch.field]) {
                body[this.config.patch.field] = PopTransform(String(value), this.config.empty);
            }
        }
        if (this.config.patch.json)
            body[this.config.patch.field] = JSON.stringify(body[this.config.patch.field]);
        if (patch && patch.metadata) {
            for (const i in patch.metadata) {
                if (!patch.metadata.hasOwnProperty(i))
                    continue;
                body[i] = patch.metadata[i];
            }
        }
        return body;
    }
    /**
     * Helper to set error message
     * @param message
     */
    _setMessage(message) {
        this.config.message = message;
    }
    /**
     * Helper to clear error message
     */
    _clearMessage() {
        this.config.message = '';
    }
    _checkPrevent() {
        if (IsArray(this.config.prevent, true)) {
            const control = this.config.control;
            const value = control.value;
            const conflicts = this.config.prevent.filter((str) => str.toLowerCase() === String(value).toLowerCase());
            if (conflicts.length) {
                control.setErrors({ unique: true });
                this._setMessage(ValidationErrorMessages(control.errors));
                return false;
            }
            else {
                this._clearMessage();
                return true;
            }
        }
        return true;
    }
}
PopFieldItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-item-component',
                template: `Field Item Component`
            },] }
];
PopFieldItemComponent.ctorParameters = () => [];
PopFieldItemComponent.propDecorators = {
    position: [{ type: Input }],
    when: [{ type: Input }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

const slideInOut = trigger('slideInOut', [
    state('in', style({ height: '*', opacity: 0 })),
    transition(':leave', [
        style({ height: '*', opacity: 1 }),
        group([
            animate(300, style({ height: 0 })),
            animate('200ms ease-in-out', style({ 'opacity': '0' }))
        ])
    ]),
    transition(':enter', [
        style({ height: '0', opacity: 0 }),
        group([
            animate(300, style({ height: '*' })),
            animate('400ms ease-in-out', style({ 'opacity': '1' }))
        ])
    ])
]);
const fadeInOut = trigger('fadeInOut', [
    // the "in" style determines the "resting" state of the element when it is visible.
    state('in', style({ opacity: 1 })),
    // fade in when created. this could also be written as transition('void => *')
    transition(':enter', [
        style({ opacity: 0 }),
        animate(600)
    ]),
    // fade out when destroyed. this could also be written as transition('void => *')
    transition(':leave', animate(600, style({ opacity: 0 })))
]);

class PopInputComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = new InputConfig();
        this.name = 'PopInputComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                if (this.config.autofocus) {
                    this.inputField.nativeElement.focus();
                }
                else if (this.config.autoselect) {
                    this.inputField.nativeElement.focus();
                    this.inputField.nativeElement.select();
                }
                this.config.triggerOnChange = (value, forcePatch = false) => {
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        // this.cdr.detectChanges();
                        this.onChange(value, forcePatch);
                    }, 0);
                };
                this.config.triggerDirectPatch = (value) => {
                    this.dom.setTimeout(`config-trigger-patch`, () => {
                        this._onPatch(value, true);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.control.markAsPristine();
                        this.config.control.markAsUntouched();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                this.config.setType = (type) => {
                    this.dom.setTimeout(`config-set-type`, () => {
                        this.config.type = type;
                        // this.cdr.detectChanges();
                    }, 0);
                };
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onKeyUp(event) {
        if (event.code === 'Enter') {
            if (this.config.control.invalid) {
                if (this.config.displayErrors)
                    this._setMessage(ValidationErrorMessages(this.config.control.errors));
            }
            else {
                this._clearMessage();
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    if (this.config.control.value !== this.asset.storedValue) {
                        if (this._isFieldPatchable()) {
                            this.onChange();
                        }
                    }
                }
                if (this.config.tabOnEnter) {
                    this.dom.focusNextInput(this.el);
                }
                else {
                    this.onBubbleEvent('onEnter');
                }
                if (IsCallableFunction(this.config.onEnter)) {
                    this.dom.setTimeout(`on-enter`, () => __awaiter(this, void 0, void 0, function* () {
                        yield this.config.onEnter(this.core, event);
                    }), 250);
                }
            }
        }
        else if (!this.config.mask && this.config.pattern && this.config.pattern.length) {
            const val = PatternValidation(this.config.pattern, 'value', this.config.control.value);
            if (val !== this.config.control.value)
                this.config.control.setValue(val);
            if (this.config.control.touched && this._isChangeValid()) {
                this._clearMessage();
            }
            else if (IsArray(this.config.prevent, true)) {
                this._isChangeValid();
            }
            this.onBubbleEvent('onKeyUp');
        }
        else {
            if (this.config.control.touched && this._isChangeValid()) {
                this._clearMessage();
            }
            else if (IsArray(this.config.prevent, true)) {
                this._isChangeValid();
            }
            this.onBubbleEvent('onKeyUp');
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-input',
                template: "<div class=\"import-field-item-container pop-input-container\" [ngClass]=\"{'sw-hidden': config.hidden, 'pop-input-minimal': config.minimal, 'pop-input-hint': config.hint, 'pop-input-default': !config.hint && !config.minimal, 'pop-input-readonly': config.readonly, 'pop-input-select': config.selectMode}\">\n  <mat-form-field appearance=\"outline\" color=\"accent\" class=\"import-field-item-container-expansion\" [title]=\"config?.tooltip\">\n    <mat-label *ngIf=\"config?.label\">{{config?.label}} <span *ngIf=\"config?.required\" >*</span>   </mat-label>\n    <input\n      matInput\n      [ngClass]=\"{'sw-dot-font': config.conceal, 'sw-pointer': (config.selectMode && config?.control?.status !== 'DISABLED'), 'pop-input-select': (config.selectMode && config?.control?.status !== 'DISABLED')}\"\n      matTooltipClass=\"pop-input-tooltip-background\"\n      [hidden]=config.hidden\n      [maxlength]=config.maxlength\n      [readonly]=config.readonly\n      [type]=config.type\n      [formControl]=config.control\n      (keyup)=\"onKeyUp($event);\"\n      (blur)=\"dom.state.hint=false; onBlur();\"\n      (focus)=\"dom.state.hint= true; onFocus();\"\n      [prefix]=config.prefix\n      [suffix]=config.suffix\n      [mask]=config.mask\n      [specialCharacters]=config.specialChars\n      [dropSpecialCharacters]=config.dropSpecial\n      [showMaskTyped]=config.showMask\n      #inputField\n    >\n    <div class=\"pop-input-select-icon\" [ngClass]=\"{'sw-pointer': config?.control?.status !== 'DISABLED'}\"  *ngIf=\"config.selectMode\">\n      <mat-icon>arrow_drop_{{config?.selectModeOptionsDirection}}</mat-icon>\n<!--      <mat-icon>arrow_drop_up</mat-icon>-->\n    </div>\n    <mat-hint class=\"pop-input-btm-rgt-hint\" *ngIf=\"config.hint && dom.state.hint\" align=\"end\">{{config.control.value?.length || 0}}/{{config.maxlength}}</mat-hint>\n\n    <div class=\"pop-input-feedback-container\" matSuffix *ngIf=\"!config.minimal\" >\n      <lib-pop-field-item-error class=\"pop-input-error\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n      <lib-pop-field-item-helper class=\"pop-input-helper\" [hidden]=\"config.message && !config.selectMode\" [helpText]=config.helpText></lib-pop-field-item-helper>\n    </div>\n    <mat-hint class=\"pop-input-btm-lft-hint\" [ngClass]=\"{'hint-disabled': config.control.status === 'DISABLED'}\"  *ngIf=\"config.hint && config.hintText\">{{config.hintText}}</mat-hint>\n    <mat-hint class=\"pop-input-btm-lft-hint\"  *ngIf=\"config.hint && config.required && !config.hintText\">*Required</mat-hint>\n    <mat-error class=\"pop-input-btm-lft-error\" *ngIf=\"config.hint && config.message\">\n      {{config.message}}\n    </mat-error>\n  </mat-form-field>\n\n\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                animations: [
                    slideInOut
                ],
                styles: [".pop-input-feedback-container{position:relative;display:flex;justify-content:center;align-items:center;top:2px;width:20px;height:20px}.pop-input-select-icon{position:absolute;right:-2px;top:0;z-index:2;color:var(--text-disabled)}.pop-input-error{top:2px;z-index:2}.pop-input-error,.pop-input-helper{position:absolute;font-size:.8em;left:2px}.pop-input-helper{top:3px;z-index:1}.pop-input-btm-lft-error,.pop-input-btm-lft-hint{position:relative;color:var(--foreground-disabled);font-size:12px;right:5px;padding-left:var(--gap-s)}.pop-input-btm-rgt-hint{color:var(--foreground-disabled);font-size:12px}.pop-input-btm-lft-error{color:var(--warn)}.pop-input-container-minimal .mat-form-field-appearance-outline .mat-form-field-wrapper,:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{margin-top:5px!important}:host ::ng-deep .mat-form-field-infix{width:0!important}:host ::ng-deep .mat-form-field-flex{margin-top:0!important}:host ::ng-deep .pop-input-default .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 0 13px}:host ::ng-deep .pop-input-minimal .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 0 13px}:host ::ng-deep .pop-input-hint .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 0 30px!important}:host ::ng-deep .pop-input-minimal .mat-form-field-infix{padding-right:2px!important}:host ::ng-deep .pop-input-select .pop-input-helper{left:-46px}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-outline{max-height:40px;background-color:var(--background-base)}:host ::ng-deep .mat-form-field-label-wrapper{overflow:visible}:host ::ng-deep .pop-input-readonly input:not(.pop-input-select){color:var(--text-disabled)}"]
            },] }
];
PopInputComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopInputComponent.propDecorators = {
    config: [{ type: Input }],
    inputField: [{ type: ViewChild, args: ['inputField', { static: true },] }]
};

class PopSelectComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = new SelectConfig();
        this.name = 'PopSelectComponent';
        this.optionsTopPos = '-5px';
        this.ui = { selected: { config: undefined } };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([
                    this._setInitialConfig(),
                    this._setConfigHooks(),
                    this._initialFauxControl()
                ]);
                resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setTimeout('check-existing-value', () => {
                    if (!this.config.control.value && this.config.autoFill && this.config.required) {
                        if (this.config.options.values.length === 1) {
                            if (IsCallableFunction(this.config.triggerOnChange)) {
                                const existingValue = this.config.options.values[0].value;
                                this.config.triggerOnChange(existingValue);
                            }
                        }
                    }
                }, 0);
                resolve(true);
            });
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * SelectsOption
     * @param optionValue: option value selected
     */
    onOptionSelected(optionValue) {
        this.config.control.setValue(optionValue);
        this.dom.state.displayItems = false;
        this.ui.selected.config.label = this.config.label;
        this.onBlur();
    }
    /**
     *  Select Box clicked
     *  @returns void
     */
    onSelectionClick($event) {
        if (!this.config.readonly && this.config.control.status !== 'DISABLED') {
            // determine display direction and top offset
            const thirdHeight = window.innerHeight / 3;
            if ($event.clientY < (thirdHeight * 2)) {
                this.dom.state.displayBottom = true;
                this.optionsTopPos = '-5px';
                this.ui.selected.config.selectModeOptionsDirection = 'down';
            }
            else {
                this.dom.state.displayBottom = false;
                let offset = (44 + (this.config.options.values.length * 48));
                offset = offset > 284 ? 284 : offset;
                this.optionsTopPos = `-${offset}px`;
                this.ui.selected.config.label = ' ';
                this.ui.selected.config.selectModeOptionsDirection = 'up';
            }
            if (this.dom.state.displayItems) {
                this.dom.state.displayItems = false;
                this.ui.selected.config.label = this.config.label;
                this.onBlur();
            }
            else {
                this.dom.state.displayItems = true;
                this.onFocus();
            }
        }
    }
    /**
     * Closes the dropdown if it is active.
     * This method is called from the ClickOutside directive.
     * If the user clicks outside of the component, it will close
     * @returns void
     */
    onOutsideCLick() {
        this.dom.state.displayItems = false;
        this.ui.selected.config.label = this.config.label;
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config for this component
     * @private
     */
    _setInitialConfig() {
        return new Promise((resolve) => {
            this.dom.state.displayItems = false;
            this.dom.state.displayBottom = true;
            this.config = IsObjectThrowError(this.config, true, `Config required`) ? this.config : null;
            this.id = this.config.name;
            return resolve(true);
        });
    }
    /**
     * Set the config hooks for this component
     * @private
     */
    _setConfigHooks() {
        return new Promise((resolve) => {
            this.config.triggerOnChange = (value) => {
                this.dom.setTimeout(`config-trigger-change`, () => {
                    // this.cdr.detectChanges();
                    this._setStrVal(value);
                    this.onChange(value, true);
                }, 0);
            };
            this.config.clearMessage = () => {
                this.dom.setTimeout(`config-clear-message`, () => {
                    this.config.message = '';
                    this.config.control.markAsPristine();
                    this.config.control.markAsUntouched();
                    // this.cdr.detectChanges();
                }, 0);
            };
            return resolve(true);
        });
    }
    /**
     * Initialize Faux control ( used to display string value of select ). Subscribes to actual control value changes to update value.
     */
    _initialFauxControl() {
        return new Promise((resolve) => {
            this.ui.selected.config = new InputConfig({
                value: '',
                disabled: this.config.disabled ? this.config.disabled : null,
                helpText: this.config.helpText,
                displayErrors: false,
                label: this.config.label,
                readonly: true,
                selectMode: true,
                minimal: this.config.minimal,
                maxlength: 65000
            });
            this._setStrVal(this.config.value);
            this.dom.setSubscriber(`value-changes`, this.config.control.valueChanges.subscribe((value) => {
                this._setStrVal(value);
            }));
            this.dom.setSubscriber(`status-changes`, this.config.control.statusChanges.subscribe((status) => {
                this.ui.selected.config.control.status = status;
            }));
            return resolve(true);
        });
    }
    _setStrVal(value) {
        if (value || value == '') { // code change by chetu developer on 16-05-2021
            const selected = this.config.options.values.find((o) => o.value === value);
            if (IsObject(selected, ['name'])) {
                this.ui.selected.config.control.setValue(selected.name);
            }
            else {
                this.ui.selected.config.control.setValue('');
            }
        }
        else {
            this.ui.selected.config.control.setValue(null);
        }
    }
}
PopSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select',
                template: "<div class=\"import-field-item-container pop-select-container pop-select-mode-{{this.config.mode}} \"\n  [ngClass]=\"{'pop-select-container-minimal': this.config.minimal, 'pop-select-readonly': this.config.readonly, 'pop-select-opened-top': (dom.state.displayItems && !dom.state.displayBottom), 'pop-select-opened-bottom': (dom.state.displayItems && dom.state.displayBottom)}\"\n  (libClickOutside)=\"onOutsideCLick();\"\n>\n\n  <lib-pop-input\n    (click)=\"onSelectionClick($event)\"\n    class=\"pop-select-faux\"\n    *ngIf=\"ui?.selected?.config\"\n    [config]=ui?.selected?.config\n    >\n  </lib-pop-input>\n\n<!--  <mat-form-field appearance=\"outline\" class=\"pop-select-container-expansion\" [title]=\"config?.tooltip\" (click)=\"selectClick()\">-->\n<!--    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>-->\n<!--&lt;!&ndash;    <div *ngIf=\"config.tooltip && config.showTooltip\" class=\"pop-select-tooltip-msg\" [innerHTML]=config.tooltip></div>&ndash;&gt;-->\n<!--    <mat-select anelClass=\"item-box\"-->\n<!--      [formControl]=\"config?.control\"-->\n<!--      (openedChange)=\"onOpenChange($event);\">-->\n<!--&lt;!&ndash;      <div class=\"item-box\"><mat-option class=\"items\"  *ngFor=\"let option of config.options.values\" [value]=\"option.value\">{{option.name}}</mat-option></div>&ndash;&gt;-->\n<!--    </mat-select>-->\n\n<!--    <div class=\"pop-select-feedback\" matSuffix *ngIf=\"!config.minimal\">-->\n<!--      <lib-pop-field-item-error class=\"pop-select-error\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>-->\n<!--    </div>-->\n<!--    <lib-pop-field-item-helper class=\"pop-select-helper\" [helpText]=config.helpText></lib-pop-field-item-helper>-->\n<!--  </mat-form-field>-->\n  <!--<a *ngIf=\"config.route && config.control.value\" class=\"sw-pop-icon pop-select-goto-icon sw-pointer\" (click)=\"link(); $event.stopPropagation();\">M</a>-->\n\n  <lib-pop-field-item-loader [show]=\"config?.patch.displayIndicator && config?.patch.running\"></lib-pop-field-item-loader>\n  <div [style.maxHeight.px]=\"config.height\" [ngClass]=\"{'pop-select-items-box-bottom' : dom.state.displayBottom, 'pop-select-items-box-top': !dom.state.displayBottom}\" *ngIf=\"dom.state.displayItems\" [style.top]=\"optionsTopPos\">\n    <div class=\"pop-select-items\" *ngFor=\"let option of config?.options.values\" (click)=\"onOptionSelected(option.value)\"\n         [ngClass]=\"{'pop-select-level-1': option.level === 1, 'pop-select-level-2': option.level === 2}\">{{option.name}}</div>\n  </div>\n</div>\n\n",
                styles: [".pop-select-opened-top{box-shadow:-1px -4px 5px 0 rgba(0,0,0,.14),0 -5px 0 0 rgba(0,0,0,.12),1px -1px 4px -1px rgba(0,0,0,.2)}.pop-select-opened-bottom{box-shadow:0 4px 5px 0 rgba(0,0,0,.14),0 1px 0 0 rgba(0,0,0,.12),0 2px 4px -1px rgba(0,0,0,.2)}.pop-select-container{position:relative;display:block;top:1px;height:45px}.pop-select-container-expansion{position:absolute!important;top:-1px;left:0;bottom:0;right:0;box-sizing:border-box!important;-moz-box-sizing:border-box}.pop-select-feedback{position:relative;display:flex;justify-content:center;align-items:center;top:0;width:12px;height:20px}.pop-select-helper{position:absolute;top:7px;right:30px;font-size:.8em}.pop-select-error{top:-1px;position:relative;font-size:.8em;left:4px}:host ::ng-deep .pop-input-readonly input:not(.pop-input-select){color:red}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}:host ::ng-deep .mat-form-field-appearance-outline .mat-select-value{padding-right:40px}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-infix .mat-select-arrow{margin-top:5px}:host ::ng-deep .pop-select-mode-label .mat-select-arrow{display:none!important}:host ::ng-deep .mat-form-field-infix{width:0!important}.pop-select-items-box-bottom{box-shadow:0 4px 5px 0 rgba(0,0,0,.14),0 1px 0 0 rgba(0,0,0,.12),0 2px 4px -1px rgba(0,0,0,.2)}.pop-select-items-box-bottom,.pop-select-items-box-top{display:flex;flex-direction:column;position:relative;min-height:var(--field-min-height);max-width:var(--field-max-width);border:1px solid var(--background-border);z-index:1000;background-color:var(--background-base);overflow-y:scroll}.pop-select-items-box-top{box-shadow:-1px -4px 5px 0 rgba(0,0,0,.14),1px 1px 0 0 rgba(0,0,0,.12),1px -1px 4px -1px rgba(0,0,0,.2)}.pop-select-items{padding:var(--gap-sm);background-color:var(--background-base);cursor:pointer}.pop-select-level-1{padding-left:var(--gap-lm)}.pop-select-level-2{padding-left:var(--gap-xl)}.pop-select-items:hover{background-color:var(--background-main-menu)}"]
            },] }
];
PopSelectComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopSelectComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopSelectMultiComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopSelectMultiComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.triggerOnChange = (value) => {
                    // this.cdr.detectChanges();
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        this.onChange(value, true);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.message = '';
                        this.config.control.markAsPristine();
                        this.config.control.markAsUntouched();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * On Blur Event
     */
    onBlur() {
        this.onBubbleEvent('onBlur');
    }
    onClose(open) {
        if (!open) {
            this.onChange();
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopSelectMultiComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select-multi',
                template: "<div class=\"import-field-item-container pop-select-multi-container\">\n  <mat-form-field appearance=\"outline\" class=\"expand-to-container\" [title]=\"config?.tooltip\">\n    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>\n<!--    <div *ngIf=\"config.tooltip && config.showTooltip\" class=\"field-tooltip-msg\" [innerHTML]=config.tooltip></div>-->\n    <mat-select\n      multiple\n      [formControl]=\"config.control\"\n      (blur)=\"config.showTooltip=false; onBlur()\"\n      (focus)=\"config.showTooltip=true; onFocus()\"\n      (change)=\"onChange()\"\n      (openedChange)=\"onClose($event);\">\n      <mat-option *ngFor=\"let option of config.options.values\" [value]=\"option.value\">{{option.name}}</mat-option>\n    </mat-select>\n    <div class=\"pop-select-multi-feedback\" matSuffix *ngIf=\"!config.minimal\">\n      <lib-pop-field-item-error class=\"pop-select-multi-error\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n    </div>\n    <lib-pop-field-item-helper class=\"pop-select-multi-helper\" [helpText]=config.helpText></lib-pop-field-item-helper>\n    <!--<div [ngClass]=\"{'sw-hidden':!this.config.control.value.length}\" class=\"pop-select-multi-count\">{{this.config.control.value.length}}</div>-->\n    <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n\n  </mat-form-field>\n</div>\n",
                styles: [".pop-select-multi-container{position:relative;display:block;padding:0}.pop-select-multi-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.pop-select-multi-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-infix .mat-select-arrow{margin-top:5px}.pop-select-multi-container ::ng-deep .mat-select-arrow-wrapper{position:relative;top:2px}.expand-to-container{position:relative;width:100%;height:100%}.pop-select-multi-feedback{position:relative;display:flex;justify-content:center;align-items:center;top:0;width:12px;height:20px}.pop-select-multi-count{position:absolute;bottom:1px;right:-7px;font-size:.7em;text-align:right;color:var(--text)}.pop-select-multi-helper{position:absolute;top:8px;right:30px;font-size:.8em}.pop-select-multi-error{top:1px;position:relative;font-size:.8em;left:4px}:host ::ng-deep .mat-form-field-appearance-outline .mat-select-value{padding-right:40px}"]
            },] }
];
PopSelectMultiComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopSelectMultiComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopCheckboxComponent extends PopFieldItemComponent {
    constructor(el, renderer, cdr) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.cdr = cdr;
        this.name = 'PopCheckboxComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.state.indeterminate = false;
                this.asset.storedValue = +this.config.control.value === 1 ? true : false;
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This will position the feedback container in the right spot
     */
    ngAfterViewInit() {
        this.asset.checkBoxBackground = this.el.nativeElement.querySelector('.mat-checkbox-background');
        this.asset.checkBoxFrame = this.el.nativeElement.querySelector('.mat-checkbox-frame');
        this.cdr.detectChanges();
    }
    onEnter(event) {
        if (this.config.tabOnEnter) {
            this.dom.focusNextInput(this.el);
        }
    }
    _beforePatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.disable();
            patch.running = true;
            this._onHideCheckbox();
            this._clearMessage();
            return resolve(true);
        });
    }
    _afterPatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.enable();
            control.markAsPristine();
            patch.running = false;
            return resolve(true);
        });
    }
    _onPatchSuccessAdditional() {
        this._displayCheckbox();
        return true;
    }
    _onPatchFailAdditional() {
        this._displayCheckbox();
        return true;
    }
    /**
     * This will trigger when the user click the checkbox to subject its value
     * This updates the config value since that is auto-handled with this input type
     */
    onToggleValue() {
        const value = !this.asset.storedValue;
        this.config.control.setValue(value, { emitEvent: true });
        this.onChange(value);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will make the checkbox hidden in the view
     */
    _onHideCheckbox() {
        this.renderer.setStyle(this.asset.checkBoxFrame, 'border-color', '');
        this.renderer.setStyle(this.asset.checkBoxBackground, 'background-color', '');
        this.renderer.setStyle(this.asset.checkBoxBackground, 'border', '');
        this.renderer.setStyle(this.asset.checkBoxBackground, 'display', 'none');
    }
    /**
     * This will make the checkbox visible in the view
     */
    _displayCheckbox() {
        this.renderer.setStyle(this.asset.checkBoxBackground, 'display', 'block');
    }
}
PopCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-checkbox',
                template: "<div class=\"pop-checkbox-container pop-checkbox-label-{{config.labelPosition}} pop-checkbox-{{config.textOverflow}}-text position-{{this.config.align}} import-field-item-container\" [ngClass]=\"{'pop-checkbox-has-label':config.label, 'pop-checkbox-no-label': !config.label, 'pop-checkbox-reverse':config.label && config.labelPosition === 'before'}\">\n  <mat-checkbox\n    [formControl]=config.control\n    [ngClass]=\"{'pop-checkbox-no-pointer': config.patch.running}\"\n    [(indeterminate)]=\"dom.state.indeterminate\"\n    [labelPosition]=\"config.labelPosition\"\n    (click)=\"$event.stopPropagation();\"\n    (change)=\"onChange();\"\n    (keyup.enter)=\"onEnter($event)\"\n  >\n  </mat-checkbox>\n\n  <!--<div class=\"pop-checkbox-spacer\" *ngIf=\"config.label\"></div>-->\n  <div class=\"pop-checkbox-filler\" *ngIf=\"config.label\"></div>\n  <div class=\"pop-checkbox-column\">\n    <lib-pop-field-item-error class=\"pop-checkbox-error\" [hidden]=\"!config.message || !config.label\" [message]=\"config.message\"></lib-pop-field-item-error>\n    <lib-pop-field-item-helper class=\"pop-checkbox-helper\" [hidden]=\"config.message || !config.label\" [helpText]=config.helpText></lib-pop-field-item-helper>\n  </div>\n  <div *ngIf=\"config.label\" class=\"pop-checkbox-label\">\n    <h4>{{config.label}}</h4>\n  </div>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n\n\n\n",
                styles: [":host{width:100%}.pop-checkbox-container{position:relative;display:flex;flex-direction:row;flex:1;box-sizing:border-box;-moz-box-sizing:border-box;justify-content:flex-start;align-items:center;min-height:40px}.pop-checkbox-reverse{flex-direction:row-reverse!important}.pop-checkbox-sub-container{display:flex;flex-grow:1;max-width:calc(var(--field-max-width) - 40px)}.pop-checkbox-filler{flex:1;flex-grow:1;min-width:10px;min-height:35px}.pop-checkbox-spacer{width:10px;box-sizing:border-box}.pop-checkbox-row{display:flex;padding-top:2px;flex-grow:1;margin-bottom:var(--gap-xxs);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.pop-checkbox-column{display:flex;flex-direction:column;align-items:center;justify-content:center;max-width:30px;min-width:30px}:host ::ng-deep .pop-checkbox-has-label .pop-checkbox-row{margin-top:var(--gap-xs)}:host ::ng-deep .pop-checkbox-has-label .mat-checkbox-layout{flex-grow:1!important}:host ::ng-deep .pop-checkbox-has-label .mat-checkbox-label{flex-grow:1!important}.pop-checkbox-no-label{margin-left:0!important;margin-right:0!important;padding-left:0!important;padding-right:0!important}:host ::ng-deep .pop-checkbox-no-label .mat-checkbox-inner-container{margin-left:0}:host ::ng-deep .pop-checkbox-no-label.position-left mat-checkbox{float:left}:host ::ng-deep .pop-checkbox-no-label.position-center mat-checkbox{margin:auto}:host ::ng-deep .pop-checkbox-no-label.position-right mat-checkbox{float:right}:host ::ng-deep .pop-checkbox-hover:hover{background:var(--accent-shade)!important}:host ::ng-deep .pop-checkbox-has-label.pop-checkbox-label-before .pop-checkbox-label{padding-right:var(--gap-xs)}:host ::ng-deep .pop-checkbox-has-label.pop-checkbox-label-after .pop-checkbox-label{padding-left:var(--gap-xs);padding-right:var(--gap-xs)}:host ::ng-deep .pop-checkbox-has-label.pop-checkbox-ellipsis-text .pop-checkbox-label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}:host ::ng-deep .pop-checkbox-has-label.pop-checkbox-ellipsis-text .pop-checkbox-label>h4{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;min-width:0}:host ::ng-deep .pop-checkbox-has-label.pop-checkbox-wrap-text .pop-checkbox-label>h4{overflow-wrap:break-spaces!important;word-wrap:break-spaces!important;white-space:normal!important}.pop-checkbox-helper{position:relative;top:3px;left:0;font-size:.7em}.pop-checkbox-error{position:relative;top:2px;left:2px;z-index:2}:host ::ng-deep .pop-checkbox-error .mat-icon{font-size:.9em}.pop-checkbox-no-label-adjust{margin-top:1px}.pop-checkbox-no-pointer{pointer-events:none}:host ::ng-deep h4{margin:0;flex:1}"]
            },] }
];
PopCheckboxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
PopCheckboxComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopRadioComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopRadioComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.asset.storedValue = this.config.control.value;
                this.asset.spinnerRef = this.el.nativeElement.querySelector('.radio-ajax-spinner'); // would use a @viewChild but it returns a component model instead of an element.. weird
                this.config.triggerOnChange = (value) => {
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        this.onChange(value, true);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.control.markAsPristine();
                        this.config.control.markAsUntouched();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onSelection(change) {
        this.asset.change = change;
        this.onChange();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-radio',
                template: "<div class=\"import-field-item-container pop-radio-container {{ config.labelPosition === 'inline' ? 'pop-radio-container-row' : 'pop-radio-container-column'}}\">\n  <div class=\"pop-radio-label-layout\">\n    <div>\n      {{config.label}}\n      <span\n        *ngIf=\"config.helpText\"\n        class=\"pop-radio-helper-icon sw-pointer sw-pop-icon\"\n        (mouseenter)=\"dom.state.helper = true\"\n        (mouseleave)=\"dom.state.helper = false\"\n        matTooltip=\"{{config.helpText}}\"\n        matTooltipPosition=\"right\">X\n      </span>\n    </div>\n    <mat-icon\n      *ngIf=\"config.message\"\n      class=\"pop-radio-error-icon\"\n      matTooltipPosition=\"right\"\n      [matTooltip]=config.message\n      [color]=\"'warn'\">info\n    </mat-icon>\n  </div>\n  <div class=\"{{ config.labelPosition === 'inline' ? 'pop-radio-inline' : '' }}\">\n    <mat-radio-group\n      [formControl]=\"config.control\"\n      [ngClass]=\"{'pop-radio-column-layout': config.layout === 'column', 'pop-radio-row-layout': config.layout === 'row'}\"\n      (change)=\"onSelection($event);\"\n      disableRipple>\n      <mat-radio-button class=\"pop-radio-option\" *ngFor=\"let option of config.options.values\" disableRipple [value]=\"option.value\">\n        <span>{{option.name}}</span>\n      </mat-radio-button>\n    </mat-radio-group>\n  </div>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n\n\n",
                styles: [".pop-radio-container-row{display:flex;justify-content:space-between}.pop-radio-container-column{display:flex;flex-direction:column}.pop-radio-inline{display:flex;justify-content:flex-end}.pop-radio-label-layout{display:inline-flex}.pop-radio-row-layout{display:inline-flex;flex-direction:row;align-items:center;justify-content:space-around;overflow-x:auto;overflow-y:hidden;width:100%;box-sizing:border-box}.pop-radio-helper-icon{font-size:.6em}.radio-error-icon{margin-left:5px;padding-top:6px;font-size:16px}.pop-radio-column-layout{display:inline-flex;flex-direction:column}.pop-radio-option{margin:5px;display:flex}.radio-ajax-spinner{position:absolute;cursor:pointer}.pop-radio-error-icon{position:relative;bottom:-2px;left:5px;font-size:16px;cursor:pointer}"]
            },] }
];
PopRadioComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopRadioComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopSwitchComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.events = new EventEmitter();
        this.name = 'PopSwitchComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.switchRef.checked = !!this.config.control.value;
                this.config.switchRef = this.switchRef;
                this.asset.storedValue = this.config.control.value;
                this.config.triggerOnChange = (value) => {
                    this.dom.setTimeout(`trigger-change`, () => {
                        this.onSelection({ checked: value });
                    }, 0);
                };
                this.config.setValue = (value) => {
                    this.dom.setTimeout(`set-value`, () => {
                        this.asset.change = value;
                        this.config.control.setValue(value, { emitEvent: false });
                        this.config.control.updateValueAndValidity();
                        this.config.control.markAsPristine();
                        this.switchRef.checked = value;
                    }, 0);
                };
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onEnter(event) {
        if (this.config.tabOnEnter) {
            this.dom.focusNextInput(this.el);
        }
    }
    onSelection(change) {
        this.asset.change = change;
        this.onChange(change.checked);
    }
    /************************************************************************************************
     *                                                                                              *
     *                                    Base Class Overrides                                      *
     *                                    ( Protected Method )                                      *
     *               These are protected instead of private so that they can be overridden          *
     *                                                                                              *
     ************************************************************************************************/
    _beforePatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.disable();
            patch.running = true;
            return resolve(true);
        });
    }
    /**
     * Called after a successful patch
     */
    _afterPatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            control.enable();
            patch.running = false;
            this.switchRef.checked = this.asset.storedValue;
            return resolve(true);
        });
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-switch',
                template: "<div class=\"pop-switch-container import-field-item-container\" [title]=\"config?.tooltip ?  config?.tooltip : '' \" [style.padding]=config.padding [ngClass]=\"{ 'pop-switch-has-label':config.label, 'pop-switch-no-label': !config.label, 'pop-switch-label-before': config.label && config.labelPosition === 'before', 'pop-switch-label-after': config.label && config.labelPosition === 'after', 'pop-switch-wrap-text': config.label && config.textOverflow === 'wrap', 'pop-switch-wrap-ellipsis': config.label && config.textOverflow === 'ellipsis'}\">\n  <mat-slide-toggle\n    #switch\n    [ngClass]=\"{'pop-switch-no-pointer': config.patch.running}\"\n    [labelPosition]=\"config.labelPosition\"\n    [disableRipple]=1\n    [disabled]=config?.disabled\n    [name]=\"config.label\"\n    (keyup.enter)=\"onEnter($event)\"\n    (change)=\"onSelection($event)\">\n\n\n    <div class=\"mat-body\">\n      <div class=\"pop-switch-feedback-container\" *ngIf=\"config.label\">\n        <lib-pop-field-item-error class=\"pop-switch-error\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n        <lib-pop-field-item-helper class=\"pop-switch-helper\" [hidden]=\"config.message\" [helpText]=config.helpText></lib-pop-field-item-helper>\n      </div>\n      <h4>{{config.label}}</h4>\n    </div>\n\n  </mat-slide-toggle>\n\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [":host{width:100%}.pop-switch-container{position:relative;display:flex;flex-direction:row;width:100%;min-height:40px;align-items:center;box-sizing:border-box}.pop-switch-has-label{justify-content:flex-start}.pop-switch-no-label{justify-content:center}.pop-switch-label{padding:5px 2px}.pop-switch-spacer{position:relative;display:flex;min-width:10px;box-sizing:border-box;background:pink}:host ::ng-deep .pop-switch-has-label .mat-slide-toggle{flex:1}:host ::ng-deep .pop-switch-label-before .mat-slide-toggle-content{display:flex;flex-grow:1;margin-right:5px;width:100%}.pop-switch-feedback-container{position:relative;display:flex;flex-direction:column;justify-content:center;align-items:center;min-width:25px;min-height:35px}:host ::ng-deep .pop-switch-label-before .mat-body{flex-direction:row-reverse!important}:host ::ng-deep .pop-switch-label-after .mat-slide-toggle-bar{margin-right:5px}:host ::ng-deep .pop-switch-label-after .mat-body h4{padding-left:var(--gap-xs)}:host ::ng-deep .pop-switch-has-label .mat-body{display:flex;flex-grow:1;box-sizing:border-box;min-width:0;align-items:center}:host ::ng-deep .pop-switch-wrap-text .mat-body h4{overflow-wrap:break-spaces!important;word-wrap:break-spaces!important;white-space:normal!important}:host ::ng-deep .pop-switch-wrap-ellipsis .mat-body h4{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}:host ::ng-deep .pop-switch-has-label.pop-switch-wrap-text .mat-slide-toggle{min-height:24px!important;height:auto!important}.pop-switch-ajax-spinner{position:absolute;cursor:pointer;z-index:1}.pop-switch-hover:hover{background:var(--accent-shade)!important}.pop-switch-no-pointer{pointer-events:none}:host ::ng-deep h4{margin:0;flex:1}.pop-switch-error{position:relative;top:2px;left:2px}:host ::ng-deep .pop-switch-error mat-icon{font-size:.98em}.pop-switch-helper{position:relative;top:2px;left:2px;font-size:.7em}"]
            },] }
];
PopSwitchComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopSwitchComponent.propDecorators = {
    switchRef: [{ type: ViewChild, args: ['switch', { static: true },] }],
    feedbackRef: [{ type: ViewChild, args: ['feedback', { static: true },] }],
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopTextareaComponent extends PopFieldItemComponent {
    constructor(el, renderer) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.name = 'PopTextareaComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                if (this.config.autoSize) {
                    this.dom.setSubscriber('auto-size', this.config.control.valueChanges.subscribe(() => {
                        this.onAutoSize();
                    }));
                }
                else {
                    if (+this.config.height) {
                        this.renderer.setStyle(this.textAreaRef.nativeElement, 'height', this.config.height + 'px');
                    }
                }
                resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (this.config.autoSize && this.config.control.value) {
                    yield Sleep(5);
                    this.onAutoSize();
                }
                resolve(true);
            }));
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Trigger on key up event
     */
    onKeyUp() {
        this.onBubbleEvent(`onKeyUp`);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    onAutoSize() {
        this.dom.setTimeout('size-delay', () => {
            this.renderer.setStyle(this.textAreaRef.nativeElement, 'height', '0');
            let height = this.textAreaRef.nativeElement.scrollHeight;
            if (+this.config.height && height < this.config.height)
                height = this.config.height;
            if (+this.config.maxHeight && height > this.config.maxHeight)
                height = this.config.maxHeight;
            this.renderer.setStyle(this.textAreaRef.nativeElement, 'height', height + 'px');
        }, 250);
    }
}
PopTextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-textarea',
                template: "<!-- <div class=\"import-field-item-container pop-textarea-container\" [ngClass]=\"{'pop-textarea-container-tooltip-adjust': config.tooltip && dom.state.tooltip}\"> -->\n<div class=\"import-field-item-container pop-textarea-container\" >\n<div class=\"pop-textarea-feedback-container\">\n    <!--<lib-main-spinner-->\n      <!--[ngClass]=\"{'sw-hidden': !config.patch.running || !config.patch.displayIndicator, 'switch-no-pointer': config.patch.running}\"-->\n      <!--[options]=\"{strokeWidth:3, color:'accent', diameter:18}\">-->\n    <!--</lib-main-spinner>-->\n    <!--<mat-icon-->\n      <!--class=\"pop-textarea-error-icon\"-->\n      <!--[ngClass]=\"{'sw-hidden': !config.message || config.patch.running}\"-->\n      <!--[matTooltipPosition]=\"'left'\"-->\n      <!--[matTooltip]=config.message-->\n      <!--[color]=\"'warn'\">info-->\n    <!--</mat-icon>-->\n  <lib-pop-field-item-error class=\"pop-textarea-error-icon\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n    <!--<div-->\n      <!--*ngIf=\"config.helpText && !config.message && ( !config.patch || !config.patch.running )\"-->\n      <!--class=\"sw-pop-icon textarea-helper-icon\"-->\n      <!--(mouseenter)=\"dom.state.helper = true\"-->\n      <!--(mouseleave)=\"dom.state.helper = false\"-->\n      <!--matTooltip=\"{{config.helpText}}\"-->\n      <!--matTooltipPosition=\"left\">X-->\n    <!--</div>-->\n  <lib-pop-field-item-helper class=\"textarea-helper-icon\" [hidden]=\"config.message\" [helpText]=config.helpText></lib-pop-field-item-helper>\n  </div>\n<!--  <div *ngIf=\"config.tooltip && dom.state.tooltip\" class=\"pop-textarea-tooltip-container\" [innerHTML]=config.tooltip></div>-->\n  <mat-form-field appearance=\"outline\" class=\"import-field-item-container-expansion\" [title]=\"config?.tooltip\">\n    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>\n    <textarea\n      #textArea\n      matInput\n      [readonly]=config.readonly\n      [formControl]=config.control\n      [maxlength]=config.maxlength\n      spellcheck=\"false\"\n      (focus)=\"dom.state.tooltip=true; onFocus();\"\n      (keyup)=\"onKeyUp();\"\n      (blur)=\"dom.state.tooltip=false; onBlur();\">\n\n    </textarea>\n    <mat-hint *ngIf=\"config.hint\" align=\"end\">{{textArea.value?.length || 0}}/{{config.maxlength}}</mat-hint>\n  </mat-form-field>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n\n",
                styles: [".pop-textarea-feedback-container{position:absolute;right:2px;top:4px;width:20px;z-index:2}.pop-textarea-error-icon{position:relative;top:2px;right:-2px;cursor:pointer}:host ::ng-deep .pop-textarea-error-icon mat-icon{font-size:.98em!important}.textarea-helper-icon{position:relative;font-size:.7em;right:-2px;top:4px;cursor:pointer}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}:host ::ng-deep .mat-form-field-appearance-outline textarea{resize:none;min-height:40px}"]
            },] }
];
PopTextareaComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
PopTextareaComponent.propDecorators = {
    textAreaRef: [{ type: ViewChild, args: ['textArea', { static: true },] }],
    config: [{ type: Input }]
};

class PopLabelComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopLabelComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configure: - this.config`) ? this.config : null;
                this.ui.copyLabel = undefined;
                this.ui.copyValue = undefined;
                this.ui.valueButton = undefined;
                this.dom.state.valueButton_theme = 'default';
                if (this.config.truncate) {
                    const truncatePipe = new TruncatePipe();
                    this.config.value = truncatePipe.transform(this.config.value, [this.config.truncate]);
                }
                if (this.config.copyLabel)
                    this.ui.copyLabel = new ButtonConfig({
                        // disabled: !this.config.copyLabelBody ? true : false,
                        disabled: false,
                        icon: this.config.copyLabelBody ? 'file_copy' : null,
                        value: this.config.copyLabelDisplay,
                        size: 25,
                        width: 100,
                        radius: 5,
                        text: 12,
                    });
                if (this.config.copyValue)
                    this.ui.copyValue = new ButtonConfig({
                        // disabled: !this.config.copyValueBody ? true : false,
                        disabled: false,
                        icon: this.config.copyValueBody ? 'file_copy' : null,
                        value: this.config.copyValueDisplay,
                        size: 25,
                        radius: 5,
                        text: 12,
                    });
                if (this.config.valueButton)
                    this.ui.valueButton = new ButtonConfig({
                        disabled: this.config.valueButtonDisabled ? true : false,
                        icon: this.config.icon,
                        value: this.config.valueButtonDisplay,
                        size: 25,
                        radius: 5,
                        text: 12,
                        bubble: true,
                        event: 'click'
                    });
                this._setValueButtonTheme();
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The user can click on a link to route to another part of the app
     */
    onRouteLink() {
        if (this.config.route) {
            const routeApp = String(this.config.route).split('/');
            if (routeApp[1] && routeApp[1] === PopHref) {
                return ServiceInjector.get(Router).navigate([routeApp.slice(2).join('/')]).catch((e) => {
                    console.log(e);
                    return false;
                });
            }
        }
        return this.onBubbleEvent('link');
    }
    /**
     * The user can click on a label button to copy a value into the clipboard
     */
    onLabelCopy() {
        const nav = navigator;
        const strip = ['ID '];
        let body = String(this.config.copyLabelBody).slice();
        strip.map((tag) => {
            if (body.includes(tag))
                body = StringReplaceAll(body, tag, '');
        });
        nav.clipboard.writeText(body);
    }
    /**
     * The user can click on a button value and copy a value to the clipboard
     */
    onValueCopy() {
        const nav = navigator;
        const strip = ['ID '];
        let body = String(this.config.copyValueBody).slice();
        strip.map((tag) => {
            if (body.includes(tag))
                body = StringReplaceAll(body, tag, '');
        });
        nav.clipboard.writeText(body);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx basically checks the label value to sees if it can be associated with a color scheme aka warning, success, error
     */
    _setValueButtonTheme() {
        if (this.config.valueButton) {
            if (this.config.valueButtonDisplay) {
                this.dom.state.valueButton_theme = GetVerbStateTheme(this.config.valueButtonDisplay);
            }
        }
    }
}
PopLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-label',
                template: "<div class=\"import-field-item-container pop-label-container\" [ngClass]=\"{'pop-label-container-border': config.border, 'pop-label-ellipsis': config.textOverflow === 'ellipsis'}\" *ngIf=\"dom.state.loaded\">\n  <div class=\"import-flex-column-xs import-flex-grow-xs\">\n    <div class=\"pop-label-text import-flex-row import-flex-start-center\">\n      <div class=\"pop-label-button-copy\" *ngIf=\"config.copyLabel\">\n        <lib-pop-button\n          (click)=\"onLabelCopy()\"\n          [config]=\"ui['copyLabel']\"\n        ></lib-pop-button>\n      </div>\n      <label *ngIf=\"!config.copyLabel\">{{config.label}}<lib-pop-field-item-helper class=\"pop-label-helper-icon\" [hidden]=\"!config.helpText\" [helpText]=config.helpText></lib-pop-field-item-helper></label>\n    </div>\n  </div>\n  <div class=\"import-flex-column-md import-flex-grow-md\" [ngSwitch]=\"config.html\">\n    <div *ngSwitchCase=\"'label'\">\n      <div *ngIf=\"config.copyValue\">\n        <lib-pop-button\n          class=\"pop-label-button-copy\"\n          (click)=\"onValueCopy()\"\n          [config]=\"ui['copyValue']\"\n        ></lib-pop-button>\n      </div>\n      <div *ngIf=\"!config.copyValue\">\n        <div *ngIf=\"config.valueButton\" class=\"pop-label-button-theme-{{dom.state.valueButton_theme}} sw-mar-rgt-sm\">\n          <lib-pop-button class=\"pop-label-button-value\" [config]=\"ui.valueButton\"></lib-pop-button>\n        </div>\n        <div *ngIf=\"!config.valueButton\" class=\"import-flex-row import-flex-end-center\">\n          <span *ngIf=\"!config.icon\" class=\"pop-label-value-text\"><h4>{{config.value}}</h4></span>\n          <div *ngIf=\"config.icon\" [ngSwitch]=\"config.iconType\" class=\"pop-label-icon-container\">\n            <mat-icon *ngSwitchCase=\"'mat'\">{{config.icon}}</mat-icon>\n            <span *ngSwitchCase=\"'sw'\" class=\"sw-pop-icon\">{{config.icon}}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n    <a class=\"sw-pointer import-flex-row import-flex-end-center\" *ngSwitchCase=\"'link'\" (click)=\"onRouteLink();\" matTooltip=\"{{config.tooltip}}\" matTooltipPosition=\"left\">\n      <div *ngIf=\"!config.icon\" class=\"pop-label-value-text\"><h4>{{config.value}}</h4></div>\n      <div *ngIf=\"config.icon\" [ngSwitch]=\"config.iconType\" class=\"pop-label-icon-container\">\n        <mat-icon *ngSwitchCase=\"'mat'\">{{config.icon}}</mat-icon>\n        <span *ngSwitchCase=\"'sw'\" class=\"sw-pop-icon\">{{config.icon}}</span>\n      </div>\n    </a>\n  </div>\n</div>\n",
                styles: [".pop-label-container{position:relative;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;-moz-box-sizing:border-box}.pop-label-container-border{border-radius:3px;border:1px solid var(--border);padding:10px}.pop-label-container-border:hover{border-color:currentColor}.pop-label-container-border:focus{border-color:var(--accent)}.pop-label-link-container{position:relative;display:flex;flex-grow:1;flex-direction:row;align-items:center;justify-content:flex-end}.pop-label-icon-container{position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center}.pop-label-helper-icon{position:relative;top:5px;font-size:.8em;z-index:2}.pop-label-text{flex:1 1 100%}.pop-label-value-text{flex:1;padding-left:var(--gap-s);box-sizing:border-box;min-width:0;text-align:right;flex-grow:1}.pop-label-value-text h4{margin:0}:host ::ng-deep .pop-label-ellipsis .pop-label-value-text h4{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.pop-label-button-copy,.pop-label-button-value{min-width:100px!important}:host ::ng-deep .pop-label-button-theme-default button{background:grey;color:#fff;box-shadow:none!important}:host ::ng-deep .pop-label-button-theme-success button{background:#35d18e!important;color:#fff!important;box-shadow:none!important;text-transform:none!important}:host ::ng-deep .pop-label-button-theme-danger button{background:#f8262e!important;color:#fff!important;box-shadow:none!important;text-transform:none!important}:host ::ng-deep .pop-label-button-theme-warn button{background:orange!important;color:#fff!important;box-shadow:none!important;text-transform:none!important}:host ::ng-deep .pop-label-button-theme-info button{background:#4e7fed!important;color:#000!important;text-transform:none!important}:host ::ng-deep .pop-label-icon-container mat-icon{margin-left:var(--gap-xs)!important}"]
            },] }
];
PopLabelComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopLabelComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopSelectFilterComponent extends PopFieldItemComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.name = 'PopSelectFilterComponent';
        this.asset = {
            filteredOptions: undefined,
            groups: [],
            onFocusValue: undefined
        };
        this.ui = {
            selected: {
                config: undefined,
                count: 0
            },
            search: {
                config: undefined,
                count: 0
            }
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configure: - this.config`) ? this.config : null;
                this._setInitialDomState();
                this._filterOptionsList('');
                this._setUpFilterObservable();
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    onEscapeHandler(event) {
        if (this.dom.state.filterActivated) {
            console.log('esc', event);
            this._closeOptionList();
        }
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Set the inital dom state of the component
     * @private
     */
    _setInitialDomState() {
        this.dom.state.filter = undefined;
        this.dom.state.filterActivated = false;
        this.dom.state.above = undefined;
        this.dom.state.below = undefined;
        this.dom.state.list = undefined;
        this.dom.state.position = 'below';
        this.dom.state.active = undefined;
        this.dom.state.checkboxPosition = this.config.checkboxPosition === 'before' ? 'before' : 'after';
        if (!this.config.multiple) {
            this.selectionListRef.selectedOptions = new SelectionModel(false);
        }
        this.ui.selected.config = new InputConfig({
            value: this.config.strVal,
            helpText: this.config.helpText,
            displayErrors: false,
            label: this.config.label,
            readonly: true,
            selectMode: true,
            maxlength: 65000
        });
        this.ui.search.config = new InputConfig({
            value: this.config.strVal,
            helpText: this.config.helpText,
            displayErrors: false,
            label: this.config.label,
            readonly: true,
            maxlength: 255
        });
        if (!this.config.multiple && +this.config.value) {
            const activeOption = IsObject(this.config.options, ['values']) ? this.config.options.values.find((option) => +option.value === +this.config.value) : null;
            if (IsObject(activeOption, ['value', 'name'])) {
                this.config.selectedOptions = [+activeOption.value];
                this.asset.onFocusValue = JSON.stringify(this.config.selectedOptions);
                this.dom.active.optionId = +activeOption.value;
                this.ui.selected.config.control.setValue(activeOption.name, { emitEvent: false });
            }
        }
        else {
            this.asset.onFocusValue = JSON.stringify(this.config.selectedOptions);
            this._updateSelectedOptions();
        }
        delete this.config.options;
    }
    /**************************************
     * Public methods invoked by the view
     * ************************************/
    /**
     * Turn the dropdown on or off. If it is turned off,
     * it will emit the close event
     * @returns void
     */
    onToggleFilter(event, list) {
        if (this.config.patch.running)
            return false;
        this.dom.state.filterActivated = !this.dom.state.filterActivated;
        if (this.dom.state.filterActivated) {
            if (this.config.float) {
                if (this.config.offsetSession) {
                    this.config.offset = this.config.offsetSession;
                }
                else if (this.config.height) {
                    this.config.offset = this.config.height;
                }
            }
            else {
                this.config.offset = null;
            }
        }
        else {
            this.config.offset = null;
        }
        this.dom.setTimeout('open-close', () => {
            if (!this.config.position)
                this._setOptionListPosition({ above: event.pageY - 280, below: window.innerHeight - event.pageY - 20, height: list.clientHeight });
            if (!this.dom.state.filterActivated) {
                this.onBubbleEvent('close');
            }
            else {
                this.asset.onFocusValue = JSON.stringify(this.config.selectedOptions);
                this.config.message = '';
                this.onBubbleEvent('open');
            }
            if (this.dom.state.filterActivated) {
                if (this.config.float) {
                    const offsetHeight = this.listRef.nativeElement.offsetHeight;
                    if (offsetHeight) {
                        this.config.offset = offsetHeight * (-1);
                        if (this.config.offset)
                            this.config.offsetSession = this.config.offset;
                    }
                }
            }
        }, 0);
        return true;
    }
    /**
     * The client user can toggle a specific grouping to be open/close
     * @param group
     */
    onToggleGroup(group) {
        if (this.config.groups.length > 1) {
            group.open = !group.open;
        }
    }
    /**
     * Closes the dropdown if it is active.
     * This method is called from the ClickOutside directive.
     * If the user clicks outside of the component, it will close
     * @param event
     * @returns void
     */
    onOutsideCLick() {
        this._closeOptionList();
    }
    /**
     * Checks/Unchecks all of the filtered options within a specific group
     * @param  FieldOption option
     * @returns boolean
     */
    onAllChange(checked) {
        if (!this.config.multiple)
            return false;
        this.config.groups.map((group) => {
            group.options.values.map((option) => {
                option.selected = checked;
            });
            group.all = checked;
            group.indeterminate = false;
        });
        setTimeout(() => {
            this._updateSelectedOptions();
        }, 0);
        return false;
    }
    /**
     * Checks/Unchecks all of the filtered options within a specific group
     * @param  FieldOption option
     * @returns boolean
     */
    onGroupChange(checked, group) {
        if (!this.config.multiple)
            return false;
        group.options.values.map((option) => {
            if (!option.hidden) {
                option.selected = checked;
            }
        });
        setTimeout(() => {
            this._checkGroupState(checked, group);
            this._updateSelectedOptions();
        }, 0);
        return false;
    }
    /**
     * Update's the list of selected options inside of the config
     * and emits a change event. This method will be called by the view
     * whenever an option is selected
     * @param MatSelectionListChange event
     * @returns void
     */
    onOptionChange(event, option, group) {
        setTimeout(() => {
            option.selected = event.target.className.search('mat-pseudo-checkbox-checked') > -1 ? true : false;
            this._checkGroupState(option.selected, group);
            this._updateSelectedOptions();
        }, 0);
    }
    onLink() {
        console.log('LINK STUB: Link to Entity', this.config.control.value);
    }
    /**
     * Checks if the given option is in the list of selected options
     * in the config. Used by the view to set the checkbox's on the initial state of the dropdown
     * @param  FieldOption option
     * @returns boolean
     */
    isOptionSelected(option) {
        return option.selected;
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Observes the value changes to the search and triggers the filter of the options
     * @returns void
     */
    _setUpFilterObservable() {
        this.ui.search.config.control.valueChanges
            .pipe(debounceTime(200)).subscribe((value) => {
            this._filterOptionsList(value);
        });
    }
    /**
     * Close the option list
     * @private
     */
    _closeOptionList() {
        if (this.dom.state.filterActivated) {
            // this.config.control.setValue( '', { emitEvent: true } );
            this.dom.state.filterActivated = false;
            this.cdr.detectChanges();
            this._checkSelectedValue(this.dom.state.filterActivated);
            this._filterOptionsList('');
            this.onBubbleEvent('close');
            this.config.offset = null;
        }
    }
    /**
     * Check the selected value to see if it needs to be stored
     * @param open
     * @private
     */
    _checkSelectedValue(open) {
        // if( !open ){
        if (this.ui.selected.config.control.invalid) {
            if (this.config.displayErrors)
                this.config.message = ValidationErrorMessages(this.ui.selected.config.control.errors);
        }
        else if (this.config.patch && (this.config.patch.path || this.config.facade)) {
            if (JSON.stringify(this.config.selectedOptions) !== this.asset.onFocusValue) {
                this.onChange();
            }
        }
    }
    /**
     * Detects if the list of options should appear above or below the select input
     * @param height
     */
    _setOptionListPosition(params) {
        if (params.height > 0) {
            this.config.offset = null;
            this.dom.state.above = params.above;
            this.dom.state.below = params.below;
            this.dom.state.list = params.height;
            // if( this.config.allowAll ) this.dom.state.list += 60;
            // if( this.config.filter ) this.dom.state.list += 58;
            this.config.position = this.dom.state.below >= this.dom.state.above ? 'below' : 'above';
            this.config.height = this.config.defaultHeight;
            if (this.config.position === 'above') {
                if (this.config.height > this.dom.state.above)
                    this.config.height = this.dom.state.above;
                this.config.minHeight = this.config.height;
            }
            else {
                if (this.config.height > this.dom.state.below)
                    this.config.height = this.dom.state.below;
                // this.config.minHeight = this.config.defaultMinHeight;
                this.config.minHeight = this.config.height;
            }
            this.dom.setTimeout(`search-focus`, () => {
                if (this.searchRef) {
                    this.searchRef.nativeElement.focus();
                    // this.onBubbleEvent( 'focus' );
                }
            }, 200);
        }
    }
    /**
     * Detects whether the check all  box for a group should be unchecked, checked, or indeterminate
     * @param checked
     * @param group
     */
    _checkGroupState(checked, group) {
        let indeterminate = false;
        let all = true;
        if (!checked) {
            all = false;
            group.options.values.some((option) => {
                if (!option.hidden && option.selected) {
                    indeterminate = true;
                    return true;
                }
            });
        }
        else {
            group.options.values.some(option => {
                if (!option.hidden && !option.selected) {
                    all = false;
                    indeterminate = true;
                    return true;
                }
            });
        }
        group.all = all;
        group.indeterminate = indeterminate;
    }
    /**
     * Finds only the options from the config's options that match
     * the string passed in, and returns those options.
     * Used as the filter when setting up the filteredOptions observable
     * @param string value
     * @returns FieldItemOption
     */
    _filterOptionsList(search) {
        this.config.groups.map((group) => {
            group.options.values.map((option) => {
                option.hidden = ObjectContainsTagSearch(option, search) ? false : true;
            });
            group.selected = group.options.values.filter((option) => {
                return !option.hidden && option.selected;
            }).length;
            group.visible = group.options.values.filter((option) => {
                return !option.hidden;
            }).length;
            const checked = group.visible === group.selected;
            this._checkGroupState(checked, group);
        });
        this.cdr.detectChanges();
    }
    /**
     * Update's the selection options in config
     * by looping through all of the currently selected items
     * in the selectionListRef.
     * @param number id
     */
    _updateSelectedOptions() {
        const selected = this.selectionListRef.selectedOptions.selected;
        let str = [];
        if (this.config.multiple) {
            this.config.selectedOptions = [];
            for (const option of selected) {
                str.push(option._text.nativeElement.innerText);
                this.config.selectedOptions.push(String(option.value).trim());
            }
            str = str.sort();
            this.config.strVal = str.join(', ');
            this.ui.selected.config.control.setValue(this.config.strVal, { emitEvent: false });
            const value = JsonCopy(this.config.selectedOptions);
            this.config.control.setValue(value, { emitEvent: false });
        }
        else {
            let value;
            for (const option of selected) {
                str.push(option._text.nativeElement.innerText);
                value = option.value;
            }
            str = str.sort();
            this.config.strVal = str.join(', ');
            this.ui.selected.config.control.setValue(this.config.strVal, { emitEvent: false });
            this.dom.active.optionId = value;
            this.config.control.setValue(value, { emitEvent: false });
            this.config.value = value;
            this._closeOptionList();
        }
    }
}
PopSelectFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select-filter',
                template: "<div class=\"pop-select-filter-container import-field-item-container\" [ngClass]=\"{'pop-select-filter-single': !config.multiple, 'pop-select-filter-multiple':config.multiple}\" (libClickOutside)=\"onOutsideCLick();\" [style.marginBottom.px]=\"config.offset\">\n  <lib-pop-input\n    class=\"pop-select-filter-values\"\n    *ngIf=\"ui.selected?.config\"\n    [class.filter-selected]=\"dom.state.filterActivated\"\n    [config]=ui.selected.config\n    (click)=\"onToggleFilter($event, list);\">\n  </lib-pop-input>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n\n  <!--<div [ngClass]=\"{'sw-hidden':!config.selectedOptions.length}\" class=\"pop-select-filer-count\">{{config.selectedOptions.length}}</div>-->\n\n  <!--<mat-icon class=\"select-filter-button-icon sw-pointer\" (click)=\"onToggleFilter($event, list);\">arrow_drop_down</mat-icon>-->\n\n  <!--<div class=\"pop-select-filter-feedback\">-->\n    <!--<div *ngIf=\"config.message\"-->\n         <!--class=\"pop-select-error\"-->\n         <!--matTooltipPosition=\"left\"-->\n         <!--[matTooltip]=config.message>-->\n      <!--<mat-icon color=\"warn\">info</mat-icon>-->\n    <!--</div>-->\n  <!--</div>-->\n\n  <div class=\"select-filter-content select-filter-items-{{config.position}}\" [ngClass]=\"{'sw-hidden': !dom.state.filterActivated}\" #list>\n\n    <div class=\"pop-select-search-header\">\n      <mat-checkbox\n        *ngIf=\"config.multiple\"\n        [(ngModel)]=\"config.all\"\n        [color]=\"'primary'\"\n        matTooltip=\"Toggle All\"\n        matTooltipPosition=\"above\"\n        (change)=\"onAllChange($event.checked);\">\n      </mat-checkbox>\n\n      <mat-form-field *ngIf=\"config.filter && ui.search.config\" appearance=\"none\" floatLabel=\"never\" class=\"sw-search\">\n        <a matPrefix>\n          <mat-icon>search</mat-icon>\n        </a>\n        <input matInput placeholder=\"Search\"\n               class=\"sw-pointer\"\n               #search\n               type=\"text\"\n               [formControl]=\"ui.search.config.control\">\n        <mat-icon class=\"sw-cursor-pointer sw-pointer\" matSuffix (click)=\"ui.search.config.control.setValue('');\">close</mat-icon>\n      </mat-form-field>\n\n    </div>\n\n    <mat-selection-list [style.minHeight.px]=config.minHeight [style.maxHeight.px]=config.height #selectionList>\n      <div *ngFor=\"let group of config.groups\">\n        <div class=\"pop-select-option-header\" *ngIf=\"group.label && group.visible\">\n          <mat-checkbox\n            *ngIf=\"config.multiple\"\n            [(ngModel)]=\"group.all\"\n            [color]=\"'primary'\"\n            [indeterminate]=group.indeterminate\n            matTooltip=\"Toggle Group\"\n            matTooltipPosition=\"above\"\n            (change)=\"onGroupChange($event.checked, group);\">\n          </mat-checkbox>\n          <div class=\"pop-select-header-label\" (click)=\"onToggleGroup(group);\">{{group.label}} ({{group.options.values.length}})</div>\n\n        </div>\n        <mat-list-option\n          [checkboxPosition]=dom.state.checkboxPosition\n          class=\"pop-select-filter-option\"\n          *ngFor=\"let option of group.options.values\"\n          [ngClass]=\"{'sw-hidden': option.hidden || !group.open, 'pop-select-filter-active': dom.active.optionId && option.value === dom.active.optionId}\"\n          [style.paddingLeft]=\"option.level+'px'\"\n          [selected]=isOptionSelected(option)\n          (click)=\"onOptionChange($event, option, group);\"\n          [value]=\"option.value\">\n          {{option.name}}\n        </mat-list-option>\n      </div>\n      <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n    </mat-selection-list>\n  </div>\n</div>\n",
                styles: [".pop-select-filter-container{position:relative;display:block;padding:0;margin:var(--gap-s) 0}.select-filter-button{border:1px solid var(--text-2);border-radius:.25em;position:relative;display:flex;justify-content:space-between;height:40px}.select-filter-button .select-filter-button-left-items{display:flex;justify-content:flex-start;align-items:center}.select-filter-button .select-filter-button-left-items .select-filter-button-bar{width:4px;background-color:var(--background-base);height:100%;border-radius:2px 0 0 2px}.select-filter-button .select-filter-button-left-items .select-filter-button-text{display:inline-block;margin-left:var(--gap-sm)}.pop-select-search-header{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:stretch;border-bottom:1px solid var(--border)}.sw-search{margin-top:-20px}.sw-search,.sw-search .mat-form-field-flex{display:flex;flex-grow:1}.pop-select-filer-count{position:absolute;bottom:-5px;right:2px;font-size:.7em;text-align:right}.select-filter-button-icon{pointer-events:none;z-index:1;position:absolute;display:flex;top:var(--gap-s);right:7px;color:var(--text-disabled);outline:0}.select-filter-button:hover{background-color:var(--background-base);cursor:pointer}.select-filter-items-above{border:1px solid var(--border);position:absolute;bottom:47px;border-radius:5px}.select-filter-items-above,.select-filter-items-below{left:0;right:0;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;z-index:3;background-color:var(--background-base);min-height:30px}.select-filter-items-below{border:1px solid var(--border);position:relative;top:1px;border-radius:3px;z-index:99}.mat-form-field{display:block;height:30px}.pop-select-filter-option{box-sizing:border-box;background:var(--background-base);height:30px}.expand-to-container{position:absolute!important;top:0;left:0;bottom:0;right:0;box-sizing:border-box!important;-moz-box-sizing:border-box}.pop-select-filter-feedback{z-index:3;position:absolute;top:8px;right:9px;display:flex;flex-flow:row;align-items:center;justify-content:center}.pop-select-option-header{display:flex;flex-direction:row;-webkit-tap-highlight-color:transparent;width:100%;padding:0;justify-content:flex-start;padding-left:var(--xs);align-items:center;box-sizing:border-box;cursor:pointer;height:30px;border-top:1px solid var(--border)!important;border-bottom:1px solid var(--border)!important;outline:0;background:var(--background-2)}.pop-select-option-header:hover{background:var(--bg-1)}.pop-select-header-label{position:relative;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-style:italic;font-weight:700;font-size:16px;padding-left:5px}.pop-select-filter-active{background:var(--background-2)}.select-filter-error{position:absolute;top:13px;left:0;font-size:.8em}:host ::ng-deep .checkbox-after{direction:rtl}:host ::ng-deep .checkbox-after .mat-checkbox-layout{width:100%}:host ::ng-deep .checkbox-after .mat-checkbox-layout .mat-checkbox-inner-container{margin:0 9px 0 auto}:host ::ng-deep .mat-checkbox-inner-container{margin:0 0 0 var(--gap-sm)}:host ::ng-deep .mat-checkbox-label{padding:0 0 0 var(--gap-sm)}:host ::ng-deep .mat-list-item-content-reverse{padding:0 var(--gap-s) 0 var(--gap-xs)!important}:host ::ng-deep mat-selection-list{overflow-y:auto;overflow-x:hidden;outline:0!important;padding-bottom:var(--gap-xs)}:host ::ng-deep mat-list-option{border:none!important}.pop-select-filter-option:focus,.pop-select-filter-option:hover{background:var(--accent-shade)}.pop-select-all-header:hover{background:var(--bg-1)}:host ::ng-deep .mat-form-field-infix{padding:8px 0 13px!important}:host ::ng-deep .pop-select-filter-values .mat-form-field-infix{padding:8px 40px 13px 0!important}:host ::ng-deep .pop-select-filter-values input{display:flex;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:100%;z-index:2;padding-right:40px}:host ::ng-deep .pop-select-filter-values .mat-form-field-infix{pointer-events:none!important}:host ::ng-deep .pop-select-filter-single mat-pseudo-checkbox{display:none!important}:host ::ng-deep .pop-select-filter-single .mat-list-text{padding-left:0!important}:host ::ng-deep .pop-select-option-header mat-checkbox{margin-left:-1px!important}:host ::ng-deep .pop-select-filter-single .sw-search{padding-left:var(--gap-s)}:host ::ng-deep .pop-select-option-header .mat-checkbox-inner-container{width:16px!important;height:16px!important}:host ::ng-deep .pop-select-option-header .mat-checkbox-label{padding:0 var(--gap-s) 0 0}:host ::ng-deep .pop-input-container{margin:0!important}:host ::ng-deep .filter-option-selected .pop-input-container{background-color:var(--accent-shade)!important}:host ::ng-deep mat-list-base{padding:0!important}:host ::ng-deep .mat-list-text{display:block;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}"]
            },] }
];
PopSelectFilterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopSelectFilterComponent.propDecorators = {
    config: [{ type: Input }],
    listRef: [{ type: ViewChild, args: ['list', { static: true },] }],
    selectionListRef: [{ type: ViewChild, args: ['selectionList', { static: true },] }],
    searchRef: [{ type: ViewChild, args: ['search',] }],
    onEscapeHandler: [{ type: HostListener, args: ['document:keydown.escape', ['$event'],] }]
};

/**
 * This directive was taken from this github repository
 * https://github.com/christianliebel/angular2-click-outside
 * found on stack over flow post
 * https://stackoverflow.com/questions/35712379/how-can-i-close-a-dropdown-on-click-outside
 *
 * Credit goes to github user christianliebel
 */
class ClickOutsideDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.libClickOutside = new EventEmitter();
    }
    onClick(event, targetElement) {
        if (!targetElement) {
            return;
        }
        const clickedInside = this._elementRef.nativeElement.contains(targetElement);
        if (!clickedInside) {
            this.libClickOutside.emit(event);
        }
    }
}
ClickOutsideDirective.decorators = [
    { type: Directive, args: [{
                selector: '[libClickOutside]'
            },] }
];
ClickOutsideDirective.ctorParameters = () => [
    { type: ElementRef }
];
ClickOutsideDirective.propDecorators = {
    libClickOutside: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['document:click', ['$event', '$event.target'],] }]
};

class ExpansionItemsComponent {
    constructor(calendar, dateAdapter, dateFormat) {
        this.calendar = calendar;
        this.dateAdapter = dateAdapter;
        this.dateFormat = dateFormat;
    }
    /**
     * Toggle Calendar between Month and Multiple Year
     */
    toggleCalView() {
        this.calendar.currentView = this.calendar.currentView === 'month' ? 'multi-year' : 'month';
    }
    /**
     * Get the date month and year label. Example: May 2021.
     */
    get periodLabel() {
        return this.dateAdapter.format(this.calendar.activeDate, this.dateFormat.display.monthYearLabel);
    }
    /**
     * Change the month or year by -1
     * @param mode month or year
     */
    previousClicked(mode) {
        this.changeDate(mode, -1);
    }
    /**
     * Change the month or year 1
     * @param mode
     */
    nextClicked(mode) {
        this.changeDate(mode, 1);
    }
    /**
     * Change the month or year by -1 or 1
     * @param mode : year or month
     * @param amount -1 or 1
     * @private
     */
    changeDate(mode, amount) {
        this.calendar.activeDate = mode === 'month' ? this.dateAdapter.addCalendarMonths(this.calendar.activeDate, amount)
            : this.dateAdapter.addCalendarYears(this.calendar.activeDate, amount);
    }
}
ExpansionItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-custom-header',
                template: "<lib-custom-panel></lib-custom-panel>\n<div class=\"example-header\">\n  <span class=\"header-label mat-body\" (click)=\"toggleCalView()\">{{ periodLabel }} <mat-icon class=\"view-nav\" >arrow_drop_down</mat-icon></span>\n  <button class=\"nav-button\" mat-icon-button (click)=\"previousClicked('month')\">\n    <mat-icon>keyboard_arrow_left</mat-icon>\n  </button>\n\n  <button class=\"nav-button\" mat-icon-button (click)=\"nextClicked('month')\">\n    <mat-icon>keyboard_arrow_right</mat-icon>\n  </button>\n\n</div>\n<div class=\"date-custom-footer\">\n  <button id=\"datepicker-cancel\" class=\"date-action-button\" mat-raised-button>CANCEL</button>\n  <button id=\"datepicker-apply\" mat-flat-button color=\"accent\" >APPLY</button>\n</div>\n",
                styles: [".example-header{display:flex;align-items:center;padding:var(--gap-m) var(--gap-m) 0 var(--gap-m)}.nav-button{color:var(--foreground-disabled)}.view-nav{position:relative;top:7px}.header-label{position:relative;top:-5px;flex:1;font-size:14px;color:var(--foreground-disabled);text-align:left;cursor:pointer}.example-double-arrow .mat-icon{color:var(--foreground-disabled);margin:-22%}.date-custom-footer{position:relative;top:320px;float:right;padding-right:var(--gap-m)}.date-action-button{margin-right:var(--gap-s)}"]
            },] }
];
ExpansionItemsComponent.ctorParameters = () => [
    { type: MatCalendar },
    { type: DateAdapter },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DATE_FORMATS,] }] }
];

class PopDateComponent extends PopFieldItemComponent {
    constructor(el, overlayContainer) {
        super();
        this.el = el;
        this.overlayContainer = overlayContainer;
        this.config = new DateConfig();
        this.name = 'PopDateComponent';
        this.ExpansionItems = ExpansionItemsComponent;
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.triggerOnChange = (value, forcePatch = false) => {
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        // this.cdr.detectChanges();
                        this.onChange(value, forcePatch);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.control.markAsPristine();
                        this.config.control.markAsUntouched();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                this._setFilter();
                return resolve(true);
            });
        };
    }
    /**
     * On init hook
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.config.type === 'Basic') {
            this.ExpansionItems = null;
        }
    }
    /**
     * After view init hook
     *  Backup picker close method
     */
    ngAfterViewInit() {
        this.selfClose = this.picker.close;
    }
    /**
     * on Open Event
     * Overwrite picker close to prevent auto closing
     */
    onOpen() {
        const olcClasses = this.overlayContainer.getContainerElement().classList;
        if (this.config.type === 'Expanded') {
            this.picker.close = () => { };
            olcClasses.add('expanded');
        }
        else {
            this.removeExpandedClass();
        }
    }
    /**
     * Removes Expanded Class from the Overlay Container if needed
     */
    removeExpandedClass() {
        const olcClasses = this.overlayContainer.getContainerElement().classList;
        if (olcClasses.contains('expanded')) {
            setTimeout(() => olcClasses.remove('expanded'), 100);
        }
    }
    /**
     * On Change event
     * @param value
     * @param force
     */
    onChange(value, force = false) {
        if (value) {
            value = PopDate.toIso(value);
        }
        else {
            value = null;
        }
        if (IsObject(this.config, ['control'])) {
            this.log.info(`onChange`, value);
            const control = this.config.control;
            if (typeof value !== 'undefined') {
                control.setValue(value);
                control.markAsDirty();
                control.updateValueAndValidity();
            }
            if (this._isChangeValid()) {
                value = typeof value !== 'undefined' ? value : this.config.control.value;
                value = this._applyTransformation(value);
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    this._onPatch(value, force);
                }
                else {
                    this.onBubbleEvent('onChange');
                }
            }
            else {
                this.onBubbleEvent('onInvalidChange');
            }
        }
    }
    /**
     * Reset the Form
     */
    onResetForm() {
        this.dom.setTimeout(`reset-form`, () => {
            this.config.control.setValue(null, { emitEvent: true });
            this.config.control.updateValueAndValidity();
            this.onChange();
        }, 0);
    }
    /**
     * Determine where the click happened. Return picker close to original state
     * @param $click
     */
    onOutsideCLick($click) {
        let isDatepickerAreaClick = $click.path.some(path => {
            if (path.className) {
                return path.className.includes('mat-datepicker');
            }
        });
        if (isDatepickerAreaClick) {
            const r = $click.path.some(path => {
                if (path.className) {
                    return path.className.includes('mat-overlay');
                }
            });
            if (r) {
                isDatepickerAreaClick = false;
            }
        }
        const isDatepickerCancel = $click.path.some(ele => {
            if (ele.id) {
                return ele.id.includes('datepicker-cancel');
            }
        });
        const isDatepickerApply = $click.path.some(ele => {
            if (ele.id) {
                return ele.id.includes('datepicker-apply');
            }
        });
        if (!isDatepickerAreaClick || isDatepickerCancel || isDatepickerApply) {
            this.picker.close = this.selfClose;
            this.picker.close();
            this.removeExpandedClass();
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeExpandedClass();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setFilter() {
        if (typeof this.config.filterPredicate === 'string') {
            switch (String(this.config.filterPredicate).toLowerCase()) {
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day !== 0 && day !== 6;
                    };
                    break;
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day >= 1 && day <= 5;
                    };
                    break;
                case 'monday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // monday
                        return day === 1;
                    };
                    break;
                default:
                    this.config.filterPredicate = null;
                    break;
            }
        }
    }
}
PopDateComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-date',
                template: "\n<div\n  class=\"import-field-item-container pop-date-container\"\n  (libClickOutside)=\"onOutsideCLick($event);\"\n>\n  <mat-form-field appearance=\"outline\" color=\"accent\" class=\"import-field-item-container-expansion\">\n    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>\n    <div *ngIf=\"config.tooltip && config.showTooltip\" class=\"field-tooltip-msg\" [innerHTML]=config.tooltip></div>\n    <input\n      type=\"text\"\n      matTooltipClass=\"input-tooltip-background\"\n      matInput\n      [matDatepicker]=\"datePicker\"\n      [readonly]=\"config.disabled\"\n      [min]=config.min\n      [max]=config.max\n      [matDatepickerFilter]=config.filterPredicate\n      [formControl]=config.control\n      (blur)=\"config.showTooltip=false; onBlur();\"\n      (focus)=\"config.showTooltip=true; onFocus();\"\n      (dateChange)=\"onChange($event.value);\"\n      placeholder=\"\"\n    >\n  </mat-form-field>\n\n    <mat-datepicker #datePicker  [ngClass]=\"{'expanded': config?.type === 'Expanded' }\" [calendarHeaderComponent]=\"ExpansionItems\"  (opened)=\"onOpen()\" >\n    </mat-datepicker >\n\n<!--  <ng-container *ngIf=\"config.type === 'Basic'\">-->\n<!--    <mat-datepicker #datePicker  >-->\n<!--    </mat-datepicker >-->\n<!--  </ng-container>-->\n\n\n  <mat-icon *ngIf=\"!config.disabled\" class=\"sw-pointer date-clear-icon\" (click)=\"onResetForm();\">clear</mat-icon>\n  <mat-datepicker-toggle class=\"date-toggle-icon\"  [for]=\"datePicker\"></mat-datepicker-toggle>\n  <lib-pop-field-item-helper class=\"date-helper-icon\" [hidden]=\"!config.helpText\" [helpText]=config.helpText></lib-pop-field-item-helper>\n\n  <div class=\"date-feedback-container\">\n    <lib-pop-field-item-error class=\"date-error-icon\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n  </div>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".pop-date-container{position:relative;display:block;padding:0;margin:var(--gap-s) 0}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{display:none}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.date-feedback-container{position:absolute;top:var(--gap-xxs);right:var(--gap-xxs);width:var(--gap-m);bottom:var(--gap-xxs);display:flex;padding-top:2px;flex-flow:row;align-items:center;justify-content:center;pointer-events:none}.date-clear-icon{right:42px;top:13px;font-size:1em}.date-clear-icon,.date-toggle-icon{position:absolute!important;width:25px;height:25px;z-index:1}.date-toggle-icon{right:24px;top:8px}.date-toggle-icon ::ng-deep .mat-icon-button{line-height:25px!important}.date-toggle-icon ::ng-deep button{width:25px;height:25px}.date-toggle-icon ::ng-deep button mat-icon{font-size:.9em}.date-error-icon{position:relative;pointer-events:all;left:4px}.date-error-icon ::ng-deep .mat-icon{font-size:1em!important}.date-helper-icon{position:absolute!important;width:25px;height:25px;right:67px;pointer-events:all;font-size:.8em;top:11px}.date-helper-icon ::ng-deep .mat-icon{font-size:.9em!important}.date-ajax-spinner{position:absolute;z-index:1}.field-tooltip-msg{position:absolute;display:block;bottom:50px;width:100%;right:-10px;left:-10px;background:#3d72ea!important;border-radius:.25em;padding:.75em;z-index:2;color:#fff;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;overflow:hidden;text-align:center}::ng-deep .expanded .mat-datepicker-content{position:relative;left:200px;border-radius:0!important;height:425px;background:var(--background-base);border-top:1px solid #d3d3d3;border-right:1px solid #d3d3d3;border-bottom:1px solid #d3d3d3}::ng-deep .mat-datepicker-content{background:var(--background-base);border:1px solid #d3d3d3}"]
            },] }
];
PopDateComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: OverlayContainer }
];
PopDateComponent.propDecorators = {
    config: [{ type: Input }],
    picker: [{ type: ViewChild, args: ['datePicker',] }]
};

class DateRangeExpansionItemsComponent {
    constructor(calendar, dateAdapter, dateFormat) {
        this.calendar = calendar;
        this.dateAdapter = dateAdapter;
        this.dateFormat = dateFormat;
    }
    /**
     * Toggle Calendar between Month and Multiple Year
     */
    toggleCalView() {
        this.calendar.currentView = this.calendar.currentView === 'month' ? 'multi-year' : 'month';
    }
    /**
     * Get the date month and year label. Example: May 2021.
     */
    get periodLabel() {
        return this.dateAdapter.format(this.calendar.activeDate, this.dateFormat.display.monthYearA11yLabel);
    }
    /**
     * Change the month or year by -1
     * @param mode month or year
     */
    previousClicked(mode) {
        this.changeDate(mode, -1);
    }
    /**
     * Change the month or year 1
     * @param mode
     */
    nextClicked(mode) {
        this.changeDate(mode, 1);
    }
    /**
     * Change the month or year by -1 or 1
     * @param mode : year or month
     * @param amount -1 or 1
     * @private
     */
    changeDate(mode, amount) {
        this.calendar.activeDate = mode === 'month' ? this.dateAdapter.addCalendarMonths(this.calendar.activeDate, amount)
            : this.dateAdapter.addCalendarYears(this.calendar.activeDate, amount);
    }
}
DateRangeExpansionItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-custom-header',
                template: "<lib-date-range-panel></lib-date-range-panel>\n<div class=\"example-header\">\n  <span class=\"header-label mat-body\" (click)=\"toggleCalView()\">{{ periodLabel }} <mat-icon class=\"view-nav\" >arrow_drop_down</mat-icon></span>\n  <button class=\"nav-button\" mat-icon-button (click)=\"previousClicked('month')\">\n    <mat-icon>keyboard_arrow_left</mat-icon>\n  </button>\n\n  <button class=\"nav-button\" mat-icon-button (click)=\"nextClicked('month')\">\n    <mat-icon>keyboard_arrow_right</mat-icon>\n  </button>\n\n</div>\n<div class=\"date-custom-footer\">\n  <button id=\"datepicker-cancel\" class=\"date-action-button\" mat-raised-button>CANCEL</button>\n  <button id=\"datepicker-apply\" mat-flat-button color=\"accent\" >APPLY</button>\n</div>\n",
                styles: [".example-header{display:flex;align-items:center;padding:var(--gap-m) var(--gap-m) 0 var(--gap-m)}.nav-button{color:var(--foreground-disabled)}.view-nav{position:relative;top:7px}.header-label{position:relative;top:-5px;flex:1;font-size:14px;color:var(--foreground-disabled);text-align:left;cursor:pointer}.example-double-arrow .mat-icon{color:var(--foreground-disabled);margin:-22%}.date-custom-footer{position:relative;top:320px;float:right;padding-right:var(--gap-m)}.date-action-button{margin-right:var(--gap-s)}::ng-deep .mat-calendar-body-in-range:not(.mat-calendar-body-range-start):not(.mat-calendar-body-range-end):before{background:var(--accent-selected)}::ng-deep td.mat-calendar-body-cell.mat-calendar-body-in-range.ng-star-inserted:last-child:before{border-top-right-radius:999px;border-bottom-right-radius:999px}::ng-deep tr:last-child td.mat-calendar-body-cell.mat-calendar-body-in-range.ng-star-inserted:last-child:before{border-top-right-radius:999px;border-bottom-right-radius:999px}::ng-deep td.mat-calendar-body-cell.mat-calendar-body-in-range.ng-star-inserted[data-mat-col=\"0\"]:before{border-top-left-radius:999px;border-bottom-left-radius:999px}::ng-deep .mat-calendar-body-range-start:before{border-top-left-radius:999px;border-bottom-left-radius:999px;background:var(--accent-selected)}::ng-deep .mat-calendar-body-range-end:before{border-top-right-radius:999px;border-bottom-right-radius:999px;background:var(--accent-selected)}"]
            },] }
];
DateRangeExpansionItemsComponent.ctorParameters = () => [
    { type: MatCalendar },
    { type: DateAdapter },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DATE_FORMATS,] }] }
];

class DateRangeConfig {
    constructor(params) {
        // Defaults
        this.type = 'Expanded';
        this.bubble = false;
        this.displayErrors = true;
        this.disabled = false;
        this.filterPredicate = null;
        this.helpText = '';
        this.id = '';
        this.label = '';
        this.min = null;
        this.max = null;
        this.message = '';
        this.name = 'name';
        this.noInitialValue = false;
        this.showTooltip = false;
        this.tooltip = '';
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.valueStart)
            this.valueStart = new Date(this.valueStart);
        if (this.valueEnd)
            this.valueEnd = new Date(this.valueEnd);
        if (typeof this.min === 'string') {
            this.min = new Date(this.min);
        }
        if (typeof this.max === 'string') {
            this.max = new Date(this.max);
        }
        // if( isNaN( this.max ) === false ){
        //   const maxDate = new Date();
        //   // maxDate.setDate(maxDate.getDate() - 1);
        //   maxDate.setDate( maxDate.getDate() + parseInt( this.max, 10 ) );
        //   this.max = new Date( maxDate );
        // }
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.noInitialValue)
            this.valueStart = '';
        if (this.noInitialValue)
            this.valueEnd = '';
        if (!this.formGroup)
            this.setControl();
    }
    setControl() {
        if (this.disabled) {
            this.formGroup =
                new FormGroup({
                    start: new FormControl({ value: this.valueStart, disabled: true }),
                    end: new FormControl({ value: this.valueEnd, disabled: true }),
                });
        }
        else {
            this.formGroup =
                new FormGroup({
                    start: new FormControl(this.valueStart, (this.validators ? this.validators : [])),
                    end: new FormControl(this.valueEnd, (this.validators ? this.validators : []))
                });
        }
    }
}

class PopDateRangeComponent extends PopFieldItemComponent {
    constructor(el, overlayContainer) {
        super();
        this.el = el;
        this.overlayContainer = overlayContainer;
        this.config = new DateRangeConfig();
        this.apply = new EventEmitter();
        this.ExpansionItems = DateRangeExpansionItemsComponent;
        this.name = 'PopDateRangeComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.triggerOnChange = (value, forcePatch = false) => {
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        // this.cdr.detectChanges();
                        this.onChange('start', value.start, forcePatch);
                        this.onChange('end', value.end, forcePatch);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.formGroup.get('start').markAsPristine();
                        this.config.formGroup.get('start').markAsPristine();
                        this.config.formGroup.get('end').markAsPristine();
                        this.config.formGroup.get('end').markAsPristine();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                this._setFilter();
                return resolve(true);
            });
        };
    }
    /**
     * On init hook
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.config.type === 'Basic') {
            this.ExpansionItems = null;
        }
    }
    /**
     * After view init hook
     *  Backup picker close method
     */
    ngAfterViewInit() {
        this.selfClose = this.picker.close;
    }
    /**
     * Get the date control name for start or end
     * @param type: start or end
     */
    getDateControlName(type) {
        if (type === 'start')
            return Object.keys(this.config.formGroup.controls)[0];
        else if (type === 'end')
            return Object.keys(this.config.formGroup.controls)[1];
    }
    /**
     * on Open Event
     * Overwrite picker close to prevent auto closing
     */
    onOpen() {
        const olcClasses = this.overlayContainer.getContainerElement().classList;
        if (this.config.type === 'Expanded') {
            this.picker.close = () => { };
            olcClasses.add('expanded');
        }
        else {
            this.removeExpandedClass();
        }
    }
    /**
     * Removes Expanded Class from the Overlay Container if needed
     */
    removeExpandedClass() {
        const olcClasses = this.overlayContainer.getContainerElement().classList;
        if (olcClasses.contains('expanded')) {
            setTimeout(() => olcClasses.remove('expanded'), 100);
        }
    }
    /**
     * Determine where the click happened. Return picker close to original state
     * @param $click
     */
    onOutsideCLick($click) {
        let isDatepickerAreaClick = $click.path.some(path => {
            if (path.className) {
                return path.className.includes('mat-datepicker');
            }
        });
        if (isDatepickerAreaClick) {
            const r = $click.path.some(path => {
                if (path.className) {
                    return path.className.includes('mat-overlay');
                }
            });
            if (r) {
                isDatepickerAreaClick = false;
            }
        }
        const isDatepickerCancel = $click.path.some(ele => {
            if (ele.id) {
                return ele.id.includes('datepicker-cancel');
            }
        });
        const isDatepickerApply = $click.path.some(ele => {
            if (ele.id) {
                return ele.id.includes('datepicker-apply');
            }
        });
        if (isDatepickerCancel || isDatepickerApply) {
            this.onChange('start');
            this.onChange('end');
            this.picker.close = this.selfClose;
            this.picker.close();
            this.removeExpandedClass();
            if (isDatepickerApply) {
                this.apply.emit({ start: this.config.formGroup.get('start').value, end: this.config.formGroup.get('end').value });
            }
        }
        else if (!isDatepickerAreaClick) {
            this.picker.close = this.selfClose;
            this.picker.close();
            this.removeExpandedClass();
        }
    }
    /**
     * On Change event
     * @param controlName
     * @param value
     * @param force
     */
    onChange(controlName, value, force = false) {
        value = this.config.formGroup.get(this.getDateControlName(controlName)).value;
        if (value) {
            value = PopDate.toIso(value);
        }
        else {
            value = null;
        }
        if (IsObject(this.config, ['formGroup'])) {
            this.log.info(`onChange`, value);
            const control = this.config.formGroup.get(controlName);
            if (typeof value !== 'undefined') {
                control.setValue(value);
                control.markAsDirty();
                control.updateValueAndValidity();
            }
            if (this.isChangeValid(controlName)) {
                value = typeof value !== 'undefined' ? value : this.config.formGroup.get(this.getDateControlName(controlName)).value;
                value = this._applyTransformation(value);
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    this._onPatch(value, force);
                }
                else {
                    this.onBubbleEvent('onChange');
                }
            }
            else {
            }
        }
    }
    /**
     * Check to see if change is valid
     * @param controlName: start or end
     * @protected
     */
    isChangeValid(controlName) {
        const control = this.config.formGroup.get(this.getDateControlName(controlName)).value;
        if (control) {
            if (control.invalid) {
                if (this.config.displayErrors)
                    this._setMessage(ValidationErrorMessages(control.errors));
                return false;
            }
        }
        return this._checkPrevent();
    }
    /**
     * Reset Form event
     */
    onResetForm() {
        this.dom.setTimeout(`reset-form`, () => {
            this.config.formGroup.get('start').setValue(null, { emitEvent: true });
            this.config.formGroup.get('start').updateValueAndValidity();
            this.config.formGroup.get('end').setValue(null, { emitEvent: true });
            this.config.formGroup.get('end').updateValueAndValidity();
            this.onChange('start');
            this.apply.emit({ start: null, end: null });
        }, 0);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeExpandedClass();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setFilter() {
        if (typeof this.config.filterPredicate === 'string') {
            switch (String(this.config.filterPredicate).toLowerCase()) {
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day !== 0 && day !== 6;
                    };
                    break;
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day >= 1 && day <= 5;
                    };
                    break;
                case 'monday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // monday
                        return day === 1;
                    };
                    break;
                default:
                    this.config.filterPredicate = null;
                    break;
            }
        }
    }
}
PopDateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-date-range',
                template: "<div\n  class=\"import-field-item-container pop-date-container\"\n  [ngClass]=\"{'disabled': config.disabled, 'ng-invalid': this.config.formGroup.status === 'INVALID' }\"\n  (libClickOutside)=\"onOutsideCLick($event);\">\n  <mat-form-field   appearance=\"outline\" color=\"accent\" class=\"import-field-item-container-expansion\">\n    <mat-label *ngIf=\"config?.label\">{{config?.label}}</mat-label>\n    <div *ngIf=\"config.tooltip && config.showTooltip\" class=\"field-tooltip-msg\" [innerHTML]=config.tooltip></div>\n\n    <mat-date-range-input\n      [ngClass]=\"{'disabled': config.disabled}\"\n      [rangePicker]=\"dateRangePicker\"\n      [formGroup]=\"config.formGroup\"\n      [min]=config.min\n      [max]=config.max\n      matTooltipClass=\"input-tooltip-background\"\n      (change)=\"onChange('start')\"\n    >\n      <input\n        matStartDate\n        [formControlName]=\"getDateControlName('start')\"\n        [readonly]=\"config.disabled\"\n        (focus)=\"config.showTooltip=true; onFocus();\"\n        (blur)=\"config.showTooltip=false; onBlur();\"\n        placeholder=\"\"\n         >\n      <input\n        type=\"text\"\n        matEndDate\n        [formControlName]=\"getDateControlName('end')\"\n        (focus)=\"config.showTooltip=true; onFocus();\"\n        (blur)=\"config.showTooltip=false; onBlur();\"\n        [readonly]=\"config.disabled\"\n\n        placeholder=\"\"\n        >\n    </mat-date-range-input>\n    <mat-icon *ngIf=\"!config.disabled\" class=\"sw-pointer date-clear-icon\" (click)=\"onResetForm();\">clear</mat-icon>\n    <mat-date-range-picker #dateRangePicker [ngClass]=\"{'expanded': config?.type === 'Expanded' }\" [calendarHeaderComponent]=\"ExpansionItems\" (opened)=\"onOpen()\"    ></mat-date-range-picker>\n    <lib-pop-field-item-helper class=\"date-helper-icon\" [hidden]=\"!config.helpText\" [helpText]=config.helpText></lib-pop-field-item-helper>\n\n\n    <mat-datepicker-toggle  class=\"date-toggle-icon\"  [for]=\"dateRangePicker\" [disabled]=\"config.disabled\" ></mat-datepicker-toggle>\n    <div class=\"date-feedback-container\">\n      <lib-pop-field-item-error class=\"date-error-icon\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n    </div>\n    <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n  </mat-form-field>\n</div>\n\n\n",
                styles: [".disabled,div.disabled ::ng-deep .mat-date-range-input-inner,div.disabled ::ng-deep div.mat-date-range-input-inner mat-datepicker-toggle,div.disabled mat-datepicker-toggle,div.disabled mat-datepicker-toggle ::ng-deep .mat-icon-button,div.disabled mat-datepicker-toggle ::ng-deep div.mat-icon-button ::ng-deep .mat-date-range-input-inner,div.disabled mat-datepicker-toggle ::ng-deep div.mat-icon-button mat-datepicker-toggle{cursor:not-allowed!important;color:var(--foreground-disabled)!important}div.disabled ::ng-deep .mat-form-field-appearance-outline .mat-form-field-outline{color:var(--background-border)}div.ng-invalid ::ng-deep .mat-form-field-appearance-outline .mat-form-field-outline{color:red}.pop-date-container{position:relative;display:block;padding:0;margin:var(--gap-s) 0}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{display:none}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.date-feedback-container{position:absolute;top:var(--gap=xxs);right:var(--gap=xxs);width:var(--gap-m);bottom:var(--gap=xxs);display:flex;padding-top:2px;flex-flow:row;align-items:center;justify-content:center;pointer-events:none}.date-clear-icon{right:31px;top:6px}.date-clear-icon,.date-toggle-icon{position:absolute!important;width:25px;height:25px;z-index:1;font-size:16px}.date-toggle-icon{right:10px;top:0}.date-toggle-icon ::ng-deep .mat-icon-button{line-height:25px!important}.date-toggle-icon ::ng-deep button{width:25px;height:25px}.date-toggle-icon ::ng-deep button mat-icon{font-size:.9em}.date-error-icon{position:relative;pointer-events:all;left:2px}.date-error-icon ::ng-deep .mat-icon{font-size:1em!important}.date-helper-icon{position:absolute!important;width:25px;height:25px;right:55px;pointer-events:all;font-size:12px;top:5px}.date-helper-icon ::ng-deep .mat-icon{font-size:16px!important}.date-ajax-spinner{position:absolute;z-index:1}.field-tooltip-msg{position:absolute;display:block;bottom:50px;width:100%;right:-10px;left:-10px;background:#3d72ea!important;border-radius:.25em;padding:.75em;z-index:2;color:#fff;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;overflow:hidden;text-align:center}::ng-deep .expanded .mat-datepicker-content{position:relative;left:200px;border-radius:0!important;height:425px;background:var(--background-base);border-top:1px solid #d3d3d3;border-right:1px solid #d3d3d3;border-bottom:1px solid #d3d3d3}::ng-deep .mat-datepicker-content{background:var(--background-base);border:1px solid #d3d3d3}"]
            },] }
];
PopDateRangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: OverlayContainer }
];
PopDateRangeComponent.propDecorators = {
    config: [{ type: Input }],
    apply: [{ type: Output }],
    picker: [{ type: ViewChild, args: ['dateRangePicker',] }]
};

const datePresets$1 = [
    'Today',
    'Last',
    'Previous',
    'Next',
    'Last Month',
    'Next Month',
    'Last Year',
    'Next Year',
    'Custom'
];
class CustomPanelComponent {
    constructor(dateAdapter, datePicker, calendar) {
        this.dateAdapter = dateAdapter;
        this.datePicker = datePicker;
        this.calendar = calendar;
        this.presets = datePresets$1;
        this.selected = 'Today';
        // Get the day of the week to add to preset. Example: Next Monday
        switch (new Date().getDay()) {
            case 0:
                this.dayOfWeek = "Sunday";
                break;
            case 1:
                this.dayOfWeek = "Monday";
                break;
            case 2:
                this.dayOfWeek = "Tuesday";
                break;
            case 3:
                this.dayOfWeek = "Wednesday";
                break;
            case 4:
                this.dayOfWeek = "Thursday";
                break;
            case 5:
                this.dayOfWeek = "Friday";
                break;
            case 6:
                this.dayOfWeek = "Saturday";
        }
    }
    /**
     * Apply the preset to Datepicker and Calendar
     * @param datePreset: Example: Today
     */
    selectDatePreset(datePreset) {
        this.selected = datePreset;
        const date = this.calculateDate(datePreset);
        this.datePicker.select(date);
        this.calendar.activeDate = date;
    }
    /**
     * Calculate date Preset
     * @param datePreset: Example: Today.
     */
    calculateDate(datePreset) {
        const today = this.today;
        switch (datePreset) {
            case 'Today':
                return today;
            case 'Last':
                return this.dateAdapter.addCalendarDays(today, -7);
            case 'Previous':
                return this.dateAdapter.addCalendarDays(today, -14);
            case 'Next':
                return this.dateAdapter.addCalendarDays(today, 7);
            case 'Last Month':
                return this.dateAdapter.addCalendarMonths(today, -1);
            case 'Next Month':
                return this.dateAdapter.addCalendarMonths(today, 1);
            case 'Last Year':
                return this.dateAdapter.addCalendarYears(today, -1);
            case 'Next Year':
                return this.dateAdapter.addCalendarYears(today, 1);
        }
    }
    /**
     * Get Today
     * @private
     */
    get today() {
        const today = this.dateAdapter.today();
        if (today === null) {
            throw new Error('date creation failed');
        }
        return today;
    }
}
CustomPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-custom-panel',
                template: "\n<mat-card class=\"pop-datepicker-panel\">\n  <button\n    class=\"date-preset-button\"\n    [ngClass]=\"{'selected': item === selected}\"\n    *ngFor=\"let item of presets\"\n    mat-button\n    color=\"accent\"\n    (click)=\"selectDatePreset(item)\"\n  >\n    {{ item }} <span *ngIf=\"item === 'Last' || item === 'Previous' || item === 'Next'\">{{dayOfWeek}}</span>\n  </button>\n</mat-card>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{position:absolute;width:200px;left:-200px}.pop-datepicker-panel{position:relative;top:-1px;border-left:1px solid #d3d3d3;border-bottom:1px solid #d3d3d3;border-top:1px solid #d3d3d3;border-radius:0;padding:var(--gap-s);height:405px}.date-preset-button,.selected{width:100%;text-align:left}.selected{background:var(--background-side-menu)}"]
            },] }
];
CustomPanelComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: MatDatepicker },
    { type: MatCalendar }
];

class PopTimeComponent extends PopFieldItemComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.config = new TimeConfig();
        this.name = 'PopTimeComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.time = 12;
                this.ui.time = {
                    12: {
                        hours: [],
                        minutes: [],
                        periods: ['AM', 'PM']
                    },
                    24: {
                        hours: [],
                        minutes: [],
                        periods: []
                    },
                    selectedHour: '12',
                    selectedMinute: '00',
                    selectedPeriod: 'AM',
                };
                this.setHoursAndMinutes();
                this.setSelectedValues();
                this.config.triggerOnChange = (value) => {
                    this.cdr.detectChanges();
                    this.onChange(value, true);
                };
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    setSelectedValues() {
        const time = this.ui.time;
        const timeValue = this.config.control.value;
        const minuteValue = timeValue.slice(2, 5).replace(/[^a-zA-Z0-9]/g, '').padStart(2, '0');
        let hourValue = timeValue.slice(0, 2).replace(/[^a-zA-Z0-9]/g, '').padStart(2, '0');
        hourValue = ((hourValue % 12) || 12).toString(10).padStart(2, '0');
        if (Number(hourValue) > 12 && this.config.time === 12)
            time.selectedPeriod = 'PM';
        if (timeValue)
            time.selectedHour = hourValue;
        time.selectedMinute = minuteValue;
    }
    setHoursAndMinutes() {
        let i;
        const hourLimit = this.config.time === 12 ? 12 : 23;
        for (i = 1; i <= hourLimit; i++) {
            this.ui.time[this.config.time].hours.push(i.toString().padStart(2, '0'));
        }
        for (i = 0; i < 60; i += this.config.interval) {
            this.ui.time[this.config.time].minutes.push(i.toString().padStart(2, '0'));
        }
    }
    setTimeValue() {
        let selectedHour = this.ui.time.selectedHour;
        if (this.ui.time.selectedPeriod === 'AM' && Number(selectedHour) === 12)
            selectedHour = '00';
        if (this.ui.time.selectedPeriod === 'PM' && Number(selectedHour) > 12)
            selectedHour = (12 + Number(selectedHour)).toString(10);
        const selectedTime = selectedHour + ':' + this.ui.time.selectedMinute + ':00';
        this.config.control.setValue(selectedTime, { emitEvent: false });
    }
}
PopTimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-time',
                template: "<div class=\"pop-time-container\">\n  <div *ngIf=\"config.label\" class=\"pop-time-container-legend import-field-item-container\">{{config.label}}</div>\n  <div class=\"pop-time-row-container\">\n    <mat-label class=\"time-column column-height\">\n      <mat-icon>schedule</mat-icon>\n    </mat-label>\n    <mat-form-field class=\"time-column align-column\">\n      <mat-select [(value)]=\"ui.time.selectedHour\"\n                  (selectionChange)=\"onChange();\">\n        <mat-option *ngFor=\"let hour of ui.time[config.time].hours\" [value]=hour>\n          {{hour}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <mat-label class=\"time-column column-height\">:</mat-label>\n    <mat-form-field class=\"time-column align-column\">\n      <mat-select [(value)]=\"ui.time.selectedMinute\"\n                  (selectionChange)=\"onChange();\">\n        <mat-option *ngFor=\"let minute of ui.time[config.time].minutes\" [value]=minute>\n          {{minute}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <mat-form-field *ngIf=\"ui.time[config.time].periods.length\" class=\"time-column align-column\">\n      <mat-select [(value)]=\"ui.time.selectedPeriod\"\n                  (selectionChange)=\"onChange();\">\n        <mat-option *ngFor=\"let period of ui.time[config.time].periods\" [value]=period>\n          {{period}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n</div>\n\n",
                styles: [".pop-time-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{display:none}.pop-time-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.pop-time-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 20px 13px 0}.pop-time-container ::ng-deep .mat-form-field-underline{display:none}.pop-time-container ::ng-deep .date-column .mat-form-field-infix{padding-left:3px}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:unset}.pop-time-container-legend{font-size:11px;position:relative;margin-top:-15px;margin-bottom:-5px;clear:both;z-index:1;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;color:var(--text-2);background:var(--bg-3)}.pop-time-row-container{text-align:center;position:relative;display:flex;flex:1 1 100%;padding:0;flex-direction:row;justify-content:flex-start;align-items:center}.time-column{position:relative;display:flex;top:-8px;flex-direction:column;width:26%;flex-grow:1;margin-right:2px}.column-height{height:27px}.align-column{text-align:center}"]
            },] }
];
PopTimeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopTimeComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopSelectListComponent extends PopFieldItemComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        // emitted every time there is an option selection, search focus, or the filter options close
        this.events = new EventEmitter();
        this.name = 'PopSelectListComponent';
        this.asset = {
            filteredOptions: undefined,
            groups: [],
            onFocusValue: undefined,
            filterActivated: false,
            disabled: {}
        };
        this.ui = {
            search: {
                config: undefined,
            },
            all: {
                overlay: undefined,
            }
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this._setInitialDomState();
                this._setUpFilterObservable();
                this._setListPosition();
                this._filterOptionList('');
                this._setConfigHooks();
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._setInitialValue();
                return resolve(true);
            });
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    triggerOnChange(wait = 1000) {
        this.dom.setTimeout('api-fetch', () => {
            this.onChange();
        }, wait);
    }
    /**
     * Checks/Unchecks all of the filtered options within a specific group
     * @param  FieldOption option
     * @returns boolean
     */
    onGroupChange(checked, group) {
        if (!this.config.multiple)
            return false;
        if (!checked)
            this.config.all = false;
        group.options.values.map((option) => {
            if (!option.hidden)
                option.selected = checked;
        });
        setTimeout(() => {
            this._checkGroupState(checked, group);
            this._updateSelectedOptions();
            this.onBubbleEvent('groupAllChange', 'Group Change', { data: group });
            this.onBubbleEvent('groupChange', 'Group Change', { data: group });
        }, 0);
        return false;
    }
    /**
     * Checks/Unchecks all of the filtered options within a specific group
     * @param  FieldOption option
     * @returns boolean
     */
    onAllChange(checked) {
        if (!this.config.multiple)
            return false;
        this.config.groups.map((group) => {
            group.options.values.map((option) => {
                option.selected = checked;
            });
            group.all = checked;
            group.indeterminate = false;
        });
        setTimeout(() => {
            this._updateSelectedOptions();
        }, 0);
        return false;
    }
    /**
     * Allow the user to clear the search text
     */
    onClearSearch() {
        this.ui.search.config.control.setValue('');
    }
    /**
     * Update's the list of selected options inside of the config
     * and emits a change event. This method will be called by the view
     * whenever an option is selected
     * @param MatSelectionListChange event
     * @returns void
     */
    onOptionChange(event, option, group) {
        if (this.config.multiple) {
            // option.selected = event.target.className.search( 'mat-pseudo-checkbox-checked' ) > -1 ? true : false;
            option.selected = !option.selected;
            if (!option.selected)
                this.config.all = false;
            this._checkGroupState(option.selected, group);
            this._updateSelectedOptions();
            this.onBubbleEvent('optionChange', 'Option Change', { data: option });
            setTimeout(() => {
                this.onBubbleEvent('groupChange', 'Group Change', { data: group });
            }, 0);
        }
        else {
            this.dom.active.optionId = option.value;
            this.config.control.setValue(option.value);
            this.config.strVal = option.name;
            this.triggerOnChange(0);
        }
    }
    /**
     * Add on to set toggle special custom property
     * @param event
     * @param option
     */
    onOptionModeChange(event, option) {
        if (this.config.multiple) {
            setTimeout(() => {
                this.onBubbleEvent('optionModeChange', 'Option Mode Change', { data: option });
            }, 0);
        }
    }
    /**
     * On link click stub
     */
    onLinkClick() {
        console.log('LINK STUB: Link to Entity', this.config.control.value);
    }
    /**
     * Allow user to open close a group section
     * @param group
     */
    onToggleGroup(group) {
        if (this.config.groups.length > 1) {
            group.open = !group.open;
        }
    }
    /**
     * Checks if the given option is in the list of selected options
     * in the config. Used by the view to set the checkboxe's on the
     * initial state of the dropdown
     * @param  FieldOption option
     * @returns boolean
     */
    isOptionSelected(option) {
        return option.selected;
    }
    isSearchValue() {
        if (IsObject(this.ui.search.config, ['control']) && this.ui.search.config.control.value) {
            return true;
        }
        return false;
    }
    /**
     * Template logic to determine if a option is hidden
     * @param option
     */
    isOptionHidden(group, option) {
        if (!group.open && !(this.isSearchValue())) {
            return true;
        }
        if (option.hidden) {
            return true;
        }
        return false;
    }
    /**
     * Template logic to determine if a option is active
     * @param option
     */
    isOptionActive(option) {
        return this.dom.active.optionId && option.value === this.dom.active.optionId;
    }
    /**
     * Template logic to determine if a option is disabled
     * @param option
     */
    isOptionDisabled(option) {
        return this.asset.disabled[option.value];
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setConfigHooks() {
        this.config.triggerOnChange = (value) => {
            this.config.control.setValue(value);
            this.config.control.markAsPristine();
            this.config.message = '';
            this.config.control.updateValueAndValidity();
            this.onChange();
        };
        this.config.disableOption = (optionId) => {
            if (IsDefined(optionId)) {
                this.asset.disabled[optionId] = true;
            }
        };
        this.config.enableOption = (optionId) => {
            if (IsDefined(optionId)) {
                delete this.asset.disabled[optionId];
            }
        };
        this.config.setDisabled = (optionsIds = null) => {
            this.dom.setTimeout(`set-disabled`, () => {
                this.config.disabledIds = optionsIds;
                this._setDisabledIds();
            }, 0);
        };
        this.config.focusSearch = () => {
            this.dom.setTimeout(`search-focus`, () => {
                if (this.searchRef) {
                    this.searchRef.nativeElement.focus();
                    // this.onBubbleEvent( 'focus' );
                }
            }, 200);
        };
        this.config.setActive = (optionId) => {
            this.dom.setTimeout(`set-disabled`, () => {
                if (+optionId) {
                    this.dom.active.optionId = optionId;
                    delete this.asset.disabled[optionId];
                }
            }, 5);
        };
        this.config.setHeight = (height) => {
            this.dom.setTimeout(`set-height`, () => {
                if (+height) {
                    this.config.minHeight = height;
                    this.config.height = height;
                }
            }, 5);
        };
        this.config.clearSelected = () => {
            this.dom.setTimeout(`clear-selected`, () => {
                this.onAllChange(false);
            }, 0);
        };
    }
    /**
     * Set the inital dom state of the component
     * @private
     */
    _setInitialDomState() {
        this.dom.state.helper = false;
        this.dom.state.filter = undefined;
        this.dom.state.allOverlayEnabled = this.config.allOverlayEnabled ? true : false;
        this.dom.state.filterActivated = false;
        this.dom.state.above = undefined;
        this.dom.state.below = undefined;
        this.dom.state.list = undefined;
        this.asset.filterActivated = false;
        this.dom.state.checkboxPosition = this.config.checkboxPosition === 'left' ? 'before' : 'after';
        this.ui.search.config = new InputConfig({
            value: '',
            helpText: this.config.helpText,
            displayErrors: false,
            label: this.config.label,
            readonly: true,
            maxlength: 255
        });
        this.ui.all.overlay = this.config.allOverlay ? new SwitchConfig({
            value: this.config.allOverlayEnabled,
            displayErrors: false,
            label: this.config.allOverlayLabel,
            disabled: this.config.disabled,
            facade: true,
            labelPosition: this.config.checkboxPosition === 'after' ? 'before' : 'after',
            patch: {
                path: '',
                field: '',
                callback: (core, event) => {
                    this.dom.setTimeout(`overlay-callback`, () => __awaiter(this, void 0, void 0, function* () {
                        this.dom.state.allOverlayEnabled = event.config.control.value === true;
                        if (IsCallableFunction(this.config.allOverlayCallback)) {
                            yield this.config.allOverlayCallback(core, event);
                        }
                    }), 0);
                }
            }
        }) : null;
        if (!this.config.multiple) {
            this.selectionListRef.selectedOptions = new SelectionModel(false);
        }
        this.asset.onFocusValue = JSON.stringify(this.config.selectedOptions);
        this._setDisabledIds();
    }
    /**
     * Set the lead mapping options that are disabled;
     * @private
     */
    _setDisabledIds() {
        this.asset.disabled = {};
        if (IsArray(this.config.disabledIds)) {
            this.config.disabledIds.map((optionId) => {
                if (IsNumber(optionId)) {
                    this.asset.disabled[optionId] = true;
                }
            });
        }
    }
    _setInitialValue() {
        if (!this.config.multiple && !this.dom.active.optionId) {
            if (IsDefined(this.config.value, false)) {
                this.dom.active.optionId = this.config.value;
                if (!(IsDefined(this.config.control.value, false))) {
                    this.config.control.setValue(this.config.value);
                }
            }
        }
        else {
            if (!(IsArray(this.config.control.value))) {
                this.config.control.setValue([]);
            }
        }
    }
    /**
     * Observes the value changes to the search and triggers the filter of the options
     * @returns void
     */
    _setUpFilterObservable() {
        this.ui.search.config.control.valueChanges
            .pipe(debounceTime(200)).subscribe((value) => {
            this._filterOptionList(value);
        });
    }
    /**
     * Detects if the list of options should appear above or below the select input
     * @param height
     */
    _setListPosition() {
        // this.config.minHeight = this.config.minHeight;
        // this.config.minHeight = 200;
        // this.config.height = this.config.defaultHeight;
    }
    /**
     * Detects where the check all  box for a group should be unchecked, checked, or indeterminate
     * @param checked
     * @param group
     */
    _checkGroupState(checked, group) {
        let indeterminate = false;
        let all = true;
        if (!checked) {
            all = false;
            group.options.values.some((option) => {
                if (!option.hidden && option.selected) {
                    indeterminate = true;
                    return true;
                }
            });
        }
        else {
            group.options.values.some(option => {
                if (!option.hidden && !option.selected) {
                    all = false;
                    indeterminate = true;
                    return true;
                }
            });
        }
        group.all = all;
        group.indeterminate = indeterminate;
    }
    /**
     * Finds only the options from the config's options that match
     * the string passed in, and returns those options.
     * Used as the filter when setting up the filteredOptions observable
     * @param string value
     * @returns FieldItemOption
     */
    _filterOptionList(search) {
        this.config.groups.map((group) => {
            group.options.values.map((option) => {
                option.hidden = ObjectContainsTagSearch(option, search) ? false : true;
            });
            group.selected = group.options.values.filter((option) => {
                return !option.hidden && option.selected;
            }).length;
            group.visible = group.options.values.filter((option) => {
                return !option.hidden;
            }).length;
            const checked = group.visible === group.selected;
            this._checkGroupState(checked, group);
            try {
                this.cdr.detectChanges();
            }
            catch (e) {
            }
        });
    }
    /**
     * Update's the selection options in config
     * by looping through all of the currently selected items
     * in the selectionListRef.
     * @param number id
     */
    _updateSelectedOptions() {
        this.dom.setTimeout('update-selected-options', () => {
            const selected = this.selectionListRef.selectedOptions.selected;
            let str = [];
            this.config.selectedOptions = [];
            for (const option of selected) {
                str.push(option._text.nativeElement.innerText);
                this.config.selectedOptions.push(option.value);
            }
            this.config.control.setValue(this.config.selectedOptions.slice());
            str = str.sort();
            this.config.strVal = str.join(', ');
            this.triggerOnChange();
        }, 50);
    }
    /**
     * Set up the body of the api patch
     * @param value
     * @private
     */
    _getPatchBody(value) {
        const patch = this.config.patch;
        const body = {};
        if (this.config.all) {
            if (typeof this.config.allValue !== 'undefined') {
                body[this.config.patch.field] = this.config.allValue;
            }
            else if (this.config.patchGroupFk) {
                body[this.config.patch.field] = [];
                this.config.groups.map((group) => {
                    body[this.config.patch.field].push(`0:${group.groupFk}`);
                });
            }
            else {
                body[this.config.patch.field] = this.config.selectedOptions.length ? this.config.selectedOptions : [];
            }
        }
        else {
            if (this.config.multiple) {
                if (!this.config.control.value.length && typeof this.config.emptyValue !== 'undefined') {
                    body[this.config.patch.field] = this.config.emptyValue;
                }
                else if (this.config.patchGroupFk) {
                    body[this.config.patch.field] = [];
                    this.config.groups.map((group) => {
                        if (group.all) {
                            body[this.config.patch.field].push(`0:${group.groupFk}`);
                        }
                        else {
                            group.options.values.filter((option) => {
                                return option.selected;
                            }).map((option) => {
                                body[this.config.patch.field].push(`${option.value}:${group.groupFk}`);
                            });
                        }
                    });
                }
                else {
                    body[this.config.patch.field] = this.config.control.value.length ? this.config.control.value : [];
                }
            }
            else {
                value = typeof value !== 'undefined' ? value : this.config.control.value;
                body[this.config.patch.field] = value;
            }
            if (patch && patch.metadata) {
                for (const i in patch.metadata) {
                    if (!patch.metadata.hasOwnProperty(i))
                        continue;
                    body[i] = patch.metadata[i];
                }
            }
        }
        if (IsArray(body[this.config.patch.field], true))
            body[this.config.patch.field].sort(function (a, b) {
                return a - b;
            });
        if (this.config.patch.metadata) {
            for (const i in this.config.patch.metadata) {
                if (!this.config.patch.metadata.hasOwnProperty(i))
                    continue;
                body[i] = this.config.patch.metadata[i];
            }
        }
        if (this.config.patch.json)
            body[this.config.patch.field] = JSON.stringify(body[this.config.patch.field]);
        return body;
    }
}
PopSelectListComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select-list',
                template: "<div class=\"pop-select-list-container import-field-item-container\">\n  <div class=\"pop-select-list-label\" *ngIf=\"config.label\">\n    {{config.label}}\n  </div>\n  <div *ngIf=\"config.helpText && !config.message && ( !config.patch || !config.patch.running )\"\n       class=\"sw-pop-icon sw-pointer pop-select-list-helper-icon\"\n       (mouseenter)=\"dom.state.helper = true\"\n       (mouseleave)=\"dom.state.helper = false\"\n       matTooltip=\"{{config.helpText}}\"\n       matTooltipPosition=\"above\">X\n  </div>\n  <div class=\"pop-select-list-feedback\">\n    <div *ngIf=\"config.message\"\n         class=\"pop-select-error-icon\"\n         matTooltipPosition=\"left\"\n         [matTooltip]=config.message>\n      <mat-icon color=\"warn\">info</mat-icon>\n    </div>\n  </div>\n  <div class=\"pop-select-list-items\" #list>\n\n    <div class=\"import-flex-row pop-select-list-overlay pop-select-list-option-header-open\" *ngIf=\"ui.all.overlay\">\n      <lib-pop-switch [config]=\"ui.all.overlay\"></lib-pop-switch>\n    </div>\n\n    <div class=\"pop-select-search-header\">\n      <mat-checkbox\n        *ngIf=\"config.multiple && config.allowAll && config.checkboxPosition === 'before'\"\n        class=\"pop-select-list-checkbox-before\"\n        [ngClass]=\"{'sw-hidden': dom.state.allOverlayEnabled}\"\n        [(ngModel)]=\"config.all\"\n        [disabled]=\"config.disabled\"\n        [color]=\"'primary'\"\n        matTooltip=\"Toggle All\"\n        matTooltipPosition=\"above\"\n        (change)=\"onAllChange($event.checked);\">\n      </mat-checkbox>\n\n      <mat-form-field *ngIf=\"config.filter && ui.search.config\" appearance=\"none\" floatLabel=\"never\" class=\"sw-search\"\n                      [ngClass]=\"{'sw-hidden': dom.state.allOverlayEnabled}\">\n        <a matPrefix>\n          <mat-icon>search</mat-icon>\n        </a>\n        <input matInput placeholder=\"Search\"\n               #search\n               type=\"text\"\n               [formControl]=\"ui.search.config.control\">\n        <mat-icon *ngIf=\"ui.search.config.control.value\" class=\"pop-select-list-clear sw-pointer\" matSuffix\n                  (click)=\"onClearSearch();\">\n          close\n        </mat-icon>\n      </mat-form-field>\n\n      <mat-checkbox\n        *ngIf=\"config.multiple && config.allowAll && config.checkboxPosition === 'after'\"\n        class=\"pop-select-list-checkbox-after\"\n        [ngClass]=\"{'sw-hidden': dom.state.allOverlayEnabled}\"\n        [(ngModel)]=\"config.all\"\n        [color]=\"'primary'\"\n        [disabled]=\"config.disabled\"\n        matTooltip=\"Toggle All\"\n        matTooltipPosition=\"above\"\n        (change)=\"onAllChange($event.checked);\">\n      </mat-checkbox>\n      <div *ngIf=\"dom.state.allOverlayEnabled && config.allOverlayMessage\" class=\"pop-select-list-overlay-message\"\n           [innerHTML]=config.allOverlayMessage></div>\n    </div>\n\n\n    <mat-selection-list [style.minHeight.px]=config.minHeight [style.maxHeight.px]=config.height #selectionList [multiple]=config.multiple>\n      <div *ngFor=\"let group of config.groups\" [ngClass]=\"{'sw-hidden': dom.state.allOverlayEnabled}\">\n        <div class=\"pop-select-list-option-header\" [ngClass]=\"{'pop-select-list-option-header-open': group.open, 'pop-select-list-option-header-before': config.checkboxPosition === 'before', 'pop-select-list-option-header-after': config.checkboxPosition !== 'before'}\" *ngIf=\"group.label && group.visible\">\n          <mat-checkbox\n            *ngIf=\"config.multiple && config.checkboxPosition === 'before'\"\n            [ngClass]=\"{'sw-disabled': !config.allowGroupAll}\"\n            [(ngModel)]=\"group.all\"\n            [color]=\"'primary'\"\n            [indeterminate]=group.indeterminate\n            matTooltip=\"Toggle Group\"\n            matTooltipPosition=\"above\"\n            (change)=\"onGroupChange($event.checked, group);\">\n          </mat-checkbox>\n          <div class=\"pop-select-list-header-label\" (click)=\"onToggleGroup(group);\">{{group.label}}\n            ({{group.options.values.length}})\n          </div>\n          <mat-checkbox\n            *ngIf=\"config.multiple && config.checkboxPosition === 'after'\"\n            [ngClass]=\"{'sw-disabled': !config.allowGroupAll}\"\n            [(ngModel)]=\"group.all\"\n            [color]=\"'primary'\"\n            [indeterminate]=group.indeterminate\n            matTooltip=\"Toggle Group\"\n            matTooltipPosition=\"above\"\n            (change)=\"onGroupChange($event.checked, group);\">\n          </mat-checkbox>\n        </div>\n\n        <mat-list-option\n          *ngFor=\"let option of group.options.values\"\n          [checkboxPosition]=config.checkboxPosition\n          [disabled]=\"config.disabled\"\n          class=\"pop-select-list-option\"\n          [ngClass]=\"{'pop-select-list-active': isOptionActive(option), 'sw-disabled': isOptionDisabled(option),'sw-hidden': isOptionHidden(group, option), 'pop-select-list-checkbox-before': config.checkboxPosition === 'before', 'pop-select-list-checkbox-after': config.checkboxPosition === 'after'}\"\n          [style.paddingLeft]=\"option.indentation+'px'\"\n          [selected]=isOptionSelected(option)\n          (click)=\"onOptionChange($event, option, group);\"\n          [value]=\"option.value\">\n          {{option.name}}\n          <div *ngIf=\"config.multiple && config.mode\" class=\"pop-select-list-mode-toggle\"\n               (click)=\"$event.stopPropagation()\">\n            <mat-button-toggle-group [(ngModel)]=\"option.mode\" (ngModelChange)=\"onOptionModeChange($event, option)\"\n                                     name=\"model\" aria-label=\"Mode\">\n              <mat-button-toggle *ngFor=\"let mode of config.mode\"\n                                 value=\"{{mode.value}}\">{{mode.name}}</mat-button-toggle>\n            </mat-button-toggle-group>\n          </div>\n        </mat-list-option>\n\n      </div>\n      <lib-pop-field-item-loader\n        [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n    </mat-selection-list>\n  </div>\n</div>\n",
                styles: [".pop-select-list-container{position:relative;display:block;padding:5px 0 0;margin:10px 0 0;box-sizing:border-box;border-top-style:none;border-radius:3px}.pop-select-list-items{border:1px solid var(--border)}.pop-select-list-label{height:15px;margin-bottom:var(--gap-s)}.pop-select-search-header{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:stretch;border-bottom:1px solid var(--border);background:var(--background-base);padding-left:5px}.mat-form-field{padding:0 10px}.sw-search{margin-top:-16px}.sw-search,.sw-search .mat-form-field-flex{display:flex;flex-grow:1}.pop-select-all-header{display:flex;flex-direction:row;-webkit-tap-highlight-color:transparent;width:100%;justify-content:space-between;align-items:center;box-sizing:border-box;padding:0 10px 0 15px;cursor:pointer;height:30px;outline:0;background:var(--bg-3)}.pop-select-header-label{position:relative;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-style:italic;font-weight:700;font-size:16px}.pop-select-list-helper-icon{position:absolute;right:1px;top:4px;font-size:.7em;z-index:2}.mat-form-field{display:block;height:30px}.pop-select-list-option{box-sizing:border-box;background:var(--background-2);height:30px;padding:0 5px}.expand-to-container{position:absolute!important;top:0;left:0;bottom:0;right:0;box-sizing:border-box!important;-moz-box-sizing:border-box}.pop-select-list-feedback{z-index:4;position:absolute;top:0;right:0;display:flex;flex-flow:row;align-items:center;justify-content:center}.pop-select-list-option-header{display:flex;flex-direction:row;-webkit-tap-highlight-color:transparent;padding:0;justify-content:flex-start;align-items:center;box-sizing:border-box;cursor:pointer;height:30px;border-top:1px solid var(--border)!important;background:var(--background-item-menu);outline:0}.pop-select-list-option-header ::ng-deep .mat-checkbox{margin-right:1px!important}.pop-select-list-option-header-before{padding:0 4px 0 20px!important}.pop-select-list-option-header-after{padding:0 4px!important}.pop-select-list-option-header-open{border-bottom:1px solid var(--border)!important}.pop-select-option-header:hover{background:var(--background-hover)}.pop-select-list-header-label{position:relative;flex:1;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:700;font-size:16px;padding-left:var(--gap-xs)}.pop-select-list-clear{position:relative;top:3px}.pop-select-list-overlay{background:var(--background-base);padding:0 var(--gap-xs)!important}.pop-select-list-overlay ::ng-deep .import-field-item-container{margin:0}.pop-select-list-overlay:hover:not(:focus){background:var(--accent-shade)!important}.pop-select-list-overlay-message{display:flex;align-items:center;justify-content:center;height:40px;width:100%}.select-list-error-icon{position:absolute;top:13px;left:2px}.pop-select-list-mode-toggle{position:absolute;top:5px;min-width:50px;padding:2px;right:40px}.pop-select-list-mode-toggle ::ng-deep .mat-button-toggle-group{height:20px;background:var(--background-base)}.pop-select-list-mode-toggle ::ng-deep .mat-button-toggle-label-content{line-height:12px;font-size:12px;color:var(--foreground-base)!important}.pop-select-list-mode-toggle ::ng-deep .mat-button-toggle-checked{background:var(--accent-background)!important}.select-ajax-spinner{position:absolute;z-index:2}.pop-select-list-active{background:var(--background-code)!important;color:var(--background-base)!important}.pop-select-list-checkbox-after{margin-right:-2px}:host ::ng-deep .checkbox-after{direction:rtl}:host ::ng-deep .checkbox-after .mat-checkbox-layout{width:100%}:host ::ng-deep .checkbox-after .mat-checkbox-layout .mat-checkbox-inner-container{margin:0 9px 0 auto}:host ::ng-deep .mat-checkbox-inner-container{margin:0 0 0 16px}:host ::ng-deep .pop-select-search-header .mat-checkbox-inner-container{margin:0 0 0 16px!important}:host ::ng-deep .mat-checkbox-label{padding:0 0 0 16px}:host ::ng-deep .mat-list-item-content-reverse{padding:0 10px 0 5px!important}:host ::ng-deep mat-selection-list{overflow-y:scroll;overflow-x:hidden;outline:0!important;background:transparent!important}:host ::ng-deep mat-list-option{border:none!important}.pop-select-list-option:hover:not(:focus){background:var(--accent-shade)!important}:host ::ng-deep .pop-select-list-checkbox-before .mat-pseudo-checkbox{margin-right:16px}:host ::ng-deep .pop-select-list-checkbox-before .mat-list-text{flex:1}:host ::ng-deep .pop-select-list-option-header .mat-checkbox-inner-container{width:16px!important;height:16px!important;margin:0 0 0 1px!important}:host ::ng-deep .pop-select-list-option-header .mat-checkbox-label{padding:0 10px 0 0}:host ::ng-deep .filter-selected .pop-input-container{background-color:var(--bg-3)!important}:host ::ng-deep .pop-input-container{margin:0!important}:host ::ng-deep .filter-option-selected .pop-input-container{background-color:var(--accent-shade)!important}:host ::ng-deep .mat-list-base{padding:0!important;margin:0!important;border:0!important}:host ::ng-deep .mat-list-text{display:block;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;padding:0!important;padding-left:var(--gap-s)}"]
            },] }
];
PopSelectListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopSelectListComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }],
    selectionListRef: [{ type: ViewChild, args: ['selectionList', { static: true },] }],
    searchRef: [{ type: ViewChild, args: ['search',] }]
};

class PopSelectModalDialogComponent extends PopFieldItemComponent {
    constructor(el, dialog, data) {
        super();
        this.el = el;
        this.dialog = dialog;
        this.data = data;
        this.name = 'PopSelectModalDialogComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.height.outer = 570;
                this.dom.height.inner = 520;
                this.config.list.minHeight = 400;
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    confirm() {
        // this.config.list.control.setValue('', { emitEvent: false });
        this.dom.setTimeout(`dialog-confirm`, () => {
            this.dialog.close(this.config.list);
        }, 0);
    }
    cancel() {
        // this.config.list.control.setValue('', { emitEvent: false });
        this.dom.setTimeout(`dialog-close`, () => {
            this.dialog.close(null);
        }, 0);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopSelectModalDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select-modal-dialog',
                template: "<div class=\"pop-select-modal-container import-field-item-container\" [style.height.px]=dom.height.outer>\n  <mat-progress-bar [ngClass]=\"{'sw-hidden': dom.state.loaded}\" mode=\"determinate\" [value]=dom.state.progress></mat-progress-bar>\n  <div class=\"pop-select-modal-wrapper\" [style.height.px]=dom.height.inner *ngIf=\"dom.state.loaded\">\n    <div class=\"mat-h2 pop-select-modal-header\">{{config.header}}</div>\n    <div class=\"pop-select-modal-content\">\n      <lib-pop-select-list [config]=config.list></lib-pop-select-list>\n    </div>\n  </div>\n  <div class=\"pop-select-modal-actions\">\n    <button class=\"pop-select-modal-btn\" mat-raised-button (click)=\"cancel()\" cdkFocusInitial>Cancel</button>\n    <button class=\"pop-select-modal-btn\" [disabled]=\"!config.list.control.value\" mat-raised-button (click)=\"confirm()\">Ok</button>\n  </div>\n</div>\n",
                styles: [":host{flex-direction:column}.pop-select-modal-container{position:absolute;top:0;left:0;right:0;padding:0 var(--gap-s);overflow-y:hidden;box-sizing:border-box}.pop-select-modal-wrapper{display:flex;flex-direction:column}.pop-select-modal-wrapper>div{flex:1}.pop-select-modal-header{text-align:center;max-height:35px}.pop-select-modal-content{flex:1 1 100%;flex-direction:column;overflow-y:auto;overflow-x:hidden}.pop-select-modal-actions{display:flex;flex-flow:row;align-items:center;justify-content:flex-end;padding:var(--gap-xs) var(--gap-s);max-height:50px;box-sizing:border-box}.pop-select-modal-btn{min-width:120px;margin-left:var(--gap-s)}:host ::ng-deep .mat-dialog-container{padding:2px!important;border:1px solid!important}"]
            },] }
];
PopSelectModalDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
PopSelectModalDialogComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopSelectModalComponent extends PopFieldItemComponent {
    constructor() {
        super();
        this.events = new EventEmitter();
        this.name = 'PopSelectModalComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
        };
        this.asset = {
            original: undefined,
            dialogRef: undefined
        };
        this.ui = {
            anchorInput: undefined,
            dialogRef: undefined
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.triggerOpen = () => {
                    this.dom.setTimeout(``, () => {
                        this.onChangeOptions();
                    }, 0);
                };
                this.ui.anchorInput = new InputConfig({
                    label: this.config.label,
                    value: this.config.list.strVal,
                    selectMode: true,
                    maxlength: 2048,
                });
                return resolve(true);
            });
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onChangeOptions() {
        this.dom.active.storedValue = this.config.list.strVal;
        this.asset.dialogRef = this.srv.dialog.open(PopSelectModalDialogComponent, {
            width: `450px`,
            height: `600px`,
            panelClass: 'sw-relative',
            data: {}
        });
        this.asset.original = {
            all: JsonCopy(this.config.list.all),
            selectedOptions: this.config.list.multiple ? JsonCopy(this.config.control.value) : [],
            groups: JsonCopy(this.config.list.groups),
            strVal: JsonCopy(this.config.list.strVal),
        };
        this.asset.dialogRef.componentInstance.config = this.config;
        this.dom.setSubscriber(`select-dialog`, this.asset.dialogRef.beforeClosed().subscribe((list) => {
            if (list && list.strVal !== this.dom.active.storedValue) {
                this.config.control.setValue(list.control.value);
                if (!list.multiple)
                    list.value = list.control.value;
                // console.log('list', list);
                this.ui.anchorInput.triggerOnChange(list.strVal);
                this.ui.anchorInput.message = '';
                this.onChange();
            }
            else {
                this.config.list.all = this.asset.original.all;
                this.config.list.selectedOptions = this.asset.original.selectedOptions;
                this.config.list.value = this.asset.original.selectedOptions;
                this.config.list.groups = this.asset.original.groups;
                this.config.list.strVal = this.asset.original.strVal;
            }
            this.asset.dialogRef = null;
        }));
        this.dom.setTimeout(`search-focus`, () => {
            if (IsCallableFunction(this.asset.dialogRef.componentInstance.config.list.focusSearch))
                this.asset.dialogRef.componentInstance.config.list.focusSearch();
        }, 200);
    }
    // displaySuccess(): void{
    //   this.ui.anchorInput.message = '';
    //   this.ui.anchorInput.patch.success = true;
    //   setTimeout(() => {
    //     this.ui.anchorInput.patch.success = false;
    //   }, 1000);
    // }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set up the body of the api patch
     * @param value
     * @private
     */
    _getPatchBody(value) {
        const body = {};
        if (!value)
            value = this.config.list.multiple ? (this.config.list.control.value.length ? this.config.list.control.value : []) : this.config.list.control.value;
        if (this.config.list.all) {
            if (typeof this.config.list.allValue !== 'undefined') {
                body[this.config.patch.field] = this.config.list.allValue;
            }
            else if (this.config.list.patchGroupFk) {
                body[this.config.patch.field] = [];
                this.config.list.groups.map((group) => {
                    body[this.config.patch.field].push(`0:${group.groupFk}`);
                });
            }
            else {
                body[this.config.patch.field] = value;
            }
        }
        else {
            if (!this.config.list.selectedOptions.length && typeof this.config.list.emptyValue !== 'undefined') {
                body[this.config.patch.field] = this.config.list.emptyValue;
            }
            else if (this.config.list.patchGroupFk) {
                body[this.config.patch.field] = [];
                this.config.list.groups.map((group) => {
                    if (group.all) {
                        body[this.config.patch.field].push(`0:${group.groupFk}`);
                    }
                    else {
                        group.options.values.filter((option) => {
                            return option.selected;
                        }).map((option) => {
                            body[this.config.patch.field].push(`${option.value}:${group.groupFk}`);
                        });
                    }
                });
            }
            else {
                body[this.config.patch.field] = value;
            }
        }
        if (IsArray(body[this.config.patch.field], true)) {
            body[this.config.patch.field] = ArrayOnlyUnique(body[this.config.patch.field]);
            body[this.config.patch.field].sort(function (a, b) {
                return a - b;
            });
        }
        if (this.config.patch.metadata) {
            for (const i in this.config.patch.metadata) {
                if (!this.config.patch.metadata.hasOwnProperty(i))
                    continue;
                body[i] = this.config.patch.metadata[i];
            }
        }
        if (this.config.patch.json)
            body[this.config.patch.field] = JSON.stringify(body[this.config.patch.field]);
        return body;
    }
}
PopSelectModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-select-modal',
                template: "<div class=\"pop-select-modal-container import-field-item-container\" *ngIf=\"dom.state.loaded\">\n  <lib-pop-input class=\"pop-select-modal-values\" (click)=\"onChangeOptions();\" [config]=\"ui.anchorInput\"></lib-pop-input>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".pop-select-modal-container{position:relative;box-sizing:border-box;margin:10px 0}:host ::ng-deep .pop-input-container{margin:0!important}:host ::ng-deep .pop-select-modal-values .mat-form-field-infix{padding:8px 20px 13px 0!important}:host ::ng-deep .pop-select-modal-values input{display:flex;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:100%;pointer-events:none!important;box-sizing:border-box}:host ::ng-deep .pop-select-modal-values .mat-form-field-infix{pointer-events:none!important}"]
            },] }
];
PopSelectModalComponent.ctorParameters = () => [];
PopSelectModalComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopButtonComponent {
    constructor() {
        this.config = new ButtonConfig();
        this.events = new EventEmitter();
        this.name = 'PopButtonComponent';
    }
    ngOnInit() {
    }
    onClick(event) {
        this.emitInputEvent(this.config.event);
    }
    emitInputEvent(name, message = null) {
        if (this.config.bubble)
            this.events.emit({ source: this.name, type: 'field', name: name, config: this.config, message: message });
    }
    ngOnDestroy() {
    }
}
PopButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-button',
                template: "<!--<div class=\"pop-button-container\" [ngClass]=\"{'sw-hidden': config.hidden}\">-->\n<!--  <button [type]=config.type-->\n<!--          matTooltipClass=\"button-tooltip-background\"-->\n<!--          [hidden]=config.hidden>-->\n<!--    {{config.label}}-->\n<!--  </button>-->\n<!--</div>-->\n\n<div class=\"pop-button-container\" [ngClass]=\"{'sw-hidden': config.hidden}\">\n  <button *ngIf=\"config.type !== 'mat-flat-button'\"\n      [style.borderRadius.px]=\"config.radius\"\n      mat-raised-button\n      [style.height.px]=\"config.size\"\n      [style.minWidth.px]=\"config.width\"\n      matTooltipClass=\"button-tooltip-background\"\n      [hidden]=config.hidden\n      [disabled]=config.disabled\n      [color]=config.color\n      (click)=\"onClick($event)\">\n    <div class=\"pop-button-content\"\n         [style.fontSize.px]=\"config.text\"\n         [style.lineHeight.px]=\"config.text\">\n      <span *ngIf=\"config.value\">{{ config.value }}</span>\n      <div *ngIf=\"config.icon && config.value\" class=\"sw-mar-hrz-xs\"></div>\n      <mat-icon\n          *ngIf=\"config.icon\"\n          [style.fontSize.px]=\"config.text\"\n          [color]=config.iconColor>\n        {{ config.icon }}\n      </mat-icon>\n    </div>\n  </button>\n  <button *ngIf=\"config.type === 'mat-flat-button'\"\n          [style.borderRadius.px]=\"config.radius\"\n          mat-flat-button\n          [style.height.px]=\"config.size\"\n          [style.minWidth.px]=\"config.width\"\n          matTooltipClass=\"button-tooltip-background\"\n          [hidden]=config.hidden\n          [disabled]=config.disabled\n          [color]=config.color\n          (click)=\"onClick($event)\">\n    <div class=\"pop-button-content\"\n         [style.fontSize.px]=\"config.text\"\n         [style.lineHeight.px]=\"config.text\">\n      <span *ngIf=\"config.value\">{{ config.value }}</span>\n      <div *ngIf=\"config.icon && config.value\" class=\"sw-mar-hrz-xs\"></div>\n      <mat-icon\n        *ngIf=\"config.icon\"\n        [style.fontSize.px]=\"config.text\"\n        [color]=config.iconColor>\n        {{ config.icon }}\n      </mat-icon>\n    </div>\n  </button>\n</div>\n",
                styles: [":host ::ng-deep .mat-raised-button{min-width:0;padding:0 5px!important;line-height:normal!important}:host ::ng-deep .mat-raised-button mat-icon{width:auto;line-height:normal}:host ::ng-deep button{flex:1;justify-content:space-around;align-items:center;font-size:1em!important;line-height:normal;outline:0;border:1px solid var(--border)!important}.pop-button-content{display:flex;align-items:center;justify-content:space-between;padding:5px;box-sizing:border-box}:host ::ng-deep .mat-icon{height:auto!important;width:auto!important}"]
            },] }
];
PopButtonComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopMinMaxComponent extends PopFieldItemComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.name = 'PopMinMaxComponent';
        this.asset.delay = 250;
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configure: - this.config`) ? this.config : null;
                this.config.triggerOnChange = (value) => {
                    this._setControlValue();
                    this.cdr.detectChanges();
                    this.onChange(value, true);
                };
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onIsMaxEvent(event) {
        if (this._isFieldChange(event)) {
            this.config.maxConfig.control.setValue((event.config.control.value ? (+this.config.control.value[this.config.minColumn] ? +this.config.control.value[this.config.minColumn] : +this.config.maxDefaultValue) : null));
            this._triggerMaxChange();
        }
    }
    onIsMinEvent(event) {
        if (this._isFieldChange(event)) {
            console.log('onIsMinEvent', event.config.control.value);
            this.config.minConfig.control.setValue((event.config.control.value ? +this.config.minDefaultValue : null));
        }
    }
    onMinEvent(event) {
        // console.log('onMinEvent', event);
        if (this._isFieldChange(event)) {
            this._triggerMinChange();
        }
    }
    onMaxEvent(event) {
        // console.log('onMaxEvent', event);
        if (this._isFieldChange(event)) {
            this._triggerMaxChange();
        }
    }
    onDecrementMin() {
        const control = this.config.minConfig.control;
        const newVal = +this.config.minConfig.control.value - 1;
        if ((newVal) >= 1) {
            control.setValue(newVal);
            this._triggerMinChange();
        }
    }
    onIncrementMin() {
        const control = this.config.minConfig.control;
        const newVal = +this.config.minConfig.control.value + 1;
        const maxVal = +this.config.maxConfig.control.value;
        if ((newVal) <= maxVal) {
            control.setValue(newVal);
            this.dom.setTimeout('on-change', () => {
                this._clearMessage();
                this._setControlValue();
                this.onChange(undefined, true);
            }, this.asset.delay);
        }
    }
    onDecrementMax() {
        const control = this.config.maxConfig.control;
        const newVal = +this.config.maxConfig.control.value - 1;
        if ((newVal) >= 1) {
            control.setValue(newVal);
            this._triggerMaxChange();
        }
    }
    onIncrementMax() {
        const control = this.config.maxConfig.control;
        const newVal = +this.config.maxConfig.control.value + 1;
        if ((newVal) <= this.config.limit) {
            control.setValue(newVal);
            this._triggerMaxChange();
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _triggerMinChange() {
        this.dom.setTimeout('on-change', () => {
            this._clearMessage();
            this._setControlValue();
            this.onChange(undefined, true);
        }, this.asset.delay);
    }
    _triggerMaxChange() {
        this.dom.setTimeout('on-change', () => {
            this._clearMessage();
            this._updateMinOptions();
            this._setControlValue();
            this.onChange(undefined, true);
        }, this.asset.delay);
    }
    _updateMinOptions() {
        // let minLimit = this.config.maxConfig.control.value;
        // const minOptions = [];
        // while( minLimit ){
        //   minOptions.push({ value: minLimit, name: minLimit, sort: minLimit });
        //   minLimit--;
        // }
        // this.config.minConfig.options = minOptions;
    }
    _setControlValue() {
        const maxValue = this.config.maxConfig.control.value;
        let minValue = this.config.minConfig.control.value;
        if (!this.config.allowNegative && minValue < 0) {
            minValue = 0;
            this.config.minConfig.control.setValue(minValue);
        }
        if (maxValue && +minValue > +maxValue) {
            minValue = maxValue;
            this.config.minConfig.control.setValue(minValue);
        }
        const value = {};
        value[this.config.minColumn] = (minValue ? +minValue : minValue);
        value[this.config.maxColumn] = (maxValue ? +maxValue : maxValue);
        this.config.control.value = value;
    }
}
PopMinMaxComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-min-max',
                template: "<div class=\"pop-minmax-container import-field-item-container import-flex-column\">\n  <div class=\"pop-minmax-feedback\" *ngIf=\"!config.minimal\">\n    <div class=\"pop-minmax-error-icon sw-pointer\"\n      [ngClass]=\"{'sw-hidden': !config.message}\"\n      matTooltipPosition=\"left\"\n      [matTooltip]=config.message>\n      <mat-icon color=\"warn\">info</mat-icon>\n    </div>\n  </div>\n  <div class=\"import-flex-row\">\n    {{config.label}}\n    <span\n      *ngIf=\"config.helpText\"\n      class=\"pop-minmax-helper-icon sw-pointer sw-pop-icon\"\n      (mouseenter)=\"dom.state.helper = true\"\n      (mouseleave)=\"dom.state.helper = false\"\n      matTooltip=\"{{config.helpText}}\"\n      matTooltipPosition=\"right\">X\n      </span>\n  </div>\n  <div class=\"import-flex-column pop-minmax-content\" [ngClass]=\"{'sw-disabled': config.patch.running}\">\n    <div class=\"import-flex-row import-flex-item-full\">\n      <div class=\"import-flex-item-md import-flex-grow-xs\">\n        <lib-pop-switch [config]=config.isMinConfig (events)=\"onIsMinEvent($event);\"></lib-pop-switch>\n      </div>\n      <div class=\"import-flex-item-xs sw-relative\">\n      </div>\n      <div class=\"import-flex-item-sm\">\n        <lib-pop-number *ngIf=\"config.isMinConfig.control.value\" [config]=config.minConfig (events)=\"onMaxEvent($event);\"></lib-pop-number>\n      </div>\n      <div class=\"import-flex-item-xs sw-relative\">\n      </div>\n    </div>\n\n    <div class=\"import-flex-row import-flex-item-full\">\n      <div class=\"import-flex-item-md import-flex-grow-xs\">\n        <lib-pop-switch [config]=config.isMaxConfig (events)=\"onIsMaxEvent($event);\"></lib-pop-switch>\n      </div>\n\n      <div class=\"import-flex-item-xs sw-relative\">\n      </div>\n\n      <div class=\"import-flex-item-sm\">\n        <lib-pop-number [ngClass]=\"{'sw-disabled': !config.isMaxConfig.control.value}\" [config]=config.maxConfig (events)=\"onMaxEvent($event);\"></lib-pop-number>\n      </div>\n      <div class=\"import-flex-item-xs sw-relative\">\n      </div>\n    </div>\n  </div>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".import-text-xs{font-size:.8em}.import-text-sm{font-size:.9em}.import-text-md{font-size:1em}.import-text-lg{font-size:1.1em}.import-text-xlg{font-size:1.2em}.sw-pad-xs{padding:var(--xs)}.sw-pad-md,.sw-pad-sm{padding:var(--md)}.sw-pad-lg{padding:var(--lg)}.sw-pad-xlg{padding:var(--xlg)}.sw-pad-hrz-xs{padding-left:var(--xs);padding-right:var(--xs)}.sw-pad-hrz-sm{padding-left:var(--sm);padding-right:var(--sm)}.sw-pad-hrz-md{padding-left:var(--md);padding-right:var(--md)}.sw-pad-hrz-lg{padding-left:var(--lg);padding-right:var(--lg)}.sw-pad-hrz-xlg{padding-left:var(--xlg);padding-right:var(--xlg)}.sw-pad-vrt-xs{padding-top:var(--xs);padding-bottom:var(--xs)}.sw-pad-vrt-md,.sw-pad-vrt-sm{padding-top:var(--md);padding-bottom:var(--md)}.sw-pad-vrt-lg{padding-top:var(--lg);padding-bottom:var(--lg)}.sw-pad-vrt-xlg{padding-top:var(--xlg);padding-bottom:var(--xlg)}.sw-pad-lft-xs{padding-left:var(--xs)}.sw-pad-lft-sm{padding-left:var(--sm)}.sw-pad-lft-md{padding-left:var(--md)}.sw-pad-lft-lg{padding-left:var(--lg)}.sw-pad-lft-xlg{padding-left:var(--xlg)}.sw-pad-rgt-xs{padding-right:var(--xs)}.sw-pad-rgt-sm{padding-right:var(--sm)}.sw-pad-rgt-md{padding-right:var(--md)}.sw-pad-rgt-lg{padding-right:var(--lg)}.sw-pad-rgt-xlg{padding-right:var(--xlg)}.sw-pad-btm-xs{padding-bottom:var(--xs)}.sw-pad-btm-sm{padding-bottom:var(--sm)}.sw-pad-btm-md{padding-bottom:var(--md)}.sw-pad-btm-lg{padding-bottom:var(--lg)}.sw-pad-btm-xlg{padding-bottom:var(--xlg)}.sw-pad-top-xs{padding-top:var(--xs)}.sw-pad-top-sm{padding-top:var(--sm)}.sw-pad-top-md{padding-top:var(--md)}.sw-pad-top-lg{padding-top:var(--lg)}.sw-pad-top-xlg{padding-top:var(--xlg)}.sw-mar-xs{margin:var(--xs)}.sw-mar-sm{margin:var(--sm)}.sw-mar-md{margin:var(--md)}.sw-mar-lg{margin:var(--lg)}.sw-mar-xlg{margin:var(--xlg)}.sw-mar-hrz-xs{margin-left:var(--xs);margin-right:var(--xs)}.sw-mar-hrz-md,.sw-mar-hrz-sm{margin-left:var(--md);margin-right:var(--md)}.sw-mar-hrz-lg{margin-left:var(--lg);margin-right:var(--lg)}.sw-mar-hrz-xlg{margin-left:var(--xlg);margin-right:var(--xlg)}.sw-mar-vrt-xs{margin-top:var(--xs);margin-bottom:var(--xs)}.sw-mar-vrt-md,.sw-mar-vrt-sm{margin-top:var(--md);margin-bottom:var(--md)}.sw-mar-vrt-lg{margin-top:var(--lg);margin-bottom:var(--lg)}.sw-mar-vrt-xlg{margin-top:var(--xlg);margin-bottom:var(--xlg)}.sw-mar-lft-xs{margin-left:var(--xs)}.sw-mar-lft-sm{margin-left:var(--sm)}.sw-mar-lft-md{margin-left:var(--md)}.sw-mar-lft-lg{margin-left:var(--lg)}.sw-mar-lft-xlg{margin-left:var(--xlg)}.sw-mar-rgt-xs{margin-right:var(--xs)}.sw-mar-rgt-sm{margin-right:var(--sm)}.sw-mar-rgt-md{margin-right:var(--md)}.sw-mar-rgt-lg{margin-right:var(--lg)}.sw-mar-rgt-xlg{margin-right:var(--xlg)}.sw-mar-btm-xs{margin-bottom:var(--xs)}.sw-mar-btm-sm{margin-bottom:var(--sm)}.sw-mar-btm-md{margin-bottom:var(--md)}.sw-mar-btm-lg{margin-bottom:var(--lg)}.sw-mar-btm-xlg{margin-bottom:var(--xlg)}.sw-mar-top-xs{margin-top:var(--xs)}.sw-mar-top-sm{margin-top:var(--sm)}.sw-mar-top-md{margin-top:var(--md)}.sw-mar-top-lg{margin-top:var(--lg)}.sw-mar-top-xlg{margin-top:var(--xlg)}:host{position:relative;display:block;width:100%;box-sizing:border-box}.pop-minmax-container ::ng-deep .mat-slide-toggle-content{padding-right:5px!important}.pop-minmax-container ::ng-deep .pop-minmax-content .mat-form-field-infix{width:auto;padding:6px 0!important;margin-top:6px!important;border:0!important;font-size:.9em}.pop-minmax-label{display:flex;justify-content:flex-start;align-items:center}.pop-minmax-content{min-height:40px;clear:both;font-size:.9em}.pop-minmax-content-section{min-height:40px}.pop-minmax-helper-icon{position:relative;top:4px;margin-left:5px;font-size:.7em;z-index:2}.pop-minmax-feedback{position:absolute;top:0;right:5px;width:20px;height:20px}.pop-minmax-error-icon{position:relative;z-index:2;top:-2px}"]
            },] }
];
PopMinMaxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopMinMaxComponent.propDecorators = {
    config: [{ type: Input }]
};

class SliderConfig {
    constructor(params) {
        this.autoTicks = false;
        this.bubble = false;
        this.column = 'column';
        this.displayErrors = true;
        this.disabled = false;
        this.facade = false;
        this.helpText = '';
        this.label = '';
        this.message = '';
        this.max = 100;
        this.min = 1;
        this.noInitialValue = false;
        this.options = [];
        this.step = 1;
        this.showTooltip = false;
        this.showTicks = true;
        this.thumbLabel = true;
        this.tickInterval = 1;
        this.tooltip = '';
        this.value = null;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!this.patch)
            this.patch = { field: '', duration: 750, path: '', disabled: false, businessId: 0 };
        if (this.patch.displayIndicator !== false)
            this.patch.displayIndicator = true;
        if (this.min > this.max) {
            this.min = this.max;
        }
        if (this.noInitialValue)
            this.value = '';
        if (!this.control)
            this.setControl();
    }
    setControl() {
        this.control = (this.disabled ? new FormControl({
            value: this.value,
            disabled: true
        }) : new FormControl(this.value, (this.validators ? this.validators : [])));
    }
}

class PopSliderComponent extends PopFieldItemComponent {
    constructor() {
        super();
        this.config = new SliderConfig();
        this.events = new EventEmitter();
        this.name = 'PopSliderComponent';
        this.dom.state.helper = false;
        this.dom.state.tooltip = false;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * On Change event
     * @param value
     * @param force
     */
    onChange(value, force = false) {
        const control = this.config.control;
        if (typeof value !== 'undefined') {
            control.setValue(value);
            control.markAsDirty();
            control.updateValueAndValidity();
        }
        if (this._isChangeValid()) {
            value = typeof value !== 'undefined' ? value : this.config.control.value;
            value = this._applyTransformation(value);
            if (this.config.patch && this.config.patch && (this.config.patch.path || this.config.facade)) {
                this._onPatch(value, false);
            }
            else {
                this.onBubbleEvent('onChange');
            }
        }
    }
    getSliderTickInterval() {
        if (this.config.showTicks) {
            return this.config.autoTicks ? 'auto' : this.config.tickInterval;
        }
        return 0;
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-slider',
                template: "<div class=\"pop-slider-container import-field-item-container\">\n  <mat-label>Maxlength</mat-label>\n  <div class=\"pop-slider-display\">{{config.value}}</div>\n  <div class=\"pop-slider-feedback-container\">\n    <div class=\"pop-slider-error-icon\"\n         [ngClass]=\"{'sw-hidden': !config.message}\"\n         matTooltipPosition=\"left\"\n         [matTooltip]=config.message>\n      <mat-icon color=\"warn\">info</mat-icon>\n    </div>\n    <!--<lib-main-spinner-->\n      <!--class=\"pop-slider-ajax-spinner\"-->\n      <!--[ngClass]=\"{'sw-hidden': !config.patch || !config.patch.displayIndicator || !config.patch.running}\"-->\n      <!--[options]=\"{strokeWidth:3, color:'accent', diameter:19}\">-->\n    <!--</lib-main-spinner>-->\n  </div>\n  <mat-slider [min]=config.min [step]=config.step (change)=\"onChange($event.value);\" [tickInterval]=\"getSliderTickInterval()\" [max]=config.max [(ngModel)]=\"config.value\" [thumbLabel]=\"config.thumbLabel\"></mat-slider>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".pop-slider-container{display:flex;flex-direction:row;flex-grow:1;justify-content:flex-start;align-items:center;width:100%;box-sizing:border-box;height:40px}:host ::ng-deep mat-label{width:75px}.pop-slider-display{display:flex;min-width:10px;padding:0 2px;text-align:right}.pop-slider-error-icon{position:absolute;z-index:2;margin-top:3px}.pop-slider-feedback-container{position:relative;display:flex;width:30px;height:20px;padding-top:2px;flex-flow:row;align-items:center;justify-content:center}:host ::ng-deep mat-slider{padding:0;vertical-align:top;display:block}:host ::ng-deep .mat-slider-horizontal{display:flex;flex-grow:1}"]
            },] }
];
PopSliderComponent.ctorParameters = () => [];
PopSliderComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopNumberComponent extends PopFieldItemComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.config = new NumberConfig();
        this.name = 'PopNumberComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.triggerOnChange = (value, forcePatch = false) => {
                    this.cdr.detectChanges();
                    this.onChange(value, forcePatch);
                };
                this.config.triggerDirectPatch = (value) => {
                    this._onPatch(value, true);
                };
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Test
     * @param event
     */
    onKeyUp(event) {
        if (event.code === 'Enter') {
            if (this.config.control.invalid) {
                if (this.config.displayErrors)
                    this._setMessage(ValidationErrorMessages(this.config.control.errors));
            }
            else {
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    if (this.config.control.value !== this.asset.storedValue) {
                        if (this._isFieldPatchable()) {
                            this.onChange();
                        }
                    }
                }
            }
        }
        else {
            this.onBubbleEvent('onKeyUp');
        }
    }
    /**
     * Hook that is called right before a patch
     */
    _beforePatch() {
        return new Promise((resolve) => {
            const patch = this.config.patch;
            const control = this.config.control;
            this._checkValue();
            control.disable();
            patch.running = true;
            return resolve(true);
        });
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    _checkValue() {
        const control = this.config.control;
        if (control.value > this.config.max) {
            control.setValue(this.config.max, { emitEvent: false });
        }
        else if (control.value < this.config.min) {
            control.setValue(this.config.min, { emitEvent: false });
        }
    }
}
PopNumberComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-number',
                template: "<div class=\"import-field-item-container pop-number-container\" [ngClass]=\"{'sw-hidden': config.hidden, 'pop-number-minimal': config.minimal, 'pop-number-container-tooltip-adjust': config.tooltip && dom.state.tooltip}\">\n  <div *ngIf=\"config.tooltip && dom.state.tooltip\" [@slideInOut] class=\"pop-number-tooltip-container\" [innerHTML]=config.tooltip></div>\n  <mat-form-field appearance=\"outline\" color=\"accent\" class=\"import-field-item-container-expansion\">\n    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>\n\n    <input\n      type=\"number\"\n      matInput\n      matTooltipClass=\"pop-number-tooltip-background\"\n      [hidden]=config.hidden\n      [min]=config.min\n      [max]=config.max\n      [step]=config.step\n      [formControl]=config.control\n      (keyup)=\"onKeyUp($event);\"\n      (blur)=\"dom.state.tooltip=false; onBlur();\"\n      (focus)=\"dom.state.tooltip= true; onFocus();\"\n      [maxlength]=config.maxlength\n    >\n    <div class=\"pop-number-feedback-container\" matSuffix *ngIf=\"!config.minimal && ( config.message || config.helpText)\">\n      <lib-pop-field-item-error class=\"pop-number-error-icon\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n      <lib-pop-field-item-helper class=\"pop-number-helper-icon\" [hidden]=\"config.message\" [helpText]=config.helpText></lib-pop-field-item-helper>\n    </div>\n  </mat-form-field>\n\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".pop-number-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 0 13px}.pop-number-container ::ng-deep .pop-number-container-minimal .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 0 13px}.pop-number-container .pop-number-container-minimal .mat-form-field-appearance-outline .mat-form-field-wrapper,.pop-number-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.pop-number-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{display:none}.pop-number-container ::ng-deep input[type=number]{text-align:left;min-width:40px;padding-right:5px}.pop-number-feedback-container{top:-4px}.pop-number-error-icon,.pop-number-feedback-container{position:relative;display:flex;justify-content:center;align-items:center;width:20px;height:20px}.pop-number-error-icon{top:5px;font-size:.8em}.pop-number-helper-icon{position:relative;font-size:.8em;top:3px;z-index:2}.pop-number-select-icon{position:absolute;z-index:2;margin-top:3px;color:var(--text-disabled)}.pop-number-ajax-spinner{position:absolute;z-index:1}.pop-number-container-tooltip-adjust{padding-top:45px}.pop-number-tooltip-container{position:absolute;display:block;right:0;left:0;top:0;height:40px;background:var(--accent);border-radius:.25em;padding:.75em;z-index:2;color:var(--primary-text);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;overflow:hidden;text-align:center}:host ::ng-deep .pop-number-minimal .mat-form-field-infix{padding-right:2px!important}"]
            },] }
];
PopNumberComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopNumberComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopFieldItemLoaderComponent {
    constructor() {
        this.show = false;
    }
    ngOnInit() {
    }
}
PopFieldItemLoaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-item-loader',
                template: `
    <mat-progress-bar
      class="pop-field-item-loader"
      *ngIf="show"
      [style.height.px]="1"
      [mode]="'query'"
    >
    </mat-progress-bar>
  `,
                styles: [':host { position: absolute; bottom:0; left: 0; right: 0 }']
            },] }
];
PopFieldItemLoaderComponent.propDecorators = {
    show: [{ type: Input }]
};

class PopFieldItemHelperComponent {
    constructor() {
        this.hidden = false;
        if (!this.helpText)
            this.helpText = '';
    }
    ngOnInit() {
    }
}
PopFieldItemHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-item-helper',
                template: `
    <span class="pop-field-item-help-text material-icons sw-pointer"
          *ngIf="!hidden && helpText"
          (mouseenter)="helper = true"
          (mouseleave)="helper = false"
          matTooltip="{{helpText}}"
          matTooltipPosition="above">help_outline
    </span>
  `,
                styles: [`
    .pop-field-item-help-text {
      position: relative;
      font-size: 1.5em;
      color: var(--text-disabled);
      z-index: 2;
    }`]
            },] }
];
PopFieldItemHelperComponent.ctorParameters = () => [];
PopFieldItemHelperComponent.propDecorators = {
    helpText: [{ type: Input }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

class PopFieldItemErrorComponent {
    constructor() {
        this.hidden = false;
        if (!this.message)
            this.message = '';
    }
    ngOnInit() {
    }
}
PopFieldItemErrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-item-error',
                template: `
    <div class="sw-pointer pop-field-item-error"
         *ngIf="!hidden && message"
         matTooltipPosition="left"
         [matTooltip]=message>
      <mat-icon color="warn">error</mat-icon>
    </div>
  `,
                styles: [`.pop-field-item-error {
    width: 20px;
    height: 20px;
    font-size: 1.1em;
    z-index: 2;
  }`]
            },] }
];
PopFieldItemErrorComponent.ctorParameters = () => [];
PopFieldItemErrorComponent.propDecorators = {
    message: [{ type: Input }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

class PopTextComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopTextComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-text',
                template: "<div class=\"import-field-item-container pop-text-container\" [style.padding.px]=\"config.padding\" [ngClass]=\"{'pop-text-border': config.border, 'pop-text-header': config.header, 'pop-text-warning': config.warning, 'pop-text-ellipsis': config.textOverflow === 'ellipsis'}\" *ngIf=\"dom.state.loaded\">\n  <div class=\"import-flex-row import-flex-start-center\">\n    <mat-icon *ngIf=\"config.warning\" class=\"theme-error\">warning_amber</mat-icon>\n    <div class=\"pop-text-value {{config.className}}\" [innerHTML]=\"config.value\"></div>\n  </div>\n</div>\n",
                styles: [".pop-text-container{position:relative;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;-moz-box-sizing:border-box}.pop-text-container .import-flex-row{min-width:0}.pop-text-border{border-radius:3px;border:1px solid var(--border);padding:var(--gap-s)}:host ::ng-deep .pop-text-header .pop-text-value{font-weight:700;font-size:18px}:host ::ng-deep .pop-text-ellipsis .pop-text-value{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host ::ng-deep .import-field-item-container{margin:0!important}:host ::ng-deep mat-icon{margin-right:var(--gap-xs)}"]
            },] }
];
PopTextComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopTextComponent.propDecorators = {
    config: [{ type: Input }]
};

const datePresets = [
    'Today',
    'So Far This Week',
    'This Week',
    'Last Week',
    'Previous Week',
    'Rest of This Week',
    'Next Week',
    'This Month',
    'Last Month',
    'Next Month'
];
class DateRangePanelComponent {
    constructor(dateAdapter, datePicker, calendar) {
        this.dateAdapter = dateAdapter;
        this.datePicker = datePicker;
        this.calendar = calendar;
        this.presets = datePresets;
        this.selected = '';
    }
    /**
     * Apply the preset to Datepicker and Calendar
     * @param datePreset: Example: This week
     */
    selectDatePreset(datePreset) {
        this.selected = datePreset;
        const [start, end] = this.calculateDateRange(datePreset);
        // @ts-ignore
        // if only start is selected we need to set end to clear out start and end.
        if ((this.selected.start !== undefined && !this.calendar.selected.end) || (this.calendar.selected.start && !this.calendar.selected.end)) {
            this.datePicker.select(start);
        }
        this.datePicker.select(start);
        this.datePicker.select(end);
        this.calendar.activeDate = end;
    }
    /**
     * Fix calulations to make monday first day of week instead of sunday
     * @param today
     * @private
     */
    adjDayOfWeekToStartOnMonday(today) {
        let dayOfWeek = this.dateAdapter.getDayOfWeek(today);
        dayOfWeek = dayOfWeek === 0 ? 6 : (dayOfWeek - 1);
        return dayOfWeek;
    }
    /**
     * Calculate date range preset
     * @param datePreset: Example: This week.
     */
    calculateDateRange(datePreset) {
        const today = this.today;
        switch (datePreset) {
            case 'Today':
                return [today, today];
            case 'So Far This Week': {
                const dayOfWeek = this.adjDayOfWeekToStartOnMonday(today);
                const start = this.dateAdapter.addCalendarDays(today, -(dayOfWeek));
                return [start, today];
            }
            case 'This Week': return this.calculateWeek(today);
            case 'Last Week': return this.calculateWeek(this.dateAdapter.addCalendarDays(today, -7));
            case 'Previous Week': return this.calculateWeek(this.dateAdapter.addCalendarDays(today, -14));
            case 'Rest of This Week': {
                const dayOfWeek = this.adjDayOfWeekToStartOnMonday(today);
                const end = this.dateAdapter.addCalendarDays(today, (6 - dayOfWeek));
                return [today, end];
            }
            case 'Next Week': {
                const dayOfWeek = this.adjDayOfWeekToStartOnMonday(today);
                const start = this.dateAdapter.addCalendarDays(today, (7 - dayOfWeek));
                return this.calculateWeek(start);
            }
            case 'This Month': return this.calculateMonth(today);
            case 'Last Month': {
                const thisDayLastMonth = this.dateAdapter.addCalendarMonths(today, -1);
                return this.calculateMonth(thisDayLastMonth);
            }
            case 'Next Month': {
                const thisDayLastMonth = this.dateAdapter.addCalendarMonths(today, 1);
                return this.calculateMonth(thisDayLastMonth);
            }
        }
    }
    /**
     * calculate start and end for week
     * @param forDay
     * @private
     */
    calculateWeek(forDay) {
        const deltaStart = this.dateAdapter.getFirstDayOfWeek() -
            this.dateAdapter.getDayOfWeek(forDay);
        const start = this.dateAdapter.addCalendarDays(forDay, deltaStart);
        const end = this.dateAdapter.addCalendarDays(start, 6);
        return [start, end];
    }
    /**
     * Calculate start and end for month
     * @param forDay
     * @private
     */
    calculateMonth(forDay) {
        const year = this.dateAdapter.getYear(forDay);
        const month = this.dateAdapter.getMonth(forDay);
        const start = this.dateAdapter.createDate(year, month, 1);
        const end = this.dateAdapter.addCalendarDays(start, this.dateAdapter.getNumDaysInMonth(forDay) - 1);
        return [start, end];
    }
    /**
     * Get Today
     * @private
     */
    get today() {
        const today = this.dateAdapter.today();
        if (today === null) {
            throw new Error('date creation failed');
        }
        return today;
    }
}
DateRangePanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-date-range-panel',
                template: "\n<mat-card class=\"pop-datepicker-panel\" >\n  <button\n    class=\"date-preset-button\"\n    [ngClass]=\"{'selected': item === selected}\"\n    *ngFor=\"let item of presets\"\n    mat-button\n    color=\"accent\"\n    (click)=\"selectDatePreset(item)\"\n  >\n    {{ item }}\n  </button>\n</mat-card>\n",
                styles: [":host{position:absolute;width:200px;left:-200px}.pop-datepicker-panel{position:relative;top:-1px;border-left:1px solid #d3d3d3;border-bottom:1px solid #d3d3d3;border-top:1px solid #d3d3d3;border-radius:0;padding:var(--gap-s);height:405px}.date-preset-button,.selected{width:100%;text-align:left}.selected{background:var(--background-side-menu)}"]
            },] }
];
DateRangePanelComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: MatDateRangePicker },
    { type: MatCalendar }
];

class PopDatePickerComponent extends PopFieldItemComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = new DatePickerConfig();
        this.name = 'PopDateComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.config.max = null;
                this.config.triggerOnChange = (value, forcePatch = false) => {
                    this.dom.setTimeout(`config-trigger-change`, () => {
                        // this.cdr.detectChanges();
                        this.onChange(value, forcePatch);
                    }, 0);
                };
                this.config.clearMessage = () => {
                    this.dom.setTimeout(`config-clear-message`, () => {
                        this.config.message = '';
                        this.config.control.markAsPristine();
                        this.config.control.markAsUntouched();
                        // this.cdr.detectChanges();
                    }, 0);
                };
                // this.config.helpText = 'sdfsdafsadf';
                this._setFilter();
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * On Change event
     * @param value
     * @param force
     */
    onChange(value, force = false) {
        if (value) {
            value = PopDate.toIso(value);
        }
        else {
            value = null;
        }
        if (IsObject(this.config, ['control'])) {
            this.log.info(`onChange`, value);
            const control = this.config.control;
            if (typeof value !== 'undefined') {
                control.setValue(value);
                control.markAsDirty();
                control.updateValueAndValidity();
            }
            if (this._isChangeValid()) {
                value = typeof value !== 'undefined' ? value : this.config.control.value;
                value = this._applyTransformation(value);
                if (this.config.patch && (this.config.patch.path || this.config.facade)) {
                    this._onPatch(value, force);
                }
                else {
                    this.onBubbleEvent('onChange');
                }
            }
            else {
                // console.log( 'invalid change', this.config.control.value );
            }
        }
    }
    onResetForm() {
        this.dom.setTimeout(`reset-form`, () => {
            this.config.control.setValue(null, { emitEvent: true });
            this.config.control.updateValueAndValidity();
            this.onChange();
        }, 0);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setFilter() {
        if (typeof this.config.filterPredicate === 'string') {
            switch (String(this.config.filterPredicate).toLowerCase()) {
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day !== 0 && day !== 6;
                    };
                    break;
                case 'weekday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // Prevent Saturday and Sunday from being selected.
                        return day >= 1 && day <= 5;
                    };
                    break;
                case 'monday':
                    this.config.filterPredicate = (d) => {
                        const day = d.getDay();
                        // monday
                        return day === 1;
                    };
                    break;
                default:
                    this.config.filterPredicate = null;
                    break;
            }
        }
    }
}
PopDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-datepicker',
                template: "<div class=\"import-field-item-container pop-date-container\">\n\n  <mat-form-field appearance=\"outline\" color=\"accent\" class=\"import-field-item-container-expansion\">\n    <mat-label *ngIf=\"config.label\">{{config.label}}</mat-label>\n    <div *ngIf=\"config.tooltip && config.showTooltip\" class=\"field-tooltip-msg\" [innerHTML]=config.tooltip></div>\n    <input\n      type=\"text\"\n      matTooltipClass=\"input-tooltip-background\"\n      matInput\n      [matDatepicker]=\"datePicker\"\n      [readonly]=\"config.disabled\"\n      [min]=config.min\n      [max]=config.max\n      [matDatepickerFilter]=config.filterPredicate\n      [formControl]=config.control\n      (blur)=\"config.showTooltip=false; onBlur();\"\n      (focus)=\"config.showTooltip=true; onFocus();\"\n      (dateChange)=\"onChange($event.value);\"\n      placeholder=\"\"\n    >\n  </mat-form-field>\n  <mat-datepicker #datePicker></mat-datepicker>\n  <mat-icon *ngIf=\"!config.disabled\" class=\"sw-pointer date-clear-icon\" (click)=\"onResetForm();\">clear</mat-icon>\n  <mat-datepicker-toggle class=\"date-toggle-icon\" [for]=\"datePicker\"></mat-datepicker-toggle>\n  <lib-pop-field-item-helper class=\"date-helper-icon\" [hidden]=\"!config.helpText\" [helpText]=config.helpText></lib-pop-field-item-helper>\n\n  <div class=\"date-feedback-container\">\n    <lib-pop-field-item-error class=\"date-error-icon\" [hidden]=\"!config.message\" [message]=\"config.message\"></lib-pop-field-item-error>\n  </div>\n  <lib-pop-field-item-loader [show]=\"config.patch.displayIndicator && config.patch.running\"></lib-pop-field-item-loader>\n</div>\n",
                styles: [".pop-date-container{position:relative;display:block;padding:0;margin:10px 0}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{display:none}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-wrapper{padding-bottom:0;margin:0!important}.pop-date-container ::ng-deep .mat-form-field-appearance-outline .mat-form-field-infix{padding:8px 20px 13px 0}.date-feedback-container{position:absolute;top:5px;right:5px;width:20px;bottom:5px;display:flex;padding-top:2px;flex-flow:row;align-items:center;justify-content:center;pointer-events:none}.date-clear-icon{right:42px;top:13px;font-size:1em}.date-clear-icon,.date-toggle-icon{position:absolute!important;width:25px;height:25px;z-index:1}.date-toggle-icon{right:20px;top:8px}.date-toggle-icon ::ng-deep .mat-icon-button{line-height:25px!important}.date-toggle-icon ::ng-deep button{width:25px;height:25px}.date-toggle-icon ::ng-deep button mat-icon{font-size:.9em}.date-error-icon{position:relative;pointer-events:all;left:2px}.date-error-icon ::ng-deep .mat-icon{font-size:1em!important}.date-helper-icon{position:absolute!important;width:25px;height:25px;right:67px;pointer-events:all;font-size:.8em;top:11px}.date-helper-icon ::ng-deep .mat-icon{font-size:.9em!important}.date-ajax-spinner{position:absolute;z-index:1}.field-tooltip-msg{position:absolute;display:block;bottom:50px;width:100%;right:-10px;left:-10px;background:#3d72ea!important;border-radius:.25em;padding:.75em;z-index:2;color:#fff;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;overflow:hidden;text-align:center}:host ::ng-deep .mat-datepicker-content{position:relative;left:150px!important;border-radius:0!important;height:425px;background:var(--background-base);border:1px solid #d3d3d3!important}"]
            },] }
];
PopDatePickerComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopDatePickerComponent.propDecorators = {
    config: [{ type: Input }]
};

// Angular
const options = undefined;
class PopFieldItemModule {
}
PopFieldItemModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    PopIndicatorsModule,
                    MaterialModule,
                    FormsModule,
                    NgxMaskModule.forRoot(options)
                ],
                declarations: [
                    PopFieldItemLoaderComponent,
                    PopFieldItemHelperComponent,
                    PopFieldItemErrorComponent,
                    PopFieldItemComponent,
                    PopButtonComponent,
                    PopInputComponent,
                    PopNumberComponent,
                    PopSelectComponent,
                    PopCheckboxComponent,
                    PopSelectMultiComponent,
                    PopSelectFilterComponent,
                    PopSelectListComponent,
                    PopSelectModalComponent,
                    PopSelectModalDialogComponent,
                    PopRadioComponent,
                    PopSwitchComponent,
                    PopTextareaComponent,
                    PopLabelComponent,
                    PopDateComponent,
                    PopDateRangeComponent,
                    DateRangeExpansionItemsComponent,
                    ExpansionItemsComponent,
                    CustomPanelComponent,
                    DateRangePanelComponent,
                    PopTimeComponent,
                    ClickOutsideDirective,
                    PopButtonComponent,
                    PopMinMaxComponent,
                    PopSliderComponent,
                    PopTextComponent,
                    PopDatePickerComponent
                ],
                exports: [
                    PopFieldItemLoaderComponent,
                    PopFieldItemHelperComponent,
                    PopFieldItemErrorComponent,
                    PopFieldItemComponent,
                    PopButtonComponent,
                    PopInputComponent,
                    PopNumberComponent,
                    PopSelectComponent,
                    PopSelectMultiComponent,
                    PopSelectFilterComponent,
                    PopSelectListComponent,
                    PopSelectModalComponent,
                    PopSelectModalDialogComponent,
                    PopCheckboxComponent,
                    PopRadioComponent,
                    PopSwitchComponent,
                    PopTextareaComponent,
                    PopDateComponent,
                    PopDateRangeComponent,
                    DateRangeExpansionItemsComponent,
                    ExpansionItemsComponent,
                    DateRangePanelComponent,
                    CustomPanelComponent,
                    PopTimeComponent,
                    PopLabelComponent,
                    PopButtonComponent,
                    PopMinMaxComponent,
                    PopSliderComponent,
                    PopTextComponent,
                    PopDatePickerComponent
                ],
                providers: [],
            },] }
];

class PopCacFilterComponent extends PopExtendComponent {
    constructor(el, APP_GLOBAL) {
        super();
        this.el = el;
        this.APP_GLOBAL = APP_GLOBAL;
        this.hidden = false;
        this.name = 'PopCacFilterComponent';
        // this represents the data to be filtered and given to the filter bar view.
        this.srv = {
            filter: ServiceInjector.get(PopCacFilterBarService),
        };
        this.asset = {
            filter: undefined // the current filter applied to all columns, this is the (finished product) that we want to be stored in the base service
        };
        this.ui = {
            config: undefined,
            entities: []
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.ui.config = this.srv.filter.getConfig();
                if (!(IsObject(this.ui.config)))
                    this.ui.config = {};
                this.srv.filter.register(el);
                if (IsObject(PopBusiness, ['id']) && this.APP_GLOBAL.isFilterBar()) {
                    if (this.ui.config.active) {
                        this.asset.filter = this.srv.filter.getFilter();
                        this.srv.filter.setActive(!this.hidden);
                    }
                }
                else {
                    this.hidden = true;
                    this.ui.config.active = false;
                    // this.srv.filter.setFilter({});
                }
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Event Emitter
     */
    onBubbleEvent(event) {
        if (event.type === 'filter') {
            switch (event.name) {
                case 'apply':
                    this.srv.filter.setFilter(event.data);
                    break;
                case 'clear':
                    this.srv.filter.setFilter({});
                    break;
                case 'state':
                    if (event.model === 'open') {
                        SetSessionSiteVar(`Business.${PopBusiness.id}.Filter.open`, event.data);
                        this.dom.setTimeout(`set-filter-height`, () => {
                            const height = this.srv.filter.getElHeight();
                            if (height) {
                                SetSessionSiteVar(`Business.${PopBusiness.id}.Filter.height`, height);
                            }
                        }, 0);
                    }
                    break;
                default:
                    break;
            }
        }
        this.srv.filter.onChange(event);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopCacFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-cac-filter',
                template: `
    <div class="pop-client-filter-container">
      <lib-pop-cac-filter-view *ngIf="ui.config?.active" (events)="onBubbleEvent($event)"></lib-pop-cac-filter-view>
    </div>
  `,
                styles: [`
    .pop-client-filter-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      box-sizing: border-box;
      /*align-items: center;*/
      padding: 0;
    }
  `]
            },] }
];
PopCacFilterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];
PopCacFilterComponent.propDecorators = {
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }],
    config: [{ type: Input }]
};

class PopCacFilterViewComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopCacFilterViewComponent';
        this.ui = {
            config: undefined,
            entities: undefined,
            map: {}
        };
        this.asset = {
            filter: undefined // the current filter applied to all columns, this is the (finished product) that we want to be stored in the base service
        };
        this.srv = {
            filter: ServiceInjector.get(PopCacFilterBarService),
            pipe: ServiceInjector.get(PopPipeService),
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.asset.filter = this.srv.filter.getFilter();
                this.ui.entities = this.srv.filter.getEntities();
                this.ui.map.entities = ArrayMapSetter(this.ui.entities, 'internal_name');
                this.ui.config = this.srv.filter.getConfig();
                this._setDefaultState();
                this._setEntityConfig();
                this.dom.setSubscriber(`data-reset`, this.srv.filter.event.data.subscribe((caller) => {
                    this.dom.setTimeout(`data-reset`, () => {
                        if (IsArray(this.ui.entities, true)) {
                            const first = this.ui.entities[0];
                            first.options.map((option) => {
                                first.display[option.id] = true;
                            });
                            this._checkVisibleForAll(first);
                            this._updateEntitySelectedText(first);
                            this._onEntityFeedUpdate(first);
                        }
                        this.ui.entities.map((entity, index) => {
                            entity.totalOptions = entity.options.length;
                            entity.filter = Object.keys(entity.selected).filter((id) => entity.selected[id]);
                            entity.totalSelected = entity.filter.length;
                        });
                        this.onUpdateOptionsDisplay(0);
                    }, 0);
                }));
                this.dom.setTimeout('init', () => {
                    this.events.emit({ source: this.name, type: 'filter', name: 'init', data: this.asset.filter });
                });
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Trigger an entity column to apply search
     * @param entity
     */
    onApplySearch(entity) {
        if (this.dom.state.searchDelay)
            clearTimeout(this.dom.state.searchDelay);
        this.dom.setTimeout(`search-delay`, () => {
            entity.options.map((option) => {
                entity.hidden[option.id] = ObjectContainsTagSearch(option, entity.search) ? false : true;
            });
            this._onEntityFeedUpdate(entity);
            this._checkVisibleForAll(entity);
        }, 200);
    }
    /**
     * Checks/Unchecks all the options within an entity column
     * @param entity
     */
    onCheckAll(entity) {
        if (IsObject(entity, true) && !entity.single) {
            entity.options.filter((option) => !entity.hidden[option.id]).map((option) => {
                entity.selected[option.id] = +entity.display[option.id] ? entity.checkAll : false;
            });
            entity.filter = Object.keys(entity.selected).filter((id) => entity.selected[id]);
            entity.totalSelected = entity.filter.length;
            entity.allSelected = entity.totalSelected === entity.totalAvailable;
            this._checkVisibleForAll(entity);
            this._updateEntitySelectedText(entity);
            this.onUpdateOptionsDisplay(this.ui.map.entities[entity.internal_name]);
            this.dom.state.filterNeedsApplied = true;
        }
    }
    /**
     * Handle when an option selection has changed
     * Detects progmatic changes
     * @param entity
     */
    onCheckboxChange(event, entity, id) {
        event.preventDefault();
        entity.selected[id] = !entity.selected[id];
        this.dom.setTimeout(`update-${entity.internal_name}-column`, () => {
            entity.filter = Object.keys(entity.selected).filter((key) => entity.selected[key]);
            entity.totalSelected = entity.filter.length;
            entity.allSelected = entity.totalSelected === entity.totalAvailable;
            this._checkVisibleForAll(entity);
            this._updateEntitySelectedText(entity);
            this.onUpdateOptionsDisplay(this.ui.map.entities[entity.internal_name]);
            this.dom.state.filterNeedsApplied = true;
        }, 100);
    }
    /**
     * Handle when an option selection has changed
     * Detects manual changes
     * @param entity
     */
    onRadioChange(event, entity, id) {
        event.preventDefault();
        if (entity.single) {
            entity.checkAll = false;
            entity.allSelected = false;
            entity.indeterminate = false;
            entity.filter = [String(id)];
            entity.totalSelected = entity.filter.length;
            entity.options.map((option) => {
                if (+option.id !== +id) {
                    entity.selected[option.id] = false;
                }
                else {
                    entity.selected[option.id] = true;
                    entity.selectedText = option.name;
                }
            });
            this.onUpdateOptionsDisplay(this.ui.map.entities[entity.internal_name]);
            this.dom.state.filterNeedsApplied = true;
        }
    }
    /**
     * The menu bar has been opened or closed
     * @param entity
     */
    onToggleOpen(entity = null) {
        this.dom.state.open = !this.dom.state.open;
        if (this.dom.state.open && entity) {
            setTimeout(() => {
                this.el.nativeElement.querySelector(`#${entity}-search-input`).focus();
            });
        }
        this.events.emit({ source: this.name, type: 'filter', name: 'state', model: 'open', data: this.dom.state.open });
    }
    /**
     * Event handler for the click of the reset button
     * @returns void
     */
    resetFilter() {
        this.asset.filter = {};
        this.ui.entities.map((entity, index) => {
            if (entity.single) {
                this._setSingleEntityConfig(entity, index);
            }
            else {
                this._setMultipleEntityConfig(entity, index);
            }
        });
        this.asset.filter = this._getCurrentFilter();
        this.dom.state.filterNeedsApplied = false;
        this.dom.state.currentFilterRelevant = false;
        this.events.emit({ source: this.name, type: 'filter', name: 'clear', data: this.asset.filter });
    }
    /**
     * Emits the apply filter event, called
     * when the apply filter button is clicked.
     * @returns void
     */
    applyFilter() {
        if (!this.ui.config.invalid) {
            this.asset.filter = this._getCurrentFilter();
            this.dom.state.currentFilterRelevant = this._isCurrentFilterRelevant();
            this.dom.state.filterNeedsApplied = false;
            this.events.emit({ source: this.name, type: 'filter', name: 'apply', data: this.asset.filter });
            // close on apply ?
            if (this.ui.config.display !== 'static') {
                this.dom.state.open = false;
                this.events.emit({ source: this.name, type: 'filter', name: 'state', model: 'open', data: this.dom.state.open });
            }
        }
    }
    trackByFn(index, item) {
        if (!item)
            return null;
        return item.id;
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Determne if all the visible options are either all checked or unchecked
     * @param entity
     * @private
     */
    _checkForIndeterminate(entity) {
        const selectedVisible = entity.options.filter((option) => !entity.hidden[option.id] && entity.display[option.id] && entity.selected[option.id]).length;
        entity.indeterminate = selectedVisible && selectedVisible < entity.totalVisible ? true : false;
    }
    /**
     * Trigger the column list to update with filtered options
     * @param entity
     */
    _onEntityFeedUpdate(entity) {
        const list = entity.options.filter(option => entity.display[option.id] && !entity.hidden[option.id]);
        if (!entity.allSelected) {
            list.sort((a, b) => {
                if (entity.selected[a.id] && !entity.selected[b.id])
                    return -1;
                if (!entity.selected[a.id] && entity.selected[b.id])
                    return 1;
            });
        }
        entity.feed.next(list);
    }
    /**
     * Updates the select configurations based on the filter bar configurations
     * @returns void
     */
    _setEntityConfig() {
        this.dom.state.loading = true;
        this.ui.entities.map((entity, index) => {
            if (entity.single) {
                this._setSingleEntityConfig(entity, index);
            }
            else {
                this._setMultipleEntityConfig(entity, index);
            }
            entity.totalAvailable = entity.options.length;
            entity.totalOptions = entity.options.length;
            entity.totalVisible = Object.keys(entity.display).filter((id) => entity.display[id] && !entity.hidden[id]).length;
        });
        this.dom.state.filterNeedsApplied = false;
        this.dom.state.currentFilterRelevant = this._isCurrentFilterRelevant();
        if (!this.dom.state.currentFilterRelevant) {
            this.srv.filter.clearFilters();
        }
    }
    /**
     * Configure a radio enity config
     * @param entity
     * @param index
     * @private
     */
    _setSingleEntityConfig(entity, index) {
        let first = entity.options[0];
        entity.checkAll = false;
        entity.indeterminate = false;
        if (IsArray(this.asset.filter[entity.internal_name], true)) {
            const asset = this.srv.filter.getAsset(entity.internal_name, +this.asset.filter[entity.internal_name][0]);
            first = { id: this.asset.filter[entity.internal_name][0], name: IsObject(asset, ['name']) ? asset.name : 'Name' };
        }
        entity.filter = [first.id];
        entity.selectedText = first.name;
        entity.totalSelected = 1;
        entity.hidden = {};
        if (index === 0) {
            entity.options.map((option) => {
                entity.display[option.id] = true;
                entity.hidden[option.id] = false;
                entity.selected[option.id] = false;
            });
            entity.selected[first.id] = true;
        }
        else {
            const prevIndex = +index - 1;
            const prevEntity = this.ui.entities[prevIndex];
            entity.options.map((option) => {
                entity.display[option.id] = prevEntity.selected[option.id];
                entity.hidden[option.id] = false;
                entity.selected[option.id] = false;
            });
            entity.selected[first.id] = true;
        }
        this._onEntityFeedUpdate(entity);
    }
    /**
     * Configure a multiple checkbox entity config
     * @param entity
     * @param index
     * @private
     */
    _setMultipleEntityConfig(entity, index) {
        const existingFilter = IsArray(this.asset.filter[entity.internal_name], true);
        entity.filter = existingFilter ? JsonCopy(this.asset.filter[entity.internal_name]) : [];
        // console.log('_setMultipleEntityConfig', entity.name, index, entity.filter.length);
        if (entity.filter.length) {
            entity.checkAll = false;
            entity.indeterminate = true;
        }
        else {
            entity.checkAll = true;
            entity.indeterminate = false;
        }
        entity.totalSelected = entity.checkAll ? entity.options.length : entity.filter.length;
        if (index === 0) {
            entity.options.map((option) => {
                entity.selected[option.id] = entity.checkAll ? true : entity.filter.includes(String(option.id));
                entity.display[option.id] = true;
                entity.hidden[option.id] = false;
            });
            entity.totalAvailable = entity.options.length;
            entity.totalSelected = existingFilter ? entity.filter.length : entity.options.length;
            entity.allSelected = entity.totalSelected === entity.totalAvailable;
            this._checkVisibleForAll(entity);
            this._updateEntitySelectedText(entity);
        }
        else {
            const prevIndex = +index - 1;
            const prevEntity = this.ui.entities[prevIndex];
            entity.options.map((option) => {
                entity.selected[option.id] = entity.checkAll ? true : prevEntity.filter.includes(String(option[prevEntity.child_link]));
                entity.display[option.id] = prevEntity.selected[option[prevEntity.child_link]];
                entity.hidden[option.id] = false;
            });
            entity.totalAvailable = entity.options.length;
            entity.totalSelected = existingFilter ? entity.filter.length : entity.options.length;
            entity.allSelected = entity.totalSelected === entity.totalAvailable;
            this._checkVisibleForAll(entity);
            this._updateEntitySelectedText(entity);
        }
        this._onEntityFeedUpdate(entity);
    }
    /**
     * Cascade changes to all columns of the right of the column that made changes
     * @param entityName
     */
    onUpdateOptionsDisplay(changedIndex) {
        this.dom.setTimeout(`options-update-${changedIndex}`, () => {
            let invalid = false;
            this.ui.entities.map((entity, index) => {
                const inView = this.ui.config.view.includes(entity.internal_name);
                if (!entity.totalSelected && inView)
                    invalid = true;
                if (index > changedIndex) {
                    const prevIndex = +index - 1;
                    const prevEntity = this.ui.entities[prevIndex];
                    entity.options.map((option) => {
                        entity.display[option.id] = prevEntity.allSelected ? true : prevEntity.filter.includes(String(option[prevEntity.child_link]));
                        if (!entity.display[option.id]) {
                            entity.selected[option.id] = false;
                        }
                    });
                    this._onEntityFeedUpdate(entity);
                    if (!(inView)) {
                        entity.options.filter((option) => !entity.hidden[option.id]).map((option) => {
                            entity.selected[option.id] = +entity.display[option.id] ? true : false;
                        });
                    }
                    entity.filter = Object.keys(entity.selected).filter((id) => entity.selected[id]);
                    entity.totalSelected = entity.filter.length;
                    if (!entity.totalSelected && this.ui.config.view.includes(entity.internal_name))
                        invalid = true;
                    this._checkVisibleForAll(entity);
                    this._updateEntitySelectedText(entity);
                }
            });
            this.ui.config.invalid = invalid;
        }, 50);
    }
    _setDefaultState() {
        if (this.ui.config.display === 'static')
            this.dom.state.open = true;
        this.dom.state = Object.assign(Object.assign({}, this.dom.state), {
            differentEntities: false,
            searchDelay: undefined,
            loading: false,
            open: false,
            loaded: false,
            currentFilterRelevant: false,
            filterNeedsApplied: false, // flags when user needs to apply changes to the filter
        });
        this.dom.state.open = IsObject(PopBusiness, ['id']) ? GetSessionSiteVar(`Business.${PopBusiness.id}.Filter.open`, false) : false;
    }
    /**
     * Update the text appears in the header of each entity column
     * @param entity
     */
    _updateEntitySelectedText(entity) {
        entity.totalText = `${entity.totalAvailable} ${entity.name} available.`;
        if (this.ui.map.entities[entity.internal_name] > 0) {
            const index = this.ui.map.entities[entity.internal_name];
            let prevIndex = index - 1;
            while (prevIndex > 0) {
                if (this.ui.entities[prevIndex].indeterminate) {
                    break;
                }
                else {
                    prevIndex--;
                }
            }
            if (entity.totalAvailable < entity.totalOptions) {
                entity.totalText += `  ${entity.totalOptions - entity.totalAvailable} filtered out by ${this.ui.entities[prevIndex].name}.`;
            }
        }
        entity.allSelected = entity.totalSelected === entity.totalAvailable;
        if (entity.allSelected || !entity.totalSelected) {
            entity.selectedText = entity.allSelected ? 'All' : 'None';
        }
        else {
            const selectedOptions = entity.options.filter((option) => {
                return entity.display[option.id] && entity.selected[option.id];
            }).map((option) => {
                return option.name;
            });
            entity.selectedText = selectedOptions.length > 4 ? selectedOptions.slice(0, 4).join(', ') + `, ... ${selectedOptions.length - 4} more` : selectedOptions.join(', ');
        }
    }
    /**
     * Determine if all the visible options in an entity column have been selected
     * @param entity
     */
    _checkVisibleForAll(entity) {
        if (IsObject(entity, true) && !entity.single) {
            let all = true;
            const visible = Object.keys(entity.display).filter((id) => entity.display[id] && !entity.hidden[id]);
            entity.totalVisible = visible.length;
            if (visible.length) {
                visible.some(id => {
                    if (!entity.selected[id]) {
                        all = false;
                        return true;
                    }
                });
            }
            else {
                all = false;
            }
            entity.checkAll = all;
            this._checkForIndeterminate(entity);
        }
    }
    /**
     * Create a payload for what the filter has generated
     */
    _getCurrentFilter() {
        const currentFilter = {};
        this.ui.entities.map((entity) => {
            if (!entity.allSelected) {
                if (entity.filter.length) {
                    currentFilter[entity.internal_name] = entity.filter.filter((id) => +id > 0);
                    console.log(entity.internal_name, entity.filter);
                    this._onEntityFeedUpdate(entity);
                }
            }
        });
        console.log('currentFilter', currentFilter);
        return currentFilter;
    }
    /**
     * Determine which entity columns are having a filtering effect
     */
    _isCurrentFilterRelevant() {
        let relevant = false;
        Object.keys(this.asset.filter).some((internal_name) => {
            if (Array.isArray(this.asset.filter[internal_name]) && this.asset.filter[internal_name].length) {
                if (internal_name in this.ui.map.entities && this.ui.entities[this.ui.map.entities[internal_name]].totalAvailable) {
                    if (this.asset.filter[internal_name].length < this.ui.entities[this.ui.map.entities[internal_name]].totalAvailable) {
                        relevant = true;
                        return true;
                    }
                }
            }
        });
        return relevant;
    }
}
PopCacFilterViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-cac-filter-view',
                template: "<div class=\"cac-filter-container theme-background-base\" *ngIf=\"ui.config\" [ngClass]=\"{'sw-hidden': !ui.config.active, 'cac-filter-container-open': dom.state.open && ui.config.display === 'default'}\">\n  <div class=\"cac-filter-loader\">\n    <mat-progress-bar *ngIf=\"ui.config.loader\" mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n\n  <div class=\"cac-filter-header\" [ngClass]=\"{'sw-hidden':dom.state.loading}\">\n\n    <div class=\"cac-filter-header-column theme-background-base\" [style.minWidth.px]=\"125\" [style.maxWidth.px]=\"125\">\n      <div class=\"cac-filter-label-text\">\n        FILTERS\n      </div>\n      <mat-icon class=\"cac-filter-label-icon sw-pointer\" [ngClass]=\"{'sw-hidden':dom.state.open}\" (click)=\"onToggleOpen();\">\n        arrow_right\n      </mat-icon>\n      <mat-icon class=\"cac-filter-label-icon sw-pointer\" [ngClass]=\"{'sw-hidden':!dom.state.open}\" (click)=\"onToggleOpen();\">\n        arrow_drop_down\n      </mat-icon>\n    </div>\n    <div class=\"cac-filter-header-column theme-background-base\" *ngFor=\"let entity of ui.entities\" [ngClass]=\"{'sw-hidden': !entity.visible}\">\n      <div class=\"cac-select-filter-button\">\n        <div class=\"cac-select-filter-button-bar\" [ngClass]=\"{'filter-selected':entity.indeterminate}\"></div>\n        <mat-form-field appearance=\"none\">\n          <mat-label>{{entity.name}}</mat-label>\n          <input\n            matInput\n            [matTooltip]=\"entity.selectedText\"\n            [readonly]=true\n            type=\"text\"\n            [(ngModel)]=\"entity.selectedText\"\n          >\n          <div class=\"sw-pointer cac-select-filter-icon\" matSuffix matTooltipPosition=\"below\" [matTooltipShowDelay]=\"500\" [matTooltip]=\"entity.totalText\">\n            <mat-icon class=\"sw-pointer\" (click)=\"onToggleOpen(entity.internal_name);\">\n              filter_list\n            </mat-icon>\n          </div>\n        </mat-form-field>\n      </div>\n    </div>\n    <div class=\"cac-filter-header-menu\" [style.minWidth.px]=\"125\" [style.maxWidth.px]=\"125\">\n      <div class=\"cac-filter-header-row\">\n        <div class=\"cac-filter-action-text\" [ngClass]=\"{'sw-disabled': ui.config.invalid, 'sw-pointer': !ui.config.invalid}\" *ngIf=\"dom.state.filterNeedsApplied\" (click)=\"applyFilter();\">\n          APPLY\n        </div>\n        <div class=\"cac-filter-action-text sw-pointer\" *ngIf=\"dom.state.currentFilterRelevant && !dom.state.filterNeedsApplied\" (click)=\"resetFilter();\">\n          RESET\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <!-- Toggle Container-->\n  <div class=\"cac-filter-body\" *ngIf=\"dom.state.open\" [@slideInOut] [ngClass]=\"{'cac-filter-body-float theme-background-base': ui.config.display === 'float'}\">\n    <div class=\"cac-filter-header-column\" [style.border]=\"0\" [style.minWidth.px]=\"125\" [style.maxWidth.px]=\"125\">\n      <!--Filler to reserve space to match headers-->\n    </div>\n    <div class=\"cac-filter-body-column\" *ngFor=\"let entity of ui.entities\" [ngClass]=\"{'sw-hidden': !entity.visible}\">\n\n      <div class=\"cac-filter-body-column-header\">\n\n        <div class=\"cac-filter-option-select-container\" *ngIf=\"!entity.single\" [style.marginLeft.px]=\"3\">\n\n          <mat-checkbox class=\"cac-filter-check-all\" [(ngModel)]=\"entity.checkAll\"\n                        [style.marginRight.px]=\"1\"\n                        [disabled]=!entity.totalVisible\n                        [indeterminate]=\"entity.indeterminate\"\n                        (change)=\"onCheckAll(entity);\">\n          </mat-checkbox>\n        </div>\n\n        <mat-form-field class=\"sw-search\" appearance=\"none\" color=\"accent\">\n          <a matPrefix>\n            <mat-icon>search</mat-icon>\n          </a>\n          <input id=\"{{entity.internal_name}}-search-input\" matInput [(ngModel)]=\"entity.search\" (keyup)=\"onApplySearch(entity)\">\n        </mat-form-field>\n        <mat-icon class=\"sw-pointer cac-filter-clear-icon\"\n                  [ngClass]=\"{'sw-transparent': !entity.search }\"\n                  matTooltip=\"Clear Search\"\n                  (click)=\"onApplySearch(entity); entity.search = '';\"\n        >\n          close\n        </mat-icon>\n      </div>\n      <mat-divider></mat-divider>\n      <cdk-virtual-scroll-viewport [@fadeInOut] itemSize=\"25\" minBufferPx=\"125\" maxBufferPx=\"250\" class=\"cac-filter-body-column-contents\">\n        <div class=\"cac-filter-body-column-row pop-checkbox-container checkbox-has-label cac-filter-option-hover\" *cdkVirtualFor=\"let option of entity.feed | async ; trackBy: trackByFn\"\n        >\n          <div class=\"cac-filter-option-select-container\">\n            <mat-checkbox\n              [ngClass]=\"{'sw-hidden':entity.single}\"\n              [(ngModel)]=\"entity.selected[option.id]\"\n              [labelPosition]=\"'before'\"\n              (click)=\"onCheckboxChange($event, entity, option.id)\"\n            ></mat-checkbox>\n            <div class=\"cac-filter-option-radio\" [ngClass]=\"{'sw-hidden':!entity.single}\">\n              <mat-icon class=\"sw-pointer\" [ngClass]=\"{'sw-hidden': entity.selected[option.id]}\" (click)=\"onRadioChange($event, entity, option.id)\">\n                radio_button_unchecked\n              </mat-icon>\n              <mat-icon class=\"sw-pointer cac-filter-option-checked\" [ngClass]=\"{'sw-hidden': !entity.selected[option.id]}\" (click)=\"onRadioChange($event, entity, option.id)\">\n                radio_button_checked\n              </mat-icon>\n            </div>\n          </div>\n          <div class=\"cac-filter-option-select-text\" *ngIf=\"entity.single\" (click)=\"onRadioChange($event, entity, option.id)\">\n            {{option.name}}\n            <small class=\"cac-filter-option-select-id\">{{option.id}}</small>\n          </div>\n          <div class=\"cac-filter-option-select-text\" *ngIf=\"!entity.single\" (click)=\"onCheckboxChange($event, entity, option.id);\">\n            {{option.name}}\n            <small class=\"cac-filter-option-select-id\">{{option.id}}</small>\n          </div>\n\n        </div>\n      </cdk-virtual-scroll-viewport>\n\n    </div>\n    <div class=\"cac-filter-header-menu\" [style.minWidth.px]=\"125\" [style.maxWidth.px]=\"125\">\n      <!--Filler to reserve space to match headers-->\n    </div>\n  </div>\n</div>\n",
                animations: [slideInOut, fadeInOut],
                styles: [".cac-filter-container{display:flex;flex-direction:column;justify-content:stretch;align-items:stretch;border:1px solid var(--border);min-height:35px;padding:5px 10px 13px;margin:30px 30px 5px;border-radius:3px;transition:height .5s}.cac-filter-container ::ng-deep .cac-filter-option-select-container .mat-checkbox-inner-container{margin-left:0!important}.cac-filter-container ::ng-deep .cac-filter-option-checked.mat-icon{color:var(--background-focused-button)!important}.cac-filter-container ::ng-deep .pop-checkbox-container{min-height:25px!important}.cac-filter-container ::ng-deep .cac-filter-body-column-header mat-form-field,.cac-filter-container mat-form-field input{width:100%;font-weight:700}.cac-filter-container ::ng-deep .cac-filter-body-column-header .mat-form-field-infix{padding-top:2px}.cac-filter-container ::ng-deep .cac-filter-body-column-row .mat-checkbox-label{width:100%}.cac-filter-container-open{min-height:220px!important;transition:height .5s}.cac-filter-loader{position:relative;display:block;width:100%;height:2px;overflow:hidden;clear:both;margin-bottom:8px}.cac-filter-header{display:flex;flex-direction:row;justify-content:flex-start;align-items:center;height:36px}.cac-filter-header-column{position:relative;display:flex;flex-direction:row;margin-left:10px;flex-basis:75%;max-width:400px;box-sizing:border-box}.cac-filter-header-column ::ng-deep .mat-form-field{width:100%;box-sizing:border-box}.cac-filter-header-column ::ng-deep .mat-form-field-infix{top:-8px;padding:2px 5px!important;margin:0 0 0 5px}.cac-filter-header-column ::ng-deep .mat-form-field-outline{color:transparent;display:none}.cac-filter-header-column ::ng-deep .mat-form-field-wrapper{padding-bottom:0!important;margin:0!important;min-width:100%;box-sizing:border-box}.cac-filter-header-column ::ng-deep input{position:relative;top:6px;white-space:nowrap;text-overflow:ellipsis;height:20px;line-height:20px;overflow:hidden;max-width:100%;pointer-events:none!important;background:var(--background-base)!important}.cac-filter-header-column ::ng-deep mat-label{background:var(--background-base)!important;font-size:1.2em;padding:0 5px}.cac-filter-header-column ::ng-deep .mat-form-field-subscript-wrapper{display:none}.cac-filter-header-menu{flex-direction:column;flex-basis:25%;flex-grow:1}.cac-filter-header-menu,.cac-filter-header-row{position:relative;display:flex;justify-content:flex-end}.cac-filter-header-row{flex-direction:row;margin-left:10px;flex-basis:100%;align-self:flex-end}.cac-filter-label-text{position:relative;text-decoration:none;margin-left:5px;margin-right:20px;color:var(--accent-900)!important;top:2px}.cac-filter-label-icon{position:relative}.cac-filter-body-column{margin-left:10px;flex-basis:75%;height:180px;width:75%;box-sizing:border-box;max-width:400px;border:1px solid var(--border)}.cac-filter-body-column,.cac-filter-body-menu{position:relative;display:flex;flex-direction:column}.cac-filter-body-menu{flex-basis:25%;overflow-x:hidden;justify-content:flex-end;align-items:center;flex-grow:1}.cac-filter-body-row{margin-left:10px;justify-content:flex-end;align-self:flex-end}.cac-filter-body-row,.cac-select-filter-button{position:relative;display:flex;flex-direction:row;flex-basis:100%}.cac-select-filter-button{height:36px;border:1px solid var(--border);border-radius:3px;justify-content:flex-start;align-items:center;cursor:pointer}.cac-select-filter-button .cac-select-filter-button-bar{width:5px;height:100%;border-radius:2px 0 0 2px}.cac-select-filter-button .cac-select-filter-button-text{display:flex;flex-direction:row;justify-content:flex-start;flex-basis:100%;padding:0}.cac-select-filter-button .cac-select-filter-button-icon{display:flex;flex-basis:10%;align-items:center;margin-right:10px}.cac-filter-clear-icon{position:relative;font-size:.9em;top:5px;right:2px}.cac-select-filter-icon{position:relative;left:-5px;font-size:1.2em}.cac-filter-body{display:flex;flex-direction:row;justify-content:flex-start;align-items:flex-start;min-height:178px}.cac-filter-body-float{position:absolute;margin-top:46px;left:0;right:0;border:1px solid var(--border);border-top:none;z-index:999999}.cac-filter-body-column-contents{position:relative;flex:1 1;height:140px;overflow-y:auto;overflow-x:hidden;margin:0}.cac-filter-body-column-header{position:relative;display:flex;flex-direction:row;justify-content:flex-start;align-items:center;min-height:25px;clear:both;padding:0 4px;border-radius:3px;border-bottom:1px solid transparent}.cac-filter-option-select-text{display:flex;flex-grow:1;box-sizing:border-box;height:25px;cursor:pointer;padding-left:2px;padding-top:5px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.cac-filter-option-select-id{display:flex;padding-right:10px;padding-top:5px;justify-content:flex-end;flex-grow:1;text-align:right;font-size:.6em;opacity:.5}.cac-filter-option-hover:hover{background:var(--background-hover)!important}.cac-filter-body-column-row{position:relative;display:flex;height:25px;clear:both;align-items:center;padding:0 4px}.cac-filter-option-select-container{width:25px;height:25px;display:flex;align-items:center;justify-content:center;margin-right:5px}.cac-filter-action-text{text-decoration:none;margin:0 20px;color:var(--accent-900);font-size:.9em}.cac-filter-option-radio{padding-top:4px!important}:host ::ng-deep .mat-ripple-element{display:none!important}.filter-selected{background-color:var(--primary)!important}"]
            },] }
];
PopCacFilterViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopCacFilterViewComponent.propDecorators = {
    channel: [{ type: Input }]
};

class PopCacFilterModule {
}
PopCacFilterModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    FormsModule,
                    ScrollingModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatCheckboxModule,
                    MatIconModule,
                    MatTooltipModule,
                    PopFieldItemModule,
                    MatProgressBarModule,
                    MatDividerModule
                ],
                declarations: [
                    PopCacFilterComponent,
                    PopCacFilterViewComponent,
                ],
                exports: [
                    PopCacFilterComponent,
                    PopCacFilterViewComponent,
                ],
                providers: [],
            },] }
];

class PopTemplateModule {
}
PopTemplateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    HttpClientModule,
                    PopMenuModule,
                    PopLeftMenuModule,
                    PopWidgetBarModule,
                    PopCacFilterModule,
                    MatSnackBarModule,
                    MatProgressBarModule,
                    PopIndicatorsModule
                ],
                declarations: [
                    PopTemplateComponent,
                    PopTemplateAjaxLoaderComponent,
                    PopTemplateWelcomeComponent,
                    PopTemplateGoodByeComponent,
                    PopTemplateErrorComponent,
                    PopTemplateBufferComponent
                ],
                entryComponents: [
                    PopTemplateAjaxLoaderComponent,
                    PopTemplateWelcomeComponent,
                    PopTemplateGoodByeComponent,
                    PopTemplateErrorComponent,
                    PopTemplateBufferComponent
                ],
                exports: [
                    PopMenuModule,
                    PopLeftMenuModule,
                    PopWidgetBarModule,
                    PopTemplateComponent,
                    PopCacFilterModule
                ]
            },] }
];

// https://medium.com/angular-in-depth/here-is-how-to-get-viewcontainerref-before-viewchild-query-is-evaluated-f649e51315fb
class PopContainerService {
    constructor() {
        this.createListeners = [];
        this.destroyListeners = [];
        this.onContainerCreated = (fn) => {
            this.createListeners.push(fn);
        };
        this.onContainerDestroyed = (fn) => {
            this.destroyListeners.push(fn);
        };
        this.registerContainer = (container) => {
            this.createListeners.forEach((fn) => {
                fn(container);
            });
        };
        this.destroyContainer = (container) => {
            this.destroyListeners.forEach((fn) => {
                fn(container);
            });
        };
    }
}
PopContainerService.prov = i0.defineInjectable({ factory: function PopContainerService_Factory() { return new PopContainerService(); }, token: PopContainerService, providedIn: "root" });
PopContainerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class LibContainerDirective {
    constructor(vc) {
        this.templateContainerRepo = ServiceInjector.get(PopContainerService);
        this.templateContainerRepo.registerContainer(vc);
    }
}
LibContainerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[libContainer]',
            },] }
];
LibContainerDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

class LibOutsideClickDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.clickOutside = new EventEmitter();
    }
    onMouseEnter(targetElement) {
        const clickedInside = this._elementRef.nativeElement.contains(targetElement);
        if (!clickedInside) {
            this.clickOutside.emit(null);
        }
    }
}
LibOutsideClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[libOutsideClick]'
            },] }
];
LibOutsideClickDirective.ctorParameters = () => [
    { type: ElementRef }
];
LibOutsideClickDirective.propDecorators = {
    clickOutside: [{ type: Output, args: ['clickOutside',] }],
    onMouseEnter: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
};

class LibTrackCapsLockDirective {
    constructor() {
        this.capsLock = new EventEmitter();
    }
    onKeyDown(event) {
        const capsOn = event.getModifierState && event.getModifierState('CapsLock');
        this.capsLock.emit(capsOn);
    }
    onKeyUp(event) {
        const capsOn = event.getModifierState && event.getModifierState('CapsLock');
        this.capsLock.emit(capsOn);
    }
}
LibTrackCapsLockDirective.decorators = [
    { type: Directive, args: [{ selector: '[libTrackCapsLock]' },] }
];
LibTrackCapsLockDirective.propDecorators = {
    capsLock: [{ type: Output, args: ['capsLock',] }],
    onKeyDown: [{ type: HostListener, args: ['window:keydown', ['$event'],] }],
    onKeyUp: [{ type: HostListener, args: ['window:keyup', ['$event'],] }]
};

class PopCommonModule {
    static forRoot(environment) {
        return {
            ngModule: PopCommonModule,
            providers: [
                {
                    provide: 'env',
                    useValue: environment
                },
            ]
        };
    }
}
PopCommonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    PopTemplateModule
                ],
                declarations: [
                    LabelPipe,
                    PhonePipe,
                    ToYesNoPipe,
                    ToActiveOrArchivedPipe,
                    TruncatePipe,
                    LibOutsideClickDirective,
                    LibContainerDirective,
                    LibTrackCapsLockDirective,
                ],
                exports: [
                    PopTemplateModule,
                    LabelPipe,
                    PhonePipe,
                    ToYesNoPipe,
                    ToActiveOrArchivedPipe,
                    TruncatePipe,
                    LibOutsideClickDirective,
                    LibContainerDirective,
                    LibTrackCapsLockDirective,
                ],
            },] }
];

class PopDatetimeService {
    constructor() {
        this.timezone = 'America/Denver';
        this.hourFormat = 12;
        this.dateFormat = `dd/mm/yyyy`;
        this.srv = {
            spacetime: spacetime
        };
    }
    transform(value, format = 'date', seconds = true) {
        return this._display({ timestamp: value, format: format, seconds: seconds });
    }
    toIso(timestamp) {
        const dt = this.srv.spacetime(timestamp, this.timezone);
        return dt.format('iso');
    }
    toIsoShort(timestamp) {
        const dt = this.srv.spacetime(timestamp, this.timezone);
        return dt.format('iso-short');
    }
    getTommorow(date) {
        return this.srv.spacetime(date).add(1, 'day').format('iso');
    }
    add(date, direction = 1, unit = 'day') {
        return this.srv.spacetime(date).add(direction, unit).format('iso');
    }
    subtract(date, direction = 1, unit = 'day') {
        return this.srv.spacetime(date).subtract(direction, unit).format('iso');
    }
    getYesterday(date) {
        return this.srv.spacetime(date).subtract(1, 'day').format('iso');
    }
    getLatest(dates) {
        let latest = null;
        if (IsArray(dates, true)) {
            latest = dates.reduce((a, b) => (this.toIso(a) > this.toIso(b) ? a : b));
            return this.toIso(latest);
        }
    }
    getEarliest(dates) {
        let latest = null;
        if (IsArray(dates, true)) {
            latest = dates.reduce((a, b) => (this.toIso(a) < this.toIso(b) ? a : b));
            return this.toIso(latest);
        }
    }
    setCurrentBusinessUnitSettings() {
        if (IsObject(PopBusiness, true)) {
            if (IsNumber(PopBusiness.hour_format, true))
                this.hourFormat = +PopBusiness.hour_format;
            if (IsString(PopBusiness.date_format, true))
                this.dateFormat = PopBusiness.date_format;
            if (!(IsNumber(PopBusiness.timezone)) && IsString(PopBusiness.timezone, true))
                this.timezone = PopBusiness.timezone;
        }
        if (IsObject(PopUser, ['setting'])) {
            if (IsNumber(PopUser.setting.hour_format, true))
                this.hourFormat = +PopUser.setting.hour_format;
            if (IsString(PopUser.setting.date_format, true))
                this.dateFormat = PopUser.setting.date_format;
            if (IsNumber(PopUser.setting.timezone)) {
                const transformToName = PopPipe.transform(PopUser.setting.timezone, { type: 'timezone' });
                if (IsString(transformToName, true)) {
                    this.timezone = transformToName;
                }
            }
            else {
                if (!(IsNumber(PopUser.setting.timezone)) && IsString(PopUser.setting.timezone, true))
                    this.timezone = PopUser.setting.timezone;
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Formats a datetime string to the correct datetime according to the timezone and formats for the user.
     *  - format enum: [date, time, datetime]
     */
    _display(datetime) {
        const hourFormat = (this.hourFormat == 24 ? 'HH:mm' + (datetime.seconds ? ':ss' : '') : 'h:mm' + (datetime.seconds ? ':ss' : '') + ' a');
        let dt = this.srv.spacetime(datetime.timestamp);
        if (IsString(this.timezone, true) && String(this.timezone).length > 10) {
            dt = dt.goto(this.timezone);
        }
        switch (datetime.format) {
            case 'datetime':
                return dt.format(this._displayFormat()) + (['full', 'full-short'].includes(this.dateFormat) ? ', ' : ' ') + dt.unixFmt(hourFormat);
            case 'date':
                return dt.format(this._displayFormat());
            case 'time':
                return dt.unixFmt(hourFormat);
            default:
                return dt.format(this._displayFormat() + ' ' + hourFormat);
        }
    }
    _displayFormat() {
        switch (this.dateFormat) {
            case 'yyyymmdd':
                return '{year}{month-pad}{date-pad}';
            case 'yyyy-mm-dd':
                return 'iso-short';
            case 'dd/mm/yyyy':
                return 'numeric-uk';
            case 'mm/dd/yyyy':
                return 'numeric-us';
            case 'yyyy/mm/dd':
                return '{year}/{month-pad}/{date-pad}';
            case 'dd-mm-yyyy':
                return '{date-pad}-{month-pad}-{year}';
            case 'yyyy/dd/mm':
                return '{year}/{date-pad}/{month-pad}';
            case 'yyyy-dd-mm':
                return '{year}-{date-pad}-{month-pad}';
            case 'mm-dd-yyyy':
                return '{month-pad}-{date-pad}-{year}';
            case 'full':
                return '{month} {date-pad}, {year}';
            case 'full-short':
                return '{month-short} {date-pad}, {year}';
            default:
                return 'iso-short';
        }
    }
}
PopDatetimeService.prov = i0.defineInjectable({ factory: function PopDatetimeService_Factory() { return new PopDatetimeService(); }, token: PopDatetimeService, providedIn: "root" });
PopDatetimeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopDatetimeService.ctorParameters = () => [];

const environment = {
    production: false,
    // apiBaseUrl: ' http://127.0.0.1:8899',
    apiBaseUrl: ' https://api.dev.popcx.com',
    baseHref: '/lib/',
    username: 'josh',
    password: 'Secret@2020',
    debug: true,
    debugLevel: 1,
    debugCache: 0,
    debugComponents: 'PopEntityListComponent',
    debugTypes: ['warn'],
    entities: true
};

class PopLogService {
    constructor(env) {
        this.env = env;
        this.name = 'PopLogService';
        if (this.enabled('init', this.name))
            console.log(this.message(`${this.name}:init`), this.color('init'));
    }
    message(message) {
        return `%c${message}`;
    }
    color(type) {
        let color = 'aqua';
        switch (type) {
            case 'warn':
                color = 'orange';
                break;
            case 'force':
            case 'error':
            case 'destroy':
                color = 'red';
                break;
            case 'info':
                color = 'aqua';
                break;
            case 'event':
                color = 'yellow';
                break;
            case 'onSession':
            case 'event-trigger':
                color = 'gold';
                break;
            case 'cache-in':
                color = 'green';
                break;
            case 'cache-out':
                color = 'darkgreen';
                break;
            case 'dom':
                color = 'brown';
                break;
            case 'debug':
                color = 'pink';
                break;
            case 'api':
                color = 'darkgreen';
                break;
            case 'config':
                color = 'pink';
                break;
            case 'theme':
                color = 'purple';
                break;
            default:
                color = 'aqua';
                break;
        }
        return `color: ${color}`;
    }
    enabled(type = '', component = null) {
        if (this.env.debug) {
            if (type && Array.isArray(this.env.debugTypes)) {
                if (this.env.debugTypes.includes(type))
                    return true;
            }
            if (typeof this.env.debugLevel === 'number') {
                if (['error', 'onSession'].includes(type) && this.env.debug >= 1) {
                    return true;
                }
                if (['warning', 'info'].includes(type) && this.env.debug >= 2) {
                    return true;
                }
                if (['events'].includes(type) && this.env.debug >= 2) {
                    return true;
                }
            }
            if (component && typeof this.env.debugComponents === 'string') {
                return this.env.debugComponents.search(component) > -1;
            }
        }
        return false;
    }
    init(componentName, message, data = '', force = false) {
        const type = 'init';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
    }
    debug(componentName, message, data = '', force = false) {
        const type = 'debug';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
    }
    cache(componentName, message, set = true, force = false) {
        let type = 'cache';
        if (this.enabled(type, componentName) || force) {
            type = set ? 'cache-in' : 'cache-out';
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)));
        }
    }
    warn(componentName, message, data = '', force = false) {
        const type = 'warn';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
    }
    info(componentName, message, data = '', force = false) {
        const type = 'info';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
    }
    theme(componentName, message, data = '', force = false) {
        const type = 'theme';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
    }
    event(componentName, message, event, force = false) {
        const type = 'event';
        if (this.enabled(type, componentName) || force)
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), event);
    }
    error(componentName, message, data = '', force = false) {
        const type = 'error';
        if (this.enabled(type, componentName) || force) {
            console.log(this.message(`${componentName}:${message}`), this.color((force ? 'force' : type)), data);
            // throw new Error('message');
        }
    }
}
PopLogService.prov = i0.defineInjectable({ factory: function PopLogService_Factory() { return new PopLogService(i0.inject("env")); }, token: PopLogService, providedIn: "root" });
PopLogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopLogService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class PopDisplayService {
    constructor() {
        this.aliases = [];
    }
    /**
     * Provides the actual name we want displayed to the user.
     * field - The field name coming from the DB.
     * displayInfo - Either a string or object. If object then will look for property display or label. Takes aliases into account. IE: account:ID
     * set - If passed will look in the displayInfo object for this field before falling back to the display or label field.
     * returns {string}
     */
    set(text, displayInfo = '', displayField = '') {
        let displayString = '';
        if (displayInfo && typeof displayInfo === 'string') {
            displayString = displayInfo;
        }
        else if (displayInfo && displayField && displayInfo[displayField]) {
            displayString = displayInfo[displayField];
        }
        else if (displayInfo && displayInfo.display) {
            displayString = displayInfo.display;
        }
        else if (displayInfo && displayInfo.label) {
            displayString = displayInfo.label;
        }
        // Check for aliases.
        if (displayString) {
            if (displayString.includes('alias:')) {
                const aliasArray = displayString.split(':');
                aliasArray.shift();
                const alias = this.alias(aliasArray.shift()).toLocaleLowerCase();
                displayString = alias.charAt(0).toUpperCase() + alias.slice(1) + ' ';
                let tempString = '';
                while (tempString = aliasArray.shift())
                    displayString += ' ' + tempString;
            }
        }
        else {
            // Format the string base on the field name.
            const words = text.split('_');
            for (const word of words) {
                if (word === 'id' || word === 'fk') {
                    displayString += 'ID ';
                }
                else {
                    displayString += word.charAt(0).toUpperCase() + word.slice(1) + ' ';
                }
            }
        }
        return displayString.trim();
    }
    alias(entity) {
        return (this.aliases[entity] ? this.aliases[entity] : entity);
    }
}
PopDisplayService.prov = i0.defineInjectable({ factory: function PopDisplayService_Factory() { return new PopDisplayService(); }, token: PopDisplayService, providedIn: "root" });
PopDisplayService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopDisplayService.ctorParameters = () => [];

class PopRequestService {
    constructor(http, env) {
        this.http = http;
        this.env = env;
        this.offsetLimit = 2000;
        // if( +this.env.offsetLimit ) this.offsetLimit = this.env.offsetLimit;
        if (!this.baseUrl) {
            const envUrl = isDevMode() && this.env && this.env.apiBaseUrl ? this.env.apiBaseUrl : null;
            this.baseUrl = (envUrl ? envUrl : `${window.location.protocol}//api.${window.location.host}`);
        }
    }
    getHeaders(version, businessId = 0) {
        return {
            'X-Popcx-Business': +businessId ? String(businessId) : PopBusiness ? String(PopBusiness.id) : String(0),
            'Content-Type': 'application/json',
            'Api-Version': (typeof version !== 'undefined' ? version : 1).toString()
        };
    }
    getBaseUrl() {
        return this.baseUrl.slice();
    }
    setBaseUrl(baseUrl) {
        if (IsString(baseUrl, true)) {
            this.baseUrl = baseUrl;
        }
    }
    getOffsetLimit() {
        return this.offsetLimit;
    }
    doGet(url, params = {}, version = 1, ignore401 = false, businessId = 0) {
        const options = {
            headers: new HttpHeaders(this.getHeaders(version, businessId)),
            params: this._setParams(params)
        };
        if (ignore401)
            options.headers.set('SkipResponse401Interceptor', '1');
        if (url[0] !== '/')
            url = `/${url}`;
        return this.http.get(`${this.getBaseUrl()}${url}`, options);
    }
    doDelete(url, body = null, version = 1, ignore401 = null, businessId = 0) {
        const options = {
            headers: new HttpHeaders(this.getHeaders(version, businessId)),
            body: body,
        };
        if (ignore401)
            options.headers.set('SkipResponse401Interceptor', '1');
        if (url[0] !== '/')
            url = `/${url}`;
        // if( data ) options.params = new HttpParams(data);
        return this.http.delete(`${this.getBaseUrl()}${url}`, options);
    }
    doPatch(url, data, version = 1, ignore401 = false, businessId = 0) {
        const headers = new HttpHeaders(this.getHeaders(version, businessId));
        if (ignore401)
            headers.set('SkipResponse401Interceptor', '1');
        if (url[0] !== '/')
            url = `/${url}`;
        return this.http.patch(this.getBaseUrl() + url, JSON.stringify(data), { headers: headers });
    }
    doPost(url, data, version = 1, ignore401 = false, businessId = 0) {
        const headers = new HttpHeaders(this.getHeaders(version, businessId));
        if (ignore401)
            headers.set('SkipResponse401Interceptor', '1');
        if (url[0] !== '/')
            url = `/${url}`;
        return this.http.post(`${this.getBaseUrl()}${url}`, JSON.stringify(data), { headers: headers });
    }
    transform(value, transformation) {
        if (IsArray(transformation, true)) {
            transformation.map((transKey) => {
                // value = this.commonRepo.transform(value, transKey);
            });
        }
        else if (IsString(transformation, true)) {
            // value = this.commonRepo.transform(value, transformation);
        }
        return value;
    }
    _setParams(body) {
        let params = new HttpParams();
        for (const key of Object.keys(body)) {
            if (body[key]) {
                if (body[key] instanceof Array) {
                    body[key].forEach((item) => {
                        params = params.append(`${key.toString()}[]`, item);
                    });
                }
                else {
                    params = params.append(key.toString(), body[key]);
                }
            }
        }
        return params;
    }
}
PopRequestService.prov = i0.defineInjectable({ factory: function PopRequestService_Factory() { return new PopRequestService(i0.inject(i1.HttpClient), i0.inject("env")); }, token: PopRequestService, providedIn: "root" });
PopRequestService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopRequestService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class PopContextMenuConfig {
    constructor(config) {
        this.emitter = new EventEmitter();
        this.toggle = new Subject();
        this.x = 0;
        this.y = 0;
        this.options = [];
        this.newTabUrl = '';
        if (config != undefined && config.newTabUrl) {
            const newTabOption = {
                label: 'Open Link in new tab',
                type: 'new_tab',
                url: config.newTabUrl,
            };
            this.options.push(newTabOption);
        }
        if (config != undefined && config.options !== undefined && config.options.length != 0) {
            for (const option of config.options)
                this.options.push(option);
        }
    }
    addNewTabOption(url) {
        const newTabOption = {
            label: 'Open Link in new tab',
            type: 'new_tab',
            url: url,
        };
        this.options.push(newTabOption);
    }
    addPortalOption(internal_name = '', id) {
        const label = TitleCase(PopPipe.transform(internal_name, { type: 'entity', arg1: 'alias', arg2: 'singular' })).replace(/_/g, ' ').trim();
        const newTabOption = {
            label: `View ${label}`,
            type: 'portal',
            metadata: {
                internal_name: internal_name,
                id: id
            }
        };
        this.options.push(newTabOption);
    }
    addOption(option) {
        this.options.push(option);
    }
    resetOptions() {
        this.options = [];
    }
}

const EntityFieldSetting = {
    show_name: {
        name: 'show_name',
        label: 'Show Name',
        helpText: 'Show the name of the field as a Header',
        type: 'boolean',
        defaultValue: false,
    },
    edit_label: {
        name: 'edit_label',
        label: 'Allow Label Changes',
        helpText: 'The User will be able to see the label, but should they be allowed to change it?',
        type: 'boolean',
        group: 'label',
        defaultValue: true
    },
    custom_label: {
        name: 'custom_label',
        label: 'Allow Custom Label',
        helpText: 'The user will be able to select \'Custom\' from the dropdown and enter their own label',
        type: 'boolean',
        group: 'label',
        defaultValue: false,
    },
    unique_label: {
        name: 'unique_label',
        label: 'Require Unique Label',
        helpText: 'Each Value entry will be required to use a select a different label',
        type: 'boolean',
        group: 'label',
        defaultValue: false,
    },
};

class PopEntityFieldService extends PopExtendService {
    constructor() {
        super();
        this.name = 'PopEntityFieldService';
        this.srv = {
            request: ServiceInjector.get(PopRequestService)
        };
        PopLog.init(this.name, 'init', this);
    }
    // /**
    //  * Ensure that at least 1 label exists
    //  * @param field
    //  */
    // setFieldEntries(field: FieldInterface): Promise<boolean>{
    //   return new Promise<boolean>((resolve) => {
    //     if( !( IsArray(field.entries, true) ) ){
    //       const entry = {
    //         name: TitleCase(`${field.fieldgroup.name} 1`),
    //         type: 'provided'
    //       };
    //       this.srv.request.doPost(`fields/${field.id}/entries`, entry, 1, false).subscribe((res) => {
    //         res = res.data ? res.data : res;
    //         field.entries = [ res ];
    //         return resolve(true);
    //       }, (err) => {
    //         PopLog.error(this.name, `_setFieldEntryValues`, GetHttpErrorMsg(err));
    //         return resolve(false);
    //       });
    //     }else{
    //       return resolve(true);
    //     }
    //   });
    // }
    // /**
    //  * Ensure that the field has the correct amount of values
    //  * @param field
    //  */
    // setFieldValues(field: FieldInterface): Promise<boolean>{
    //   return new Promise<boolean>((resolve) => {
    //
    //     if( IsArray(field.entries, true) ){
    //       const realDataKeys = Object.keys(field.data).filter((id) => +id > 0);
    //       const api = [];
    //       if( !realDataKeys.length ){
    //         console.log('create default value for  ', realDataKeys, field);
    //         api.push(1);
    //       }
    //       if(field.multiple){
    //         let neededValues = field.multiple_min - realDataKeys.length;
    //         console.log('needed', neededValues);
    //         while(neededValues){
    //           api.push(1);
    //           neededValues--;
    //         }
    //
    //       }
    //       console.log('should have values', api)
    //
    //       return resolve(true);
    //     }else{
    //       return resolve(false);
    //     }
    //   });
    // }
    addEntryValue(core, field) {
        const dataIndex = field.data_keys.length;
        const entry = dataIndex in field.entries ? field.entries[dataIndex] : null;
        if (IsObject(entry, ['id'])) {
            console.log('entry', entry);
            const item = {
                data: {},
                entry: entry,
                config: {},
                index: dataIndex
            };
            Object.keys(field.children).map((name) => {
                const fieldItem = JsonCopy(field.children[name]);
                fieldItem.model.value = null; // clear any value that might have been stored from previous entry
                item.data[name] = null;
                fieldItem.model.facade = true;
                item.config[name] = FieldItemModelConfig(core, fieldItem.model);
            });
            return item;
        }
        else {
            console.log('fail', entry);
            return null;
        }
    }
    removeEntryValue(core, field, dataKey) {
        return new Promise((resolve) => {
            console.log('removeEntryValue', core, field, dataKey);
            const data = field.data[dataKey];
            if (IsObject(data, ['id'])) {
                const body = {};
                const path = StringReplaceAll(ParseUrlForParams(`#path/#entityId`, core.params), '//', '/');
                body[field.name] = {
                    field_entry_id: dataKey,
                    id: data.id
                };
                this.srv.request.doDelete(path, body, 1, false).subscribe((res) => {
                    if (res.data)
                        res = res.data;
                    console.log('removeEntryValue', res);
                    return resolve(true);
                }, () => {
                    return resolve(false);
                });
            }
            else {
                return resolve(true);
            }
        });
    }
    /**
     * Update a value for a single field item column of a field record
     * @param core
     * @param field
     * @param event
     */
    updateFieldItem(core, field, event) {
        return new Promise((resolve) => {
            if (IsValidFieldPatchEvent(core, event)) {
                const patch = {};
                const path = StringReplaceAll(ParseUrlForParams(`#path/#entityId`, core.params), '//', '/');
                patch[field.name] = {
                    field_entry_id: +event.data_key,
                    field_id: +field.id,
                    id: field.data[event.data_key].id ? field.data[event.data_key].id : null
                };
                patch[field.name][event.column] = event.config.control.value;
                this.srv.request.doPatch(path, patch, 1, false).subscribe((res) => {
                    if (res.data)
                        res = res.data;
                    const value = res[field.name].record[event.column];
                    field.data[event.data_key].id = res[field.name].record.id;
                    field.data[event.data_key][event.column] = value;
                    // if( IsObject(core.entity[ field.name ], true) ){
                    //   core.entity[ field.name ][ event.column ] = value;
                    // }else if( IsArray(core.entity[ field.name ], true) ){
                    //   console.log('session the data', core.entity[ field.name ], value);
                    // }
                    return resolve(true);
                }, (err) => {
                    const fieldPatch = event.config.patch;
                    const control = event.config.control;
                    fieldPatch.running = false;
                    control.markAsDirty();
                    control.setValue(this.asset.storedValue);
                    control.setErrors({ server: true });
                    event.config.message = GetHttpErrorMsg(err);
                    return resolve(false);
                });
            }
        });
    }
    /**
     * Set any field settings for this field & field items, and apply and stored values
     * @param field
     * @param settings
     */
    setFieldCustomSetting(field, settings) {
        const stored = field.configs;
        if (IsObject(field, ['fieldgroup', 'configs']) && IsObject(settings)) {
            settings = JSON.parse(JSON.stringify(Object.assign(Object.assign({}, EntityFieldSetting), settings)));
            Object.keys(settings).map((name) => {
                const setting = settings[name];
                if (IsObject(setting, true)) {
                    const value = IsDefined(setting.value, false) ? setting.value : setting.defaultValue;
                    setting.value = value;
                    if (setting.item && IsObject(field.children, [setting.item])) {
                        field.children[setting.item].custom_setting[name] = setting;
                        field.children[setting.item].setting[name] = value;
                    }
                    else {
                        field.custom_setting[name] = setting;
                        field.setting[name] = value;
                    }
                }
            });
            const childrenIdLookup = {};
            Object.keys(field.children).map((name) => {
                childrenIdLookup[field.children[name].id] = name;
            });
            if (IsArray(stored.field_configs, true)) {
                stored.field_configs.map((setting) => {
                    if (!field.custom_setting[setting.name]) {
                        // ToDo:: Do We want to allow the database to pass in configs that are not local?
                        PopLog.warn(this.name, `setFieldCustomSettingDefaults: setting no longer defined`, setting);
                        // field.custom_setting[ setting.name ] = setting;
                    }
                    else {
                        field.custom_setting[setting.name].id = setting.id;
                        field.custom_setting[setting.name].value = setting.value;
                    }
                    field.setting[setting.name] = setting.value;
                });
            }
            if (IsObject(stored.item_configs, true)) {
                Object.keys(stored.item_configs).map((fieldItemId) => {
                    const fieldItemConfigs = stored.item_configs[fieldItemId];
                    if (IsArray(fieldItemConfigs, true)) {
                        fieldItemConfigs.map((setting) => {
                            if (setting.field_id in childrenIdLookup) {
                                const item = field.children[childrenIdLookup[setting.field_id]];
                                // if( !item.custom_setting ) item.custom_setting = {};
                                if (!item.custom_setting[setting.name]) {
                                    // ToDo:: Do We want to allow the database to pass in configs that are not local
                                    PopLog.warn(this.name, `setFieldCustomSettingDefaults: setting no longer defined`, setting);
                                    // item.custom_setting[ setting.name ] = setting;
                                }
                                else {
                                    item.custom_setting[setting.name].id = setting.id;
                                    item.custom_setting[setting.name].value = setting.value;
                                }
                                // if( !item.setting ) item.setting = {};
                                item.setting[setting.name] = setting.value;
                                console.log('here', setting.name, { item: item, setting: setting });
                            }
                        });
                    }
                });
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _my() {
        return true;
    }
}
PopEntityFieldService.prov = i0.defineInjectable({ factory: function PopEntityFieldService_Factory() { return new PopEntityFieldService(); }, token: PopEntityFieldService, providedIn: "root" });
PopEntityFieldService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopEntityFieldService.ctorParameters = () => [];

class PopEntityFieldComponent extends PopExtendDynamicComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopEntityFieldComponent';
        this.srv = {
            field: ServiceInjector.get(PopEntityFieldService),
            router: ServiceInjector.get(Router),
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                // #1 Check Required Data:
                this.field = IsObjectThrowError(this.field, ['id'], `${this.name}:configure: - this.field`) ? this.field : null;
                this.id = this.field.id;
                // #2 Attach a context menu
                this._attachContextMenu();
                // #3 Handle Bubble events
                this.dom.handler.bubble = (core, event) => this.onBubbleEvent('handler', null, event);
                this.trait.bubble = true; // leave this on
                // #5: Render the dynamic field
                this.template.attach('container'); // 'container' references the @viewChild at top of file
                this.template.render([{
                        type: this.field.component,
                        inputs: {
                            core: this.core,
                            field: this.field,
                        }
                    }]);
                // set states
                this._setFieldState();
                resolve(true);
            });
        };
    }
    /**
     * This component should have a purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The user can call actions on this field
     * @param event
     */
    onActionButtonClick(event) {
        this.log.event(`onActionButtonClick`, event);
        if (event.type === 'field') {
            if (event.name === 'add') {
                this.onAdd(event);
            }
            else if (event.name === 'remove') {
                // this.onRemove(event);
            }
            else if (event.name === 'close') {
                // this.onClose(event);
            }
        }
        return true;
    }
    /**
     * User wants to add a value entry into the field
     * @param event
     */
    onAdd(event) {
        this.log.event(`onAdd`, event);
        if (this.field.facade) {
            this.onBubbleEvent('onAdd', null, event);
        }
        else {
            const childEmitter = StorageGetter(this.template, ['refs', '0', 'instance', 'events']);
            if (childEmitter) {
                childEmitter.emit(event);
                this._setFieldState();
            }
        }
        return true;
    }
    /**
     * User wants to make edits to the value entries
     * @param event
     */
    onEdit(event, dataKey) {
        this.log.event(`onEdit`, event);
        return true;
    }
    /**
     * User wants to remove a value entry
     * @param event
     */
    onRemove(event) {
        this.log.event(`onRemove`, event);
        console.log('here');
        if (this.field.facade) {
            this.onBubbleEvent('onRemove', null, event);
        }
        else {
            console.log('real delete action');
        }
        this._setFieldState();
        return true;
    }
    /**
     * User closes the edit ability of the value entries
     * @param event
     */
    onClose(event) {
        this.log.event(`onClose`, event);
        return true;
    }
    /**
     * The user can click on a link to view the config setup of this field
     */
    onNavigateToField() {
        this.srv.router.navigate(['entities', 'fields', this.field.id]).catch((e) => true);
    }
    /**
     * Handle the bubble events that come up
     * @param event
     */
    onBubbleEvent(name, extension, event) {
        this.log.event(`onBubbleEvent`, event);
        this._setFieldState();
        this.events.emit(event);
        return true;
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set internal state flags of a field
     * @private
     */
    _setFieldState() {
        this.dom.setTimeout(`allow-template-changes`, () => {
            // this.field.canAdd = this.field.multiple && this.field.data_keys.length < this.field.multiple_max;
            this.field.canAdd = this.field.multiple && this.field.data_keys.length < this.field.entries.length;
            this.field.canRemove = this.field.multiple && this.field.data_keys.length > this.field.multiple_min;
        }, 100);
    }
    /**
     * Interept the mouse right click to show a context menu for this field
     * @param event
     */
    _attachContextMenu() {
        this.dom.contextMenu.config = new PopContextMenuConfig();
        //
        this.dom.contextMenu.configure = (event) => {
            const hasAccess = true; // TBD
            if (hasAccess && this.dom.contextMenu.config) {
                event.preventDefault(); // prevent the default behavior of the right click.
                // reset the context menu, and configure it to load at the position clicked.
                this.dom.contextMenu.config.resetOptions();
                this.dom.contextMenu.config.addPortalOption('field', this.field.id);
                this.dom.contextMenu.config.addNewTabOption(`entities/fields/${this.field.id}`);
                this.dom.contextMenu.config.x = event.clientX;
                this.dom.contextMenu.config.y = event.clientY;
                this.dom.contextMenu.config.toggle.next(true);
            }
        };
        this.dom.setSubscriber('context-menu', this.dom.contextMenu.config.emitter.subscribe((event) => {
            this.events.emit(event);
        }));
    }
}
PopEntityFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field',
                template: "<!--<div class=\"pop-entity-field-container sw-field-main-wrapper-boundary\" (contextmenu)=\"dom.contextMenu.configure($event);\">-->\n<div class=\"pop-entity-field-container sw-field-main-wrapper-boundary\">\n<!--<div class=\"pop-entity-field-container sw-field-main-wrapper-boundary\">-->\n  <div class=\"import-field-header\" *ngIf=\"field.multiple || field.setting.show_name\">\n    <div class=\"import-field-header-title\" [ngClass]=\"{'sw-field-main-container-header-title-link sw-pointer sw-hover': true}\" (click)=\"onNavigateToField();\">\n      {{field.label}}\n    </div>\n    <!--<lib-pop-field-btn *ngIf=\"field.canAdd\" class=\"sw-mar-hrz-sm\" action=\"add\" [field]=\"field\" (events)=\"onActionButtonClick($event);\"></lib-pop-field-btn>-->\n  </div>\n  <div class=\"import-field-container\">\n    <ng-container #container></ng-container>\n  </div>\n  <!--<lib-pop-context-menu *ngIf=\"dom.contextMenu.config\" [config]=\"dom.contextMenu.config\"></lib-pop-context-menu>-->\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".sw-mar-xs{margin:var(--xs)}.sw-mar-sm{margin:var(--sm)}.sw-mar-md{margin:var(--md)}.sw-mar-lg{margin:var(--lg)}.sw-mar-xlg{margin:var(--xlg)}.sw-mar-hrz-xs{margin-left:var(--xs);margin-right:var(--xs)}.sw-mar-hrz-md,.sw-mar-hrz-sm{margin-left:var(--md);margin-right:var(--md)}.sw-mar-hrz-lg{margin-left:var(--lg);margin-right:var(--lg)}.sw-mar-hrz-xlg{margin-left:var(--xlg);margin-right:var(--xlg)}.sw-mar-vrt-xs{margin-top:var(--xs);margin-bottom:var(--xs)}.sw-mar-vrt-md,.sw-mar-vrt-sm{margin-top:var(--md);margin-bottom:var(--md)}.sw-mar-vrt-lg{margin-top:var(--lg);margin-bottom:var(--lg)}.sw-mar-vrt-xlg{margin-top:var(--xlg);margin-bottom:var(--xlg)}.sw-mar-lft-xs{margin-left:var(--xs)}.sw-mar-lft-sm{margin-left:var(--sm)}.sw-mar-lft-md{margin-left:var(--md)}.sw-mar-lft-lg{margin-left:var(--lg)}.sw-mar-lft-xlg{margin-left:var(--xlg)}.sw-mar-rgt-xs{margin-right:var(--xs)}.sw-mar-rgt-sm{margin-right:var(--sm)}.sw-mar-rgt-md{margin-right:var(--md)}.sw-mar-rgt-lg{margin-right:var(--lg)}.sw-mar-rgt-xlg{margin-right:var(--xlg)}.sw-mar-btm-xs{margin-bottom:var(--xs)}.sw-mar-btm-sm{margin-bottom:var(--sm)}.sw-mar-btm-md{margin-bottom:var(--md)}.sw-mar-btm-lg{margin-bottom:var(--lg)}.sw-mar-btm-xlg{margin-bottom:var(--xlg)}.sw-mar-top-xs{margin-top:var(--xs)}.sw-mar-top-sm{margin-top:var(--sm)}.sw-mar-top-md{margin-top:var(--md)}.sw-mar-top-lg{margin-top:var(--lg)}.sw-mar-top-xlg{margin-top:var(--xlg)}.sw-pad-xs{padding:var(--xs)}.sw-pad-md,.sw-pad-sm{padding:var(--md)}.sw-pad-lg{padding:var(--lg)}.sw-pad-xlg{padding:var(--xlg)}.sw-pad-hrz-xs{padding-left:var(--xs);padding-right:var(--xs)}.sw-pad-hrz-sm{padding-left:var(--sm);padding-right:var(--sm)}.sw-pad-hrz-md{padding-left:var(--md);padding-right:var(--md)}.sw-pad-hrz-lg{padding-left:var(--lg);padding-right:var(--lg)}.sw-pad-hrz-xlg{padding-left:var(--xlg);padding-right:var(--xlg)}.sw-pad-vrt-xs{padding-top:var(--xs);padding-bottom:var(--xs)}.sw-pad-vrt-md,.sw-pad-vrt-sm{padding-top:var(--md);padding-bottom:var(--md)}.sw-pad-vrt-lg{padding-top:var(--lg);padding-bottom:var(--lg)}.sw-pad-vrt-xlg{padding-top:var(--xlg);padding-bottom:var(--xlg)}.sw-pad-lft-xs{padding-left:var(--xs)}.sw-pad-lft-sm{padding-left:var(--sm)}.sw-pad-lft-md{padding-left:var(--md)}.sw-pad-lft-lg{padding-left:var(--lg)}.sw-pad-lft-xlg{padding-left:var(--xlg)}.sw-pad-rgt-xs{padding-right:var(--xs)}.sw-pad-rgt-sm{padding-right:var(--sm)}.sw-pad-rgt-md{padding-right:var(--md)}.sw-pad-rgt-lg{padding-right:var(--lg)}.sw-pad-rgt-xlg{padding-right:var(--xlg)}.sw-pad-btm-xs{padding-bottom:var(--xs)}.sw-pad-btm-sm{padding-bottom:var(--sm)}.sw-pad-btm-md{padding-bottom:var(--md)}.sw-pad-btm-lg{padding-bottom:var(--lg)}.sw-pad-btm-xlg{padding-bottom:var(--xlg)}.sw-pad-top-xs{padding-top:var(--xs)}.sw-pad-top-sm{padding-top:var(--sm)}.sw-pad-top-md{padding-top:var(--md)}.sw-pad-top-lg{padding-top:var(--lg)}.sw-pad-top-xlg{padding-top:var(--xlg)}.import-text-xs{font-size:.8em}.import-text-sm{font-size:.9em}.import-text-md{font-size:1em}.import-text-lg{font-size:1.1em}.import-text-xlg{font-size:1.2em}:host ::ng-deep .mat-form-field .mat-form-field-infix{width:0!important}:host ::ng-deep .mat-form-field-appearance-outline .mat-form-field-flex{margin-top:0!important}.pop-entity-field-container{position:relative;display:block;min-height:30px;width:100%;box-sizing:border-box;max-width:var(--field-max-width);margin-top:10px;clear:both}.pop-entity-field-container .import-field-item-container{margin-top:5px!important}.pop-entity-field-container ::ng-deep .mat-form-field-infix{width:0!important}.pop-entity-field-container ::ng-deep .mat-form-field-flex{margin-top:0!important}"]
            },] }
];
PopEntityFieldComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopEntityFieldComponent.propDecorators = {
    field: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class PopDomService {
    constructor() {
        this.id = PopUid();
        this.name = 'PopDomService';
        this.asset = {
            sessionKeys: { height: 1, width: 1, state: 1, active: 1, session: 1 },
            map: {}
        };
        this.ui = {
            active: {},
            fields: new Map(),
            map: {}
        };
        this.position = {};
        this.map = {};
        this.components = {};
    }
    onRegister(component) {
        if (component.name && typeof component.id !== 'undefined' && component.dom) {
            if (this.components[component.name] && this.components[component.name][component.id]) {
                this.applyDomKeys(component);
            }
            else {
                this.createDomSession(component);
            }
        }
    }
    onSession(dom, key = null) {
        if (dom.name && dom.id) {
            this.sessionDomKeys(dom, key);
        }
    }
    getComponentHeight(component, componentId = 1) {
        return this.components[component] && this.components[component][componentId] && IsObject(this.components[component][componentId].height, true) ? this.components[component][componentId].height : null;
    }
    getComponentWidth(component, componentId = 1) {
        return this.components[component] && this.components[component][componentId] && IsObject(this.components[component][componentId].width, true) ? this.components[component][componentId].width : null;
    }
    getComponentSession(component, componentId = 1) {
        return this.components[component] && this.components[component][componentId] && IsObject(this.components[component][componentId].onSession, true) ? this.components[component][componentId].onSession : null;
    }
    onDetach(name, id) {
        if (name && id) {
            if (this.components[name] && this.components[name][id]) {
                delete this.components[name][id];
            }
        }
    }
    ngOnDestroy() {
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    createDomSession(component) {
        if (component.name && typeof component.id !== 'undefined') {
            if (!this.components[component.name])
                this.components[component.name] = {};
            if (!this.components[component.name][component.id])
                this.components[component.name][component.id] = {};
            // if( dom.emitter instanceof EventEmitter ) this.components[ dom.name ][ dom.entityId ].emitter = dom.emitter;
            this.sessionDomKeys(component);
        }
    }
    applyDomKeys(component) {
        if (this.components[component.name] && this.components[component.name][component.id]) {
            Object.keys(this.components[component.name][component.id]).map((key) => {
                if (key && this.asset.sessionKeys[key]) {
                    component.dom[key] = this.components[component.name][component.id][key];
                }
            });
        }
    }
    sessionDomKeys(component, key = null) {
        if (this.components[component.name] && this.components[component.name][component.id]) {
            if (key && key in this.asset.sessionKeys) {
                if (IsObject(component.dom[key], true)) {
                    this.components[component.name][component.id][key] = component.dom[key];
                }
            }
            else {
                Object.keys(this.asset.sessionKeys).map((sessionKey) => {
                    if (IsObject(component.dom[sessionKey], true)) {
                        this.components[component.name][component.id][sessionKey] = component.dom[sessionKey];
                    }
                });
            }
        }
    }
}
PopDomService.prov = i0.defineInjectable({ factory: function PopDomService_Factory() { return new PopDomService(); }, token: PopDomService, providedIn: "root" });
PopDomService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopDomService.ctorParameters = () => [];

class PopTableDialogComponent$1 {
    constructor(dialog, data) {
        this.dialog = dialog;
        this.data = data;
        this.ui = {
            table: undefined,
        };
        this._buildTable();
    }
    ngOnInit() {
    }
    _buildTable() {
        const tableData = this.data.data;
        this.data.table.data = tableData;
        this.ui.table = this.data.table;
    }
    onClose() {
        this.dialog.close(null);
    }
}
PopTableDialogComponent$1.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-table-dialog',
                template: "<div class=\"container\">\n  <!-- <h2 class=\"confirmation-header\"> {{data.display}} </h2>\n  <div class=\"cpcup-body\"> {{data.body}} </div>\n  <div class=\"pull-right\">\n      <button mat-raised-button class=\"mat-raised-button\" (click)=\"onClose()\" role=\"button\"> CLOSE </button>\n  </div> -->\n  <h1 class=\"cpc-confirmation-dialog-header\">{{data.header}}</h1>\n  <!-- <div [ngClass]=\"{'sw-hidden': !data.body}\" class=\"cpc-confirmation-body pt-10\" [innerHTML]=\"data.body\"></div> -->\n  <p class=\"cpc-confirmation-body\">{{data.message}}</p>\n  <div>\n    <lib-pop-table [config]=\"ui.table\"></lib-pop-table>\n  </div>\n\n  <div class=\"cpc-confirmation-dialog-footer cpc-pull-right\">\n    <button mat-raised-button class=\"mat-raised-button\" (click)=\"onClose()\" role=\"button\"> CLOSE</button>\n  </div>\n</div>\n",
                styles: [".cpc-pull-right{margin-top:var(--gap-lm);float:right}.cpc-pull-right button{margin-right:var(--radius-xl)}:host ::ng-deep .pop-table-container{overflow-y:scroll}.cpc-confirmation-dialog-header{margin-top:0;text-align:center}.cpc-confirmation-body{margin:var(--gap-s) 0 var(--gap-lm) 0;padding:var(--gap-m);overflow-y:auto}.cpc-confirmation-dialog-footer{display:flex;justify-content:space-between;align-items:center}:host ::ng-deep .pop-table-footer{display:none!important}"]
            },] }
];
PopTableDialogComponent$1.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class PopSideBySideComponent extends PopExtendComponent {
    constructor(el, _domRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopSideBySideComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            param: ServiceInjector.get(PopEntityUtilParamService),
            router: ServiceInjector.get(Router),
        };
        this.availableFilterValue = '';
        this.assignedFilterValue = '';
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.id = this.config.id ? this.config.id : PopUid();
                this._trackAssignedOptions();
                this._setHooks();
                this._setContextMenu();
                this._checkForAssignedOptions();
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this._setHeight();
                return resolve(true);
            }));
        };
    }
    /**
     * This component should have a purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Filter Utility
     * @param type
     * @param filter
     */
    onApplyFilter(type, filter) {
        this.dom.setTimeout('apply-filter', () => {
            if (this.config.filterBoth) {
                this.onFilterBoth(filter);
                this.assignedFilterValue = filter;
                this.availableFilterValue = filter;
            }
            else {
                if (type === 'assigned') {
                    this._filterAssignedOptions(filter);
                    this.assignedFilterValue = filter;
                }
                else {
                    this._filterAvailableOptions(filter);
                    this.availableFilterValue = filter;
                }
            }
            this.onBubbleEvent('apply-filter', null, { method: type, value: filter });
        }, 200);
    }
    /**
     * Filter both columns
     */
    onFilterBoth(filter) {
        this.config.options.values.map(option => {
            option.assignedFilter = option.optionFilter = !ObjectContainsTagSearch(option, filter);
        });
    }
    /**
     * Assign a specific option
     */
    onOptionAssign(option, confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.config.disabled) {
                if (IsObject(option, true) && !this.ui.assigned[option.value] && !option.optionBlock && !option.optionFilter) {
                    if (this.config.facadeEvent) {
                        this.onBubbleEvent('facadeEvent', 'Facade Event has been triggered', {
                            method: 'remove',
                            options: [option],
                            ids: [+option.value]
                        }, true);
                        return resolve(true);
                    }
                    else {
                        yield this._assign([option], confirmed);
                        return resolve(true);
                    }
                }
                else {
                    return resolve(true);
                }
            }
        }));
    }
    /**
     * Assign all options
     */
    onAssignAllOptions(confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const options = this.config.options.values.filter(option => {
                return !this.ui.assigned[option.value] && !option.optionBlock && !option.optionFilter;
            });
            if (!options.length) {
                return resolve(true);
            }
            if (this.config.facadeEvent) {
                this.onBubbleEvent('facadeEvent', 'Facade Event has been triggered', {
                    method: 'assign',
                    options: options,
                    ids: options.map(o => +o.value)
                }, true);
                return resolve(true);
            }
            else {
                yield this._assign(options, confirmed);
                return resolve(true);
            }
        }));
    }
    /**
     * Remove an option that is assigned
     * @param option
     * @param confirmed
     */
    onRemoveOption(option, confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.config.disabled) {
                if (IsObject(option)) {
                    if (this.config.facadeEvent) {
                        this.onBubbleEvent('facadeEvent', 'Facade Event has been triggered', {
                            method: 'remove',
                            options: [option],
                            ids: [+option.value]
                        }, true);
                        return resolve(true);
                    }
                    else {
                        yield this._remove([option], confirmed);
                        return resolve(true);
                    }
                }
                else {
                    return resolve(true);
                }
            }
        }));
    }
    /**
     * Remove all options that are assigned
     */
    onRemoveAllOptions(confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.config.patch.removeErrMessage = '';
            const options = [];
            this.config.options.values.map(option => {
                if (this.ui.assigned[option.value] && !option.assignedFilter) {
                    option.patching = true;
                    options.push(option);
                }
            });
            if (!options.length) {
                return resolve(true);
            }
            if (this.config.facadeEvent) {
                this.onBubbleEvent('facadeEvent', 'Facade Event has been triggered', {
                    method: 'remove',
                    options: options,
                    ids: options.map(o => +o.value)
                }, true);
                return resolve(true);
            }
            else {
                yield this._remove(options, confirmed);
                return resolve(true);
            }
        }));
    }
    /**
     * Go to linked route of option
     * @param option
     */
    onNavigateToOptionRoute(option) {
        if (this.config.route) {
            let route = this.config.route.slice();
            route = String(route).replace(/:value/g, '' + option.value).replace(/:name/g, option.name);
            this.srv.router.navigateByUrl(route).then(data => {
            })
                .catch(e => {
                // const errMessage = 'Route not found:' + route;
                // console.log(e);
                this.events.emit({ source: this.name, type: 'context_menu', name: 'portal', data: route, config: this.config });
                // option.errMessage = errMessage;
                // setTimeout(() => {
                //   if( option.errMessage === errMessage ) option.errMessage = '';
                // }, 2000);
            });
        }
    }
    /**
     * Intercept the user right mouse click to show a context menu for this component
     * @param option
     * @param event
     */
    onMouseRightClick(option, event) {
        let route = this.config.route.slice();
        route = String(route).replace(/:value/g, '' + option.value).replace(/:name/g, option.name);
        if (!route)
            return false;
        // if we haven't returned, prevent the default behavior of the right click.
        event.preventDefault();
        const context = this.dom.contextMenu.config;
        // reset the context menu, and configure it to load at the position clicked.
        context.resetOptions();
        // if(this.config.internal_name) this.dom.contextMenu.addPortalOption(this.config.internal_name, +row.entityId);
        const api_path = route.split('/')[0];
        const entityParams = this.srv.param.getEntityParamsWithPath(api_path, option.value);
        if (entityParams)
            context.addPortalOption(entityParams.internal_name, entityParams.entityId);
        context.addNewTabOption(route);
        context.x = event.clientX;
        context.y = event.clientY;
        context.toggle.next(true);
    }
    onBubbleEvent(eventName, message = null, extend = {}, force = false) {
        const event = {
            type: 'field',
            name: eventName,
            source: this.name
        };
        if (this.config)
            event.config = this.config;
        if (message)
            event.message = message;
        Object.keys(extend).map((key) => {
            event[key] = extend[key];
        });
        this.log.event(`onBubbleEvent`, event);
        if (this.config.bubble || force) {
            this.events.emit(event);
        }
        return event;
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _assign(options, confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this._beforePatch(options);
            if (this.config.facade) {
                yield Sleep(500);
                this._onAssignSuccess(options);
                return resolve(true);
            }
            else if (this.config.patch.path && this.config.patch.field) {
                const request = this._getRequest('assign', this._getRequestBody('assign', options, confirmed));
                request.subscribe((res) => __awaiter(this, void 0, void 0, function* () {
                    if (res.data)
                        res = res.data;
                    if (res.confirmation) {
                        const isConfirmed = yield this._confirmAction(res.confirmation);
                        if (isConfirmed) {
                            this._assign(options, true).then(() => true);
                        }
                    }
                    else {
                        this._onAssignSuccess(options);
                        this.onBubbleEvent('patch', 'Patched', {
                            success: true,
                            method: 'assign',
                            ids: options.map(o => o.value),
                            value: this.config.assigned
                        }, true);
                    }
                    return resolve(res);
                }), (err) => {
                    this._handleAssignError(err);
                    this._onAssignFail(options);
                    return resolve(false);
                });
            }
            else {
                this._onAssignSuccess(options);
                return resolve(true);
            }
        }));
    }
    _remove(options = [], confirmed = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this._beforePatch(options);
            if (this.config.facade) {
                yield Sleep(500);
                this._onRemoveSuccess(options);
                return resolve(true);
            }
            else if (this.config.patch.path && this.config.patch.field) {
                if (!confirmed && this.config.patch.conflictPath) {
                    const value = options[0].value;
                    // const path = 'users/12/roles/1/conflicts';
                    const path = InterpolateString(this.config.patch.conflictPath, { value: value });
                    // users/{entityId}/roles/{value}/conflicts
                    PopRequest.doPost(path, {}).subscribe((res) => __awaiter(this, void 0, void 0, function* () {
                        if (res.data)
                            res = res.data;
                        if (IsArray(res, true)) {
                            options.map((option) => {
                                option.patching = false;
                            });
                            const isConfirmed = yield this._confirmAction(res[0]);
                            if (isConfirmed) {
                                this._remove(options, true).then(() => true);
                            }
                        }
                        else {
                            this._remove(options, true).then(() => true);
                        }
                    }));
                }
                else {
                    const request = this._getRequest('remove', this._getRequestBody('remove', options, confirmed));
                    request.subscribe((res) => __awaiter(this, void 0, void 0, function* () {
                        if (res.data)
                            res = res.data;
                        this._onRemoveSuccess(options);
                        this.onBubbleEvent('patch', 'Patched', {
                            success: true,
                            method: 'remove',
                            ids: options.map(o => o.value),
                            value: this.config.assigned
                        }, true);
                        return resolve(res);
                    }), (err) => {
                        this._handleRemoveError(err);
                        this._onRemoveFail(options);
                    });
                }
            }
            else {
                this._onRemoveSuccess(options);
                return resolve(true);
            }
        }));
    }
    _getRequestBody(method, options, confirmed = false) {
        if (this.config.patch.field) {
        }
        const body = {};
        if (this.config.patch.metadata) {
            for (const i in this.config.patch.metadata) {
                if (!this.config.patch.metadata.hasOwnProperty(i))
                    continue;
                body[i] = this.config.patch.metadata[i];
            }
        }
        body[this.config.patch.field] = options.map(o => o.value);
        body['method'] = method;
        body['confirmed'] = confirmed;
        return body;
    }
    _getRequest(method, body = {}) {
        let path = this.config.patch.path;
        const ignore401 = (this.config.patch.ignore401 ? true : null);
        const version = (this.config.patch.version ? this.config.patch.version : 1);
        const post = {};
        if (this.config.patch.metadata) {
            for (const i in this.config.patch.metadata) {
                if (!this.config.patch.metadata.hasOwnProperty(i))
                    continue;
                post[i] = this.config.patch.metadata[i];
            }
        }
        if (this.config.patch.addId) {
            const id = body[this.config.patch.field][0];
            path = InterpolateString(this.config.patch.path, { id: id });
        }
        if (method === 'assign') {
            switch (String(this.config.patch.assignMethod).toLowerCase()) {
                case 'patch':
                    return PopRequest.doPatch(`${path}`, body, version, ignore401);
                    break;
                case 'post':
                    return PopRequest.doPost(`${path}`, body, version, ignore401);
                    break;
                default:
                    return PopRequest.doPost(`${path}`, body, version, ignore401);
                    break;
            }
        }
        else {
            switch (String(this.config.patch.removedMethod).toLowerCase()) {
                case 'patch':
                    return PopRequest.doPatch(`${path}`, body, version, ignore401);
                    break;
                case 'post':
                    return PopRequest.doPost(`${path}`, body, version, ignore401);
                    break;
                case 'delete':
                    return PopRequest.doDelete(`${path}`, body, version, ignore401);
                    break;
                default:
                    return PopRequest.doDelete(`${path}`, body, version, ignore401);
                    break;
            }
            return PopRequest.doDelete(`${path}`, body, version, ignore401);
        }
    }
    _handleAssignError(err) {
        this.config.patch.assignErrMessage = GetHttpErrorMsg(err);
        this.config.patch.running = false;
    }
    _handleRemoveError(err) {
        this.config.patch.removeErrMessage = GetHttpErrorMsg(err);
        this.config.patch.running = false;
    }
    _onAssignSuccess(options = []) {
        this.config.patch.running = false;
        options.map(option => {
            this.ui.assigned[option.value] = 1;
            option.patching = false;
        });
        this._checkForAssignedOptions();
        const event = this.onBubbleEvent('assign', 'Assigned', {
            method: 'assign',
            ids: options.map(o => o.value),
            value: this.config.assigned
        });
        if (IsCallableFunction(this.config.patch.callback)) {
            this.config.patch.callback(this.core, event);
        }
    }
    _beforePatch(options = []) {
        this.config.patch.removeErrMessage = '';
        this.config.patch.running = true;
        options.map((option) => {
            option.patching = true;
            option.errMessage = '';
        });
    }
    _formatConflictData(conflictData) {
        const tableData = conflictData.map(pods => {
            return { pod: pods.name, title: pods.pivot.is_leader ? 'Leader' : 'Member' };
        });
        return tableData;
    }
    _confirmAction(conflictData) {
        return new Promise((resolve) => {
            const tableData = this._formatConflictData(conflictData);
            this.srv.dialog.open(PopTableDialogComponent$1, {
                width: '500px',
                data: {
                    data: tableData,
                    type: 'sideBySide',
                    table: this.config.patch.conflictTableConfig,
                    message: this.config.patch.conflictMessage,
                    header: this.config.patch.conflictHeader ? this.config.patch.conflictHeader : ''
                }
            }).afterClosed().subscribe(res => {
                return resolve(res ? true : false);
            });
        });
    }
    _onAssignFail(options = []) {
        this.config.patch.running = false;
        options.map(option => {
            delete this.ui.assigned[option.value];
            option.patching = false;
        });
        this._checkForAssignedOptions();
    }
    _onRemoveFail(options = []) {
        this.config.patch.running = false;
        options.map(option => {
            this.ui.assigned[option.value] = 1;
            option.patching = false;
        });
        this._checkForAssignedOptions();
    }
    _onRemoveSuccess(options = []) {
        this.config.patch.running = false;
        options.map(option => {
            delete this.ui.assigned[option.value];
            option.patching = false;
        });
        this._checkForAssignedOptions();
        const event = this.onBubbleEvent('remove', 'Removed', {
            method: 'remove',
            ids: options.map(o => o.value),
            value: this.config.assigned
        });
        if (IsCallableFunction(this.config.patch.callback)) {
            this.config.patch.callback(this.core, event);
        }
    }
    /**
     * Helper function that naivgates the complexity of the setting the heights needed in this component
     */
    _setHeight() {
        return new Promise((resolve) => {
            this.dom.overhead = 2;
            if (this.config.hasHeader)
                this.dom.overhead += 38;
            if (this.config.hasFilterRow)
                this.dom.overhead += 49;
            if (this.config.hasLabelRow)
                this.dom.overhead += 45;
            if (!this.config.height)
                this.config.height = PopTemplate.getContentHeight(false, 270);
            let tabColumnHeight = this.dom.repo.getComponentHeight('PopEntityTabColumnComponent', this.position);
            if (!tabColumnHeight)
                tabColumnHeight = this.dom.repo.getComponentHeight('PopTabMenuComponent', 1);
            if (tabColumnHeight && tabColumnHeight.inner) {
                this.dom.height.default = tabColumnHeight.inner - 20;
            }
            else {
                this.dom.height.default = PopTemplate.getContentHeight(false, this.dom.overhead);
            }
            if (this.config.parentClassName) {
                this.dom.overhead = this.dom.overhead + (Math.abs(this.el.nativeElement.offsetTop) + 100);
                this.dom.setHeightWithParent(this.config.parentClassName, this.dom.overhead, this.dom.height.default).then((res) => {
                    this.log.info(`setHeight with ${this.config.parentClassName}`);
                    return resolve(true);
                });
            }
            else {
                if (this.config.height) {
                    // if( this.config.height < ( this.dom.overhead * 2 ) ) this.config.height = this.dom.overhead * 2;
                    this.dom.setHeight(this.config.height, this.dom.overhead);
                    this.log.info(`setHeight with config.height:${this.config.height} - overhead:${this.dom.overhead}`);
                }
                else if (this.config.bucketHeight) {
                    this.config.height = this.config.bucketHeight + this.dom.overhead;
                    this.dom.setHeight(+this.config.height, this.dom.overhead);
                    this.log.info(`setHeight with config.bucketHeight:${this.config.bucketHeight} - overhead:${this.dom.overhead}`);
                }
                else if (this.config.bucketLimit) {
                    this.config.bucketLimit = this.config.bucketLimit > this.config.options.values.length ? this.config.options.values.length : this.config.bucketLimit;
                    this.config.bucketHeight = (this.config.bucketLimit * 30.5);
                    this.config.height = this.config.bucketHeight + this.dom.overhead;
                    this.dom.setHeight(+this.config.height, this.dom.overhead);
                    this.log.info(`setHeight with config.bucketLimit:${this.config.bucketLimit} - overhead:${this.dom.overhead}`);
                }
                else {
                    this.log.info(`setHeight with defaultHeight:${this.dom.height.default} - overhead:${this.dom.overhead}`);
                    this.dom.setHeight(this.dom.height.default, this.dom.overhead);
                }
                return resolve(true);
            }
        });
    }
    /**
     * This will block certain options from being available
     * @param bucket
     * @param ids
     */
    _blockBucketOptions(bucket, ids) {
        if (['assign', 'option', 'both'].includes(bucket)) {
            const map = ArrayMapSetter(this.config.options.values, 'value');
            ids.map((id) => {
                if (id in map) {
                    if (bucket === 'assign') {
                        this.config.options.values[map[id]].assignBlock = true;
                    }
                    else if (bucket === 'option') {
                        this.config.options.values[map[id]].optionBlock = true;
                    }
                    else {
                        this.config.options.values[map[id]].assignBlock = true;
                        this.config.options.values[map[id]].optionBlock = true;
                    }
                }
            });
        }
    }
    /**
     * This will un-block certain options from being available
     * @param bucket
     * @param ids
     */
    _unblockBucketOptions(bucket, ids) {
        if (['assign', 'option', 'both'].includes(bucket)) {
            const map = ArrayMapSetter(this.config.options.values, 'value');
            ids.map((id) => {
                if (id in map) {
                    if (bucket === 'assign') {
                        this.config.options.values[map[id]].assignBlock = false;
                    }
                    else if (bucket === 'option') {
                        this.config.options.values[map[id]].optionBlock = false;
                    }
                    else {
                        this.config.options.values[map[id]].assignBlock = false;
                        this.config.options.values[map[id]].optionBlock = false;
                    }
                }
            });
        }
    }
    /**
     * Allow other modules to trigger certain functionality
     * @param option
     * @param event
     */
    _setHooks() {
        this.config.assign = (options, confirmed = false) => {
            return this._assign(options, confirmed);
        };
        this.config.remove = (options, confirmed = false) => {
            return this._remove(options, confirmed);
        };
        this.config.removeAllOptions = () => {
            return of(this.onRemoveAllOptions());
        };
        this.config.addAllOptions = () => {
            return of(this.onAssignAllOptions());
        };
        this.config.applyFilter = (type, filter) => {
            this.onApplyFilter(type, filter);
        };
        this.config.getAssigned = () => {
            return this.config.assigned.slice();
        };
        this.config.block = (bucket, ids) => {
            this._blockBucketOptions(bucket, ids);
        };
        this.config.unblock = (bucket, ids) => {
            this._unblockBucketOptions(bucket, ids);
        };
    }
    /**
     * Intercept the user right mouse click to show a context menu for this component
     * @param option
     * @param event
     */
    _setContextMenu() {
        this.dom.contextMenu.config = new PopContextMenuConfig();
        this.dom.setSubscriber('context-menu', this.dom.contextMenu.config.emitter.subscribe((event) => {
            this.log.event(`context-menu`, event);
            this.events.emit(event);
        }));
    }
    /**
     * Get the count of assigned options
     */
    _checkForAssignedOptions() {
        this.config.assigned = Object.keys(this.ui.assigned);
        this.ui.assignedCount = this.config.assigned.length;
        this.ui.optionsCount = this.config.options.values.length;
        if (this.ui.assignedCount == this.ui.optionsCount)
            this.ui.optionsCount = 0;
    }
    /**
     * Filter assigned options
     * @param filter
     */
    _filterAssignedOptions(filter) {
        this.config.options.values.map(option => {
            option.assignedFilter = !ObjectContainsTagSearch(option, filter);
        });
    }
    /**
     * Filter un-assigned options
     * @param filter
     */
    _filterAvailableOptions(filter) {
        this.config.options.values.map(option => {
            option.optionFilter = !ObjectContainsTagSearch(option, filter);
        });
    }
    /**
     * Set the intial state of the assigned options
     */
    _trackAssignedOptions() {
        this.ui.assigned = {};
        this.config.assigned.map(optionID => {
            this.ui.assigned[optionID] = 1;
        });
    }
}
PopSideBySideComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-side-by-side',
                template: "<div class=\"sbs-container\" [style.height.px]=dom.height.outer *ngIf=\"dom.state.loaded\">\n  <div *ngIf=\"config.display && config.displayTitle\" class=\"sbs-row-container\">\n    <div class=\"sbs-title\">{{config.display}}</div>\n  </div>\n\n  <div class=\"sbs-row-container sbs-border-top sbs-border-r sbs-border-l\" *ngIf=\"config.hasLabelRow\">\n    <div class=\"sbs-column-container sbs-border-r sbs-header\">\n      <div class=\"sbs-column-content sbs-center-text-vert\" >\n        <div class=\"sbs-row-container\">\n          <div class=\"sbs-error-container sbs-assigned-error-container\" *ngIf=\"config.patch.removeErrMessage\">\n            <div class=\"sw-pointer options-error\" matTooltipPosition=\"right\" [matTooltip]=\"config.patch.removeErrMessage\">\n              <mat-icon class=\"sbs-error-icon\" color=\"warn\">info</mat-icon>\n            </div>\n        </div>\n\n        <div class=\"sbs-item-toggle-container sw-pointer sbs-item-toggle-container-left\" *ngIf=\"config.removeAll\">\n          <div class=\"sw-push-button-label\"\n\n               [ngClass]=\"{'sw-disabled': config.disabled || config.patch.running}\"\n               (click)=\"onRemoveAllOptions();\"\n               matTooltipPosition=\"above\"\n               [matTooltip]=\"'Remove All'\"\n               [matTooltipShowDelay]=\"750\"\n               [matTooltipHideDelay]=\"250\">\n            <p>S</p>\n            <div class=\"sw-push-button-inner-label\">\n            </div>\n          </div>\n        </div>\n\n        <div class=\"sbs-row-container sbs-flex sbs-title-left\"\n             [ngClass]=\"{'sw-hidden': !config.assignedLabel, 'sw-disabled': config.disabled}\">\n            <div class=\"sbs-flex mat-body-2 sbs-label header-label\">{{config.assignedLabel}}</div>\n          </div>\n\n        </div>\n      </div>\n    </div>\n    <div class=\"sbs-column-container sbs-header\">\n      <div class=\"sbs-column-content sbs-center-text-vert\">\n        <div class=\"sbs-row-container\">\n\n          <div class=\"sbs-item-toggle-container\"\n               *ngIf=\"config.assignAll\">\n            <div class=\"sw-push-button-label sw-pointer\"\n                 [ngClass]=\"{'sw-disabled': config.disabled || config.patch.running}\"\n                 (click)=\"onAssignAllOptions();\"\n                 matTooltipPosition=\"above\"\n                 [matTooltipShowDelay]=\"750\"\n                 [matTooltipHideDelay]=\"250\"\n                 [matTooltip]=\"'Assign All'\">\n              <p class=\"rotate\">S</p>\n              <div class=\"sw-push-button-inner-label\">\n              </div>\n            </div>\n\n          </div>\n          <div class=\"sbs-row-container sbs-flex sbs-title-left\"\n               [ngClass]=\"{'sw-hidden': !config.optionsLabel,'sw-disabled': config.disabled}\">\n            <div class=\"sbs-label sbs-flex sbs-header-label mat-body-2 header-label\">{{config.optionsLabel}}</div>\n          </div>\n          <div class=\"sbs-error-container sbs-options-error-container\" *ngIf=\"config.patch.assignErrMessage\">\n            <div class=\"sw-pointer options-error\"\n                 matTooltipPosition=\"left\"\n                 [matTooltip]=\"config.patch.assignErrMessage\">\n              <mat-icon class=\"sbs-error-icon\" color=\"warn\">info</mat-icon>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"sbs-row-container \" *ngIf=\"config.hasFilterRow && !config.filterBoth\">\n    <div class=\"sbs-column-container sbs-search-header sbs-border-l sbs-border-top \">\n      <div class=\"sbs-column-content sbs-center-text-vert\">\n        <div class=\"sbs-row-container\">\n          <mat-icon matPrefix class=\"sbs-search-icon\">search</mat-icon>\n          <input #assignedFilter class=\"sbs-flex sbs-filter mat-body-2\" placeholder=\"Search\"\n                 (keyup)=\"onApplyFilter('assigned', $event.target['value'])\">\n          <mat-icon class=\"sw-pointer sbs-clear-filter\"  class=\"sw-pointer sbs-clear-filter\" [ngClass]=\"{'hide-clear-icon': !this.assignedFilterValue, 'show-clear-icon': this.assignedFilterValue}\"\n                    (click)=\"assignedFilter.value = ''; assignedFilter.focus(); onApplyFilter('assigned', '');\">clear\n          </mat-icon>\n        </div>\n      </div>\n    </div>\n    <div class=\"sbs-column-container sbs-border-l sbs-border-r sbs-border-top\">\n      <div class=\"sbs-column-content  sbs-center-text-vert\">\n        <div class=\"sbs-row-container\">\n          <mat-icon matPrefix class=\"sbs-search-icon\">search</mat-icon>\n          <input #optionFilter class=\"sbs-flex sbs-filter\" placeholder=\"Search\"\n                 (keyup)=\"onApplyFilter('options', $event.target['value'])\">\n          <mat-icon class=\"sw-pointer sbs-clear-filter\" [ngClass]=\"{'hide-clear-icon': !this.availableFilterValue, 'show-clear-icon': this.availableFilterValue}\" (click)=\"optionFilter.value = ''; optionFilter.focus(); onApplyFilter('options', '');\">\n            clear\n          </mat-icon>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"sbs-row-container sbs-border-l sbs-border-r sbs-border-top sbs-content-pad sbs-search-header\" *ngIf=\"config.hasFilterRow && config.filterBoth\">\n\n    <div class=\"sbs-column-content  sbs-center-text-vert\">\n      <div class=\"sbs-row-container\">\n\n    <mat-icon matPrefix class=\"sbs-search-icon\">search</mat-icon>\n    <input #bothFilter class=\"sbs-flex sbs-filter\" placeholder=\"Search\" (keyup)=\"onApplyFilter('both', $event.target.value)\">\n    <mat-icon class=\"sw-pointer sbs-clear-filter\" [ngClass]=\"{'hide-clear-icon': !this.availableFilterValue, 'show-clear-icon': this.availableFilterValue}\" (click)=\"bothFilter.value = ''; bothFilter.focus(); onApplyFilter('both', '');\">\n      clear\n    </mat-icon>\n      </div></div>\n  </div>\n\n  <div class=\"sbs-row-container sbs-border-top sbs-border-r sbs-border-l sbs-border-bottom\" [style.height.px]=\"dom.height.inner\">\n    <div class=\"sbs-column-container sbs-border-r sbs-column-left\">\n      <div class=\"sbs-column-container sbs-flex\" *ngIf=\"!ui.optionsCount && config.displayHelper ? '': !ui.assignedCount && config.displayHelper\">\n        <div class=\"sbs-column-content\">\n          <div class=\"sbs-row-container\">\n            <mat-icon class=\"sbs-helper-icon\">sentiment_dissatisfied</mat-icon>\n          </div>\n          <div class=\"sbs-row-container \">\n            <label class=\"help-text sbs-align-center\">{{config.helpText}}</label>\n          </div>\n          <div class=\"sbs-row-container \">\n          <p class=\"help-caption mat-caption sbs-align-center\">Use the arrows <span class=\"left-arrow\">S</span> to make assignments</p>\n          </div>\n        </div>\n      </div>\n      <mat-list class=\"sbs-bucket sbs-assigned-bucket\" [style.height.px]=\"dom.height.inner\" *ngIf=\"ui.assignedCount || !config.displayHelper\">\n        <!--<mat-list-item class=\"sbs-assigned-item\" *ngFor=\"let option of config.options.values\" [ngClass]=\"{'sw-disabled': config.disabled, 'sw-hidden': !ui.assigned[option.value] || option.assignedFilter || option.assignBlock }\" (contextmenu)=onMouseRightClick(option,$event)>-->\n        <mat-list-item class=\"sbs-assigned-item\" *ngFor=\"let option of config.options.values\" [ngClass]=\"{'sw-disabled': config.disabled, 'sw-hidden': !ui.assigned[option.value] || option.assignedFilter || option.assignBlock }\">\n          <div class=\"sbs-item-toggle-container sbs-align-left\">\n            <div class=\"sw-push-button sw-pointer\"\n                 [ngClass]=\"{'sw-hidden': option.patching}\"\n                 matTooltipPosition=\"above\"\n                 [matTooltipShowDelay]=\"750\"\n                 [matTooltipHideDelay]=\"250\"\n                 [matTooltip]=\"'Remove'\"\n                 (click)=\"onRemoveOption(option);\">\n              <p>S</p>\n              <div class=\"sw-push-button-inner\">\n              </div>\n            </div>\n            <div class=\"sbs-feedback-container\"\n                 [ngClass]=\"{'sw-hidden': !option.patching || !config.patch.displayIndicator}\">\n              <lib-main-spinner\n                [options]=\"{strokeWidth:3, color:'accent', diameter:19}\">\n              </lib-main-spinner>\n            </div>\n          </div>\n\n          <div class=\"sw-circle-ID\" *ngIf=\"config.displayCircleID\">\n            {{ option.name | characterIcon }}\n          </div>\n\n          <div class=\"sbs-item-label-container\">\n              <span class=\"sbs-label sbs-flex\">\n                <div [ngSwitch]=\"config.optionHtml\">\n                  <span *ngSwitchCase=\"'label'\" class=\"mat-body-2 sbs-right-bucket-label\">{{option.name}}</span>\n                  <a *ngSwitchCase=\"'route'\" (click)=\"onNavigateToOptionRoute(option);\" class=\"mat-body-2 sbs-right-bucket-label sw-pointer\">{{option.name}}</a></div></span>\n            <div class=\"sw-pointer\"\n                 *ngIf=\"option.errMessage\"\n                 matSuffix=\"\"\n                 matTooltipPosition=\"left\"\n                 [matTooltip]=option.errMessage>\n              <mat-icon color=\"warn\">info</mat-icon>\n            </div>\n          </div>\n\n        </mat-list-item>\n      </mat-list>\n    </div>\n    <div class=\"sbs-column-container  sbs-column-left \">\n      <mat-list class=\"sbs-bucket\" [style.height.px]=\"dom.height.inner\">\n\n        <div class=\"sbs-column-container sbs-flex\" *ngIf=\"!ui.optionsCount && config.displayHelper\">\n          <div class=\"sbs-column-content sbs-mar-btm \">\n            <div class=\"sbs-row-container\">\n              <mat-icon class=\"sbs-helper-icon\">sentiment_dissatisfied</mat-icon>\n            </div>\n            <div class=\"sbs-row-container\">\n              <label class=\"help-text h2 sbs-align-center\">{{config.helpTextRight}}</label>\n            </div>\n            <!--<div class=\"sbs-row-container sbs-align-center\">-->\n            <!--<p class=\"sbs-helper-text sbs-align-center\">Use the arrows <span class=\"sw-push-button-sample\">S</span>to make assignments</p>-->\n            <!--</div>-->\n          </div>\n        </div>\n\n        <!--<mat-list-item *ngFor=\"let option of config.options.values\" [ngClass]=\"{'sw-disabled': config.disabled, 'sw-hidden': ui.assigned[option.value] || option.optionFilter || option.optionBlock}\" (contextmenu)=onMouseRightClick(option,$event)>-->\n        <mat-list-item class=\"sbs-item\" *ngFor=\"let option of config.options.values\" [ngClass]=\"{'sw-disabled': config.disabled, 'sw-hidden': ui.assigned[option.value] || option.optionFilter || option.optionBlock}\">\n          <div class=\"sbs-item-toggle-container\">\n            <div class=\"sw-push-button sw-pointer\"\n                 [ngClass]=\"{'sw-hidden': option.patching}\"\n                 matTooltipPosition=\"above\"\n                 [matTooltipShowDelay]=\"750\"\n                 [matTooltipHideDelay]=\"250\"\n                 [matTooltip]=\"'Assign'\"\n                 (click)=\"onOptionAssign(option);\">\n              <p class=\"rotate\">S</p>\n              <div class=\"sw-push-button-inner\">\n              </div>\n            </div>\n            <div class=\"sbs-feedback-container\"\n                 [ngClass]=\"{'sw-hidden': !option.patching || !config.patch.displayIndicator}\">\n              <lib-main-spinner\n                [options]=\"{strokeWidth:3, color:'accent', diameter:19}\">\n              </lib-main-spinner>\n            </div>\n          </div>\n\n          <div class=\"sw-circle-ID\" *ngIf=\"config.displayCircleID\">\n            {{ option.name | characterIcon }}\n          </div>\n\n          <div class=\"sbs-item-label-container\">\n              <span class=\"sbs-label sbs-flex\">\n                <div [ngSwitch]=\"config.optionHtml\">\n                  <span *ngSwitchCase=\"'label'\" class=\"mat-body-2 sbs-right-bucket-label\">{{option.name}}</span>\n                  <a *ngSwitchCase=\"'route'\" (click)=\"onNavigateToOptionRoute(option);\" class=\"mat-body-2 sbs-right-bucket-label sw-pointer\">{{option.name}}</a>\n                </div>\n              </span>\n            <div class=\"sw-pointer\"\n                 *ngIf=\"option.errMessage\"\n                 matSuffix=\"\"\n                 matTooltipPosition=\"left\"\n                 [matTooltip]=option.errMessage>\n              <mat-icon color=\"warn\">info</mat-icon>\n            </div>\n          </div>\n        </mat-list-item>\n      </mat-list>\n    </div>\n  </div>\n  <!--<lib-pop-context-menu *ngIf=\"dom.contextMenu\" [config]=\"dom.contextMenu.config\"></lib-pop-context-menu>-->\n</div>\n",
                styles: [".sbs-container{flex:1}.sbs-row-container{display:flex;flex-direction:row;clear:both}.sbs-align-center{align-items:center}.sbs-flex{display:flex;min-width:1%;flex-basis:1%;flex-grow:1}.sbs-column-container{display:flex;flex-direction:column;flex-basis:50%;overflow:hidden}.sbs-column-content{position:relative;display:block}.sbs-title{position:relative;font-size:1em;overflow:hidden;text-overflow:ellipsis;margin:var(--mar-md) 0}.sbs-header{height:46px;background-color:var(--background-main-menu)}.sbs-search-header{height:46px}.header-label{color:var(--foreground-disabled)}.sbs-center-text-vert{margin:auto;width:100%}.sbs-label{position:relative;margin-left:var(--gap-m)}.sbs-label>span{position:relative;font-size:var(--text-md);line-height:var(--gap-m);margin:var(--mar-sm) 0;font-weight:lighter;text-overflow:ellipsis;justify-content:space-between;white-space:nowrap}.sbs-label-null{font-size:var(--text-lg);font-weight:500}.sbs-align-left{text-align:left!important}.sbs-align-center{width:100%;text-align:center!important}.sbs-search-container{position:relative;display:flex;flex-direction:row;align-items:center;height:var(--gap-m)}.sbs-bucket{min-height:var(--gap-lm);height:100%;overflow-y:scroll;overflow-x:hidden;padding-bottom:var(--mar-sm)}.sbs-bucket::-webkit-scrollbar{width:6px}.sbs-left-bucket-label,.sbs-right-bucket-label{position:absolute;left:0;top:-8px;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.sbs-right-bucket-label{min-width:0;color:var(--foreground-header)}.sbs-right-bucket-label:hover{text-decoration:underline;color:var(--foreground-icon);opacity:1}.sbs-bucket::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 var(--gap-lm) var(--darken02);border-radius:var(--border-s)}.sbs-bucket::-webkit-scrollbar-thumb{border-radius:var(--border-s);-webkit-box-shadow:inset 0 0 var(--gap-lm) var(--darken06)}.sbs-assigned-item{position:relative;direction:ltr;height:var(--gap-lm)}.sbs-item{padding-top:px}.sbs-filter{border:0;outline:0;background:none;color:var(--text);padding:0}.sbs-filter::-moz-placeholder{color:var(--foreground-disabled)}.sbs-filter:-ms-input-placeholder{color:var(--foreground-disabled)}.sbs-filter::placeholder{color:var(--foreground-disabled)}.sbs-search-icon,.search-icon{margin-left:var(--gap-m)}.sbs-search-icon{margin-right:var(--gap-xs);font-weight:700}.sbs-clear-filter{position:relative;font-size:24px;text-align:center;margin-right:var(--gap-m)}.sbs-all-icon{outline:0}p.sbs-helper-text{margin:0}.sbs-helper-text{line-height:24px;min-height:24px;font-size:var(---text-sm)}.sbs-helper-icon{width:var(--gap-xxl);height:var(--gap-xxl);font-size:var(--gap-xxl);color:var(--accent);margin:0 auto;padding-top:112px}.sbs-container ::ng-deep .mat-form-field-infix{max-width:100%!important;margin:0 auto!important}.sbs-container ::ng-deep mat-list{padding-top:var(--gap-xxs)!important;border:0!important}.sbs-container ::ng-deep mat-list-item{box-sizing:border-box;height:38px;border-left:0!important}.sbs-container ::ng-deep .mat-list-item-content{padding:0!important;justify-content:space-between;box-sizing:border-box}a{text-decoration:none}.sbs-feedback-container{position:relative;display:flex;height:var(--gap-lm);padding-top:var(--mar-xs);flex-flow:column;align-items:center;justify-content:center}.sbs-item-label-container{display:flex;flex-grow:1;min-width:0;align-items:center}.sbs-item-toggle-container{padding-left:var(--gap-m)}.sbs-error-container,.sbs-item-toggle-container{display:flex;flex-direction:column;align-items:center;justify-content:center}.sbs-error-container{height:var(--gap-lm);width:var(--gap-lm);padding-top:var(--mar-xs)}.sbs-assigned-error-container{top:0}.sbs-assigned-error-container,.sbs-options-error-container{position:absolute;right:0;z-index:2}.options-error{position:relative;top:-6px;left:-5px}.mat-list .mat-list-item,.mat-nav-list .mat-list-item,.mat-selection-list .mat-list-item{background-color:var(--bg-3)}.sbs-border-l{border-left:1px solid var(--border)}.sbs-border-r{border-right:1px solid var(--border)}.sbs-border-top{border-top:1px solid var(--border)}.sbs-border-bottom{border-bottom:1px solid var(--border)}.sw-circle-ID{margin-left:var(--gap-sm);height:24px!important;width:24px!important;line-height:24px}.sw-push-button-label p.rotate{top:-var(--gap-xs)!important}.sw-push-button-label{margin-left:var(--gap-m);position:relative}.sbs-mar-btm{margin-bottom:50px}.left-arrow{display:inline-block;height:10px;width:10px;border-radius:2px;position:relative;text-align:center;background-color:var(--background-code);margin:0;line-height:1.8em;color:#fff;font-size:5px;font-family:pop-icon,sans-serif;transform:rotate(180deg);top:-2px}.help-text{font-size:18px;margin-top:var(--gap-sm)}.help-caption{color:var(--foreground-disabled)}.hide-clear-icon{visibility:hidden}.show-clear-icon{visibility:visible}"]
            },] }
];
PopSideBySideComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopSideBySideComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopConfirmationDialogComponent {
    constructor(config, dialog) {
        this.config = config;
        this.dialog = dialog;
    }
    ngOnInit() {
        if (!this.config.display)
            this.config.display = 'Confirmation';
        if (!this.config.option)
            this.config.option = { confirmed: 1 };
        if (!this.config.align)
            this.config.align = 'center';
    }
    onConfirm() {
        this.dialog.close(this.config.option);
    }
    onCancel() {
        this.dialog.close(null);
    }
}
PopConfirmationDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-confirmation-dialog',
                template: "<h1 class=\"pop-confirmation-dialog-header\">{{config.display}}</h1>\n\n<div [ngClass]=\"{'sw-hidden': !config.body}\" class=\"pop-confirmation-body pop-confirmation-align-{{config.align}}\" [innerHTML]=\"config.body\"></div>\n\n<mat-divider [style.width.%]=100 [style.marginBottom.px]=15></mat-divider>\n\n<div class=\"pop-confirmation-dialog-footer\">\n  <button class=\"pop-confirmation-btn\" mat-raised-button (click)=\"onCancel()\" cdkFocusInitial>Cancel</button>\n  <button class=\"pop-confirmation-btn\" color=\"accent\" mat-raised-button (click)=\"onConfirm()\">Confirm</button>\n</div>\n\n",
                styles: [".pop-confirmation-dialog-header{margin-top:0;text-align:center}.pop-confirmation-body{margin:var(--gap-s) 0 var(--gap-lm) 0;padding:var(--gap-m);min-height:30px;max-height:400px;overflow-y:auto}.pop-confirmation-align-left{text-align:left}.pop-confirmation-align-center{text-align:center}.pop-confirmation-align-right{text-align:right}.pop-confirmation-dialog-footer{display:flex;min-height:var(--gap-m);justify-content:flex-end;align-items:center}.pop-confirmation-btn{margin-left:var(--gap-s)}"]
            },] }
];
PopConfirmationDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef }
];

class PopEntityFieldModalComponent extends PopExtendDynamicComponent {
    constructor(dialog, data) {
        super();
        this.dialog = dialog;
        this.data = data;
        this.name = 'PopEntityFieldModalComponent';
    }
    ngOnInit() {
        super.ngOnInit();
    }
    onFormSubmit() {
        if (this.dom.state.validated) {
        }
    }
    onFormCancel() {
        this.dom.state.loaded = false;
        this.dom.setTimeout(`close-modal`, () => {
            this.dialog.close(-1);
        }, 500);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityFieldModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-modal',
                template: "<div *ngIf=\"dom.state.loaded\" [@slideInOut]>\n  <div class=\"pop-field-dialog-title\" >{{data.field.name}}</div>\n  <div class=\"pop-field-dialog-fields\">\n    <!--<form [formGroup]=\"ui.form\" (keydown.enter)=\"onEnterPress($event)\" (ngSubmit)=\"onFormSubmit()\" [className]=\"dom.state.pending ? 'in-dialog-field-lock' : ''\">-->\n      <!--<lib-group [ngClass]=\"{'in-dialog-disabled': dom.state.pending}\" [config]=\"config\" (events)=\"onBubbleEvent($event);\"></lib-group>-->\n    <!--</form>-->\n  </div>\n  <div class=\"pop-field-dialog-buttons\">\n    <button class=\"pop-field-dialog-cancel\" mat-raised-button (click)=\"onFormCancel();\" [disabled]=\"dom.state.pending\">\n      Cancel\n    </button>\n    <button class=\"pop-field-dialog-other\" mat-raised-button color=\"accent\" (click)=\"onFormSubmit()\" [disabled]=\"!dom.state.validated || dom.state.pending\">\n      <span *ngIf=\"!dom.state.pending\">OK</span>\n      <div *ngIf=\"dom.state.pending\">\n        <mat-spinner diameter=\"20\"></mat-spinner>\n      </div>\n    </button>\n  </div>\n  <div class=\"pop-field-dialog-message-layout\" *ngIf=\"dom.state.success || dom.error?.message\" [@slideInOut]>\n    <div *ngIf=\"dom.state.success\" class=\"pop-field-dialog-success\">{{dom.state.success}}</div>\n    <div *ngIf=\"dom.error.message\" class=\"pop-field-dialog-errors\">{{dom.error.message}}</div>\n  </div>\n</div>\n",
                animations: [
                    slideInOut
                ],
                styles: [".import-field-item-container{position:relative;min-height:var(--field-min-height);max-width:var(--field-max-width);margin:var(--field-margin-l)}.import-field-item-container-expansion{position:relative;width:100%;height:100%;box-sizing:border-box!important;-moz-box-sizing:border-box}.import-field-item-tooltip-msg{position:absolute;display:block;bottom:50px;width:100%;right:-10px;left:-10px;background:var(--field-tooltip-bg);border-radius:var(--field-tooltip-radius);padding:var(--field-tooltip-padding);color:var(--field-tooltip-color);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;overflow:hidden;text-align:center;z-index:2}.import-field-item-container .mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.import-field-item-container .mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap,.import-field-item-container .mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start{border-width:1px}.import-field-item-container .mat-form-field-appearance-outline .mat-form-field-outline:not(:focus){background-color:var(--background-base)}:host{position:relative;display:block;min-width:400px}:host .pop-field-dialog-title{font-weight:500;text-align:center;margin-bottom:10px}:host .pop-field-dialog-fields{position:relative;display:block;width:100%;margin-bottom:10px}:host .pop-field-dialog-fields .pop-field-dialog-field{margin-bottom:10px}:host .pop-field-dialog-fields .pop-field-dialog-field-lock{opacity:90%}:host .pop-field-dialog-fields .pop-field-dialog-field-spinner{position:absolute;left:50%;top:50%;margin-left:-22px;margin-top:-40px}:host .pop-field-dialog-buttons{margin-top:20px;margin-bottom:10px;display:flex;justify-content:space-between}:host .pop-field-dialog-buttons .pop-field-dialog-cancel{order:1;display:flex;align-items:center;justify-content:center;min-height:35px;min-width:100px}:host .pop-field-dialog-buttons .pop-field-dialog-other{order:2;display:flex;align-items:center;justify-content:center;margin-left:10px;min-width:100px;min-height:35px}:host .pop-field-dialog-errors{color:var(--warn);text-align:center;word-break:break-word}:host .pop-field-dialog-success{color:var(--success);text-align:center;word-break:break-word}:host .pop-field-dialog-message-layout{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:center;text-align:center}:host .pop-field-dialog-disabled{pointer-events:none}"]
            },] }
];
PopEntityFieldModalComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class PopEntityFieldBoilerComponent extends PopExtendComponent {
    constructor(el, _domRepo, custom_setting = {}) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.custom_setting = custom_setting;
        this.name = 'PopEntityFieldBoilerComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            field: ServiceInjector.get(PopEntityFieldService),
        };
        this.ui = {
            actionBtnWidth: 0,
            asset: undefined,
        };
        /**
         * This should transformValue and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                // #1: Enforce a CoreConfig
                this.field = IsObjectThrowError(this.field, ['id', 'data_keys'], `${this.name}:configureDom: - this.field`) ? this.field : null;
                this.id = this.field.id;
                this.ui.asset = {};
                this._setInitialConfig();
                this._transformChildren();
                this.field.data_keys.map((dataKey, index) => {
                    this.dom.session[dataKey] = {};
                    this.dom.session[dataKey].display = {};
                    this.dom.state[dataKey] = {
                        open: false,
                        template: this.field.state,
                        footer_adjust: this.field.state,
                        customLabel: false
                    };
                });
                this.dom.setSubscriber(`parent-event-handler`, this.events.subscribe((event) => {
                    if (IsObject(event, true)) {
                        if (event.name === 'add') {
                            this.onAdd(event);
                        }
                    }
                }));
                // this.srv.field.setFieldEntries(this.field).then(() => {
                //   this.srv.field.setFieldValues(this.field).then(() => {
                //     return resolve(true);
                //   });
                // });
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._restoreDomSession();
                this._setAssetConfigs();
                this._setFieldAttributes();
                return resolve(true);
            });
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Handle click of action button
     * @param event
     * @param dataKey
     */
    onActionEvent(event, dataKey) {
        if (event.type === 'field') {
            switch (String(event.name).toLowerCase()) {
                // case 'add':
                //   this.onAdd(event);
                //   break;
                case 'remove':
                    this.onRemove(event, dataKey);
                    break;
                case 'edit':
                    this.onEdit(event, dataKey);
                    break;
                case 'close':
                    this.onClose(event, dataKey);
                    break;
                default:
                    break;
            }
        }
        return true;
    }
    /**
     * handle Input Changes from the field items
     * @param event
     * @param dataKey
     * @param name
     */
    onFieldItemEvent(event, dataKey = null, name = null) {
        if (IsValidFieldPatchEvent(this.core, event)) {
            this.onPatch(event, dataKey, name);
        }
        else if (event.type === 'field') {
            if (event.name === 'close') {
                this.onClose(event, dataKey);
            }
        }
        return true;
    }
    /**
     * User wants to add a value entry  into the field
     * @param event
     */
    onAdd(event) {
        // console.log('add lower', this.field.data_keys.length < this.field.entries.length, this.field.entries);
        this.log.event(`onAdd`, event);
        if (this.field.data_keys.length < this.field.entries.length) {
            const index = this.field.entries.length - 1;
            const item = this.srv.field.addEntryValue(this.core, this.field);
            const data = item.data;
            delete item.data;
            this.field.data[item.entry.id] = data;
            this.field.items[item.entry.id] = item;
            this.field.data_keys.push(item.entry.id + '');
            this._setFieldItemAttribute(item.entry.id, index);
            this._setAssetConfig(item.entry.id, index);
            this.dom.setTimeout('open-new', () => {
                this._updateState(item.entry.id, 'open', true);
            }, 0);
            // this.dom.session[ value.entry.id ] = {};
            // this.dom.session[ value.entry.id ].display = {};
            // this.dom.state[ value.entry.id ] = {
            //   open: true,
            //   template: this.field.state,
            //   footer_adjust: this.field.state,
            //   customLabel: false
            // };
        }
        return true;
    }
    /**
     * User wants to open the value entry and make edits
     * @param event
     */
    onEdit(event, dataKey) {
        this.log.event(`onEdit`, event);
        if (this.field.modal) {
            console.log('has modal');
            const dialogRef = this.srv.dialog.open(PopEntityFieldModalComponent, {
                width: `${window.innerWidth * .50}px`,
                height: `${window.innerHeight * .50}px`,
                panelClass: 'sw-relative',
                data: {
                    core: this.core,
                    field: this.field
                }
            });
            this.dom.subscriber.dialog = dialogRef.beforeClosed().subscribe((changed) => {
                if (changed || this.dom.state.refresh) {
                    // this._configureTable();up
                }
                this.dom.state.blockModal = false;
            });
        }
        else {
            this.dom.state.template = 'template_edit';
            this.dom.state.open = true;
            if (IsDefined(dataKey) && this.dom.state[dataKey]) {
                this.dom.state[dataKey].template = 'template_edit';
                this.dom.state[dataKey].open = true;
            }
            else {
                Object.keys(this.dom.state).map((key) => {
                    if (IsNumber(key)) {
                        this.dom.state[key].template = 'template_edit';
                        this.dom.state[key].open = true;
                    }
                });
            }
            this.dom.store('state');
            return true;
        }
    }
    /**
     * User wants to remove a value entry
     * @param event
     */
    onRemove(event, dataKey) {
        this.log.event(`onRemove`, event);
        if (this.field.facade) {
            this.onBubbleEvent('remove', { dataKey: dataKey });
        }
        else {
            this.srv.dialog.open(PopConfirmationDialogComponent, {
                width: '350px',
                data: {
                    option: null,
                    body: `Delete this field value?`
                }
            }).afterClosed().subscribe(option => {
                if (option && option.confirmed) {
                    this.srv.field.removeEntryValue(this.core, this.field, dataKey).then((res) => {
                        delete this.field.data[dataKey];
                        delete this.field.items[dataKey];
                        this.field.data_keys.pop();
                        delete this.dom.state[dataKey];
                        delete this.ui.asset[dataKey];
                        delete this.dom.session[dataKey];
                        this.dom.store('session');
                        this.onBubbleEvent('remove', { dataKey: dataKey });
                    });
                }
            });
        }
        return true;
    }
    /**
     * User closes the edit ability of the value entries
     * @param event
     */
    onClose(event, dataKey) {
        this.log.event(`onClose`, event);
        this.dom.state.open = false;
        this.dom.state.template = 'template_readonly';
        if (dataKey) {
            this.dom.state[dataKey].template = 'template_readonly';
            this.dom.state[dataKey].open = false;
        }
        else {
            Object.keys(this.dom.state).map((key) => {
                if (IsNumber(key)) {
                    this.dom.state[key].template = 'template_readonly';
                    this.dom.state[key].open = false;
                }
            });
        }
        this.onBubbleEvent('close');
        return true;
    }
    /**
     * A method to remove an additional values from this field
     * @param id
     * @param archive
     */
    onPatch(event, dataKey = null, name = null) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            event.data_key = dataKey;
            event.column = name;
            if (this.field.facade) {
                this.onBubbleEvent('onPatch', null, event);
            }
            else {
                if (true) {
                    yield this.srv.field.updateFieldItem(this.core, this.field, event);
                    this.field.data[dataKey][name] = event.config.control.value;
                    this._triggerUpdateAssetDisplay(dataKey);
                }
            }
            return resolve(true);
        }));
    }
    /**
     * Handle the bubble events that come up
     * @param event
     */
    onBubbleEvent(name, extension, event) {
        if (!event)
            event = { source: this.name, type: 'field', name: name };
        if (extension)
            event = Object.assign(Object.assign({}, event), extension);
        this.log.event(`bubbleEvent`, event);
        this.events.emit(event);
        return true;
    }
    /**
     * Clean up dom subscribers, interval, timeouts, ..etc
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                   Base Protected Methods                                     *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config
     * Intended to be overridden per field
     */
    _setInitialConfig() {
    }
    /**
     * Pass in any session changes
     * The user may change tabs and the state should be restored
     */
    _restoreDomSession() {
        this.field.data_keys.map((dataKey, index) => {
            if (IsObject(this.dom.session[dataKey], true)) {
                const item = this.field.items[dataKey];
                const session = this.dom.session[dataKey];
                if (IsObject(session.entry, ['id'])) {
                    item.entry = session.entry;
                }
            }
        });
    }
    /**
     * Build the default configs that are across all the fieelds
     */
    _setAssetConfigs() {
        this.srv.field.setFieldCustomSetting(this.field, this.custom_setting);
        delete this.custom_setting;
        this.field.data_keys.map((dataKey, index) => {
            this._setAssetConfig(+dataKey, index);
        });
    }
    /**
     * Labels are a built in method that all fields should need
     * @param dataKey
     * @param index
     * @private
     */
    _setAssetConfig(dataKey, index) {
        const customEntries = DeepCopy(this.field.entries).filter((entry) => {
            return entry.type === 'custom';
        });
        const providedEntries = DeepCopy(this.field.entries).filter((entry) => {
            return entry.type !== 'custom';
        });
        const entries = [...providedEntries];
        const item = this.field.items[dataKey];
        if (!item.entry) {
            item.entry = this.field.entries[0];
        }
        this._updateDisplayField(dataKey, 'label', item.entry.name);
        const customLabel = this.field.setting.edit_label && this.field.setting.custom_label && item.entry.type === 'custom' ? true : false;
        this._updateState(dataKey, 'custom_label', customLabel);
        if (this.field.setting.custom_label && IsArray(customEntries, true))
            entries.push(customEntries[customEntries.length - 1]);
        // ToDo:: Add api calls to store values for these configs
        if (!IsObject(this.ui.asset[dataKey], true)) {
            this.ui.asset[dataKey] = {
                display: new InputConfig({
                    readonly: true,
                    label: item.entry.name,
                    value: this._getAssetDisplayStr(dataKey),
                    // minimal: true,
                }),
                entry: new SelectConfig({
                    label: 'Label',
                    value: item.entry ? item.entry.id : null,
                    options: { values: ConvertArrayToOptionList(entries) },
                    minimal: true,
                    facade: true,
                    patch: {
                        field: ``,
                        path: ``,
                        callback: (core, event) => {
                            if (IsValidFieldPatchEvent(core, event)) {
                                this._updateFieldEntry(dataKey, +event.config.control.value);
                            }
                        }
                    }
                }),
                customLabel: new InputConfig({
                    label: 'Custom Label',
                    value: this.dom.session[dataKey].customLabel ? this.dom.session[dataKey].customLabel : '',
                    required: true,
                    validators: [Validators.required],
                    maxlength: 24,
                    // minimal: true,
                    facade: true,
                    patch: {
                        field: ``,
                        path: ``,
                        callback: (core, event) => {
                            if (IsValidFieldPatchEvent(core, event)) {
                                this._updateCustomEntryLabel(dataKey, event.config.control.value);
                            }
                        }
                    }
                })
            };
        }
        this._updateCustomLabelState(dataKey, item.entry);
    }
    /**
     * Updates when a values changes it label/entry
     * @param dataKey
     * @param entryId
     */
    _updateFieldEntry(dataKey, entryId) {
        const item = this.field.items[dataKey];
        if (IsObject(item, true)) {
            const entryLookup = ArrayMapSetter(this.field.entries, 'id');
            const entry = this.field.entries[entryLookup[entryId]];
            item.entry = entry;
            this.dom.session[dataKey].entry = entry;
            this.dom.store('session');
            this._updateCustomLabelState(dataKey, entry);
        }
    }
    /**
     * Updates the custom label if the user chooses to make a custom entry label
     * @param dataKey
     * @param value
     */
    _updateCustomEntryLabel(dataKey, value) {
        const item = this.field.items[dataKey];
        if (IsObject(item, true)) {
            this._updateDisplayField(dataKey, 'label', value);
            if (IsObject(this.dom.session[dataKey], true)) {
                this.dom.session[dataKey].customLabel = value;
                this.dom.store('session');
            }
            this._updateDisplayLabel(dataKey, value);
            // ToDo:: Figure where to save this
        }
    }
    /**
     * Ensure the state of the view matches up according to the stored entry/label
     * Custom Labels need special handling
     * @param dataKey
     * @param entry
     */
    _updateCustomLabelState(dataKey, entry) {
        if (dataKey && IsObject(entry, ['id', 'type', 'name'])) {
            const isCustom = entry.type === 'custom';
            if (isCustom) {
                this._updateState(dataKey, 'customLabel', (this.field.setting.edit_label && isCustom ? true : false));
                if (!this.ui.asset[dataKey].customLabel.control.value) {
                    this.ui.asset[dataKey].customLabel.control.setValue('Custom', { emitEvent: true });
                    this._updateDisplayField(dataKey, 'label', 'Custom');
                }
                else {
                    const previousCustomLabel = this.ui.asset[dataKey].customLabel.control.value;
                    this._updateDisplayField(dataKey, 'label', previousCustomLabel);
                    if (this.dom.session.entry) {
                        this.dom.session.entry.name = previousCustomLabel;
                    }
                }
                this._updateDisplayLabel(dataKey, this.ui.asset[dataKey].customLabel.control.value);
            }
            else {
                this._updateState(dataKey, 'customLabel', false);
                this._updateDisplayField(dataKey, 'label', entry.name);
                this._updateDisplayLabel(dataKey, entry.name);
            }
        }
    }
    /**
     * Update the display label of the value config
     * Some fields only use a single field item that is defaulted to the value column
     * @param dataKey
     * @param value
     */
    _updateDisplayLabel(dataKey, value) {
        const item = this.field.items[dataKey];
        if (IsObject(item, true)) {
            const configs = item.config;
            const valueConfig = IsObject(item.config, ['value']) ? configs.value : null;
            if (IsObject(valueConfig, true)) { // this means that it a a simple field,
                valueConfig.label = value;
            }
            this.ui.asset[dataKey].display.label = value;
        }
    }
    /**
     * Set the Display of a specific value entry
     * Sometime a display input is used to combine all the values into one, it appears in the readonly state
     * @param dataKey
     */
    _updateAssetDisplay(dataKey) {
        if (this.ui.asset && this.ui.asset[dataKey]) {
            const display = this.ui.asset[dataKey].display;
            display.value = this._getAssetDisplayStr(dataKey);
            this.dom.setTimeout(`display-update-${dataKey}`, () => {
                display.control.value = display.value;
            }, 0);
        }
    }
    /**
     * Debounce requests for set phone display
     * @param dataKey
     */
    _triggerUpdateAssetDisplay(dataKey) {
        this.dom.setTimeout(`field-display-${dataKey}`, () => {
            this._updateAssetDisplay(dataKey);
        }, 100);
    }
    /**
     * Session the display value for a field item change
     * In some cases the value that is selected is not necessarily what should be presented, so we track it separately just in case
     * Ie ... when an id is selected when need to show the appropriate label that should go with it not the id itself
     * @param dataKey
     * @param field
     * @param value
     */
    _updateDisplayField(dataKey, field, value) {
        if (IsDefined(dataKey) && IsObject(this.dom.session)) {
            if (!IsObject(this.dom.session[dataKey]))
                this.dom.session[dataKey] = {};
            if (!IsObject(this.dom.session[dataKey].display))
                this.dom.session[dataKey].display = {};
            this.dom.session[dataKey].display[field] = value;
            // this.dom.store('session');
        }
    }
    /**
     * Get the actual data object for a specific key
     * Pass in a field key if you want a only a certain field value
     * @param dataKey
     * @param fieldKey
     */
    _getDataKey(dataKey, fieldKey) {
        let data = IsObjectThrowError(this.field.data, true, `${this.name}:getDataKey`) ? this.field.data[dataKey] : null;
        if (data && fieldKey) {
            data = fieldKey in data ? data[fieldKey] : null;
        }
        return data;
    }
    /**
     * Builds the display string
     * Override in each field component as necessary
     * @param dataKey
     */
    _getAssetDisplayStr(dataKey) {
        let str = '';
        const configs = this._getDataKeyItemConfig(dataKey);
        Object.keys(configs).map((name) => {
            const config = configs[name];
            if (config.control && config.control.value) {
                str += (' ' + config.control.value);
            }
        });
        return String(str).trim();
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class, gives the mutate/transform resources if needed
     */
    _transformChildren() {
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class
     */
    _setFieldAttributes() {
        return true;
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class
     */
    _setFieldItemAttribute(dataKey, index) {
        return true;
    }
    /**
     * Get the item configs for a of a dataKey
     * Pass in a fieldKey if you only want the item config of a certain field
     * @param dataKey
     * @param fieldKey
     */
    _getDataKeyItemConfig(dataKey, fieldKey) {
        const data = IsObjectThrowError(this.field.items[dataKey], true, `${this.name}:_getDataKeyItem`) ? this.field.items[dataKey] : null;
        if (fieldKey) {
            const config = IsObjectThrowError(data.config[fieldKey], true, `${this.name}:_getDataKeyItem:${fieldKey}`) ? data.config[fieldKey] : null;
            return config;
        }
        return data.config;
    }
    /**
     * Resolve a value to the name that goes with it from the option list
     * @param value
     * @param index
     */
    _getTypeOptionName(value, index) {
        const typeConfig = this._getDataKeyItemConfig(this.field.data_keys[index], 'type');
        if (typeConfig.options) {
            const optionsMap = ArrayMapSetter(typeConfig.options.values, 'value');
            const option = value in optionsMap ? typeConfig.options.values[optionsMap[value]] : null;
            if (option) {
                return option.name;
            }
            return value;
        }
        return '';
    }
    /**
     * Resolve a value to the name that goes with it from the option list
     * @param value
     * @param index
     */
    _getEntryOptionName(value, index) {
        const titleConfig = this._getDataKeyItemConfig(this.field.data_keys[index], 'title');
        if (titleConfig.options) {
            const optionsMap = ArrayMapSetter(titleConfig.options.values, 'value');
            const option = value in optionsMap ? titleConfig.options.values[optionsMap[value]] : null;
            if (option) {
                return option.name;
            }
            return value;
        }
        return '';
    }
    /**
     * Get the value entry of a specific index
     * @param index
     */
    _getValueEntry(index) {
        if (IsArray(this.field.entries, true)) {
            return IsObject(this.field.entries[index], true) ? this.field.entries[index] : this.field.entries[0];
        }
        return null;
    }
    /**
     * Helper method to update a state variable, and make sure that a state object exits for each data key
     * @param dataKey
     * @param field
     * @param value
     */
    _updateState(dataKey, field, value) {
        if (IsDefined(dataKey) && IsObject(this.dom.state)) {
            if (!IsObject(this.dom.state[dataKey])) {
                this.dom.state[dataKey] = {
                    open: false,
                    template: this.field.state,
                    footer_adjust: this.field.state,
                    customLabel: false
                };
            }
            this.dom.state[dataKey][field] = value;
        }
    }
}
PopEntityFieldBoilerComponent.decorators = [
    { type: Component, args: [{
                template: '<div>Boiler</div>'
            },] }
];
PopEntityFieldBoilerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: undefined, decorators: [{ type: Inject, args: [FIELD_CUSTOM_SETTING,] }] }
];
PopEntityFieldBoilerComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityNameComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, NameFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityNameComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityNameComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-name',
                template: "<div class=\"pop-entity-name import-field-container\">\n  <div class=\"import-flex-column import-field-flex-row-offset\" *ngFor=\"let dataKey of field.data_keys\">\n    <div *ngIf=\"field.items[dataKey].config; let items;\">\n      <div *ngIf=\"dom.state.loaded && ui.asset[dataKey]; let asset\">\n        <div *ngIf=\"dom.state[dataKey]; let state;\">\n\n          <div class=\"import-flex-row import-field-flex-row-offset\">\n            <div class=\"import-flex-row-wrap\">\n              <div class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">\n                <lib-pop-input class=\"pop-entity-name-display\" [config]=\"asset.display\"></lib-pop-input>\n              </div>\n              <div *ngIf=\"true\" class=\"import-field import-flex-item-icon\">\n                <lib-pop-entity-field-edit-icon\n                  (events)=\"onActionEvent($event, dataKey);\" [field]=\"this.field\"\n                  [dom]=\"dom\"\n                ></lib-pop-entity-field-edit-icon>\n              </div>\n            </div>\n          </div>\n\n\n          <div *ngIf=\"state.open\" class=\"import-flex-row-wrap pt-02 sw-pad-lft-sm sw-pad-rgt-sm  sw-mar-top-sm\">\n\n            <!--<div *ngIf=\"field.multiple && field.setting.edit_label && asset.entry; let entry;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n              <!--<lib-pop-select [config]=\"entry\"></lib-pop-select>-->\n            <!--</div>-->\n            <!--<div *ngIf=\"state.customLabel && asset.customLabel; let item;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n              <!--<lib-pop-input [config]=\"item\"></lib-pop-input>-->\n            <!--</div>-->\n            <!--<div class=\"import-flex-row-break\"></div>-->\n\n\n            <div *ngIf=\"items['prefix']\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-md\">\n              <lib-pop-input [config]=\"items['prefix']\" (events)=\"onFieldItemEvent($event, dataKey, 'prefix');\"></lib-pop-input>\n            </div>\n\n            <div *ngIf=\"items['first']\" class=\"import-field import-field-spacing import-flex-item-md import-flex-grow-lg\">\n              <lib-pop-input [config]=\"items['first']\" (events)=\"onFieldItemEvent($event, dataKey, 'first');\"></lib-pop-input>\n            </div>\n\n            <div class=\"import-flex-row-break\" *ngIf=\"items['prefix'] && field.items['middle']\"></div>\n\n            <div *ngIf=\"items['middle']\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-md\">\n              <lib-pop-input [config]=\"items['middle']\" (events)=\"onFieldItemEvent($event, dataKey, 'middle');\"></lib-pop-input>\n            </div>\n\n            <div class=\"import-flex-row-break\" *ngIf=\"!field.items['prefix'] && !field.items['middle']\"></div>\n\n            <div *ngIf=\"items['last']\" class=\"import-field import-field-spacing import-flex-item-md import-flex-grow-lg\">\n              <lib-pop-input [config]=\"items['last']\" (events)=\"onFieldItemEvent($event, dataKey, 'last');\"></lib-pop-input>\n            </div>\n\n            <div class=\"import-flex-row-break\" *ngIf=\"items['prefix'] && field.items['first'] && field.items['middle'] && field.items['last']\"></div>\n\n            <div *ngIf=\"items['suffix']\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-md\">\n              <lib-pop-input [config]=\"items['suffix']\" (events)=\"onFieldItemEvent($event, dataKey, 'suffix');\"></lib-pop-input>\n            </div>\n\n            <div *ngIf=\"items['suffix']\" class=\"import-field import-field-spacing import-flex-item-md import-flex-grow-lg\"></div>\n\n            <!--<div class=\"import-field-footer\" [ngClass]=\"{'import-field-footer-adjust': !field.multiple || field.items['first'] && field.items['middle'] && field.items['last'] && field.items['suffix']}\">-->\n            <div class=\"import-field-footer sw-mar-top-md\" *ngIf=\"field.canRemove\">\n              <lib-pop-field-btn class=\"sw-mar-rgt-lg\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n            </div>\n\n            <div class=\"import-flex-row-wrap import-flex-end sw-mar-top-lg sw-pad-rgt-lg sw-pad-btm-sm\">\n              <lib-pop-button\n                [config]=\"{value:'Close', size: 30, color: 'accent', bubble: true, event: 'close'}\"\n                (events)=\"onActionEvent($event, dataKey);\"\n              ></lib-pop-button>\n            </div>\n\n          </div>\n\n        </div>\n\n\n      </div>\n\n    </div>\n  </div>\n</div>\n\n",
                styles: [""]
            },] }
];
PopEntityNameComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityNameComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityDatetimeComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'PopEntityDatetimeComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.id = this.field.id;
                this.trait.bubble = true;
                this.dom.state.open = false;
                this.dom.state.footer_adjust = false;
                this.dom.state.row1 = {
                    first: true,
                    visible: true,
                };
                this.setDateItem();
                this.setTimeItem();
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    setDateItem() {
        let dateValue = this.field.items['datetime'].value ? ConvertDateFormat(this.field.items['datetime'].value, 'mm/dd/yyyy') : null;
        dateValue = dateValue === '12/31/1969' ? null : dateValue;
        // console.log(dateValue, 'dateValue');
        this.field.items['date'] = new DateConfig({
            label: 'Date',
            value: dateValue,
        });
    }
    setTimeItem() {
        const timeValue = this.field.items['datetime'].value ? ConvertDateToTimeFormat(this.field.items['datetime'].value) : null;
        this.field.items['time'] = new TimeConfig({
            label: 'Time',
            time: 12,
            interval: 1,
            value: timeValue,
        });
    }
    emitInputEvent(name, config, message = null, success = null) {
        if (this.field.options.bubble)
            this.events.emit({ source: this.name, type: 'field', name: name, config: config, success: success, message: message });
    }
    handleDateEvent(event) {
        const items = this.field.items;
        if (items['datetime'] && items['time'] && items['time'].value) {
            const datetimeValue = ConvertDateFormat(items['date'].control.value, 'yyyy-mm-dd') + ' ' + items['time'].control.value;
            // console.log(datetimeValue, 'datetimeValue');
            items['datetime'].triggerOnChange(datetimeValue);
        }
        if (this.field.options.bubble) {
            this.emitInputEvent(event.name, this.field.items['date']);
        }
        // this.events.emit(event);
    }
    handleEvent(event) {
        // console.log(event, 'handleEventEmail');
        this.events.emit(event);
    }
    handleTimeEvent(event) {
        if (event.type === 'field' && event.name === 'onChange') {
            const items = this.field.items;
            if (items['datetime'] && items['date'] && items['date'].value) {
                const datetimeValue = ConvertDateFormat(items['date'].control.value, 'yyyy-mm-dd') + ' ' + items['time'].control.value;
                console.log(datetimeValue, 'datetimeValue');
                items['datetime'].triggerOnChange(datetimeValue);
            }
        }
        if (this.field.options.bubble) {
            this.emitInputEvent(event.name, this.field.items['time']);
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityDatetimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-datetime',
                template: "<div class=\"pop-entity-datetime-field pop-datetime-container\" [ngClass]=\"{'pop-datetime-container-wrapper': field.options.legend}\">\n  <div *ngIf=\"field.options.legend\" class=\"pop-datetime-container-legend\">{{field.name}}</div>\n  <div *ngIf=\"dom.state.row1.visible\" class=\"pop-datetime-row-container\"\n       [ngClass]=\"{'pop-datetime-first-row': dom.state.row1.first}\">\n    <div *ngIf=\"field.items['date']\" class=\"pop-datetime-date-wrapper\">\n      <lib-pop-date [config]=\"field.items['date']\" (events)=\"handleDateEvent($event);\"></lib-pop-date>\n    </div>\n    <div *ngIf=\"field.items['time']\" class=\"pop-datetime-time-wrapper\">\n      <lib-pop-time [config]=\"field.items['time']\" (events)=\"handleTimeEvent($event);\"></lib-pop-time>\n    </div>\n  </div>\n  <div class=\"pop-datetime-row-container\">\n    <div *ngIf=\"field.items['timezone']\" class=\"pop-datetime-time-zone-wrapper\">\n      <lib-pop-select [config]=\"field.items['timezone']\"></lib-pop-select>\n    </div>\n    <lib-pop-input [config]=\"field.items['datetime']\" (events)=\"handleEvent($event);\"></lib-pop-input>\n  </div>\n</div>\n",
                styles: [":host{position:relative;display:block;width:100%;margin:10px 0}.pop-datetime-container{position:relative;display:block;padding:0;min-height:40px}.pop-datetime-container-wrapper{border:1px solid var(--darken4);padding:5px;border-radius:3px}.pop-datetime-container-legend{position:relative;margin-top:-15px;margin-bottom:-5px;clear:both;z-index:1;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;color:var(--darken4);background:var(--bg-3)}.pop-datetime-row-container{position:relative;display:flex;flex:1 1 100%;margin-top:10px;padding:0;flex-direction:row;justify-content:flex-start;align-items:center;background:var(--bg-3)}.pop-datetime-first-row{margin-top:10px!important}.pop-datetime-date-wrapper{width:25%}.pop-datetime-date-wrapper,.pop-datetime-time-wrapper{position:relative;display:flex;flex-direction:column;flex-grow:1;margin-right:2px}.pop-datetime-time-wrapper{width:27%;height:31px;border:1px solid var(--text-2);padding:5px;border-radius:3px}.pop-datetime-datetime-wrapper,.pop-datetime-time-zone-wrapper{position:relative;display:flex;flex-direction:column;width:25%;flex-grow:1;margin-right:2px}"]
            },] }
];
PopEntityDatetimeComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopEntityDatetimeComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityEmailComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, EmailFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityEmailComponent';
        this.asset = {
            extensionKeys: ['action'],
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                this._setFieldItemAttribute(+dataKey, index);
            });
        }
        return true;
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class
     */
    _setFieldItemAttribute(dataKey, index) {
        const item = this.field.items[dataKey];
        const configKeys = Object.keys(item.config);
        this.dom.state.has_extension = configKeys.some(r => this.asset.extensionKeys.includes(r));
        if ('action' in item.config) {
            this.ui.actionBtnWidth = 50;
            item.config['action'] = new ButtonConfig({
                icon: 'email',
                size: 42,
                value: null,
                // disabled: true
            });
        }
        if ('address' in item.config) {
            const child = this.field.children['address'];
            const addressConfig = item.config['address'];
            addressConfig.pattern = 'Email';
            addressConfig.type = 'email';
            const validators = [];
            validators.push(Validators.email);
            if (+child.rule.required)
                validators.push(Validators.required);
            if (+child.rule.maxlength)
                validators.push(Validators.maxLength(+child.rule.maxlength));
            addressConfig.validators = validators;
            if (this.field.multiple)
                addressConfig.label = this.field.entries[index].name;
            addressConfig.patch.callback = () => {
                this._updateAddress(+dataKey, index);
            };
            this._updateAddress(+dataKey, index);
        }
        return true;
    }
    _updateAddress(dataKey, index) {
        const addressConfig = this._getDataKeyItemConfig(dataKey, 'address');
        if (addressConfig.metadata.source) {
            const value = addressConfig.control.value;
            addressConfig.value = value;
            this._triggerUpdateAssetDisplay(dataKey);
        }
    }
}
PopEntityEmailComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-email',
                template: "<div class=\"pop-entity-input-field import-field-container\">\n  <div *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n    <div *ngIf=\"field.items[dataKey].config; let items;\" class=\"import-flex-column import-flex-item-full\">\n      <div class=\"import-flex-row import-field-flex-row-offset\">\n        <div class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-md\" *ngIf=\"items['address']; let item;\">\n          <lib-pop-input [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'address');\"></lib-pop-input>\n        </div>\n\n        <div *ngIf=\"items['action']; let item;\" class=\"pop-entity-email-btn-container\">\n          <div class=\"import-field import-flex-item-icon\">\n            <lib-pop-button\n              [config]=\"item\"\n              (events)=\"onActionEvent($event, dataKey);\"\n            ></lib-pop-button>\n          </div>\n        </div>\n\n      </div>\n      <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-md\" *ngIf=\"field.canRemove && isLast\">\n        <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n      </div>\n    </div>\n  </div>\n</div>\n",
                styles: [".pop-entity-email-btn-container{position:relative;display:flex;top:9px;left:-7px;flex-direction:row;max-height:40px;align-items:center;justify-content:flex-end}.pop-entity-email-btn-container div{margin-left:5px}"]
            },] }
];
PopEntityEmailComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityEmailComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityPhoneComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, PhoneFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityPhoneComponent';
        this.asset = {
            extensionKeys: ['type', 'voice_button', 'sms_button', 'do_not_call', 'do_not_sms', 'country_id'],
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Builds the display string
     * @param dataKey
     */
    _getAssetDisplayStr(dataKey) {
        let str = '';
        const display = this.dom.session[dataKey].display;
        const items = this._getDataKeyItemConfig(dataKey);
        if ('country_id' in items && display['country_id']) {
            str += `+${display['country_id']} `;
        }
        if (display['number']) {
            str += `${display['number']}`;
        }
        if ('extension' in items && display['extension']) {
            str += ` Ext. ${display['extension']} `;
        }
        return str;
    }
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                this._setFieldItemAttribute(+dataKey, index);
            });
        }
        return true;
    }
    _setFieldItemAttribute(dataKey, index) {
        this.ui.actionBtnWidth = 50;
        let hasCallBtn = false;
        let hasTextBtn = false;
        const item = this.field.items[dataKey];
        const configKeys = Object.keys(item.config);
        this.dom.state.has_extension = configKeys.some(r => this.asset.extensionKeys.includes(r));
        this.ui.asset[dataKey].canCallBtn = new ButtonConfig({
            icon: 'local_phone',
            value: null,
            // disabled: true
        });
        this.ui.asset[dataKey].canTextBtn = new ButtonConfig({
            icon: 'textsms',
            value: null,
            // disabled: true
        });
        if ('type' in item.config) {
            // If type is set, use as the label of the phone number
            const typeConfig = item.config['type'];
            this._updateNumberLabel(+dataKey, index);
            typeConfig.patch.callback = () => {
                this._updateNumberLabel(+dataKey, index);
            };
            // If value entry exists, disable type
            // if( this.field.multiple && index in this.field.entries ){
            //   typeConfig.control.disable();
            // }else{
            //   typeConfig.control.enable();
            // }
        }
        if ('stop_call_at' in item.config) {
            // ToDo:: Figure out what this button will actually do
            hasCallBtn = true;
        }
        if ('stop_text_at' in item.config) {
            // ToDo:: Figure out what this button will actually do
            hasTextBtn = true;
        }
        if ('country_id' in item.config) {
            const countryConfig = item.config['country_id'];
            countryConfig.patch.callback = () => {
                this._updateCountry(+dataKey, index);
            };
            this._updateCountry(+dataKey, index);
        }
        if ('number' in item.config) {
            const numberConfig = item.config['number'];
            numberConfig.mask = '(000) 000-0000';
            numberConfig.dropSpecial = false;
            numberConfig.patch.callback = () => {
                this._updateNumber(+dataKey, index);
            };
            this._updateNumber(+dataKey, index);
        }
        if ('extension' in item.config) {
            const extConfig = item.config['extension'];
            extConfig.mask = '0*00000';
            extConfig.patch.callback = () => {
                this._updateExtension(+dataKey, index);
            };
            this._updateExtension(+dataKey, index);
        }
        // if( itemKeys.includes('number') ){
        // if( itemKeys.includes('country_code') || itemKeys.includes('ext') ){
        //   this.dom.state.merged = true;
        //   const items = [ this.field.items[ dataId ][ 'number' ] ];
        //   if( itemKeys.includes('country_code') ) items.unshift(this.field.items[ dataId ][ 'country_code' ]);
        //   if( itemKeys.includes('ext') ) items.push(this.field.items[ dataId ][ 'ext' ]);
        //   this.field.items[ dataId ][ 'number' ] = this._getMergedPhone(items);
        //
        //   this.dom.setSubscriber('phone', this.field.items[ dataId ][ 'number' ].control.valueChanges
        //     .pipe(
        //       distinctUntilChanged(),
        //       debounceTime(500),
        //     )
        //     .subscribe((value: string) => {
        //       if( value ) this._validatePhone(dataId, value);
        //     }));
        // }
        // }
        if (hasCallBtn)
            this.ui.actionBtnWidth += 50;
        if (hasTextBtn)
            this.ui.actionBtnWidth += 50;
        return true;
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _updateCountry(dataKey, index) {
        const countryConfig = this._getDataKeyItemConfig(dataKey, 'country_id');
        if (countryConfig.metadata.source) {
            const source = countryConfig.metadata.source;
            const sourceMap = countryConfig.metadata.map.source;
            const value = countryConfig.control.value;
            const option = value in sourceMap ? source[sourceMap[value]] : null;
            countryConfig.value = value;
            console.log('_updateCountry option', option);
            if (IsObject(option, ['phone_country_code'])) {
                this._updateDisplayField(dataKey, 'country_id', option.phone_country_code);
            }
            this._triggerUpdateAssetDisplay(dataKey);
        }
    }
    _updateNumber(dataKey, index) {
        const numberConfig = this._getDataKeyItemConfig(dataKey, 'number');
        const value = numberConfig.control.value;
        this._updateDisplayField(dataKey, 'number', value);
        numberConfig.value = value;
        this._triggerUpdateAssetDisplay(dataKey);
    }
    _updateExtension(dataKey, index) {
        const extConfig = this._getDataKeyItemConfig(dataKey, 'extension');
        const value = extConfig.control.value;
        this._updateDisplayField(dataKey, 'extension', value);
        this._triggerUpdateAssetDisplay(dataKey);
    }
    _updateNumberLabel(dataKey, index) {
        if (this.field.multiple && IsArray(this.field.entries, true)) {
            this._updateNumberLabelToMatchEntry(index);
        }
        else {
            this._updateNumberLabelToMatchType(+dataKey);
        }
        this._triggerUpdateAssetDisplay(dataKey);
    }
    _updateNumberLabelToMatchEntry(index) {
        const entry = this._getValueEntry(index);
        const typeConfig = this._getDataKeyItemConfig(this.field.data_keys[index], 'type');
        const numberConfig = this._getDataKeyItemConfig(this.field.data_keys[index], 'number');
        const stored = this._getDataKey(this.field.data_keys[index], 'type');
        const display = this.ui.asset[this.field.data_keys[index]].display;
        if (entry && entry.type && !stored) {
            typeConfig.control.setValue(entry.type);
        }
        const value = entry ? (entry.name ? entry.name : this._getTypeOptionName(entry.type, index)) : (numberConfig.label ? numberConfig.label : '');
        if (value) {
            numberConfig.label = value;
            display.label = value;
        }
    }
    /**
     * The label of value entry should match the type
     * @param dataKey
     */
    _updateNumberLabelToMatchType(dataKey) {
        const typeConfig = this._getDataKeyItemConfig(dataKey, 'type');
        const numberConfig = this._getDataKeyItemConfig(dataKey, 'number');
        const optionsMap = ArrayMapSetter(typeConfig.options.values, 'value');
        const value = typeConfig.control.value;
        const display = this.ui.asset[dataKey].display;
        const option = value in optionsMap ? typeConfig.options.values[optionsMap[value]] : null;
        numberConfig.label = option ? option.name : TitleCase(SnakeToPascal(value));
        display.label = numberConfig.label;
    }
}
PopEntityPhoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-phone',
                template: "<div class=\"pop-entity-phone-field import-field-container\">\n  <div *ngFor=\"let dataKey of field.data_keys\">\n    <div *ngIf=\"field.items[dataKey].config; let items;\">\n      <div *ngIf=\"dom.state.loaded && ui.asset[dataKey]; let asset\">\n        <div *ngIf=\"dom.state[dataKey]; let state;\">\n\n          <div class=\"import-flex-row import-field-flex-row-offset\" [ngClass]=\"{'sw-disabled':state.open}\">\n            <div class=\"import-flex-row-wrap\">\n              <div class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">\n                <lib-pop-input class=\"pop-entity-phone-display\" [config]=\"asset.display\"></lib-pop-input>\n              </div>\n\n              <div class=\"pop-entity-phone-btn-container\" [style.width.px]=\"ui.actionBtnWidth\">\n                <div *ngIf=\"items['stop_call_at'] && !items['stop_call_at'].control.value\" class=\"import-field import-flex-item-icon\">\n                  <lib-pop-button\n                    [config]=\"asset.canCallBtn\"\n                    (events)=\"onActionEvent($event, dataKey);\"\n                  ></lib-pop-button>\n                </div>\n\n                <div *ngIf=\"items['stop_text_at'] && !items['stop_text_at'].control.value\" class=\"import-field import-flex-item-icon\">\n                  <lib-pop-button\n                    [config]=\"asset.canTextBtn\"\n                    (events)=\"onActionEvent($event, dataKey);\"\n                  ></lib-pop-button>\n                </div>\n\n                <div *ngIf=\"true\" class=\"import-field import-flex-item-icon sw-pad-rgt-md\">\n                  <lib-pop-entity-field-edit-icon\n                    (events)=\"onActionEvent($event, dataKey);\" [field]=\"this.field\"\n                    [dom]=\"dom\"\n                  ></lib-pop-entity-field-edit-icon>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <!-- extension box -->\n\n          <div [ngClass]=\"{'sw-hidden':!state.open}\" class=\"import-flex-row-wrap pt-02 sw-pad-lft-sm sw-pad-rgt-sm  sw-mar-top-sm\">\n            <div class=\"import-flex-row-wrap\">\n\n\n              <!--<div *ngIf=\"field.multiple && field.setting.edit_label && asset.entry; let entry;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n              <!--<lib-pop-select [config]=\"entry\"></lib-pop-select>-->\n              <!--</div>-->\n              <!--<div *ngIf=\"state.customLabel && asset.customLabel; let item;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n              <!--<lib-pop-input [config]=\"item\"></lib-pop-input>-->\n              <!--</div>-->\n              <!--<div class=\"import-flex-row-break\"></div>-->\n\n              <!--<div class=\"import-flex-column-lg\">-->\n                <div *ngIf=\"items['country_id']\" class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                  <lib-pop-select\n                    [config]=\"items['country_id']\"\n                    (events)=\"onFieldItemEvent($event, dataKey, 'country_id');\"\n                  ></lib-pop-select>\n                </div>\n\n                <div *ngIf=\"items['number']\" class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-sm\">\n                  <lib-pop-input\n                    [config]=\"items['number']\"\n                    (events)=\"onFieldItemEvent($event, dataKey, 'number');\"\n                  ></lib-pop-input>\n                </div>\n\n                <!--<div *ngIf=\"items['type']; let item;\"-->\n                <!--class=\"import-field import-field-spacing import-flex-item-md import-flex-grow-sm\">-->\n                <!--<lib-pop-select-->\n                <!--[config]=\"item\"-->\n                <!--(events)=\"onFieldItemEvent($event, dataKey, item.column);\"-->\n                <!--&gt;</lib-pop-select>-->\n                <!--</div>-->\n\n                <div *ngIf=\"items['extension']\" class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                  <lib-pop-input\n                    [config]=\"items['extension']\"\n                    (events)=\"onFieldItemEvent($event, dataKey, 'extension');\"\n                  ></lib-pop-input>\n                </div>\n              <!--</div>-->\n\n            </div>\n\n            <div class=\"import-flex-row-wrap\">\n              <div class=\"import-flex-column-md\">\n                <div class=\"import-field import-flex-item-full import-flex-grow-lg\">\n                  <lib-pop-checkbox\n                    *ngIf=\"items['stop_call_at']; let item;\"\n                    [config]=\"item\"\n                    (events)=\"onFieldItemEvent($event, dataKey, 'can_call');\">\n                  </lib-pop-checkbox>\n                </div>\n\n                <div class=\"import-field import-flex-item-full import-flex-grow-lg\">\n                  <lib-pop-checkbox\n                    *ngIf=\"items['stop_text_at']; let item;\"\n                    [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'can_text');\"\n                  ></lib-pop-checkbox>\n                </div>\n\n              </div>\n              <div class=\"import-flex-column-md import-flex-end sw-pad-rgt-lg sw-pad-btm-lg\">\n                <div class=\"import-flex-item-full import-flex-grow-lg sw-mar-top-md import-flex-end\">\n                  <lib-pop-field-btn *ngIf=\"field.canRemove\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n                </div>\n              </div>\n            </div>\n            <mat-divider></mat-divider>\n            <div class=\"import-flex-row-wrap import-flex-end sw-pad-rgt-lg sw-pad-btm-sm\">\n              <lib-pop-button\n                [config]=\"{value:'Close', size: 30, color: 'accent', bubble: true, event: 'close'}\"\n                (events)=\"onActionEvent($event, dataKey);\"\n              ></lib-pop-button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                styles: [".pop-entity-phone-btn-container{position:relative;top:8px;display:flex;flex-direction:row;max-height:40px;align-items:center;justify-content:flex-end}.pop-entity-phone-btn-container div{margin-left:5px}:host ::ng-deep .pop-entity-phone-display input{font-size:.95em}"]
            },] }
];
PopEntityPhoneComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityPhoneComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityAddressComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, AddressFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityAddressComponent';
        this.asset = {
            extensionKeys: [],
            states: []
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config
     * Intended to be overridden per field
     */
    _setInitialConfig() {
        // this.field.modal = PopEntityAddressEditComponent;
        this.field.modal = null;
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class, gives the chance to mutate/transform resources if needed
     */
    _transformChildren() {
        // const states = IsArray(this.field.children[ 'region_id' ].source, true) ? this.field.children[ 'region_id' ].source : null;
        // if( states ){
        //   this.asset.states = JsonCopy(this.field.children[ 'region_id' ].source).map((state: any) => {
        //     state.long_name = state.name;
        //     state.name = state.abbr;
        //   });
        // }
    }
    /**
     * This will be different for each type of field group
     * Intended to be overridden in each class
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                this._setFieldItemAttribute(+dataKey, index);
            });
        }
        return true;
    }
    _setFieldItemAttribute(dataKey, index) {
        var _a;
        const item = this.field.items[dataKey];
        const configKeys = Object.keys(item.config);
        this.dom.state.has_extension = configKeys.some(r => this.asset.extensionKeys.includes(r));
        if ('line_1' in item.config) {
            const line1Config = item.config['line_1'];
            line1Config.patch.callback = (_core, event) => {
            };
        }
        if ('line_2' in item.config) {
            const line2Config = item.config['line_2'];
            line2Config.patch.callback = (core, event) => {
            };
        }
        if ('line_3' in item.config) {
            const line3Config = item.config['line_3'];
            line3Config.patch.callback = (core, event) => {
            };
        }
        if ('region_id' in item.config) {
            const regionConfig = item.config['region_id'];
            const child = this.field.children['zip'];
            const countryConfig = item.config['country_id'];
            regionConfig.height = 250;
            if (!((_a = child.setting) === null || _a === void 0 ? void 0 : _a.allow_canada)) {
                const newOptions = regionConfig.options.values.filter(region => region['country_id'] == 1);
                regionConfig.options.values = newOptions;
                this._triggerUpdateAssetDisplay(dataKey);
            }
            // regionConfig.minimal = true;
            regionConfig.patch.callback = () => {
                this._updateRegionId(+dataKey, index);
            };
            this._updateRegionId(+dataKey, index);
        }
        if ('country_id' in item.config) {
            const countryConfig = item.config['country_id'];
            // countryConfig.minimal = true;
            countryConfig.patch.callback = () => {
                this._updateCountry(+dataKey, index);
            };
            this._updateCountry(+dataKey, index);
        }
        if ('zip' in item.config) {
            const zipConfig = item.config['zip'];
            const countryConfig = item.config['country_id'];
            const child = this.field.children['zip'];
            zipConfig.validators = [Validators.required, ValidateZip];
            zipConfig.setControl();
            zipConfig.facade = true;
            zipConfig.patch.callback = () => {
                this._updateZip(+dataKey, index, child.setting);
            };
            // this._updateZip(+dataKey, index);
        }
        if ('zip_4' in item.config) {
            const zip4Config = item.config['zip_4'];
            const zipConfig = item.config['zip'];
            const countryConfig = item.config['country_id'];
            zip4Config.mask = '0000';
            if (this._isUSA(countryConfig)) {
                zip4Config.readonly = zipConfig.value == '' ? true : false;
            }
            else
                zip4Config.readonly = true;
            // zip4Config.minimal = true;
            zip4Config.patch.callback = () => {
                // this._updateZip(+dataKey, index);
            };
            // this._updateZip(+dataKey, index);
        }
        if ('county' in item.config) {
            const countyConfig = item.config['county'];
            const countryConfig = item.config['country_id'];
            if (!this._isUSA(countryConfig))
                countyConfig.readonly = true;
        }
        return true;
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _updateCountry(dataKey, index) {
        const countryConfig = this._getDataKeyItemConfig(dataKey, 'country_id');
        const child = this.field.children['country_id'];
        if (IsArray(child.source, true)) {
            const value = countryConfig.control.value;
            const option = value in child.sourceMap ? child.source[child.sourceMap[value]] : null;
            countryConfig.value = value;
            if (IsObject(option, ['name'])) {
                this._updateDisplayField(dataKey, 'country_id', option.name);
            }
            this._triggerUpdateAssetDisplay(dataKey);
        }
    }
    _updateRegionId(dataKey, index) {
        const stateConfig = this._getDataKeyItemConfig(dataKey, 'region_id');
        const child = this.field.children['region_id'];
        if (IsArray(child.source, true)) {
            const value = stateConfig.control.value;
            if (value) {
                const option = value in child.sourceMap ? child.source[child.sourceMap[value]] : null;
                stateConfig.value = value;
                if (IsObject(option, ['name'])) {
                    this._updateDisplayField(dataKey, 'region_id', option.name);
                }
                this._triggerUpdateAssetDisplay(dataKey);
            }
        }
    }
    _updateZip(dataKey, index, customSettings) {
        return __awaiter(this, void 0, void 0, function* () {
            const zipConfig = this._getDataKeyItemConfig(dataKey, 'zip');
            const zip4Config = this._getDataKeyItemConfig(dataKey, 'zip_4');
            const countyConfig = this._getDataKeyItemConfig(dataKey, 'county');
            // check for +4
            // this._validateZip(dataKey , zipConfig.control.value);
            // Get location details from zipcode
            if (zipConfig && zipConfig.control.value && (customSettings.allow_canada ? String(zipConfig.control.value).length <= 6 : String(zipConfig.control.value).length == 5)) {
                zip4Config.readonly = false;
                if (customSettings === null || customSettings === void 0 ? void 0 : customSettings.auto_fill) {
                    this.dom.state[dataKey].loading = true;
                    const details = yield this._getAddressFromZip(zipConfig.control.value);
                    if (IsObject(details, true)) {
                        let newCountry, newRegion;
                        const dataKeyConfig = this.field.items[dataKey]['config'];
                        if ('region_id' in dataKeyConfig)
                            newRegion = this.field.children['region_id'].source.find(state => String(state['abbr']).toLowerCase() == String(details['state_prefix']).toLowerCase());
                        if ('country_id' in dataKeyConfig)
                            newCountry = this.field.children['country_id'].source.find(country => String(country['abbrv']).toLowerCase() == String(details['country']).toLowerCase());
                        // updating location from
                        // this.field.items[dataKey]['config']['zip'].triggerOnChange(zipConfig.control.value);
                        // newCountry.abbrv='CAN'
                        if (newCountry.abbrv == "CAN") {
                            zip4Config.triggerOnChange(null);
                            zip4Config.readonly = true;
                            countyConfig.readonly = true;
                            countyConfig.triggerOnChange(null);
                        }
                        else {
                            zip4Config.readonly = false;
                            countyConfig.readonly = false;
                        }
                        if ('city' in dataKeyConfig) {
                            this.field.items[dataKey]['config']['city'].triggerOnChange(details['city']);
                            this._updateDisplayField(dataKey, 'city', details['city']);
                        }
                        if ('county' in dataKeyConfig && newCountry.abbrv == "USA") {
                            this.field.items[dataKey]['config']['county'].triggerOnChange(details['county']);
                            this._updateDisplayField(dataKey, 'county', details['county']);
                        }
                        if ('country_id' in dataKeyConfig) {
                            this.field.items[dataKey]['config']['country_id'].triggerOnChange(newCountry['id']);
                            this._updateDisplayField(dataKey, 'county', newCountry['name']);
                        }
                        if ('region_id' in dataKeyConfig) {
                            if (IsObject(newRegion, true)) {
                                this.field.items[dataKey]['config']['region_id'].triggerOnChange(newRegion['id']);
                            }
                            else {
                                this.field.items[dataKey]['config']['region_id'].triggerOnChange(null);
                            }
                        }
                        this.dom.state[dataKey].loading = false;
                        this.dom.state[dataKey].zipError = null;
                    }
                    else {
                        this.dom.state[dataKey].zipError = 'Invalid ZipCode';
                        this.dom.state[dataKey].loading = false;
                    }
                }
            }
            else {
                this.dom.state[dataKey].zipError = 'Invalid ZipCode';
                if (zip4Config.control.value) {
                    zip4Config.triggerOnChange(null);
                }
                zip4Config.readonly = true;
                zipConfig.triggerOnChange(null);
            }
            const child = this.field.children['zip'];
            if (IsArray(child.source, true)) {
                const value = zipConfig.control.value;
                // console.log(value);
                if (value) {
                    const option = value in child.sourceMap ? child.source[child.sourceMap[value]] : null;
                    zipConfig.value = value;
                    if (IsObject(option, ['name'])) {
                        this._updateDisplayField(dataKey, 'zip', option.name);
                    }
                    this._triggerUpdateAssetDisplay(dataKey);
                }
            }
        });
    }
    /**
     *
     * @param countryConfig
     * @returns
     */
    _isUSA(countryConfig) {
        var _a;
        if (countryConfig.value && IsArray((_a = countryConfig === null || countryConfig === void 0 ? void 0 : countryConfig.options) === null || _a === void 0 ? void 0 : _a.values, true)) {
            const country = countryConfig.options.values.find(country => country.value == countryConfig.value);
            if (country.name.toLowerCase().split(' ').join('') != 'unitedstates')
                return false;
            else
                return true;
        }
        else
            return true;
    }
    _getAddressFromZip(zipcode) {
        return new Promise((resolve, reject) => {
            PopRequest.doGet(`legacy/data/zip-codes?zip_code=${zipcode}`).subscribe(res => {
                res = GetHttpArrayResult(res).pop() || [];
                return resolve(res);
            });
        });
    }
}
PopEntityAddressComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-address',
                template: "<div class=\"pop-entity-address-field import-field-container\">\n\n  <!--<div class=\"pop-entity-address-readonly-container\" [ngClass]=\"{'sw-hidden': dom.state.template !== 'template_readonly'}\">-->\n  <div class=\"pop-entity-address-readonly-container\">\n    <div class=\"pop-entity-address-label-header\">\n      <div class=\"pop-entity-address-label pop-entity-address-label-title\" *ngIf=\"field.multiple\">\n        &nbsp;Label\n      </div>\n      <div class=\"pop-entity-address-label pop-entity-address-label-address\">\n        &nbsp;<div *ngIf=\"field.multiple\">Address</div>\n        <div *ngIf=\"!field.multiple\">{{field.entries[0].name}}</div>\n      </div>\n\n      <div class=\"pop-entity-address-label pop-entity-address-label-icon\">\n        <div class=\"import-flex-row import-flex-item-sm import-flex-grow-sm\"></div><!-- Filler -->\n        <lib-pop-entity-field-edit-icon\n          *ngIf=\"!field.multiple\"\n          class=\"import-flex-align-end\"\n          (events)=\"onActionEvent($event, 0);\" [field]=\"field\"\n          [dom]=\"dom\"\n        ></lib-pop-entity-field-edit-icon>\n      </div>\n\n    </div>\n\n    <div [ngClass]=\"{'sw-field-mar-btm-sm':isLast}\" *ngFor=\"let dataKey of field.data_keys; last as isLast;\">\n      <div *ngIf=\"field.data[dataKey]; let data;\">\n        <div *ngIf=\"field.items[dataKey].config; let items;\">\n          <div *ngIf=\"dom.state[dataKey]; let state;\">\n            <div *ngIf=\"dom.session[dataKey].display; let display;\">\n\n              <div class=\"pop-entity-address-item-header\" [ngClass]=\"{'sw-hidden':state.open}\">\n                <div class=\"pop-entity-address-item  pop-entity-address-item-title\" *ngIf=\"field.multiple\">\n                  <div>{{dom.session[ dataKey ].display.label}}</div>\n                </div>\n                <div class=\"pop-entity-address-item  pop-entity-address-item-address\">\n                  <div class=\"import-flex-row-wrap\" *ngIf=\"items['line_1'] && data['line_1']\">\n                    <div>&nbsp;{{data['line_1']}}</div>\n                  </div>\n\n                  <div class=\"import-flex-row-wrap\">\n                    <div *ngIf=\"items['line_2'] && data['line_2']\">&nbsp;{{data['line_2']}}</div>\n                    <div *ngIf=\"items['line_3'] && data['line_3']\">&nbsp;{{data['line_3']}}</div>\n                  </div>\n\n                  <div class=\"import-flex-row-wrap\">\n                    <div *ngIf=\"items['city'] && data['city']\">&nbsp;{{data['city']}}</div>\n                    <div *ngIf=\"items['city'] && data['city'] && items['region_id'] && display['region_id']\">,</div>\n                    <div *ngIf=\"items['region_id'] && display['region_id']\">\n                      &nbsp;{{display['region_id']}}</div>\n                    <div *ngIf=\"items['region_id'] && data['region_id'] && items['county'] && data['county']\">\n                      ,</div>\n                    <div *ngIf=\"items['county'] && data['county']\">&nbsp;{{data['county']}}</div>\n                    <div *ngIf=\"items['zip'] && data['zip']\">&nbsp;{{data['zip']}}</div>\n                    <div *ngIf=\"items['zip_4'] && data['zip_4']\">-{{data['zip_4']}}</div>\n                    <div *ngIf=\"items['country_id'] && display['country_id']\">&nbsp;{{display['country_id']}}</div>\n                  </div>\n\n                </div>\n                <div class=\"pop-entity-address-item-icon\">\n                  <!-- Filler -->\n                  <lib-pop-entity-field-edit-icon\n                    *ngIf=\"field.multiple\"\n                    [style.marginLeft.px]=\"-15\"\n                    (events)=\"onActionEvent($event, dataKey);\" [field]=\"field\"\n                    [dom]=\"dom\"\n                  ></lib-pop-entity-field-edit-icon>\n                </div>\n              </div>\n              <mat-divider *ngIf=\"!isLast\" [style.width.%]=\"100\" [style.marginTop.px]=\"5\"></mat-divider>\n\n              <div [ngClass]=\"{'sw-hidden':!state.open}\" class=\"pt-02 sw-pad-hrz-sm sw-mar-top-xs\">\n                <div class=\"import-flex-row import-field-flex-row-offset\">\n                  <div class=\"import-flex-row-wrap\">\n\n                    <!-- v Label and Custom lablel - turned off for now v -->\n\n                    <!--<div *ngIf=\"field.multiple && field.setting.edit_label && asset.entry; let entry;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n                    <!--<lib-pop-select [config]=\"entry\"></lib-pop-select>-->\n                    <!--</div>-->\n                    <!--<div *ngIf=\"state.customLabel && asset.customLabel; let item;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n                    <!--<lib-pop-input [config]=\"item\"></lib-pop-input>-->\n                    <!--</div>-->\n                    <!--<div class=\"import-flex-row-break\"></div>-->\n\n                    <!-- ^ Label and Custom lable - turned off for now ^ -->\n\n\n                    <div *ngIf=\"items['line_1']\" class=\"import-field import-field-spacing import-flex-item-full import-flex-grow-lg\">\n                      <lib-pop-input\n                        [config]=\"items['line_1']\"\n                        (events)=\"onFieldItemEvent($event, dataKey, 'line_1');\"\n                      ></lib-pop-input>\n                    </div>\n\n                    <div *ngIf=\"items['line_2']\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">\n                      <lib-pop-input\n                        [config]=\"items['line_2']\"\n                        (events)=\"onFieldItemEvent($event, dataKey, 'line_2');\"\n                      ></lib-pop-input>\n                    </div>\n\n                    <div *ngIf=\"items['line_3']\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">\n                      <lib-pop-input\n                        [config]=\"items['line_3']\"\n                        (events)=\"onFieldItemEvent($event, dataKey, 'line_3');\"\n                      ></lib-pop-input>\n                    </div>\n\n                    <div class=\"import-flex-row-break\"></div>\n                    <div *ngIf=\"items['zip']\" class=\"import-flex-row import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-input class=\"import-flex-item-xs import-flex-grow-xs\" [config]=\"items['zip']\" (events)=\"onFieldItemEvent($event, dataKey, 'zip');\"></lib-pop-input>\n                    </div>\n\n                    <div *ngIf=\"items['zip_4']\" class=\"import-flex-row import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-input class=\"import-flex-item-xs import-flex-grow-xs\" [config]=\"items['zip_4']\" (events)=\"onFieldItemEvent($event, dataKey, 'zip_4');\"></lib-pop-input>\n                    </div>\n                    <!-- Show error message -->\n\n                    <div *ngIf=\"items['zip']\" class=\"import-flex-row-break\"></div>\n\n                    <mat-progress-bar\n                    class=\"pop-field-item-loader\"\n                    *ngIf=\"state.loading\"\n                    [style.height.px]=\"1\"\n                    [mode]=\"'query'\"\n                  >\n                  </mat-progress-bar>\n\n                    <div *ngIf=\"items['zip'] && state.zipError\" class=\"import-flex-row import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n\n                      <p >{{state.zipError}}</p>\n                    </div>\n                    <div class=\"import-flex-row-break\"></div>\n\n\n\n                    <div *ngIf=\"items['city']\" class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-input [config]=\"items['city']\" (events)=\"onFieldItemEvent($event, dataKey, 'city');\"></lib-pop-input>\n                    </div>\n\n                    <div *ngIf=\"items['region_id']\" class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-select [config]=\"items['region_id']\" (events)=\"onFieldItemEvent($event, dataKey, 'region_id');\"></lib-pop-select>\n                    </div>\n\n\n                    <div class=\"import-flex-row-break\"></div>\n\n                    <div *ngIf=\"items['county']\"\n                         class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-input [config]=\"items['county']\"\n                                     (events)=\"onFieldItemEvent($event,dataKey,  'county');\"></lib-pop-input>\n                    </div>\n\n                    <div *ngIf=\"items['country_id']\"\n                         class=\"import-field import-field-spacing import-flex-item-xs import-flex-grow-xs\">\n                      <lib-pop-select [config]=\"items['country_id']\"\n                                      (events)=\"onFieldItemEvent($event, dataKey, 'country_id');\"></lib-pop-select>\n                    </div>\n                  </div>\n                </div>\n\n                <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove\">\n                  <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n                </div>\n\n                <div *ngIf=\"true\" class=\"import-flex-row-wrap import-flex-end sw-pad-rgt-lg sw-pad-vrt-lg\">\n                  <lib-pop-button\n                    [config]=\"{value:'Close', size: 30, color: 'accent', bubble: true, event: 'close'}\"\n                    (events)=\"onActionEvent($event, dataKey);\"\n                  ></lib-pop-button>\n                </div>\n                <div *ngIf=\"false\" class=\"import-flex-row-wrap import-flex-end sw-pad-rgt-lg sw-pad-vrt-lg\">\n                  <lib-pop-button\n                    [config]=\"{value:'Close', size: 30, color: 'accent', bubble: true, event: 'close'}\"\n                    (events)=\"onActionEvent($event);\"\n                  ></lib-pop-button>\n                </div>\n\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".pop-entity-address-field{position:relative;min-height:80px;clear:both;margin-top:17px}.pop-entity-address-readonly-container{position:relative;flex:1;border:1px solid var(--border);border-radius:3px;padding-bottom:5px}.pop-entity-address-label-header{display:flex;align-items:center;justify-content:flex-start;min-height:45px;border-bottom:1px solid var(--border)}.pop-entity-address-label-title{width:30%}.pop-entity-address-label-address{word-wrap:break-word;display:flex;flex-grow:1;width:60%}.pop-entity-address-label-icon{display:flex;width:10%}.pop-entity-address-item-title{width:25%}.pop-entity-address-item-address{display:flex;flex-grow:1;width:70%;flex-direction:column}.pop-entity-address-item-icon{display:flex;flex-direction:row;width:5%;align-items:center;justify-content:flex-start}:host ::ng-deep .pop-entity-address-item-icon mat-icon{font-size:.95em}.pop-entity-address-item-header{display:flex;align-items:flex-start;justify-content:flex-start;margin-top:5px;min-height:35px}.pop-entity-address-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding:0 5px}.pop-entity-address-item{font-size:.8em;padding:0 5px}:host ::ng-deep lib-pop-field-item-loader{top:3rem!important}"]
            },] }
];
PopEntityAddressComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityAddressComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityInputComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, InputFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityInputComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label']);
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                item.config.value.label = item.entry ? item.entry.name : defaultLabel;
            });
        }
        return true;
    }
}
PopEntityInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-input',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n    <!--<div *ngIf=\"dom.state[dataKey]; let state;\">-->\n      <!--<div *ngIf=\"ui.asset[dataKey]; let asset;\">-->\n        <div class=\"import-flex-row import-flex-item-full\" *ngIf=\"items.config['value']; let item;\">\n          <lib-pop-input class=\"import-field import-flex-item-xs import-flex-grow-xs\" [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'value');\"></lib-pop-input>\n          <!--<div class=\"pop-entity-input-item-icon\" *ngIf=\"field.multiple\">-->\n            <!--<lib-pop-entity-field-edit-icon-->\n              <!--(events)=\"onActionEvent($event, dataKey);\" [field]=\"field\"-->\n              <!--[dom]=\"dom\"-->\n            <!--&gt;</lib-pop-entity-field-edit-icon>-->\n          <!--</div>-->\n        </div>\n        <!--<div [ngClass]=\"{'sw-hidden':!state.open}\" class=\"pt-02 sw-pad-hrz-sm sw-mar-top-xs\">-->\n\n          <!--<div class=\"import-flex-row import-field-flex-row-offset\">-->\n            <!--<div class=\"import-flex-row-wrap\">-->\n              <!--<div *ngIf=\"field.setting.edit_label && asset.entry; let entry;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n                <!--<lib-pop-select [config]=\"entry\"></lib-pop-select>-->\n              <!--</div>-->\n              <!--<div *ngIf=\"state.customLabel && asset.customLabel; let item;\" class=\"import-field import-field-spacing import-flex-item-sm import-flex-grow-sm\">-->\n                <!--<lib-pop-input [config]=\"item\"></lib-pop-input>-->\n              <!--</div>-->\n            <!--</div>-->\n          <!--</div>-->\n\n          <!--<div *ngIf=\"field.canRemove\" class=\"import-flex-row-wrap import-flex-end\">-->\n            <!--<lib-pop-field-btn class=\"sw-mar-top-md sw-pad-rgt-lg\" doAction=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>-->\n          <!--</div>-->\n          <!---->\n        <!--</div>-->\n        <!--<div *ngIf=\"isLast && i !== 0\" class=\"import-flex-row-wrap import-flex-end sw-pad-rgt-md sw-pad-vrt-lg\">-->\n          <!--<lib-pop-button-->\n            <!--[config]=\"{value:'Close', size: 30, color: 'accent', bubble: true, event: 'close'}\"-->\n            <!--(events)=\"onActionEvent($event, dataKey);\"-->\n          <!--&gt;</lib-pop-button>-->\n        <!--</div>-->\n        <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n          <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n        </div>\n\n      <!--</div>-->\n    <!--</div>-->\n  </div>\n</div>\n\n",
                styles: [".pop-entity-input-item-icon{display:flex;flex-direction:column;width:10%;align-items:flex-end;justify-content:center}"]
            },] }
];
PopEntityInputComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityInputComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntitySelectComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, SelectFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntitySelectComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label']);
        const entryLabel = this.field.entries[0].name;
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                if (this.field.multiple) {
                    item.config.value.label = this.dom.session[dataKey].display.label;
                }
                else {
                    item.config.value.label = entryLabel ? entryLabel : defaultLabel;
                }
            });
        }
        return true;
    }
}
PopEntitySelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-select',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n    <div class=\"import-flex-row\">\n      <div class=\"import-flex-row-wrap\">\n        <div *ngIf=\"items.config['value']; let item;\" class=\"import-field import-flex-item-xs import-flex-grow-xs\">\n          <lib-pop-select [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, item.column);\"></lib-pop-select>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n\n  </div>\n</div>\n",
                styles: [""]
            },] }
];
PopEntitySelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntitySelectComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityRadioComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, RadioFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityRadioComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label'], '');
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                item.config.value.label = item.entry ? item.entry.name : defaultLabel;
            });
        }
        return true;
    }
}
PopEntityRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-radio',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n\n    <div class=\"import-flex-row import-flex-item-full\" *ngIf=\"items.config['value']; let item;\">\n      <lib-pop-radio class=\"import-field import-flex-item-xs import-flex-grow-xs\" [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'value');\"></lib-pop-radio>\n    </div>\n\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n  </div>\n</div>\n",
                styles: [".pop-entity-input-item-icon{display:flex;flex-direction:column;width:10%;align-items:flex-end;justify-content:center}"]
            },] }
];
PopEntityRadioComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityRadioComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityCheckboxComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, CheckboxFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityCheckboxComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label'], '');
        console.log('defaultLabel', defaultLabel);
        const entryLabel = this.field.entries[0].name;
        console.log('entryLabel', entryLabel);
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                if (this.field.multiple) {
                    item.config.value.label = this.dom.session[dataKey].display.label;
                }
                else {
                    item.config.value.label = entryLabel ? entryLabel : defaultLabel;
                }
            });
        }
        return true;
    }
}
PopEntityCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-checkbox',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n\n    <div class=\"import-flex-row import-flex-item-full\" *ngIf=\"items.config['value']; let item;\">\n      <lib-pop-checkbox class=\"import-field import-flex-item-xs import-flex-grow-xs\" [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'value');\"></lib-pop-checkbox>\n    </div>\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-md\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n  </div>\n</div>\n\n",
                styles: [""]
            },] }
];
PopEntityCheckboxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityCheckboxComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntitySwitchComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, SwitchFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntitySwitchComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label'], '');
        const entryLabel = this.field.entries[0].name;
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                if (this.field.multiple) {
                    item.config.value.label = this.dom.session[dataKey].display.label;
                }
                else {
                    item.config.value.label = entryLabel ? entryLabel : defaultLabel;
                }
            });
        }
        return true;
    }
}
PopEntitySwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-switch',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n    <div class=\"import-flex-row\">\n      <div class=\"import-flex-row-wrap\">\n        <div *ngIf=\"items.config['value']; let item;\" class=\"import-field import-flex-item-xs import-flex-grow-xs\">\n          <lib-pop-switch [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, item.column);\"></lib-pop-switch>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n\n  </div>\n</div>\n",
                styles: [""]
            },] }
];
PopEntitySwitchComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntitySwitchComponent.propDecorators = {
    field: [{ type: Input }]
};

const SelectMultiFieldSetting = {
    unique_label: {
        name: 'unique_label',
        type: 'boolean',
        defaultValue: true,
    },
};

class PopEntitySelectMultiComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, SelectMultiFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntitySelectMultiComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label']);
        const entryLabel = this.field.entries[0].name;
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                if (this.field.multiple) {
                    item.config.value.label = this.dom.session[dataKey].display.label;
                }
                else {
                    item.config.value.label = entryLabel ? entryLabel : defaultLabel;
                }
            });
        }
        return true;
    }
}
PopEntitySelectMultiComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-select-multi',
                template: "<div class=\"pop-entity-input-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n    <div class=\"import-flex-row\">\n      <div class=\"import-flex-row-wrap\">\n        <div *ngIf=\"items.config['value']; let item;\" class=\"import-field import-flex-item-xs import-flex-grow-xs\">\n          <lib-pop-select-multi [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, item.column);\"></lib-pop-select-multi>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n\n  </div>\n</div>\n",
                styles: [""]
            },] }
];
PopEntitySelectMultiComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntitySelectMultiComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityTextareaComponent extends PopEntityFieldBoilerComponent {
    constructor(el, _domRepo) {
        super(el, _domRepo, TextareaFieldSetting);
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityTextareaComponent';
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                  Override Inherited Methods                                  *
     *                                    ( Protected Methods )                                     *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will setup this field to handle changes and transformations
     */
    _setFieldAttributes() {
        const defaultLabel = StorageGetter(this.field, ['children', 'value', 'model', 'label']);
        if (this.field && this.field.items) {
            Object.keys(this.field.items).map((dataKey, index) => {
                const item = this.field.items[dataKey];
                item.config.content.label = item.entry ? item.entry.name : defaultLabel;
            });
        }
        return true;
    }
}
PopEntityTextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-textarea',
                template: "<div class=\"pop-entity-textarea-field import-field-container\" *ngFor=\"let dataKey of field.data_keys; let i = index;  last as isLast\">\n  <div *ngIf=\"field.items[dataKey]; let items;\">\n\n    <div class=\"import-flex-row import-flex-item-full\" *ngIf=\"items.config['content']; let item;\">\n      <lib-pop-textarea class=\"import-field import-flex-item-xs import-flex-grow-xs\" [config]=\"item\" (events)=\"onFieldItemEvent($event, dataKey, 'content');\"></lib-pop-textarea>\n    </div>\n\n    <div class=\"import-field-footer sw-mar-top-sm sw-pad-rgt-lg\" *ngIf=\"field.canRemove && isLast\">\n      <lib-pop-field-btn class=\"sw-mar-rgt-sm\" action=\"remove\" [field]=\"field\" (events)=\"onActionEvent($event, dataKey);\"></lib-pop-field-btn>\n    </div>\n\n  </div>\n</div>\n",
                styles: [".pop-entity-textarea-item-icon{display:flex;flex-direction:column;width:10%;align-items:flex-end;justify-content:center}"]
            },] }
];
PopEntityTextareaComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityTextareaComponent.propDecorators = {
    field: [{ type: Input }]
};

var MOCK_DATA = [
	{
		number: "(432) 8681369",
		prefix: "Honorable",
		first: "Aryn",
		middle: "Freddie",
		last: "Guyan",
		suffix: "II",
		line_1: "Hallows",
		line_2: "Westridge",
		line_3: "671",
		city: "Midland",
		region_id: 10,
		country: "United States",
		zip: "79705"
	},
	{
		number: "(310) 6622956",
		prefix: "Ms",
		first: "Atalanta",
		middle: "Brody",
		last: "Drennan",
		suffix: "Jr",
		line_1: "Manufacturers",
		line_2: "Manitowish",
		line_3: "3548",
		city: "Los Angeles",
		region_id: 20,
		country: "United States",
		zip: "90035"
	},
	{
		number: "(256) 9125413",
		prefix: "Rev",
		first: "Morten",
		middle: "Ashien",
		last: "Exroll",
		suffix: "IV",
		line_1: "Oakridge",
		line_2: "Del Sol",
		line_3: "907",
		city: "Huntsville",
		region_id: 18,
		country: "United States",
		zip: "35815"
	},
	{
		number: "(405) 9975613",
		prefix: "Rev",
		first: "Barthel",
		middle: "Cleopatra",
		last: "McFaul",
		suffix: "IV",
		line_1: "Clyde Gallagher",
		line_2: "Badeau",
		line_3: "5",
		city: "Oklahoma City",
		region_id: 11,
		country: "United States",
		zip: "73173"
	},
	{
		number: "(251) 8931103",
		prefix: "Mr",
		first: "Dietrich",
		middle: "Sidonnie",
		last: "Illingsworth",
		suffix: "Jr",
		line_1: "Transport",
		line_2: "Stuart",
		line_3: "90679",
		city: "Mobile",
		region_id: 30,
		country: "United States",
		zip: "36689"
	},
	{
		number: "(828) 3451730",
		prefix: "Rev",
		first: "Arty",
		middle: "Shawnee",
		last: "Zapata",
		suffix: "III",
		line_1: "Swallow",
		line_2: "Lawn",
		line_3: "34",
		city: "Asheville",
		region_id: 2,
		country: "United States",
		zip: "28815"
	},
	{
		number: "(304) 4762071",
		prefix: "Ms",
		first: "Wye",
		middle: "Jilleen",
		last: "Boynes",
		suffix: "Sr",
		line_1: "4th",
		line_2: "Tennessee",
		line_3: "1",
		city: "Huntington",
		region_id: 47,
		country: "United States",
		zip: "25775"
	},
	{
		number: "(214) 3168936",
		prefix: "Mr",
		first: "Gregg",
		middle: "Faustine",
		last: "Keattch",
		suffix: "Jr",
		line_1: "Bunker Hill",
		line_2: "Golf View",
		line_3: "832",
		city: "Dallas",
		region_id: 6,
		country: "United States",
		zip: "75260"
	},
	{
		number: "(954) 7929407",
		prefix: "Ms",
		first: "Caresa",
		middle: "Fania",
		last: "Pinnock",
		suffix: "Jr",
		line_1: "Quincy",
		line_2: "Stone Corner",
		line_3: "8",
		city: "Fort Lauderdale",
		region_id: 12,
		country: "United States",
		zip: "33330"
	},
	{
		number: "(915) 6300446",
		prefix: "Mr",
		first: "Korella",
		middle: "Kristyn",
		last: "Wildblood",
		suffix: "IV",
		line_1: "Fair Oaks",
		line_2: "Scott",
		line_3: "2",
		city: "El Paso",
		region_id: 31,
		country: "United States",
		zip: "88574"
	},
	{
		number: "(703) 6359815",
		prefix: "Ms",
		first: "Sheila-kathryn",
		middle: "Charissa",
		last: "Blown",
		suffix: "II",
		line_1: "Butternut",
		line_2: "Coolidge",
		line_3: "9",
		city: "Reston",
		region_id: 32,
		country: "United States",
		zip: "20195"
	},
	{
		number: "(520) 8823460",
		prefix: "Dr",
		first: "Jilleen",
		middle: "Odelle",
		last: "Wraggs",
		suffix: "II",
		line_1: "Londonderry",
		line_2: "Sugar",
		line_3: "631",
		city: "Tucson",
		region_id: 46,
		country: "United States",
		zip: "85743"
	},
	{
		number: "(501) 2671110",
		prefix: "Mr",
		first: "Mada",
		middle: "Jeanie",
		last: "Croall",
		suffix: "III",
		line_1: "Redwing",
		line_2: "Express",
		line_3: "11",
		city: "North Little Rock",
		region_id: 13,
		country: "United States",
		zip: "72118"
	},
	{
		number: "(229) 6574703",
		prefix: "Ms",
		first: "Bruis",
		middle: "Melody",
		last: "Matyja",
		suffix: "Jr",
		line_1: "Raven",
		line_2: "Lerdahl",
		line_3: "0780",
		city: "Decatur",
		region_id: 27,
		country: "United States",
		zip: "30089"
	},
	{
		number: "(706) 2720582",
		prefix: "Rev",
		first: "Odey",
		middle: "Hashim",
		last: "Reany",
		suffix: "III",
		line_1: "Green Ridge",
		line_2: "Bay",
		line_3: "727",
		city: "Augusta",
		region_id: 16,
		country: "United States",
		zip: "30905"
	},
	{
		number: "(201) 9304490",
		prefix: "Ms",
		first: "Gerhardt",
		middle: "Thorndike",
		last: "Duhig",
		suffix: "IV",
		line_1: "Oak Valley",
		line_2: "Messerschmidt",
		line_3: "7",
		city: "Paterson",
		region_id: 30,
		country: "United States",
		zip: "07522"
	},
	{
		number: "(512) 8449175",
		prefix: "Mrs",
		first: "Garvy",
		middle: "Jay",
		last: "Jeggo",
		suffix: "Jr",
		line_1: "Bunting",
		line_2: "Bunker Hill",
		line_3: "3164",
		city: "Austin",
		region_id: 33,
		country: "United States",
		zip: "78759"
	},
	{
		number: "(610) 1346823",
		prefix: "Rev",
		first: "Kristan",
		middle: "Evania",
		last: "Hugonin",
		suffix: "IV",
		line_1: "Oriole",
		line_2: "Carioca",
		line_3: "93791",
		city: "Allentown",
		region_id: 33,
		country: "United States",
		zip: "18105"
	},
	{
		number: "(972) 4871606",
		prefix: "Honorable",
		first: "Frank",
		middle: "Caritta",
		last: "Perrett",
		suffix: "Sr",
		line_1: "Morrow",
		line_2: "Emmet",
		line_3: "897",
		city: "Dallas",
		region_id: 14,
		country: "United States",
		zip: "75205"
	},
	{
		number: "(816) 3091864",
		prefix: "Mr",
		first: "Reeba",
		middle: "Sheri",
		last: "Bremmer",
		suffix: "II",
		line_1: "Merrick",
		line_2: "Truax",
		line_3: "86683",
		city: "Kansas City",
		region_id: 2,
		country: "United States",
		zip: "64130"
	},
	{
		number: "(916) 6852072",
		prefix: "Mrs",
		first: "Guthrie",
		middle: "Gerladina",
		last: "Cureton",
		suffix: "Jr",
		line_1: "Mayer",
		line_2: "Goodland",
		line_3: "402",
		city: "Sacramento",
		region_id: 1,
		country: "United States",
		zip: "95813"
	},
	{
		number: "(561) 3435348",
		prefix: "Honorable",
		first: "Zelda",
		middle: "Dorette",
		last: "St. Queintain",
		suffix: "III",
		line_1: "Ilene",
		line_2: "Bunker Hill",
		line_3: "09912",
		city: "Boca Raton",
		region_id: 37,
		country: "United States",
		zip: "33499"
	},
	{
		number: "(904) 5841821",
		prefix: "Ms",
		first: "Gian",
		middle: "Evanne",
		last: "Peschmann",
		suffix: "II",
		line_1: "Sullivan",
		line_2: "Derek",
		line_3: "08",
		city: "Jacksonville",
		region_id: 32,
		country: "United States",
		zip: "32255"
	},
	{
		number: "(702) 3087097",
		prefix: "Mr",
		first: "Fin",
		middle: "Otho",
		last: "Culleford",
		suffix: "III",
		line_1: "Harbort",
		line_2: "Jay",
		line_3: "12720",
		city: "Las Vegas",
		region_id: 50,
		country: "United States",
		zip: "89178"
	},
	{
		number: "(518) 6415717",
		prefix: "Honorable",
		first: "Doy",
		middle: "Frasco",
		last: "Fudger",
		suffix: "Jr",
		line_1: "Rutledge",
		line_2: "Blaine",
		line_3: "65688",
		city: "Albany",
		region_id: 46,
		country: "United States",
		zip: "12205"
	},
	{
		number: "(202) 2075385",
		prefix: "Mrs",
		first: "Fairfax",
		middle: "Jobey",
		last: "ducarme",
		suffix: "Sr",
		line_1: "Moland",
		line_2: "Spohn",
		line_3: "135",
		city: "Washington",
		region_id: 38,
		country: "United States",
		zip: "20226"
	},
	{
		number: "(304) 8477966",
		prefix: "Mrs",
		first: "Finn",
		middle: "Decca",
		last: "Campling",
		suffix: "III",
		line_1: "Kings",
		line_2: "Almo",
		line_3: "022",
		city: "Charleston",
		region_id: 44,
		country: "United States",
		zip: "25362"
	},
	{
		number: "(786) 7805933",
		prefix: "Ms",
		first: "Colet",
		middle: "Mitchael",
		last: "Signe",
		suffix: "III",
		line_1: "Maywood",
		line_2: "Scofield",
		line_3: "838",
		city: "Miami",
		region_id: 25,
		country: "United States",
		zip: "33147"
	},
	{
		number: "(918) 9261303",
		prefix: "Rev",
		first: "Clementia",
		middle: "Emmy",
		last: "Spain",
		suffix: "IV",
		line_1: "Trailsway",
		line_2: "Summer Ridge",
		line_3: "01986",
		city: "Tulsa",
		region_id: 2,
		country: "United States",
		zip: "74103"
	},
	{
		number: "(303) 1982164",
		prefix: "Ms",
		first: "Noelyn",
		middle: "Brody",
		last: "Curley",
		suffix: "III",
		line_1: "Sullivan",
		line_2: "Redwing",
		line_3: "8905",
		city: "Denver",
		region_id: 34,
		country: "United States",
		zip: "80204"
	},
	{
		number: "(801) 2223513",
		prefix: "Rev",
		first: "Pierrette",
		middle: "Carmine",
		last: "Farr",
		suffix: "IV",
		line_1: "American",
		line_2: "Fair Oaks",
		line_3: "42160",
		city: "Salt Lake City",
		region_id: 25,
		country: "United States",
		zip: "84115"
	},
	{
		number: "(570) 6033172",
		prefix: "Honorable",
		first: "Bruno",
		middle: "Modestine",
		last: "Pattisson",
		suffix: "Sr",
		line_1: "Arizona",
		line_2: "Rusk",
		line_3: "1629",
		city: "Wilkes Barre",
		region_id: 23,
		country: "United States",
		zip: "18706"
	},
	{
		number: "(941) 7116852",
		prefix: "Dr",
		first: "Asher",
		middle: "Ricky",
		last: "Shallow",
		suffix: "Jr",
		line_1: "Kipling",
		line_2: "Maple Wood",
		line_3: "41284",
		city: "Pinellas Park",
		region_id: 28,
		country: "United States",
		zip: "34665"
	},
	{
		number: "(202) 1979450",
		prefix: "Mr",
		first: "Sanford",
		middle: "Robert",
		last: "Bucklee",
		suffix: "Jr",
		line_1: "Kings",
		line_2: "Calypso",
		line_3: "27111",
		city: "Alexandria",
		region_id: 45,
		country: "United States",
		zip: "22309"
	},
	{
		number: "(310) 7014715",
		prefix: "Dr",
		first: "Conan",
		middle: "Jarrett",
		last: "Pavier",
		suffix: "Jr",
		line_1: "Sauthoff",
		line_2: "Dixon",
		line_3: "0",
		city: "Fresno",
		region_id: 50,
		country: "United States",
		zip: "93762"
	},
	{
		number: "(469) 6780351",
		prefix: "Rev",
		first: "Esme",
		middle: "Hortense",
		last: "Tremethack",
		suffix: "II",
		line_1: "Forster",
		line_2: "Warrior",
		line_3: "7",
		city: "Dallas",
		region_id: 30,
		country: "United States",
		zip: "75216"
	},
	{
		number: "(803) 8625420",
		prefix: "Honorable",
		first: "Cassy",
		middle: "Westley",
		last: "Charity",
		suffix: "II",
		line_1: "Mayer",
		line_2: "Hudson",
		line_3: "85911",
		city: "Columbia",
		region_id: 30,
		country: "United States",
		zip: "29215"
	},
	{
		number: "(615) 3226644",
		prefix: "Rev",
		first: "Ardys",
		middle: "Markus",
		last: "Monahan",
		suffix: "III",
		line_1: "Heffernan",
		line_2: "Ludington",
		line_3: "96743",
		city: "Nashville",
		region_id: 50,
		country: "United States",
		zip: "37245"
	},
	{
		number: "(304) 4328658",
		prefix: "Mr",
		first: "Ceil",
		middle: "Bird",
		last: "Allred",
		suffix: "Jr",
		line_1: "Dorton",
		line_2: "Tennyson",
		line_3: "0695",
		city: "Charleston",
		region_id: 26,
		country: "United States",
		zip: "25326"
	},
	{
		number: "(401) 1098335",
		prefix: "Mr",
		first: "Skye",
		middle: "Jacky",
		last: "Duffyn",
		suffix: "III",
		line_1: "Independence",
		line_2: "Mosinee",
		line_3: "85884",
		city: "Providence",
		region_id: 17,
		country: "United States",
		zip: "02912"
	},
	{
		number: "(540) 6236316",
		prefix: "Honorable",
		first: "Johannah",
		middle: "Herminia",
		last: "Ebertz",
		suffix: "III",
		line_1: "Hanson",
		line_2: "Glacier Hill",
		line_3: "30",
		city: "Roanoke",
		region_id: 25,
		country: "United States",
		zip: "24034"
	},
	{
		number: "(202) 1509886",
		prefix: "Honorable",
		first: "Guthrey",
		middle: "Winny",
		last: "Reuss",
		suffix: "III",
		line_1: "1st",
		line_2: "Melody",
		line_3: "4772",
		city: "Washington",
		region_id: 24,
		country: "United States",
		zip: "20575"
	},
	{
		number: "(202) 4485396",
		prefix: "Mrs",
		first: "Heath",
		middle: "Reinhard",
		last: "Cherry",
		suffix: "II",
		line_1: "Shasta",
		line_2: "Grover",
		line_3: "16155",
		city: "Washington",
		region_id: 43,
		country: "United States",
		zip: "20238"
	},
	{
		number: "(203) 3391386",
		prefix: "Ms",
		first: "Boot",
		middle: "Matthew",
		last: "Spurgin",
		suffix: "Sr",
		line_1: "Muir",
		line_2: "Manitowish",
		line_3: "2107",
		city: "Norwalk",
		region_id: 11,
		country: "United States",
		zip: "06854"
	},
	{
		number: "(786) 1710016",
		prefix: "Mrs",
		first: "Sky",
		middle: "Trent",
		last: "Faichney",
		suffix: "Jr",
		line_1: "Continental",
		line_2: "Luster",
		line_3: "415",
		city: "Miami",
		region_id: 32,
		country: "United States",
		zip: "33158"
	},
	{
		number: "(816) 7081228",
		prefix: "Rev",
		first: "Elihu",
		middle: "Joel",
		last: "Widdows",
		suffix: "IV",
		line_1: "Kingsford",
		line_2: "Melody",
		line_3: "52316",
		city: "Kansas City",
		region_id: 37,
		country: "United States",
		zip: "64125"
	},
	{
		number: "(517) 9466139",
		prefix: "Mr",
		first: "Karalee",
		middle: "Weston",
		last: "Dearell",
		suffix: "Sr",
		line_1: "Stang",
		line_2: "Kingsford",
		line_3: "0570",
		city: "Lansing",
		region_id: 3,
		country: "United States",
		zip: "48930"
	},
	{
		number: "(602) 6259964",
		prefix: "Rev",
		first: "Godart",
		middle: "Murdoch",
		last: "Blewett",
		suffix: "IV",
		line_1: "Rowland",
		line_2: "Manley",
		line_3: "471",
		city: "Peoria",
		region_id: 47,
		country: "United States",
		zip: "85383"
	},
	{
		number: "(347) 8954655",
		prefix: "Mr",
		first: "Angus",
		middle: "Murielle",
		last: "Minet",
		suffix: "Jr",
		line_1: "Golf",
		line_2: "Truax",
		line_3: "2812",
		city: "New York City",
		region_id: 9,
		country: "United States",
		zip: "10004"
	},
	{
		number: "(414) 6717514",
		prefix: "Mr",
		first: "Polly",
		middle: "Conney",
		last: "Longworth",
		suffix: "Sr",
		line_1: "Summerview",
		line_2: "Mandrake",
		line_3: "9",
		city: "Milwaukee",
		region_id: 2,
		country: "United States",
		zip: "53263"
	}
];

class PopFieldEditorService extends PopExtendService {
    constructor() {
        super();
        this.name = 'PopFieldEditorService';
        this.asset = {
            data: MOCK_DATA,
            core: undefined,
            field: undefined,
            viewParams: {
                select: {
                    disabled: 1,
                    display: 1,
                    required: 1,
                    // required: 1
                },
                select_multi: {
                    disabled: 1,
                    display: 1,
                    helpText: 1,
                    // required: 1
                },
                input: {
                    display: 1,
                    readonly: 1,
                    required: 1,
                    pattern: 1,
                    validation: 1,
                    transformation: 1,
                    maxlength: 1,
                    minlength: 1,
                    mask: 1,
                    disabled: 1,
                    allow_canada: 1,
                    auto_fill: 1
                },
                phone: {
                    display: 1,
                    readonly: 1,
                    required: 1,
                    mask: 1
                },
                checkbox: {
                    display: 1,
                    readonly: 1,
                },
                button: {
                    display: 1,
                    disabled: 1,
                },
                radio: {
                    display: 1,
                    disabled: 1,
                    layout: 1
                },
                switch: {
                    display: 1,
                    disabled: 1,
                    allow_canada: 1,
                    auto_fill: 1
                }
            },
            viewLabels: {
                address: {
                    defaultValue: 'Address',
                },
                phone: {
                    defaultValue: 'Phone',
                },
            },
            viewMultiple: {
                address: 1,
                phone: 1,
                email: 1,
                switch: 1
                // input: 1,
                // select: 1,
                // name: 1
            },
            viewOptions: {
                select: {
                    enum: false,
                    defaultValue: 1,
                    values: [
                        { value: 1, name: 'Option 1' },
                        { value: 2, name: 'Option 2' },
                        { value: 3, name: 'Option 3' },
                    ]
                },
                select_multi: {
                    enum: false,
                    defaultValue: [],
                    values: [
                        { value: 1, name: 'Option 1' },
                        { value: 2, name: 'Option 2' },
                        { value: 3, name: 'Option 3' },
                    ]
                },
                radio: {
                    enum: false,
                    defaultValue: 'yes',
                    values: [
                        { value: 'yes', name: 'Yes' },
                        { value: 'no', name: 'No' },
                    ]
                },
            },
            viewRequired: {
                address: {
                    label: 1,
                    zip: 1
                },
                input: {
                    value: 1
                },
                select: {
                    value: 1
                },
                select_multi: {
                    value: 1
                },
                multi_selection: {
                    value: 1
                },
                switch: {
                    value: 1
                },
                phone: {
                    label: 1,
                    number: 1
                },
                email: {
                    address: 1
                },
                name: {
                    first: 1,
                    last: 1
                }
            },
            viewIgnored: {
                address: {
                    street: 1,
                    u_s_state_id: 1
                },
            },
            viewTemplate: {
                selection: 1,
            },
            labelTypes: {
                defaultValue: 'provided',
                options: [{ value: 'provided', name: 'Provided' }, { value: 'custom', name: 'Custom' }],
            },
        };
    }
    /**
     * Register the field to make sure that any needed attributes are added
     * @param core
     * @param dom
     */
    register(core, dom, scheme) {
        return new Promise((resolve) => {
            if (IsObjectThrowError(core, ['entity'], `Invalid Core`) && IsObjectThrowError(core.entity, true, `Invalid Core`)) {
                this.asset.core = core;
                // console.log('field is ', core.entity);
                this.asset.core.entity.items.map((item) => {
                    FieldItemRules(item);
                });
                this._setFieldCustomSettings(core.entity);
                if (IsObject(core.entity.custom_setting, true)) {
                    if (!dom.ui.customSetting)
                        dom.ui.customSetting = {};
                    Object.keys(core.entity.custom_setting).map((settingName) => {
                        const setting = core.entity.custom_setting[settingName];
                        const component = this.getCustomSettingComponent(core, core.entity, setting, scheme);
                        dom.ui.customSetting[setting.name] = component;
                    });
                }
                this.asset.core.entity.trait = this.getFieldTraits(this.asset.core.entity.fieldgroup.name);
                this._setFieldEntryValues(core, scheme).then(() => {
                    return resolve(true);
                });
            }
        });
    }
    // /**
    //  * When we pull field up in the editor to make changes, clear out the cache of that field so when the field is viewed it will pull in any changes
    //  * @param internal_name
    //  * @param fieldId
    //  */
    // clearCustomFieldCache( internal_name: string, fieldId: number ){
    //   this.srv.field.clearCustomFieldCache( fieldId );
    // }
    /**
     * Get a set of mock data for a given field
     * @param internal_name
     */
    getDefaultValues(internal_name) {
        let defaultValues = {};
        switch (internal_name) {
            case 'address':
                defaultValues = this.getAddressValues();
                break;
            case 'phone':
                defaultValues = this.getPhoneValues();
                break;
            case 'name':
                defaultValues = this.getNameValues();
                break;
            default:
                defaultValues = { value: null };
                break;
        }
        return defaultValues;
    }
    isSchemePrimaryField(scheme, field) {
        if (IsObject(scheme, ['id', 'mapping']) && IsObject(field, ['id', 'fieldgroup'])) {
            const primary = this.getSchemePrimary(scheme);
            const groupName = field.fieldgroup.name;
            if (groupName in primary && +primary[groupName] === +field.id) {
            }
        }
        return false;
    }
    isSchemeFieldItemDisabled(scheme, fieldId, itemId) {
        if (IsObject(scheme, ['id', 'mapping']) && +fieldId && +itemId) {
            const setting = this.getSchemeFieldItemMapping(scheme, fieldId, itemId);
            if (IsDefined(setting.active, false)) {
                return +setting.active === 1 ? false : true;
            }
        }
        return false;
    }
    isSchemeFieldEntryDisabled(scheme, fieldId, entryId) {
        if (IsObject(scheme, ['id', 'mapping']) && +fieldId && +entryId) {
            const setting = this.getSchemeFieldSetting(scheme, fieldId);
            return IsArray(setting.disabled_entries, true) && setting.disabled_entries.includes(entryId);
        }
        return false;
    }
    getSchemeFieldSetting(scheme, fieldId) {
        if (IsObject(scheme, true) && +fieldId) {
            this.ensureSchemeFieldMapping(scheme, fieldId);
            let storage = this.getSchemeFieldMapping(scheme);
            if (IsObject(storage, true)) {
                storage = StorageSetter(storage, [`field_${fieldId}`]);
                return storage;
            }
        }
        return null;
    }
    getSchemeFieldSection(scheme, fieldId, sectionName) {
        if (IsObject(scheme, true) && +fieldId) {
            const storage = this.getSchemeFieldSetting(scheme, fieldId);
            if (IsObject(storage)) {
                return StorageSetter(storage, [sectionName]);
            }
        }
        return null;
    }
    ensureSchemeFieldMapping(scheme, fieldId) {
        if (!(IsObject(scheme.mapping))) {
            scheme.mapping = {};
        }
        if (!(IsObject(scheme.mapping.field))) {
            scheme.mapping.field = {};
        }
        if (!(IsObject(scheme.mapping.field[`field_${fieldId}`]))) {
            scheme.mapping.field[`field_${fieldId}`] = {};
        }
        if (!(IsObject(scheme.mapping.field[`field_${fieldId}`].trait_entry))) {
            scheme.mapping.field[`field_${fieldId}`].trait_entry = {};
        }
        if (!(IsArray(scheme.mapping.field[`field_${fieldId}`].disabled_entries))) {
            scheme.mapping.field[`field_${fieldId}`].disabled_entries = [];
        }
    }
    getSchemeFieldItemMapping(scheme, fieldId, itemId) {
        if (IsObject(scheme, true) && +fieldId && +itemId) {
            let storage = this.getSchemeFieldSetting(scheme, fieldId);
            if (IsObject(storage, true)) {
                if (!(IsObject(storage.item))) {
                    storage.item = {};
                }
                if (!(IsObject(storage.item[`item_${itemId}`]))) {
                    storage.item[`item_${itemId}`] = {};
                }
                storage = StorageSetter(storage, ['item', `item_${itemId}`]);
                return storage;
            }
        }
        return null;
    }
    getSchemeFieldItemSection(scheme, fieldId, itemId, sectionName) {
        if (IsObject(scheme, true) && +fieldId && +itemId && IsString(sectionName, true)) {
            const storage = this.getSchemeFieldItemMapping(scheme, fieldId, itemId);
            if (storage && IsString(sectionName, true)) {
                return StorageSetter(storage, [sectionName]);
            }
        }
        return null;
    }
    getFieldTraits(fieldGroupName) {
        const traits = [];
        let setting = {};
        switch (String(fieldGroupName).toLowerCase()) {
            case 'address':
                setting = AddressFieldSetting;
                break;
            case 'email':
                setting = EmailFieldSetting;
                break;
            case 'name':
                setting = NameFieldSetting;
                break;
            case 'phone':
                setting = PhoneFieldSetting;
                break;
            case 'select-multi':
                setting = SelectMultiFieldSetting;
                break;
            case 'radio':
                break;
        }
        if (IsObject(setting, true)) {
            Object.keys(setting).map((settingName) => {
                const tmp = setting[settingName];
                if (IsObject(tmp, ['type'])) {
                    if (tmp.type === 'trait') {
                        traits.push(tmp);
                    }
                }
            });
        }
        return traits;
    }
    getSchemePrimary(scheme) {
        return StorageSetter(scheme, ['mapping', 'primary']);
    }
    getSchemeRequired(scheme) {
        return StorageSetter(scheme, ['mapping', 'required']);
    }
    getSchemeFieldMapping(scheme) {
        return StorageSetter(scheme, ['mapping', 'field']);
    }
    updateSchemeFieldMapping(scheme) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(scheme, ['id'])) {
                const res = yield this._updateSchemeFieldMapping(scheme, 'field');
                return resolve(res);
            }
        }));
    }
    updateSchemePrimaryMapping(scheme) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(scheme, ['id'])) {
                const res = yield this._updateSchemeFieldMapping(scheme, 'primary');
                return resolve(res);
            }
        }));
    }
    updateSchemeRequiredMapping(scheme) {
        if (IsObject(scheme, ['id'])) {
            this._updateSchemeFieldMapping(scheme, 'required');
        }
    }
    /**
     * When a entry is added , we need to set a default type
     */
    getDefaultLabelTypeOptions() {
        return JSON.parse(JSON.stringify(this.asset.labelTypes));
    }
    /**
     * Check what param options apply to a specific field
     * @param key
     */
    getViewParams(key = null) {
        if (key && key in this.asset.viewParams) {
            return JSON.parse(JSON.stringify(this.asset.viewParams[key]));
        }
        return JSON.parse(JSON.stringify(this.asset.viewParams));
    }
    /**
     * Check what param options apply to a specific field
     * @param key
     */
    getViewMultiple(key = null) {
        if (key) {
            if (key in this.asset.viewMultiple) {
                return this.asset.viewMultiple[key];
            }
            else {
                return null;
            }
        }
        return JSON.parse(JSON.stringify(this.asset.viewMultiple));
    }
    /**
     * Check what fields items are required under a fieldgroup type
     * @param fieldGroupName
     * @param fieldItemName
     */
    getViewRequired(fieldGroupName, fieldItemName) {
        return fieldGroupName in this.asset.viewRequired && fieldItemName in this.asset.viewRequired[fieldGroupName];
    }
    /**
     * Check what fields items are ingnored under a fieldgroup type
     * @param fieldGroupName
     * @param fieldItemName
     */
    getViewIgnored(fieldGroupName, fieldItemName, scheme) {
        if (fieldGroupName in this.asset.viewIgnored && fieldItemName in this.asset.viewIgnored[fieldGroupName]) {
            return true;
        }
        return false;
    }
    /**
     * Get a set of default options to for a specific view , ie.. a radio, select need options
     * @param key
     */
    getViewOptions(key = null) {
        if (key && key in this.asset.viewOptions) {
            return JSON.parse(JSON.stringify(this.asset.viewOptions[key]));
        }
        return JSON.parse(JSON.stringify(this.asset.viewOptions));
    }
    /**
     * Address Data Factory
     */
    getAddressValues() {
        const random = Math.floor(Math.random() * 50);
        return {
            // business: company.companyName(),
            line_1: this.asset.data[random].line_1,
            line_2: this.asset.data[random].line_2,
            line_3: 'Attn: ' + this.asset.data[random].line_3,
            city: this.asset.data[random].city,
            region_id: this.asset.data[random].region_id,
            county: 'Ohio',
            country_id: 1,
            zip: String(this.asset.data[random].zip).slice(0, 5),
            zip_4: '0000',
        };
    }
    /**
     * Name Data Factory
     */
    getNameValues() {
        const random = Math.floor(Math.random() * 50);
        return {
            prefix: this.asset.data[random].prefix,
            first: this.asset.data[random].first,
            middle: this.asset.data[random].middle,
            last: this.asset.data[random].last,
            suffix: this.asset.data[random].suffix,
        };
    }
    /**
     * Phone Data Factory
     */
    getPhoneValues() {
        const random = Math.floor(Math.random() * 50);
        return {
            title: undefined,
            country_id: 1,
            number: this.asset.data[random].number,
            extension: '123456',
            voice_button: null,
            sms_button: null,
            can_call: 1,
            can_text: 1,
        };
    }
    /**
     * This was built for rendering a dynamic list of custom settings, Probably not the right approach since settings so far have been sporadically placed so far
     * @param core
     * @param field
     * @param setting
     */
    getCustomSettingComponent(core, field, setting, scheme) {
        let component;
        const hasAccess = core.access.can_update && !core.entity.system ? true : false;
        switch (String(setting.type).toLowerCase()) {
            case 'boolean':
                component = {
                    type: PopSwitchComponent,
                    inputs: {
                        core: core,
                        config: new SwitchConfig({
                            name: setting.name,
                            label: setting.label ? setting.label : TitleCase(SnakeToPascal(setting.name)),
                            helpText: setting.helpText ? setting.helpText : null,
                            value: typeof setting.value !== 'undefined' ? setting.value : setting.defaultValue,
                            facade: true,
                            disabled: !hasAccess,
                            metadata: {
                                setting: setting
                            },
                            patch: {
                                field: ``,
                                path: ``,
                                callback: (ignore, event) => {
                                    if (IsValidFieldPatchEvent(core, event)) {
                                        if (IsObject(scheme, true)) {
                                            const session = this.getSchemeFieldSection(scheme, +field.id, 'setting');
                                            if (IsObject(session)) {
                                                session[setting.name] = event.config.control.value;
                                                this._updateSchemeFieldMapping(scheme, 'field');
                                            }
                                        }
                                        else {
                                            this.storeCustomSetting(core, event).then(() => {
                                                PopLog.event(this.name, `Custom Setting Saved:`, event);
                                            });
                                        }
                                    }
                                }
                            }
                        }),
                        hidden: 0,
                        when: setting.when ? setting.when : null,
                    },
                    position: field.position,
                    ancillary: true,
                    sort: field.sort,
                };
                break;
            case 'transformation':
                component = {
                    type: PopSelectComponent,
                    inputs: {
                        core: core,
                        config: new SelectConfig({
                            name: setting.name,
                            label: setting.label ? setting.label : TitleCase(SnakeToPascal(setting.name)),
                            helpText: setting.helpText ? setting.helpText : null,
                            value: setting.value ? setting.value : setting.defaultValue,
                            disabled: !hasAccess,
                            facade: true,
                            options: {
                                values: ConvertArrayToOptionList(setting.options.values, {
                                    empty: setting.options.empty,
                                    sort: true,
                                })
                            },
                            metadata: {
                                setting: setting
                            },
                            patch: {
                                duration: 500,
                                field: ``,
                                path: ``,
                                callback: (core2, event) => {
                                    if (IsValidFieldPatchEvent(core, event)) {
                                        if (IsObject(scheme, true)) {
                                            const session = this.getSchemeFieldSection(scheme, +field.id, 'setting');
                                            if (IsObject(session)) {
                                                session[setting.name] = event.config.control.value;
                                                this._updateSchemeFieldMapping(scheme, 'field');
                                            }
                                        }
                                        else {
                                            this.storeCustomSetting(core, event).then(() => {
                                                PopLog.event(this.name, `Custom Setting Saved:`, event);
                                            });
                                        }
                                    }
                                }
                            }
                        }),
                        hidden: 0,
                        when: setting.when ? setting.when : null,
                    },
                    position: field.position,
                    ancillary: true,
                    sort: field.sort,
                };
                break;
            case 'trait':
                break;
            case 'fixed':
                break;
            default:
                component = {
                    type: PopSwitchComponent,
                    inputs: {
                        core: core,
                        config: new SwitchConfig({
                            name: setting.name,
                            label: setting.label ? setting.label : TitleCase(SnakeToPascal(setting.name)),
                            helpText: setting.helpText ? setting.helpText : null,
                            value: typeof setting.value !== 'undefined' ? setting.value : setting.defaultValue,
                            facade: true,
                            metadata: {
                                setting: setting
                            },
                        }),
                        hidden: 0,
                        when: setting.when ? setting.when : null,
                    },
                    position: field.position,
                    ancillary: true,
                    sort: field.sort,
                };
        }
        return component;
    }
    /**
     * Store a custom setting
     * Determine whether the setting already exists in the database, post or patch accordingly
     * @param core
     * @param event
     */
    storeCustomSetting(core, event) {
        return new Promise((resolve) => {
            // PopTemplate.buffer();
            PopLog.event(this.name, `storeCustomSetting`, event);
            const setting = event.config.metadata.setting;
            const body = {
                value: event.config.control.value
            };
            if (+setting.field_id)
                body.field_id = +setting.field_id;
            if (+setting.field_item_id)
                body.field_item_id = +setting.field_item_id;
            const fieldId = +setting.field_id ? +setting.field_id : core.entity.id;
            let request = undefined;
            if (setting.id) {
                request = PopRequest.doPatch(`apps/fields/${fieldId}/configs/${setting.id}`, body, 1, false);
            }
            else {
                body.name = setting.name;
                body.type = setting.type;
                request = PopRequest.doPost(`apps/fields/${fieldId}/configs`, body, 1, false);
            }
            request.subscribe((res) => {
                if (res.data)
                    res = res.data;
                if (IsObject(res, ['id'])) {
                    event.config.metadata.setting = Object.assign(Object.assign({}, event.config.metadata.setting), CleanObject(res));
                    if (setting.item) {
                        // ToDo:: Store a seting on to a field item
                        // console.log('save on item', core.entity);
                        // console.log('setting', res);
                    }
                    else {
                        core.entity.custom_setting[setting.name].value = body.value;
                        core.entity.setting[setting.name] = body.value;
                        const nameLookup = ArrayMapSetter(core.entity.configs.field_configs, 'name');
                        if (setting.name in nameLookup) {
                            core.entity.configs.field_configs[nameLookup[setting.name]] = Object.assign({}, event.config.metadata.setting);
                        }
                        else {
                            core.entity.configs.field_configs.push(event.config.metadata.setting);
                        }
                    }
                    this.triggerFieldPreviewUpdate();
                    return resolve(true);
                }
            }, (err) => {
                return resolve(GetHttpErrorMsg(err));
            });
            return resolve(true);
        });
    }
    /**
     * Store a custom setting
     * Determine whether the setting already exists in the database, post or patch accordingly
     * @param core
     * @param event
     */
    storeFieldItemRule(core, fieldItem, event) {
        return new Promise((resolve) => {
            let request = undefined;
            const rule = event.config.metadata.rule;
            const fieldItemId = fieldItem.id;
            const value = event.config.control.value;
            const body = {
                value: value,
            };
            if (IsObject(rule.validationMap, true)) {
                rule.validation = rule.validationMap[String(value)];
            }
            if (rule.validation) {
                body.field_validation_id = rule.validation.id;
                if (rule.validation.fixed) {
                    rule.value = rule.validation.value;
                }
            }
            else {
                rule.value = value;
                // pass
            }
            if (rule.field_id) { // patch
                request = PopRequest.doPatch(`fields/${fieldItemId}/rules/${rule.id}`, body, 1, false);
            }
            else {
                body.field_item_id = null;
                body.name = rule.name;
                request = PopRequest.doPost(`fields/${fieldItemId}/rules`, body, 1, false);
            }
            request.subscribe((res) => {
                res = GetHttpObjectResult(res);
                if (IsObject(res, ['value'])) {
                    // event.config.metadata.rule = res;
                    fieldItem.rule[rule.name] = value;
                    this.triggerFieldPreviewUpdate();
                    return resolve(true);
                }
                return resolve(true);
            }, (err) => {
                return resolve(GetHttpErrorMsg(err));
            });
        });
    }
    /**
     * Trigger the field prview component to update
     */
    triggerFieldPreviewUpdate() {
        if (IsObject(this.asset.core, ['channel'])) {
            this.dom.setTimeout('trigger-preview', () => {
                this.asset.core.channel.next({
                    source: this.name,
                    target: 'PopEntityFieldPreviewComponent',
                    type: 'component',
                    name: 'update'
                });
            }, 0);
        }
    }
    /**
     * Cleanup timeouts, intervals, subscriptions, etc
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    // private _updateSchemeFieldMapping( scheme: EntitySchemeSectionInterface, key: string ){
    //   if( IsObject( scheme, [ 'id', 'mapping' ] ) && IsString( key, true ) && key in scheme.mapping ){
    //     this.dom.setTimeout( `update-scheme-field-${key}`, () => {
    //       const body = { mapping: {} };
    //       // body.mapping[ key ] = scheme.mapping[ key ];
    //       body.mapping = scheme.mapping;
    //       this.dom.setSubscriber( `update-scheme-field-${key}`, PopRequest.doPatch( `profile-schemes/${scheme.id}`, body, 1, false ).subscribe( ( res ) => {
    //         res = GetHttpResult( res );
    //         console.log( '_updateSchemeFieldMapping', res );
    //       }, ( err ) => {
    //         PopLog.error( this.name, `_setFieldEntryValues`, GetHttpErrorMsg( err ) );
    //       } ) );
    //     }, 0 );
    //   }
    // }
    _updateSchemeFieldMapping(scheme, key) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(scheme, ['id', 'mapping']) && IsString(key, true) && key in scheme.mapping) {
                this.dom.setTimeout(`update-scheme-field-${key}`, () => {
                    const body = { mapping: {} };
                    // body.mapping[ key ] = scheme.mapping[ key ];
                    body.mapping = scheme.mapping;
                    this.dom.setSubscriber(`update-scheme-field-${key}`, PopRequest.doPatch(`profile-schemes/${scheme.id}`, body, 1, false).subscribe((res) => {
                        res = GetHttpResult(res);
                        //             console.log( '_updateSchemeFieldMapping', res );
                        return resolve(true);
                    }, (err) => {
                        PopLog.error(this.name, `_setFieldEntryValues`, GetHttpErrorMsg(err));
                        return resolve(false);
                    }));
                }, 0);
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * Assign the custom setting values and config that exist for this field
     * @param field
     * @param stored
     */
    _setFieldCustomSettings(field, scheme) {
        if (IsObject(field, ['fieldgroup', 'configs'])) {
            const stored = field.configs;
            const fieldSettings = GetCustomFieldSettings(field);
            const customSettings = JSON.parse(JSON.stringify(Object.assign(Object.assign({}, EntityFieldSetting), fieldSettings)));
            // console.log( 'customSettings', customSettings );
            // console.log('stored', stored);
            if (IsObject(customSettings, true)) {
                const itemIdLookup = ArrayMapSetter(field.items, 'id');
                const itemNameLookup = ArrayMapSetter(field.items, 'name');
                // console.log('itemNameLookup', itemNameLookup);
                Object.keys(customSettings).map((settingName) => {
                    const setting = customSettings[settingName];
                    if (IsObject(setting, true)) {
                        if (setting.item) {
                            if (setting.item in itemNameLookup) {
                                // console.log('setting', setting);
                                const item = field.items[itemNameLookup[setting.item]];
                                if (!item.custom_setting)
                                    item.custom_setting = {};
                                if (!item.setting)
                                    item.setting = {};
                                setting.field_item_id = item.field_item_id;
                                setting.field_id = item.id;
                                // console.log('item', item);
                                const value = setting.value ? setting.value : setting.defaultValue;
                                item.custom_setting[settingName] = setting;
                                item.setting[settingName] = value;
                            }
                        }
                        else {
                            if (!field.custom_setting)
                                field.custom_setting = {};
                            if (!field.setting)
                                field.setting = {};
                            if (!field.trait)
                                field.trait = {};
                            let value;
                            if (IsObject(scheme, true)) {
                                const storage = this.getSchemeFieldSection(scheme, +field.id, 'setting');
                                if (IsObject(storage, true) && setting.name in storage) {
                                    value = storage[setting.name];
                                }
                                else {
                                    value = setting.value ? setting.value : setting.defaultValue;
                                }
                            }
                            else {
                                value = setting.value ? setting.value : setting.defaultValue;
                            }
                            if (setting.type === 'trait') {
                                field.trait[settingName] = value;
                            }
                            else {
                                field.custom_setting[settingName] = setting;
                                field.setting[settingName] = value;
                            }
                        }
                    }
                });
                if (IsArray(stored.field_configs, true)) {
                    stored.field_configs.map((setting) => {
                        if (!field.custom_setting[setting.name]) {
                            // ToDo:: Do We want to allow the database to pass in configs that are not local
                            // field.custom_setting[ setting.name ] = setting;
                        }
                        else {
                            field.custom_setting[setting.name].id = setting.id;
                            field.custom_setting[setting.name].value = setting.value;
                        }
                        field.setting[setting.name] = setting.value;
                    });
                }
                if (IsObject(stored.item_configs, true)) {
                    Object.keys(stored.item_configs).map((fieldItemId) => {
                        const fieldItemConfigs = stored.item_configs[fieldItemId];
                        if (IsArray(fieldItemConfigs, true)) {
                            fieldItemConfigs.map((setting) => {
                                if (setting.field_id in itemIdLookup) {
                                    const item = field.items[itemIdLookup[setting.field_id]];
                                    if (!item.custom_setting)
                                        item.custom_setting = {};
                                    if (!item.custom_setting[setting.name]) {
                                        item.custom_setting[setting.name] = setting;
                                    }
                                    else {
                                        item.custom_setting[setting.name].id = setting.id;
                                        item.custom_setting[setting.name].value = setting.value;
                                    }
                                    if (!item.setting)
                                        item.setting = {};
                                    item.setting[setting.name] = setting.value;
                                }
                            });
                        }
                    });
                }
            }
            // console.log('stored custom setings', field, stored);
            // delete field.configs;
        }
    }
    /**
     * Ensure that at least 1 label exists
     * @param field
     */
    _setFieldEntryValues(core, scheme) {
        return new Promise((resolve) => {
            const field = core.entity;
            if (IsArray(field.entries, true)) {
                field.entries.sort(DynamicSort('sort_order'));
            }
            if (!(IsArray(field.entries, true))) {
                const entry = {
                    name: TitleCase(`${(field.name ? field.name : field.fieldgroup.name)}`),
                    type: 'provided',
                    sort_order: 0,
                };
                PopRequest.doPost(`fields/${field.id}/entries`, entry, 1, false).subscribe((res) => {
                    res = res.data ? res.data : res;
                    field.entries = [res];
                    return resolve(true);
                }, (err) => {
                    PopLog.error(this.name, `_setFieldEntryValues`, GetHttpErrorMsg(err));
                    return resolve(false);
                });
            }
            else {
                return resolve(true);
            }
        });
    }
}
PopFieldEditorService.prov = i0.defineInjectable({ factory: function PopFieldEditorService_Factory() { return new PopFieldEditorService(); }, token: PopFieldEditorService, providedIn: "root" });
PopFieldEditorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopFieldEditorService.ctorParameters = () => [];

class PopEntityUtilFieldService {
    constructor(field) {
        this.field = field;
        this.name = 'PopEntityUtilFieldService';
        this.cache = new PopCacheService();
    }
    /**
     * Build out the necessary configs for a custom field group and all of this field items involved
     * Fields may have multiple values , so a unique set of configs mut be created for each data entry
     * @param core
     * @param field
     */
    buildCustomField(core, field) {
        let items;
        if (!field.metadata)
            field.metadata = {};
        if (!field.multiple_min)
            field.multiple_min = 1;
        if (!field.multiple_max || field.multiple_max > 10)
            field.multiple_max = 10;
        if (!field.multiple_max_limit)
            field.multiple_max_limit = 10;
        const scheme = StorageGetter(core, ['entity', 'scheme']);
        const useScheme = IsObject(scheme, ['id', 'mapping']) ? true : false;
        field.primary = useScheme ? this.field.isSchemePrimaryField(scheme, field) : false;
        const fieldCustomSettings = GetCustomFieldSettings(field);
        const itemCustomModels = {};
        if (IsObject(fieldCustomSettings, true)) {
            Object.keys(fieldCustomSettings).map((key) => {
                const setting = fieldCustomSettings[key];
                if (IsObject(setting, ['item', 'model']) && setting.item && setting.type === 'model') {
                    if (!itemCustomModels[setting.item])
                        itemCustomModels[setting.item] = {};
                    itemCustomModels[setting.item][setting.model] = setting.value;
                }
            });
        }
        // console.log( itemCustomModels, 'itemCustomModels' );
        field.children = {};
        // make a copy of the field items to use as a pattern
        let fieldItemSet = JsonCopy(field.items);
        fieldItemSet = fieldItemSet.filter((fieldItem) => {
            return +fieldItem.active;
        }).filter((fieldItem) => {
            return useScheme ? !(this.field.isSchemeFieldItemDisabled(scheme, +field.id, +fieldItem.id)) : true;
        }).map((fieldItem) => {
            const itemCustomModel = IsObject(itemCustomModels[fieldItem.name]) ? itemCustomModels[fieldItem.name] : {};
            fieldItem = JsonCopy(Object.assign(Object.assign({}, fieldItem), itemCustomModel));
            fieldItem = CleanObject(fieldItem, {
                blacklist: ['children', 'entries', 'items', 'storage', 'webhook', 'object_name', 'depth_level']
            });
            // fieldItem.model.value = item.model.options.defaultValue || null;
            // ToDo:: Inject scheme rule values
            this.setFieldItemRules(+field.id, fieldItem, scheme);
            // console.log('fieldItem', fieldItem);
            const model = FieldItemModel(core, fieldItem);
            if (IsArray(fieldItem.source, true) && !IsArray(model.options.values, true)) {
                model.options.rawValues = fieldItem.source;
                model.options.values = fieldItem.source;
            }
            // if (IsArray(fieldItem.source)) {
            //   console.log('fielditem source', fieldItem);
            //   console.log('options', model.options);
            // }
            const view = FieldItemView(fieldItem.view);
            const item = CleanObject({
                id: fieldItem.id,
                custom_setting: {},
                model: model,
                table: fieldItem.table ? fieldItem.table : { sort: 99, visible: false },
                view: view,
                component: view.name,
                setting: this._getFieldItemSetting(fieldItem),
                rules: fieldItem.rules,
                rule: fieldItem.rule,
                source: IsArray(fieldItem.source, true) ? fieldItem.source : null,
                sourceMap: IsArray(fieldItem.source, true) ? ArrayMapSetter(fieldItem.source, 'id') : null
            });
            field.children[fieldItem.name] = item;
            return item;
        });
        const dataSort = {};
        if (IsArray(field.entries, true)) {
            field.entries.sort(DynamicSort('sort_order'));
            field.entries.map((entry, index) => {
                dataSort[entry.id] = index;
            });
        }
        field.items = {};
        items = {};
        field.data = IsObject(field.data, true) ? field.data : {};
        if (useScheme) {
            Object.keys(field.data).map((dataKey) => {
                if (this.field.isSchemeFieldEntryDisabled(scheme, +field.id, +dataKey)) {
                    delete field.data[dataKey];
                }
            });
        }
        // get id of keys from field entries
        // console.log(field.entries);
        if (field.multiple) {
            const dataKeys = field.entries.map(i => i.id);
            field.data_keys = dataKeys.sort(function (a, b) {
                const varA = +dataSort[a];
                const varB = +dataSort[b];
                if (varA > varB) {
                    return 1;
                }
                else if (varA < varB) {
                    return -1;
                }
                return 0;
            });
        }
        else {
            field.data_keys = IsArray(field.entries, true) ? [field.entries[0].id] : [];
        }
        const entryLookup = ArrayMapSetter(field.entries, 'id');
        field.data_keys.map((dataKey, index) => {
            items[dataKey] = {
                entry: dataKey in entryLookup ? field.entries[entryLookup[dataKey]] : this._getFieldItemEntry(field, dataKey, index),
                config: {}
            };
            fieldItemSet.map((fieldItem) => {
                // ToDo:: Determine whether patch should always be created; A.C.
                if (IsObject(fieldItem.model, ['name'])) {
                    fieldItem.model.value = this._getModelValue(core, field, fieldItem.model, dataKey);
                    fieldItem.model.facade = 1;
                    const config = FieldItemModelConfig(core, fieldItem.model);
                    items[dataKey].config[fieldItem.model.name] = config;
                }
                else {
                    // console.log('fail', fieldItem);
                }
            });
        });
        const coreField = {
            id: +field.id,
            ancillary: field.ancillary ? 1 : 0,
            canAdd: field.canAdd,
            canRemove: field.canRemove,
            configs: field.configs || {},
            custom_setting: field.custom_setting || {},
            metadata: field.metadata,
            multiple: !!field.multiple,
            multiple_min: field.multiple_min,
            multiple_max: field.multiple_max,
            multiple_max_limit: field.multiple_max_limit ? field.multiple_max_limit : 10,
            data: field.data,
            data_keys: field.data_keys,
            facade: !!field.facade,
            fieldgroup: field.fieldgroup,
            entries: IsArray(field.entries) ? field.entries : [],
            hidden: field.hidden ? true : false,
            internal_name: field.fieldgroup.name,
            name: String(SpaceToSnake(field.name)).toLowerCase(),
            label: field.label,
            position: field.position,
            setting: field.setting || {},
            show_name: !!field.show_name,
            sort: field.sort,
            state: field.state ? field.state : 'template_edit',
            when: field.when ? field.when : null,
            children: field.children,
            items: items,
        };
        const formName = field.fieldgroup.name === 'selection' ? field.children.value.view.name : field.fieldgroup.name ? field.fieldgroup.name : 'select';
        coreField.component = this._getEntityFieldComponent(formName);
        return new FieldConfig(coreField);
    }
    _setSchemeFieldSettings(scheme, field) {
        if (IsObject(scheme, ['id', 'mapping']) && IsObject(field, true)) {
            // console.log( '_setSchemeFieldSettings', scheme, field );
        }
        return field;
    }
    /**
     * Build out a config for a field item
     * @param core
     * @param model
     */
    buildCoreFieldItem(core, model) {
        return {
            model: model,
            component: this._getFormComponent(model.form),
            config: FieldItemModelConfig(core, model)
        };
    }
    /**
     * Get the rules that should be applied on this field
     * @param fieldItem
     * @private
     */
    setFieldItemRules(fieldId, fieldItem, scheme) {
        const RuleSet = {};
        fieldItem.rule = {};
        const itemRules = IsArray(fieldItem.itemrules, true) ? fieldItem.itemrules : []; // default rules inherited from the field_item_id
        // const mapping = this.field.getSchemeFieldItemMapping(scheme, fieldId, +fieldItem.id);
        // console.log('mapping', mapping);
        const fieldRules = IsArray(fieldItem.fieldrules, true) ? fieldItem.fieldrules : []; // rules specific to this field item
        const schemeRules = IsObject(scheme, ['id', 'mapping']) ? this.field.getSchemeFieldItemSection(scheme, fieldId, +fieldItem.id, 'rule') : {};
        // we want field rules to override items rules when there is overlap ie.. the item might come with a default rule but the items rules should override it
        itemRules.map((rule) => {
            if (IsArray(rule.validations, true)) {
                if (!(IsObject(rule.options)))
                    rule.options = {};
                rule.options.values = ConvertArrayToOptionList(rule.validations, {
                    nameKey: 'label',
                });
                rule.validationMap = ArrayKeyBy(rule.validations, 'id');
                rule.value = +rule.validation.id;
            }
            else {
                rule.value = rule.raw_value;
            }
            if (!rule.value && rule.default_value)
                rule.value = rule.default_value;
            RuleSet[rule.name] = rule;
        });
        fieldRules.map((rule) => {
            if (IsObject(RuleSet[rule.name])) {
                RuleSet[rule.name].id = rule.id;
                RuleSet[rule.name].value = IsArray(RuleSet[rule.name].validations, true) ? rule.validation.id : rule.raw_value;
                RuleSet[rule.name].field_id = rule.field_id;
            }
        });
        fieldItem.rules = Object.values(RuleSet);
        fieldItem.rules.map((rule) => {
            if (!rule.validation.fixed) {
                fieldItem.rule[rule.name] = ParseModelValue(rule.value);
                if (IsObject(schemeRules, [rule.name])) {
                    fieldItem.rule[rule.name] = schemeRules[rule.name];
                }
            }
        });
        // delete fieldItem.fieldrules;
        // delete fieldItem.itemrules;
    }
    /**
     * A method that builds entity fieldset from the server models
     * @param entityConfig
     * @param fieldPosition
     */
    buildDomFields(core, dom) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let coreField, component;
            // dom.ui.fields.clear();
            const baseFields = core.repo.model.field;
            const baseList = Object.values(baseFields).sort(DynamicSort('sort'));
            const customFields = yield this._getEntityCustomFields(core);
            PopLog.info(this.name, `buildDomFields`, {
                base: baseFields,
                custom: customFields
            });
            const customList = Object.values(customFields).sort((function (a, b) {
                if (a.fieldgroup.id === b.fieldgroup.id) {
                    return b.label < a.label ? 1 : -1;
                }
                return a.fieldgroup.id > b.fieldgroup.id ? 1 : -1;
            }));
            // Place base field inf front of base fields, and then put custom fields (sorted by type,name)
            const allFields = [...baseList, ...customList].map((field, index) => {
                field.sort = index;
                // return JSON.parse( JSON.stringify( field ) );
                return DeepCopy(field);
            });
            if (IsArray(allFields, true)) {
                allFields.map((field) => {
                    const name = field.model ? field.model.name : field.name;
                    // console.log(name, field.onLoad);
                    if (+core.entity.scheme_id && !(IsObject(core.entity.scheme_assets)))
                        core.entity.scheme_assets = {};
                    const customFieldAssetLocation = +core.entity.scheme_id && IsObject(core.entity.scheme_assets, false) ? core.entity.scheme_assets : core.entity;
                    if (IsObject(field, true) && name) {
                        if (field.when) {
                            if (IsString(field.when))
                                field.when = [field.when];
                            field.hidden = !EvaluateWhenConditions(core, field.when, core);
                        }
                        if (IsObject(field, ['fieldgroup']) && name in customFieldAssetLocation) {
                            coreField = this.buildCustomField(core, field);
                            if (coreField) {
                                component = {
                                    type: PopEntityFieldComponent,
                                    inputs: CleanObject({
                                        core: core,
                                        field: new FieldConfig(coreField),
                                        hidden: field.hidden ? 1 : 0,
                                        when: field.when,
                                        onLoad: field.onLoad,
                                        onEvent: field.onEvent,
                                        onUnload: field.onUnload,
                                    }),
                                    custom: true,
                                    position: field.position ? field.position : 1,
                                    ancillary: field.ancillary,
                                    sort: field.sort,
                                };
                                dom.ui.fields.set(+field.id, component);
                            }
                            // }else if( IsObject( field, [ 'model' ] ) && name in core.entity ){
                        }
                        else if (IsObject(field, ['model']) && ((name in core.entity) || field.preserve)) {
                            field.model.view = { name: field.model.form };
                            if (field.model.transformation)
                                field.model.value = this._getModelValue(core, field, field.model);
                            const model = FieldItemModel(core, field.model);
                            const coreItem = {
                                model: model,
                                table: IsObject(field.table, true) ? field.table : { sort: 99, visible: false },
                                component: this._getFormComponent(field.model.view.name),
                                config: FieldItemModelConfig(core, model)
                            };
                            if (coreItem && coreItem.config) {
                                if (typeof coreItem.config.setControl === 'function')
                                    coreItem.config.setControl(); // build the control now so that the control can be the defacto session value
                                component = {
                                    type: coreItem.component,
                                    inputs: CleanObject({
                                        core: core,
                                        config: coreItem.config,
                                        hidden: field.hidden ? 1 : 0,
                                        when: field.when,
                                        onLoad: field.onLoad,
                                        onEvent: field.onEvent,
                                        onUnload: field.onUnload,
                                    }),
                                    custom: false,
                                    position: field.position ? field.position : 1,
                                    ancillary: field.ancillary ? true : false,
                                    when: IsArray(field.when, true) ? field.when : null,
                                    sort: field.sort ? field.sort : 99,
                                };
                                dom.ui.fields.set(coreItem.model.name, component);
                            }
                        }
                    }
                });
            }
            return resolve(true);
        }));
    }
    /**
     * A method that builds entity fieldset from the server models
     * @param entityConfig
     * @param fieldPosition
     */
    getDomFields(fieldPosition = 1, dom) {
        const componentList = [];
        dom.ui.fields.forEach((component, key) => {
            if (!component.ancillary && component.position === fieldPosition) {
                componentList.push(component);
            }
        });
        return componentList;
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Loop through the data for the entity and identify what refers to custom fields
     * Retrieve the field data for each of the custom fields that exist
     * @param core
     * @private
     */
    _getEntityCustomFields(core) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const tmp = {};
            const customFields = {};
            if (core && core.params.can_extend) {
                if (IsObject(core.entity)) {
                    Object.keys(core.entity).map((key) => {
                        if (IsObject(core.entity[key], ['@metadata'])) {
                            tmp[key] = core.entity[key];
                        }
                        else if (IsArray(core.entity[key], true) && IsObject(core.entity[key][0], ['@metadata'])) {
                            tmp[key] = core.entity[key];
                        }
                    });
                }
                if (+core.entity.scheme_id && IsObject(core.entity.scheme_assets, true)) {
                    Object.keys(core.entity.scheme_assets).map((key) => {
                        if (IsObject(core.entity.scheme_assets[key], ['@metadata'])) {
                            tmp[key] = core.entity.scheme_assets[key];
                        }
                        else if (IsArray(core.entity.scheme_assets[key], true) && IsObject(core.entity.scheme_assets[key][0], ['@metadata'])) {
                            tmp[key] = core.entity.scheme_assets[key];
                        }
                    });
                }
                const requests = [];
                const names = [];
                let fieldId;
                const fieldRepo = yield PopEntity.getEntityRepo('field');
                Object.keys(tmp).map((name) => {
                    if (IsObject(tmp[name])) { // field only has a single value
                        if (IsObject(tmp[name]['@metadata'], ['@field_id'])) {
                            const record = tmp[name];
                            const metadata = record['@metadata'];
                            // delete record[ '@metadata' ];
                            fieldId = metadata['@field_id'];
                            tmp[name] = [record];
                        }
                    }
                    else if (IsArray(tmp[name], true)) { // field has multiple values
                        const data = [];
                        const firstRecord = tmp[name][0];
                        fieldId = firstRecord['@metadata']['@field_id'];
                        // tmp[ name ].map((record, index) => {
                        //   // const dataKey = field_entry_id ? field_entry_id : ( metadata2[ '@record_id' ] ? +metadata2[ '@record_id' ] : index );
                        //   delete record[ '@metadata' ];
                        //   data.push(record);
                        // });
                        //
                        // tmp[ name ] = data;
                    }
                    if (+fieldId) {
                        names.push(name);
                        requests.push(this.cache.get('custom_field', String(fieldId), fieldRepo.getEntity(fieldId)));
                    }
                });
                if (requests.length) {
                    forkJoin(requests).subscribe((results) => {
                        results.map((result, index) => __awaiter(this, void 0, void 0, function* () {
                            if (IsDefined(result, false)) {
                                result = GetHttpResult(result);
                                const fieldName = names[index];
                                result.name = fieldName;
                                result.data = fieldName in tmp ? tmp[fieldName] : {};
                                const customField = yield this._setFieldEntries(result);
                                const field = yield this._setEntityCustomFieldDataStructure(customField);
                                customFields[fieldName] = field;
                                if (index === (results.length - 1)) {
                                    return resolve(customFields);
                                }
                            }
                            else {
                                if (index === (results.length - 1)) {
                                    return resolve(customFields);
                                }
                            }
                        }));
                    }, (err) => {
                        return resolve(customFields);
                    });
                }
                else {
                    return resolve(customFields);
                }
            }
            else {
                return resolve(customFields);
            }
        }));
    }
    clearCustomFieldCache(fieldId) {
        this.cache.clear('custom_field', String(fieldId));
    }
    /**
     * Field Entries are a way to define the value structure of a field
     * By default a field will have a single value, but a field can be configured to have multiple values
     * Field entries provide a template of a specific amount of values a field should have
     * @param field
     * @private
     */
    _setFieldEntries(field) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // if( IsObject( field, [ 'data' ] ) && IsArray( field.data ) ){
            //   // console.log('field', field);
            //   let values = field.data.length;
            //   const entries = field.entries.filter( ( x ) => x.type !== 'custom' ).length;
            //   let entriesNeeded = 0;
            //   if( entries < values ){
            //     entriesNeeded = +values - +entries;
            //   }
            //
            //   const requests = [];
            //   let limit = 100;
            //   while( entriesNeeded > 0 && limit ){
            //     limit--;
            //     values++;
            //     requests.push( PopRequest.doPost( `fields/${field.id}/entries`, {
            //       name: TitleCase( `${field.fieldgroup.name} ${values}` ),
            //       type: 'provided'
            //     }, 1, false ) );
            //     entriesNeeded--;
            //   }
            //   if( requests.length ){
            //     forkJoin( requests ).subscribe( ( results ) => {
            //       results.map( ( result: any, index: number ) => {
            //         if( result.data ) result = result.data;
            //         field.entries.push( result );
            //       } );
            //       return resolve( field );
            //     }, () => {
            //       return resolve( field );
            //     } );
            //
            //   }else{
            //     return resolve( field );
            //   }
            // }else{
            //   return resolve( field );
            // }
            return resolve(field);
        }));
    }
    /**
     * Field data should come in as an array of records
     * Ensure that each each record has a unique entry id, and index data by field_entry_id;
     * @param customField
     */
    _setEntityCustomFieldDataStructure(customField) {
        return new Promise((resolve) => {
            const data = {};
            // console.log('customField', customField);
            if (IsArray(customField.data, true)) {
                if (IsArray(customField.entries, true)) {
                    customField.data.map((record, index) => {
                        if (!record.field_entry_id)
                            record.field_entry_id = customField.entries[index].id;
                        // console.log("is diff ? ", record.field_entry_id , ' - ', customField.entries[index].id);
                        // delete record[ '@metadata' ];
                        data[record.field_entry_id] = record;
                    });
                }
            }
            else {
                if (IsArray(customField.entries)) {
                    customField.entries.map((entry) => {
                        data[entry.id] = {};
                        const items = customField.items;
                        if (IsArray(customField.items, true)) {
                            items.map((item) => {
                                data[entry.id][item.name] = null;
                            });
                        }
                    });
                }
            }
            customField.data = data;
            return resolve(customField);
        });
    }
    /**
     * Get the settings that should be applied on this field item
     * @param fieldItem
     * @private
     */
    _getFieldItemSetting(fieldItem) {
        return {};
    }
    /**
     * A field entry is used to identity a specific value in a set of multiple values
     * @param field
     * @param dataKey
     * @param index
     * @private
     */
    _getFieldItemEntry(field, dataKey, index) {
        let entry = {};
        const data = field.data[dataKey];
        if (IsArray(field.entries, true)) {
            const customEntries = field.entries.filter((item) => {
                return item.type !== 'custom';
            });
            const customIdLookup = ArrayMapSetter(customEntries, 'id');
            const providedEntries = field.entries.filter((item) => {
                return item.type !== 'custom';
            });
            const entryIndex = index % providedEntries.length;
            const providedIdLookup = ArrayMapSetter(providedEntries, 'id');
            if (data.field_entry_id && data.field_entry_id in providedIdLookup) {
                entry = providedEntries[providedIdLookup[data.field_entry_id]];
            }
            else if (data.field_entry_id && data.field_entry_id in customIdLookup) {
                entry = customEntries[customIdLookup[data.field_entry_id]];
                // ToDo:: Find the cutstom label that should be inserted here
            }
            else if (entryIndex in field.entries) {
                entry = providedEntries[entryIndex];
            }
            else {
                entry = providedEntries[0];
            }
        }
        else {
            entry = null;
        }
        return entry;
    }
    /**
     * Map the form in a field model to the angular component that will be used to render the field
     * @param form
     * @private
     */
    _getFormComponent(form) {
        let component = null;
        if (IsString(form, true)) {
            switch (String(form).toLowerCase()) {
                case 'sidebyside':
                    component = PopSideBySideComponent;
                    break;
                case 'select':
                    component = PopSelectComponent;
                    break;
                case 'select-filter':
                    component = PopSelectFilterComponent;
                    break;
                case 'select-list':
                    component = PopSelectListComponent;
                    break;
                case 'select-multi':
                case 'select_multi':
                    component = PopSelectMultiComponent;
                    break;
                case 'select-modal':
                    component = PopSelectModalComponent;
                    break;
                case 'text':
                case 'input':
                    component = PopInputComponent;
                    break;
                case 'textstring':
                    component = PopTextComponent;
                    break;
                case 'number':
                    component = PopNumberComponent;
                    break;
                case 'date':
                    component = PopDateComponent;
                    break;
                case 'datepicker':
                    component = PopDatePickerComponent;
                    break;
                case 'time':
                    component = PopTimeComponent;
                    break;
                case 'checkbox':
                    component = PopCheckboxComponent;
                    break;
                case 'switch':
                    component = PopSwitchComponent;
                    break;
                case 'minmax':
                    component = PopMinMaxComponent;
                    break;
                case 'radio':
                    component = PopRadioComponent;
                    break;
                case 'textarea':
                    component = PopTextareaComponent;
                    break;
                case 'label':
                    component = PopLabelComponent;
                    break;
                case 'button':
                    component = PopButtonComponent;
                    break;
                default:
                    PopLog.warn(this.name, `_getFormComponent: fail`, form);
                    break;
            }
        }
        return component;
    }
    /**
     * Resolve the value that lines up with the column/name of the field item from the data set
     * The idea here is that a value may have already created for this field item and we need to make sure the field item initializes with the value
     * @param core
     * @param field
     * @param model
     * @param dataKey
     * @private
     */
    _getModelValue(core, field, model, dataKey) {
        let value = null;
        if (dataKey) {
            if (IsObject(field.data, true) && IsObject(model, true)) {
                if (dataKey in field.data && model.name in field.data[dataKey]) {
                    value = field.data[dataKey][model.name];
                    if (model.transformation)
                        value = PopPipe.transform(value, model.transformation, core);
                }
            }
        }
        else if (model.name in core.entity) {
            value = core.entity[model.name];
            if (model.transformation)
                value = PopPipe.transform(value, model.transformation, core);
        }
        return value;
    }
    /**
     * Get the custom field template that is made for the field group
     * @param name
     * @private
     */
    _getEntityFieldComponent(name) {
        let component = null;
        switch (String(name).toLowerCase()) {
            case 'name':
                component = PopEntityNameComponent;
                break;
            case 'email':
                component = PopEntityEmailComponent;
                break;
            case 'phone':
                component = PopEntityPhoneComponent;
                break;
            case 'address':
                component = PopEntityAddressComponent;
                break;
            case 'date':
            case 'datetime':
                component = PopEntityDatetimeComponent;
                break;
            case 'textfield':
            case 'input':
                component = PopEntityInputComponent;
                break;
            case 'selection':
            case 'select':
                component = PopEntitySelectComponent;
                break;
            case 'select-multi':
            case 'select_multi':
            case 'multi_selection':
                component = PopEntitySelectMultiComponent;
                break;
            case 'radio':
                component = PopEntityRadioComponent;
                break;
            case 'checkbox':
                component = PopEntityCheckboxComponent;
                break;
            case 'toggle':
            case 'switch':
                component = PopEntitySwitchComponent;
                break;
            case 'texteditor':
            case 'textarea':
                component = PopEntityTextareaComponent;
                break;
            default: {
                PopLog.warn(this.name, `_getEntityFieldComponent: fail`, name);
                break;
            }
        }
        return component;
    }
}
PopEntityUtilFieldService.prov = i0.defineInjectable({ factory: function PopEntityUtilFieldService_Factory() { return new PopEntityUtilFieldService(i0.inject(PopFieldEditorService)); }, token: PopEntityUtilFieldService, providedIn: "root" });
PopEntityUtilFieldService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntityUtilFieldService.ctorParameters = () => [
    { type: PopFieldEditorService }
];

class PopEntityRepoService {
    constructor(env) {
        this.env = env;
        this.name = 'PopEntityRepoService';
        this.activated = false;
        this.apiVersion = 1;
        if (!this.env)
            this.env = environment;
        this.setServiceContainer();
    }
    setServiceContainer() {
        this.srv = {
            base: ServiceInjector.get(PopBaseService),
            cache: new PopCacheService(),
            display: ServiceInjector.get(PopDisplayService),
            field: ServiceInjector.get(PopEntityUtilFieldService),
            log: ServiceInjector.get(PopLogService),
            request: ServiceInjector.get(PopRequestService),
            resource: ServiceInjector.get(PopResourceService),
            router: ServiceInjector.get(Router),
        };
    }
    /**
     * Pass in in the EntityParams to tie this to a specific type of entity
     * (Moved out of constructor die to build issues)
     * @param entityParams
     */
    register(entityParams) {
        if (entityParams && entityParams.internal_name) {
            this.id = entityParams.internal_name;
            this.params = entityParams;
            this.activated = true;
            this.srv.log.init(this.name, `created:${this.id}`);
        }
    }
    /**
     * Pass in a route config for this entity
     * @param routes
     */
    setRoutes(routes) {
        this.routes = routes;
    }
    /**
     * A http call to archive a single entity
     * @param id
     * @param archive
     */
    archiveEntity(id, archive) {
        this.srv.cache.clearAll();
        let path = InterpolateEntityRoute(this.routes.archive.entity.path, { id: id });
        let body = {};
        if (archive) {
            if (IsObject(this.routes.archive.entity.params, true))
                body = DeepMerge(JsonCopy(body), this.routes.archive.entity.params);
            body = Object.assign(Object.assign({}, body), { business_id: PopBusiness.id, archived: -1 });
            return this.srv.request.doDelete(path, body, this.apiVersion);
        }
        else {
            path = InterpolateEntityRoute(this.routes.restore.entity.path, { id: id });
            if (IsObject(this.routes.restore.entity.params, true))
                body = DeepMerge(JsonCopy(body), this.routes.restore.entity.params);
            body = Object.assign(Object.assign({}, body), { business_id: PopBusiness.id, archived: -1 });
            return this.srv.request.doPost(path, body, this.apiVersion);
        }
    }
    /**
     * A http call to archive  multiple entities that passes a  {xx: {archive: 1}, xx: {archive: 1}, } structure
     * @param ids Primary Keys of the entities .[ 1 or 1,2,3,4,5 ]
     * @param archive
     */
    archiveEntities(ids, archive) {
        this.srv.cache.clearAll();
        const requests = [];
        if (archive) {
            String(ids).split(',').map((id) => {
                const path = InterpolateEntityRoute(this.routes.archive.entity.path, { id: id });
                requests.push(this.srv.request.doDelete(path, null, this.apiVersion));
            });
        }
        else {
            String(ids).split(',').map((id) => {
                let path = InterpolateString(this.routes.restore.entity.path, { id: id });
                path = StringReplaceAll(path, '\\?', '');
                path = StringReplaceAll(path, '\\/\\/', '\\/');
                requests.push(this.srv.request.doPost(path, { archived: -1 }, this.apiVersion));
            });
        }
        return forkJoin(requests);
    }
    /**
     *  A method that returns the configured app
     */
    getAppName() {
        return this.params.app;
    }
    /**
     * A Http call that gets the entity configs
     * @param id Primary Key of the entity
     */
    getConfig() {
        const path = `${this.routes.get.config.path}?entity_id=${this.params.id}`;
        if (this.params.id) {
            const body = IsObject(this.routes.get.config.params, true) ? this.routes.get.config.params : {};
            return this.srv.request.doGet(path, body, this.apiVersion).pipe(map((res) => {
                res = res.data ? res.data : res;
                res = ArrayGroupBy(res, 'type');
                if (IsObject(res, true)) {
                    Object.keys(res).map((type) => {
                        if (IsArray(res[type], true)) {
                            const tmp = {};
                            res[type].map((setting) => {
                                tmp[setting.name] = setting.config;
                            });
                            res[type] = tmp;
                        }
                    });
                }
                else {
                    res = {};
                }
                return res;
            }));
        }
        else {
            return of({});
        }
    }
    /**
     *  A http call that gets a list of entities
     * @param queryParams '?archived=1', '?archived=0'
     */
    getEntities(body = {}, queryParams) {
        return new Promise((resolve) => {
            let data = [];
            if (!(IsObject(queryParams)))
                queryParams = { archived: 0 };
            if (!(IsObject(body)))
                body = { archived: IsDefined(queryParams.archived) ? queryParams.archived : 0 };
            if (this.model.table.filter && this.model.table.filter.active && IsObject(this.model.table.filter.query, true)) {
                if (!queryParams.bypassFilters) {
                    Object.keys(this.model.table.filter.query).map((filterName) => {
                        if (filterName in PopFilter && IsArray(PopFilter[filterName], true))
                            body[this.model.table.filter.query[filterName]] = PopFilter[filterName];
                    });
                    // queryParams.limit = 100;
                }
            }
            const path = `${this.routes.get.entities.path}`;
            if (IsObject(this.routes.get.entities.params, true) && !queryParams.bypassParams) {
                body = DeepMerge(JsonCopy(body), this.routes.get.entities.params);
            }
            let page = 1;
            this.srv.request.doGet(`${path}`, body, this.apiVersion).subscribe((res) => {
                data = res.data;
                if (IsObject(res.meta, true)) {
                    const requests = [];
                    const lastPage = res.meta.last_page;
                    while (page < lastPage) {
                        page++;
                        requests.push(this.srv.request.doGet(`${path}?page=${page}`, body, this.apiVersion));
                    }
                    if (requests.length) {
                        forkJoin(requests).subscribe((pages) => {
                            pages.map((nextPage) => {
                                data.push(...nextPage.data);
                            });
                            return resolve(data);
                        });
                    }
                    else {
                        return resolve(data);
                    }
                }
                else {
                    return resolve(data);
                }
            });
        });
    }
    /**
     * A method that clears any cache for this entity type
     */
    clearAllCache(caller = '') {
        this.srv.cache.clearAll();
    }
    /**
     * A method that clears any cache for this entity type
     */
    clearCache(cacheType, cacheKey, caller = '') {
        this.srv.cache.clear(cacheType, cacheKey);
    }
    setCache(cacheType, cacheKey, data, minutes = 1) {
        if (IsString(cacheType, true) && IsString(cacheKey) && IsDefined(data)) {
            if (minutes > 60)
                minutes = 60;
            this.srv.cache.set(cacheType, cacheKey, data, (minutes * 60 * 1000));
        }
    }
    getCache(cacheType, cacheKey) {
        return new Promise((resolve) => {
            if (IsString(cacheType, true) && IsString(cacheKey)) {
                this.srv.cache.get(cacheType, cacheKey).subscribe((cacheData) => {
                    if (IsDefined(cacheData)) {
                        return resolve(cacheData);
                    }
                    else {
                        resolve(null);
                    }
                });
            }
            else {
                resolve(null);
            }
        });
    }
    /**
     *
     * @param id Primary Key of the entity
     * @param params '?metadata=1', '?metadata=0', '?metadata=1&filter=id,name'
     * @return Observable
     */
    getEntity(id, queryParams) {
        if (!queryParams || typeof (queryParams) !== 'object')
            queryParams = {};
        let body = { archived: IsDefined(queryParams.archived) ? queryParams.archived : -1 };
        if (+id) {
            const path = `${InterpolateString(this.routes.get.entity.path, { id: id })}`;
            if (IsObject(this.routes.get.entity.params, true) && !queryParams.bypassParams)
                body = DeepMerge(JsonCopy(body), this.routes.get.entity.params);
            this.srv.log.info(this.name, path, body);
            const request = this.srv.request.doGet(path, body, this.apiVersion);
            return queryParams.bypassCache ? request : this.srv.cache.get('entity', String(id), request);
        }
        return of(undefined);
    }
    /**
     * A Http call that gets the entity history
     * @param id Primary Key of the entity
     */
    getHistory(id) {
        return of([]);
        // const path = InterpolateString(this.routes.get.history, { id: id });
        // return this.srv.request.doGet(path, {}, this.apiVersion);
    }
    /**
     * A Http call that gets the entity metadata
     * @param id Primary Key of the entity
     */
    getUiResource(core) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let ui = {};
            if (IsObject(this.model.resource, true)) {
                const success = yield this.srv.resource.setCollection(this.model.resource, core);
                if (success) {
                    ui = this.srv.resource.getCollection(this.model.resource);
                    return resolve(ui);
                }
                else {
                    resolve(false);
                }
            }
            else {
                resolve(ui);
            }
        }));
    }
    /**
     * A Http call that gets the entity metadata
     * @param id Primary Key of the entity
     */
    reloadResource(core, resourceName) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (resourceName && IsObject(this.model.resource, [resourceName])) {
                if (!IsObject(core.resource))
                    core.resource = {};
                core.resource[resourceName] = yield this.srv.resource.reloadResource(core, this.model.resource[resourceName]);
                return resolve(true);
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * A Http call that gets the entity metadata
     * @param id Primary Key of the entity
     */
    injectResource(core, resource, reload = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(resource, ['name'])) {
                if (!(IsObject(this.model.resource[resource.name]))) {
                    if (!IsObject(this.model.resource))
                        this.model.resource = {};
                    if (!IsObject(core.resource))
                        core.resource = {};
                    this.model.resource[resource.name] = Object.assign({}, DeepCopy(resource));
                    if (resource.api_path && IsString(resource.api_path, true)) {
                        core.resource[resource.name] = yield this.srv.resource.reloadResource(core, resource);
                    }
                    else {
                        core.resource[resource.name] = resource;
                    }
                    return resolve(true);
                }
                else if (IsObject(this.model.resource[resource.name], true) && resource.api_path && reload) {
                    yield this.reloadResource(core, resource.name);
                    return resolve(true);
                }
                else {
                    return resolve(true);
                }
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * A method that gets the entity singular name for entity
     * @param field
     */
    getInternalName() {
        return this.params.internal_name;
    }
    /**
     * Get the alias display for this entity;
     * @param alias 'singular | 'plural';
     */
    getDisplayName(alias = 'singular') {
        return PopPipe.transform(this.params.internal_name, { type: 'entity', arg1: 'alias', arg2: alias });
    }
    /**
     * A method that gets the base api path for the entity
     * @param field
     */
    getApiPath() {
        return this.params.path;
    }
    /**
     * A http call that gets the preferences of a user
     */
    getPreferences(core, cache = false) {
        return new Promise((resolve) => {
            const buUserId = this.srv.base.getCurrentBusinessUserId();
            if (buUserId) {
                const path = `${this.routes.get.preference.path}`;
                let body = { path: this.params.internal_name, bu_user_id: buUserId };
                if (IsObject(this.routes.get.preference.params, true))
                    body = DeepMerge(JsonCopy(body), this.routes.get.preference.params);
                const request = this.srv.request.doGet(path, body, this.apiVersion, true).pipe(map((res) => {
                    const preferences = {};
                    const tmp = res.data ? res.data : res;
                    if (IsArray(tmp, true)) {
                        tmp.map((preference) => {
                            preferences[preference.type] = Object.assign(Object.assign({}, preference.settings), { id: preference.id });
                        });
                    }
                    return preferences;
                }));
                if (cache) {
                    this.srv.cache.get(this.params.internal_name, 'preference', request, 600000).subscribe((res) => {
                        if (!IsObject(core.preference))
                            core.preference = {};
                        core.preference = Object.assign(Object.assign({}, core.preference), res);
                        return resolve(true);
                    }, (err) => {
                        return resolve(false);
                    });
                }
                else {
                    request.subscribe((res) => {
                        if (!IsObject(core.preference))
                            core.preference = {};
                        core.preference = Object.assign(Object.assign({}, core.preference), res);
                        return resolve(true);
                    }, () => {
                        return resolve(false);
                    });
                }
            }
            else {
                return resolve(false);
            }
        });
    }
    /**
     * A http call that gets the preferences of a user
     */
    deletePreference(id, type) {
        return new Promise((resolve) => {
            const path = `${this.routes.get.preference.path}/${id}`;
            this.srv.request.doDelete(path, null, this.apiVersion, true).pipe().subscribe(() => {
                const defaultPreference = null;
                return resolve(defaultPreference);
                // this.srv.cache.clear([ `${this.params.internal_name}:preference` ]);
                // this.getPreferences(true).subscribe(() => {
                //   // ToDo:: Check inside entity models to see if a default table settings exist
                //   const defaultPreference = null;
                //   return resolve(defaultPreference);
                // });
            }, () => {
                return resolve(false);
            });
        });
    }
    /**
     * An Http call to save a preference
     * @param id
     * @param type
     * @param body
     */
    savePreference(id = null, type, body) {
        let request;
        if (+id) {
            const path = `${this.routes.get.preference.path}/${id}`;
            if (IsObject(this.routes.get.preference.params, true))
                body = DeepMerge(JsonCopy(body), this.routes.get.preference.params);
            request = this.srv.request.doPatch(path, body, this.apiVersion, true).pipe(map((res) => {
                let preference = {};
                const tmp = res.data ? res.data : res;
                if (IsObject(tmp, true)) {
                    preference = Object.assign(Object.assign({}, tmp.settings), { id: tmp.id });
                }
                return preference;
            }));
        }
        else {
            const buUserId = this.srv.base.getCurrentBusinessUserId();
            const path = `${this.routes.get.preference.path}`;
            if (IsObject(this.routes.get.preference.params, true))
                body = DeepMerge(JsonCopy(body), this.routes.get.preference.params);
            body = Object.assign(Object.assign({}, body), {
                path: this.params.internal_name,
                type: type,
                bu_user_id: buUserId,
                name: `${TitleCase(this.params.name)} ${TitleCase(type)} Setting`
            });
            request = this.srv.request.doPost(path, body, this.apiVersion, true).pipe(map((res) => {
                let preference = {};
                const tmp = res.data ? res.data : res;
                if (IsObject(tmp, true)) {
                    preference = Object.assign(Object.assign({}, tmp.settings), { id: tmp.id });
                }
                return preference;
            }));
        }
        return request;
    }
    /**
     * A method that will navigate the user to the Tab View of an entity
     * Method should take into consideration the aliases that the entity might have
     * @param id Primary Key of the entity
     * @param tab
     */
    navigateToEntity(id, tab) {
        return this.srv.router.navigateByUrl(`${this.srv.display.alias(SpaceToHyphenLower(this.params.name))}/${id}/${tab}`);
    }
    /**
     * A method that will navigate the user to the List View of an entity
     * Method should take into consideration the aliases that the entity might have
     * @param id Primary Key of the entity
     * @param tab
     */
    navigateToEntities() {
        return this.srv.router.navigateByUrl(this.srv.display.alias(SpaceToHyphenLower(this.params.name)));
    }
    /**
     * A method that update an entity relation
     * Method should take into consideration the aliases that the entity might have
     * @param id Primary Key of the entity
     * @param tab
     */
    updateEntity(id, entity, queryParams) {
        const path = InterpolateString(this.routes.patch.entity.path, { id: id });
        return this.srv.request.doPatch(path, entity, this.apiVersion);
    }
}
PopEntityRepoService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

const DefaultEntityAction = {
    new: {
        description: 'Add A New Record To #name',
        config: {
            fields: {
                name: {
                    required: true,
                    pattern: 'Alpha'
                },
            },
            http: 'POST',
            label: 'New #internal_name',
            postUrl: '#path',
            goToUrl: '#path/:id/general',
            submit: 'New',
        },
        active: 1
    },
    advanced_search: {
        description: 'Advanced Search For #internal_name',
        config: {
            fields: {
                name: {
                    required: true,
                    pattern: 'AlphaNumeric'
                },
            },
            http: 'GET',
            label: 'Advanced Search',
            get_url: '#path',
            goToUrl: null,
            submit: 'Search',
        },
        active: 1
    }
};

const DefaultEntityTable = {
    setting: {
        columns: {
            id: {
                checkbox: { sort_let: 0, visible: true },
                display: 'ID',
                sort: 4,
                visible: true
            },
            name: {
                display: 'Name',
                sort: 1,
                visible: true
            },
        },
        options: {
            display_header: true,
            column_search: false,
            column_sort: false,
            sticky_header: true,
        }
    },
    permission: {
        allowColumnDisplayToggle: true,
        allowColumnStickyToggle: true,
        allowColumnSearchToggle: true,
        allowColumnSortToggle: true,
        allowHeaderStickyToggle: true,
        allowHeaderDisplayToggle: true,
        allowPaginatorToggle: true,
    },
    button: {
        archived: true,
        clone: true,
        new: true,
        advanced_search: false,
        custom: []
    },
    filter: {
        active: false,
        display: 'default'
    },
};

const 0 = {
    ancillary: 1,
    position: 1,
    table: {
        checkbox: {
            visible: true,
            sort: 0
        },
        visible: true,
        sort: 999
    },
    model: {
        form: 'label',
        name: 'id',
        label: 'ID',
        visible: true,
        maxlength: 32,
        copyLabel: true,
        labelButton: true,
        valueButton: true,
        copyLabelBody: '#id',
        copyLabelDisplay: 'ID #id',
        valueButtonDisplay: ':archived',
        valueButtonDisabled: true,
        valueButtonDisplayTransformation: 'toActiveOrArchived',
        subLabel: 'Created',
        subValue: 'created_at'
    },
    sort: 0
};
const DefaultEntityField = {
    id: 0,
    name: {
        ancillary: 0,
        position: 1,
        table: {
            visible: true,
            sort: 2
        },
        model: {
            form: 'input',
            name: 'name',
            label: 'Name',
            bubble: true,
            pattern: 'Default',
            visible: true,
            required: 1,
            maxlength: 64,
            patch: {
                field: 'name',
                path: '#path/#entityId'
            }
        },
        sort: 2
    },
    description: {
        ancillary: 0,
        position: 1,
        table: {
            visible: true,
            sort: 3
        },
        model: {
            form: 'textarea',
            name: 'description',
            label: 'Description',
            autoSize: false,
            height: 70,
            maxHeight: 150,
            maxlength: 255,
            sort: 3,
            patch: {
                field: 'description',
                path: '#path/#entityId'
            }
        },
        sort: 3
    },
    added_by_user: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99
        },
        model: {
            form: 'label',
            name: 'added_by_user',
            label: 'Added By',
            truncate: 64,
        },
        sort: 99,
    },
    archived_by_user: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99
        },
        model: {
            form: 'label',
            name: 'archived_by_user',
            label: 'Archived By',
            truncate: 64,
        },
        sort: 99
    },
    created_at: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99,
            transformation: {
                arg1: 'date',
                type: 'date'
            },
        },
        model: {
            form: 'label',
            name: 'created_at',
            label: 'Added Date',
            truncate: 64,
            transformation: {
                arg1: 'date',
                type: 'date'
            },
        },
        sort: 99
    },
    created_by_user_id: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99
        },
        model: {
            form: 'label',
            name: 'created_by_user_id',
            label: 'Added By ID',
            truncate: 64,
        },
        sort: 99
    },
    deleted_at: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99,
            transformation: {
                arg1: 'date',
                type: 'date'
            },
        },
        model: {
            form: 'label',
            name: 'deleted_at',
            label: 'Deleted At',
            transformation: {
                arg1: 'date',
                type: 'date'
            },
            type: 'label',
            action: 'general'
        },
        when: [
            [
                [
                    'entity.deleted_at'
                ]
            ]
        ],
        sort: 99
    },
    deleted_by_user_id: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99,
        },
        model: {
            form: 'label',
            name: 'deleted_by_user_id',
            label: 'Archived',
            visible: true,
            maxlength: 32,
            transformation: {
                type: 'toYesNoPipe'
            }
        },
        sort: 99
    },
    updated_at: {
        ancillary: 1,
        position: 1,
        table: {
            visible: false,
            sort: 99,
            transformation: {
                arg1: 'date',
                type: 'date'
            },
        },
        model: {
            form: 'label',
            name: 'updated_at',
            label: 'Last Update',
            transformation: {
                arg1: 'date',
                type: 'date'
            },
            type: 'label',
            action: 'general'
        },
        when: [
            [
                [
                    'entity.updated_at'
                ]
            ]
        ],
        sort: 99
    },
    archived: {
        ancillary: 1,
        position: 1,
        table: {
            visible: true,
            sort: 99,
            transformation: {
                type: 'toYesNoPipe'
            },
        },
        model: {
            form: 'label',
            name: 'archived',
            label: 'Archived',
            transformation: {
                type: 'toYesNoPipe'
            },
            type: 'label',
        },
        when: [
            [
                [
                    'entity.archived'
                ]
            ]
        ],
        sort: 99
    }
};

const DefaultEntityResource = {
// entities: {
//   name: 'entities',
//   defaultValue: null,
//   data_type: 'api_records',
//   api_path: 'entities?select=id,name,internal_name&archived=-1',
//   api_cache: 1,
//   data_filter: {},
// },
};

const DefaultEntityMenu = {
    button: {
        archive: true,
        clone: false,
        custom: [],
        delete: false,
        goBack: true
    },
    archiveKey: 'archived'
};

const DefaultEntityRoute = {
    get: {
        entity: {
            path: `#path/{id}`,
            params: {},
        },
        entities: {
            path: `#path`,
            params: {},
        },
        config: {
            path: `apps/configs`,
            params: {},
        },
        history: {
            path: `#path/{id}/history`,
            params: {},
        },
        preference: {
            path: `apps/preferences`,
            params: {},
        },
    },
    patch: {
        entity: {
            path: `#path/{id}`,
            params: {},
        },
    },
    archive: {
        entity: {
            path: `#path/{id}`,
            params: {},
        },
    },
    restore: {
        entity: {
            path: `#path/{id}`,
            params: {},
        },
    }
};

class PopEntityService {
    /**
     * This srv is used in the
     * @param env
     */
    constructor(fieldUtil, paramUtil) {
        this.fieldUtil = fieldUtil;
        this.paramUtil = paramUtil;
        this.name = 'PopEntityService';
        this.asset = {
            access: new Map(),
            base: new Map(),
            dataSetter: new Map(),
            entryAccess: new Map(),
            lastDataSetter: new Map(),
            decorator: new Map(),
            filter: new Map(),
            params: new Map(),
            repo: new Map(),
            tabs: new Map(),
            resources: new Map(),
            actions: new Map(),
            fields: new Map(),
            tables: new Map(),
            menus: new Map(),
            routes: new Map(),
        };
        this.asset.tabs.set('default', []);
    }
    /**
     * Check a specific crud access against an entity
     * @param internal_name
     * @param accessType
     */
    checkAccess(internal_name, accessType) {
        return this.paramUtil.checkAccess(internal_name, accessType);
    }
    /**
     * Configure/Extend the default behavior of an entity
     * @param internal_name
     * @param extend
     */
    configure(internal_name, extend) {
        if (IsArray(extend.tab, true))
            this.setEntityTabs(internal_name, extend.tab);
        if (IsObject(extend.action, true))
            this.setEntityAction(internal_name, extend.action);
        if (IsArray(extend.entryAccess, true))
            this.setEntityEntryAccess(internal_name, extend.entryAccess);
        if (IsObject(extend.resource, true))
            this.setEntityResource(internal_name, extend.resource);
        if (IsCallableFunction(extend.dataSetter))
            this.setEntityDataSetter(internal_name, extend.dataSetter);
        if (IsCallableFunction(extend.lastDataSetter))
            this.setLastEntityDataSetter(internal_name, extend.lastDataSetter);
        if (IsCallableFunction(extend.decorator))
            this.setEntityDecorator(internal_name, extend.decorator);
        if (IsCallableFunction(extend.filter))
            this.setEntityFilter(internal_name, extend.filter);
        if (IsObject(extend.table, true))
            this.setEntityTable(internal_name, extend.table);
        if (IsObject(extend.route, true))
            this.setEntityRoute(internal_name, extend.route);
        if (IsObject(extend.field, true))
            this.setEntityField(internal_name, extend.field);
        if (IsObject(extend.menu, true))
            this.setEntityMenu(internal_name, extend.menu);
    }
    /**
     * A method to get a Core Config for an entity
     * Uses cache service to improve performance
     * ALL ENTITY RELATED COMPONENTS RELY ON THIS !!!!
     * @param entityParams
     * @param metadata
     */
    getCoreConfig(internal_name, entityId = 0, dom) {
        return new Promise((resolve) => {
            //       console.log('internal_name', entityId);
            this._getBaseCoreConfig(internal_name).then((baseConfig) => {
                if (+entityId > 0) {
                    baseConfig.params.entityId = +entityId;
                    baseConfig.repo.getEntity(baseConfig.params.entityId, {}).subscribe((res) => __awaiter(this, void 0, void 0, function* () {
                        baseConfig.entity = res.data ? res.data : res;
                        yield this.setCoreDomAssets(baseConfig, dom);
                        // await this.setCoreDomAssets(baseConfig, dom);
                        return resolve(baseConfig);
                    }), () => {
                        if (PopHistory.isPreviousHistory())
                            PopHistory.goBack();
                        return resolve(null);
                    });
                }
                else {
                    return resolve(baseConfig);
                }
            });
        });
    }
    /**
     * Preferences are something that might change in the base configs, keep them there for now since they will not change often
     * Note: Moved preferences to base configs since they are not playing nice with cache and I want to update them directly
     * @param internal_name
     * @param key
     * @param value
     */
    updateBaseCoreConfig(internal_name, key, value) {
        const base = this.asset.base.get(internal_name);
        let subKey;
        if (base) {
            if (key.includes(':')) {
                const keys = key.split(':');
                key = String(keys[0]).trim();
                subKey = String(keys[1]).trim();
            }
            if (key in base) {
                if (subKey) {
                    if (subKey in base[key]) {
                        base[key][subKey] = value;
                    }
                }
                else {
                    base[key] = value;
                }
            }
            this.asset.base.set(internal_name, base);
        }
        return true;
    }
    /**
     * Get the base set of the entity definitions
     * These is the starting point when it comes to entities
     * @param internal_name
     * @param entityId
     */
    getEntityParams(internal_name, entityId = null) {
        let entityParams;
        if (this.asset.params.has(internal_name)) {
            entityParams = Object.assign({}, this.asset.params.get(internal_name));
            entityParams.entity = entityId;
        }
        else {
            entityParams = this.paramUtil.getEntityParams(internal_name);
            if (entityParams) {
                this.asset.params.set(internal_name, Object.assign({}, entityParams));
            }
        }
        return entityParams;
    }
    /**
     * Get the entity repo
     * These is the starting point when it comes to entities
     * @param internal_name
     * @param entityId
     */
    getEntityRepo(internal_name) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const baseConfig = yield this._getBaseCoreConfig(internal_name);
            if (IsObject(baseConfig), ['repo']) {
                return resolve(baseConfig.repo);
            }
            else {
                return resolve(null);
            }
        }));
    }
    /**
     * Get the entity params that are associated with a angular route ie.. /admin/accounts should resolve to the account params
     * @param api_path
     * @param id
     */
    getEntityParamsWithPath(api_path, id = null) {
        return this.paramUtil.getEntityParamsWithPath(api_path, id);
    }
    /**
     * A helper function that fetches an entity internal name from an Active Route
     * This is a way to ask based of the current route what entity am I dealing with
     * @param route
     * @param extension
     */
    getRouteInternalName(route, extension) {
        let internal_name = 'user';
        if (route.snapshot.params && route.snapshot.params.internal_name) {
            internal_name = route.snapshot.params.internal_name;
        }
        else if (extension && IsString(extension.internal_name, true)) {
            internal_name = extension.internal_name;
        }
        else if (IsString(route.snapshot.data.internal_name, true)) {
            internal_name = route.snapshot.data.internal_name;
        }
        else if (IsString(route.snapshot.data.can_read, true)) {
            internal_name = route.snapshot.data.can_read;
        }
        else {
            let pathEntityParams;
            if (route.snapshot.routeConfig && route.snapshot.routeConfig.path) {
                pathEntityParams = this.paramUtil.getEntityParamsWithPath(route.snapshot.routeConfig.path);
            }
            if (pathEntityParams) {
                internal_name = pathEntityParams.internal_name;
            }
            else {
                let attempt;
                const parts = window.location.pathname.split('/');
                while (!internal_name || parts.length) {
                    attempt = parts.pop();
                    if (isNaN(attempt) && this.paramUtil.getEntityParams(attempt)) {
                        internal_name = attempt;
                        break;
                    }
                    if (!internal_name && isNaN(attempt) && this.paramUtil.getEntityParamsWithPath(attempt)) {
                        internal_name = attempt;
                        break;
                    }
                }
            }
        }
        return internal_name;
    }
    /**
     * A helper function that fetches an entity Id from an Active Route
     * This is a way to ask based of the current route what entity am I dealing with
     * @param route
     * @param extension
     */
    getRouteParentId(route, extension) {
        let parentId = null;
        if (route.snapshot.params && route.snapshot.params.id) {
            parentId = route.snapshot.params.id;
        }
        else {
            let attempt;
            const parts = window.location.pathname.split('/');
            while (!parentId || parts.length) {
                attempt = parts.pop();
                if (IsNumber(attempt, true)) {
                    parentId = attempt;
                    break;
                }
            }
        }
        return parentId;
    }
    /**
     * Get the set of tab configs that belong to an entity
     */
    getEntityTabs(core) {
        if (IsObject(core, ['params', 'entity']) && this.asset.tabs.has(core.params.internal_name)) {
            const tabs = this.asset.tabs.get(core.params.internal_name).filter((tab) => {
                return EvaluateWhenConditions(core, tab.when, core);
            });
            return [...tabs];
        }
        else {
            return [...this.asset.tabs.get('default')];
        }
    }
    /**
     * A method that refreshes just the entity on an CoreConfig
     * Will automatically update the entity on the entity config
     * @param config
     * @param queryParams
     */
    refreshCoreEntity(core, dom, queryParams) {
        return new Promise((resolve) => {
            if (core.params.entityId)
                core.repo.clearCache('entity', String(core.params.entityId), 'PopEntityService:refreshEntity');
            if (!IsObject(queryParams))
                queryParams = {};
            if (core && core.repo) {
                queryParams.bypassCache = true;
                core.repo.getEntity(core.params.entityId, queryParams).subscribe((res) => __awaiter(this, void 0, void 0, function* () {
                    const entity = GetHttpObjectResult(res);
                    Object.keys(entity).map((key) => {
                        core.entity[key] = entity[key];
                    });
                    yield this.setCoreDomAssets(core, dom);
                    PopLog.info(this.name, `refreshCoreEntity`, core.entity);
                    return resolve(entity);
                }), (err) => {
                    return resolve(null);
                });
            }
            else {
                return resolve(null);
            }
        });
    }
    /**
     * This function is responsible to make sure the CoreConfig has resources to do its job
     * IE... If a field request a data set , this function should make sure that it is available
     * @param core
     * @param dom
     * @private
     */
    setCoreDomAssets(core, dom) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            core.resource = yield core.repo.getUiResource(core);
            if (IsObject(core.entity, true)) {
                const dataSetter = StorageGetter(core.repo, ['model', 'dataSetter'], null);
                if (IsCallableFunction(dataSetter)) {
                    core.entity = dataSetter(core, core.entity, dom);
                }
                if (IsObject(dom, true)) {
                    yield this.fieldUtil.buildDomFields(core, dom);
                }
                const lastDataSetter = StorageGetter(core.repo, ['model', 'lastDataSetter'], null);
                if (IsCallableFunction(lastDataSetter)) {
                    core.entity = lastDataSetter(core, core.entity, dom);
                }
            }
            return resolve(true);
        }));
    }
    /**
     * Set the base definitions for an entity
     * Each entity needs to define these so we know how to talk to the api in regards to it
     * The api should provide this details as part of the auth token
     * @param internal_name
     * @param entityId
     */
    setEntityParams(params) {
        PopLog.info(this.name, `Entity Params set for ${params.internal_name}`, params);
        this.paramUtil.setEntityParams(params);
    }
    /**
     * Attach a set of tab configs to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityTabs(internal_name, tabs) {
        if (IsString(internal_name, true) && Array.isArray(tabs)) {
            PopLog.info(this.name, `Entity Tabs set for ${internal_name}`, tabs);
            this.asset.tabs.set(internal_name, tabs);
        }
    }
    /**
     * Attach a set of actions to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityAction(internal_name, action) {
        if (IsString(internal_name, true) && IsObject(action)) {
            PopLog.info(this.name, `Entity Action set for ${internal_name}`, action);
            this.asset.actions.set(internal_name, action);
        }
    }
    /**
     * Attach a set of actions to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityEntryAccess(internal_name, entryAccess) {
        if (IsString(internal_name, true) && IsArray(entryAccess, true)) {
            PopLog.info(this.name, `Entity entryAccess set for ${internal_name}`, entryAccess);
            this.asset.entryAccess.set(internal_name, entryAccess);
        }
    }
    /**
     * Attach a set of table options for an entity
     * @param internal_name
     * @param tabs
     */
    setEntityTable(internal_name, table) {
        if (IsString(internal_name, true) && IsObject(table)) {
            PopLog.info(this.name, `Entity Action set for ${internal_name}`, table);
            this.asset.tables.set(internal_name, table);
        }
    }
    /**
     * Attach a set of table options for an entity
     * @param internal_name
     * @param tabs
     */
    setEntityRoute(internal_name, route) {
        if (IsString(internal_name, true) && IsObject(route)) {
            PopLog.info(this.name, `Entity Route set for ${internal_name}`, route);
            this.asset.routes.set(internal_name, route);
        }
    }
    /**
     * Attach a set of tab menu configs to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityMenu(internal_name, menu) {
        if (IsString(internal_name, true) && IsObject(menu, true)) {
            PopLog.info(this.name, `Entity Menu set for ${internal_name}`, menu);
            this.asset.menus.set(internal_name, menu);
        }
    }
    /**
     * Attach a set of resources to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityResource(internal_name, resource) {
        if (IsString(internal_name, true) && IsObject(resource)) {
            PopLog.info(this.name, `Entity Resource set for ${internal_name}`, resource);
            this.asset.resources.set(internal_name, resource);
        }
    }
    /**
     * Attach a data decorator that mutates entity data response
     * @param internal_name
     * @param tabs
     */
    setEntityDecorator(internal_name, decorator) {
        if (IsString(internal_name, true) && IsCallableFunction(decorator)) {
            PopLog.info(this.name, `Entity Decorator set for ${internal_name}`, decorator.toString());
            this.asset.decorator.set(internal_name, decorator);
        }
    }
    /**
     * Attach a data decorator that mutates entity data response
     * @param internal_name
     * @param tabs
     */
    setEntityDataSetter(internal_name, dataSetter) {
        if (IsString(internal_name, true) && IsCallableFunction(dataSetter)) {
            PopLog.info(this.name, `Entity Data Setter set for ${internal_name}`, dataSetter.toString());
            this.asset.dataSetter.set(internal_name, dataSetter);
        }
    }
    /**
     * Attach a data decorator that mutates entity data response
     * @param internal_name
     * @param tabs
     */
    setLastEntityDataSetter(internal_name, dataSetter) {
        if (IsString(internal_name, true) && IsCallableFunction(dataSetter)) {
            PopLog.info(this.name, `Entity Last Data Setter  set for ${internal_name}`, dataSetter.toString());
            this.asset.lastDataSetter.set(internal_name, dataSetter);
        }
    }
    /**
     * Attach a data filter to limit the entity data response
     * @param internal_name
     * @param tabs
     */
    setEntityFilter(internal_name, filter) {
        if (IsString(internal_name, true) && IsCallableFunction(filter)) {
            PopLog.info(this.name, `Entity Filter set for ${internal_name}`, filter.toString());
            this.asset.filter.set(internal_name, filter);
        }
    }
    /**
     * Attach a set of fields to an entity
     * @param internal_name
     * @param tabs
     */
    setEntityField(internal_name, field) {
        if (IsString(internal_name, true) && IsObject(field)) {
            PopLog.info(this.name, `Entity Field set for ${internal_name}`, field);
            this.asset.fields.set(internal_name, field);
        }
    }
    /**
     * Get extended fields attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityField(internal_name) {
        if (IsString(internal_name, true)) {
            const field = this.asset.fields.get(internal_name);
            return field ? field : {};
        }
    }
    /**
     * Get entry access for an entity
     * @param internal_name
     * @param tabs
     */
    getEntityEntryAccess(internal_name) {
        if (IsString(internal_name, true)) {
            const entryAccess = this.asset.entryAccess.get(internal_name);
            return IsArray(entryAccess, true) ? entryAccess : [];
        }
    }
    /**
     * Get extended fields attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityResource(internal_name) {
        if (IsString(internal_name, true)) {
            const resource = this.asset.resources.get(internal_name);
            return resource ? resource : {};
        }
    }
    /**
     * Get entity data decorator
     * @param internal_name
     * @param tabs
     */
    getEntityDecorator(internal_name) {
        if (IsString(internal_name, true)) {
            const decorator = this.asset.decorator.get(internal_name);
            return IsCallableFunction(decorator) ? decorator : null;
        }
    }
    /**
     * Get entity data decorator
     * @param internal_name
     * @param tabs
     */
    getEntityDataSetter(internal_name) {
        if (IsString(internal_name, true)) {
            const dataSetter = this.asset.dataSetter.get(internal_name);
            return IsCallableFunction(dataSetter) ? dataSetter : null;
        }
    }
    /**
     * Get entity data decorator
     * @param internal_name
     * @param tabs
     */
    getEntityLastDataSetter(internal_name) {
        if (IsString(internal_name, true)) {
            const lastDataSetter = this.asset.lastDataSetter.get(internal_name);
            return IsCallableFunction(lastDataSetter) ? lastDataSetter : null;
        }
    }
    /**
     * Get entity data decorator
     * @param internal_name
     * @param tabs
     */
    getEntityFilter(internal_name) {
        if (IsString(internal_name, true)) {
            const filter = this.asset.filter.get(internal_name);
            return IsCallableFunction(filter) ? filter : null;
        }
    }
    /**
     * Get extended actions attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityAction(internal_name) {
        if (IsString(internal_name, true)) {
            const action = this.asset.actions.get(internal_name);
            return action ? action : {};
        }
    }
    /**
     * Get extended table attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityTable(internal_name) {
        if (IsString(internal_name, true)) {
            const table = this.asset.tables.get(internal_name);
            return table ? table : {};
        }
    }
    /**
     * Get extended table attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityRoute(internal_name) {
        if (IsString(internal_name, true)) {
            const route = this.asset.routes.get(internal_name);
            return route ? route : {};
        }
    }
    /**
     * Get extended table attached to an entity
     * @param internal_name
     * @param tabs
     */
    getEntityMenu(internal_name) {
        if (IsString(internal_name, true)) {
            const action = this.asset.menus.get(internal_name);
            return action ? action : {};
        }
    }
    bustAllCache() {
        this.asset.repo.forEach((repo, key) => {
            PopLog.init(this.name, `Bust cache for ${repo.getInternalName()}`);
            repo.clearAllCache('bustAllCache');
        });
    }
    ngOnDestroy() {
        console.log(this.name, `destroyed:${this.id}`);
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will do all of the work of building and storing the base config for each entity
     * @param internal_name
     * @param routes
     * @private
     */
    _getBaseCoreConfig(internal_name) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.asset.base.has(internal_name)) {
                const params = this.getEntityParams(internal_name);
                const core = new CoreConfig({
                    params: IsObjectThrowError(params, true, `Could not resolve params for ${internal_name}`) ? params : null,
                });
                core.flag = { routeCheck: IsAliasable(internal_name), assetCheck: true, modalCheck: false, refreshCheck: false };
                core.access = this._getEntityAccess(core.params);
                core.channel = new EventEmitter();
                core.repo = this._getEntityRepo(core.params);
                core.repo.model = {
                    action: DeepMerge(JsonCopy(DefaultEntityAction), this.getEntityAction(core.params.internal_name)),
                    dataSetter: this.getEntityDataSetter(core.params.internal_name),
                    lastDataSetter: this.getEntityLastDataSetter(core.params.internal_name),
                    decorator: this.getEntityDecorator(core.params.internal_name),
                    filter: this.getEntityFilter(core.params.internal_name),
                    table: DeepMerge(JsonCopy(DefaultEntityTable), this.getEntityTable(core.params.internal_name)),
                    field: Object.assign(Object.assign({}, DeepMerge(DefaultEntityField)), this.getEntityField(core.params.internal_name)),
                    resource: DeepMerge(JsonCopy(DefaultEntityResource), this.getEntityResource(core.params.internal_name)),
                    route: DeepMerge(JsonCopy(DefaultEntityRoute), this.getEntityRoute(core.params.internal_name)),
                    menu: DeepMerge(JsonCopy(DefaultEntityMenu), this.getEntityMenu(core.params.internal_name))
                };
                core.repo.setRoutes(InterpolateEntityRoutes(core.repo.model.route, core.params));
                yield forkJoin([this._getEntityConfig(core, internal_name), core.repo.getPreferences(core)]).subscribe(() => {
                    this.asset.base.set(internal_name, core);
                    return resolve(Object.assign({}, this.asset.base.get(internal_name)));
                }, () => {
                    return resolve(Object.assign({}, this.asset.base.get(internal_name)));
                });
            }
            else {
                return resolve(Object.assign({}, this.asset.base.get(internal_name)));
            }
        }));
    }
    /**
     * Get the an entity repo class for a specific entity
     * This is intended to be run when a CoreConfig is requested for an entity, once created it will be stored and reused
     *
     * @param entityParams
     * @param routes
     */
    _getEntityRepo(entityParams) {
        let repo = null;
        if (IsObject(entityParams, true)) {
            if (this.asset.repo.has(entityParams.internal_name)) {
                repo = this.asset.repo.get(entityParams.internal_name);
            }
            else {
                repo = new PopEntityRepoService();
                repo.register(entityParams);
                this.asset.repo.set(entityParams.internal_name, repo);
            }
        }
        return repo;
    }
    /**
     * Get the crud access that is associated to a specific entity
     * This is intended to be run when a CoreConfig is requested for an entity, once created it will be stored and reused
     * @param entityParams
     */
    _getEntityAccess(entityParams) {
        let entityAccess = null;
        if (IsObject(entityParams, true)) {
            entityAccess = this.paramUtil.getAccess(entityParams.internal_name);
            if (this.asset.access.has(entityParams.internal_name)) {
                entityAccess = Object.assign({}, this.asset.access.get(entityParams.internal_name));
            }
            else {
                entityAccess = this.paramUtil.getAccess(entityParams.internal_name);
                if (entityAccess) {
                    this.asset.access.set(entityParams.internal_name, Object.assign({}, entityAccess));
                }
            }
        }
        return entityAccess;
    }
    _getEntityConfig(core, internal_name) {
        return new Promise((resolve) => {
            core.repo.getConfig().subscribe((res) => {
                // this.getJsonModel(internal_name).then((res: any) => {
                let ApiModels = res.data ? res.data : res;
                ApiModels = ApiModels.model ? ApiModels.model : ApiModels;
                if (!IsObject(ApiModels)) {
                    ApiModels = {};
                }
                core.repo.model = Object.assign(Object.assign({}, core.repo.model), ApiModels //  Gives the api the ability to send over data, stub for future features
                );
                return resolve(true);
            }, () => {
                return resolve(false);
            });
        });
    }
}
PopEntityService.prov = i0.defineInjectable({ factory: function PopEntityService_Factory() { return new PopEntityService(i0.inject(PopEntityUtilFieldService), i0.inject(PopEntityUtilParamService)); }, token: PopEntityService, providedIn: "root" });
PopEntityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntityService.ctorParameters = () => [
    { type: PopEntityUtilFieldService },
    { type: PopEntityUtilParamService }
];

class PopRouteHistoryResolver {
    constructor(router) {
        this.router = router;
        this.sessionVar = 'Navigation.history';
        // ToDo: Grab enitty map dynamically
        router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe((event) => {
            const path = window.location.pathname.split('/');
            path.shift();
            path.pop();
            SetSessionSiteVar('App.name', path[0]);
            SetSessionSiteVar('App.entity', path[path.length - 1]);
        });
    }
    resolve(route, state) {
        const path = window.location.pathname.split('/');
        path.shift();
        path.pop();
        SetSessionSiteVar('App.name', path[0]);
        SetSessionSiteVar('App.entity', path[path[path.length - 1]]);
        this.saveNavigationHistory({ name: '', base: path[0], path: state.url });
        return true;
    }
    saveNavigationHistory(history) {
        let historyArray = GetSessionSiteVar(this.sessionVar);
        if (!historyArray)
            historyArray = [];
        // Because a non-existing siteVar returns an object and we need it to be an array.
        if (typeof historyArray[0] === 'undefined')
            historyArray = [];
        // Make sure that we don't have two entries in a row of the same thing.
        if (typeof historyArray[0] !== 'undefined' && historyArray[0].path == history.path)
            return;
        // Add the new entry and keep the multiple_max to 20 for now.
        historyArray.unshift(history);
        if (historyArray.length > 20)
            historyArray.splice(-1, 1);
        SetSessionSiteVar(this.sessionVar, historyArray);
    }
    isPreviousHistory() {
        const historyArray = GetSessionSiteVar(this.sessionVar);
        return IsArray(historyArray, true);
    }
    goBack(count = 1) {
        if (count < 1)
            count = 1;
        const historyArray = GetSessionSiteVar(this.sessionVar);
        const path = window.location.pathname.split('/');
        // If they came from outside of pop then don't send them back there but instead send them to apps main page.
        if (typeof historyArray.length === 'undefined' || typeof historyArray[1] === 'undefined') {
            this.router.navigate(['/']);
            return;
        }
        // The where they should go back to and also purge that route from the array.
        const goBackTo = (historyArray[count] !== 'undefined' ? historyArray[count] : historyArray.slice(-1)[0]);
        if (historyArray.length)
            historyArray.shift();
        SetSessionSiteVar(this.sessionVar, historyArray);
        // If where they are going back to is in the same app then use the router otherwise do reload to sthat route.
        if (goBackTo.base === path[1]) {
            this.router.navigate([goBackTo.path]).catch(() => true);
        }
        else {
            window.location.href = window.location.origin + '/' + goBackTo.base + goBackTo.path;
        }
    }
}
PopRouteHistoryResolver.prov = i0.defineInjectable({ factory: function PopRouteHistoryResolver_Factory() { return new PopRouteHistoryResolver(i0.inject(i1$1.Router)); }, token: PopRouteHistoryResolver, providedIn: "root" });
PopRouteHistoryResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PopRouteHistoryResolver.ctorParameters = () => [
    { type: Router }
];

class PopTabMenuService extends PopExtendService {
    constructor() {
        super();
        this.id = PopUid();
        this.name = 'PopTabMenuService';
        this.asset = {
            core: undefined,
            config: undefined,
            dom: undefined,
            id: undefined,
            map: {},
            outlet: undefined,
            resetOutlet: undefined,
            route: undefined,
            path: undefined,
            clearCache: false
        };
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            entity: ServiceInjector.get(PopEntityService),
            log: ServiceInjector.get(PopLogService),
            router: ServiceInjector.get(Router),
        };
        this.ui = {
            entityParams: undefined
        };
        this.change = new Subject(); // event emitter
        this._setDomExtensions();
        this._initSession();
    }
    _initSession() {
        this.dom.session = Object.assign({ scroll: {}, path: '', fields: {} }, this.dom.session);
    }
    /**
     * Add Buttons to the Tab Menu
     * @param buttons Array<TabButtonInterface>)
     * @returns void
     */
    addButtons(buttons) {
        if (buttons && buttons.length) {
            this.asset.config.buttons.push(...buttons);
            this.asset.map.buttons = ArrayMapSetter(this.asset.config.buttons, 'id');
            this._emitChange('buttons');
        }
    }
    /**
     * Add Tabs to the Tab Menu
     * @param tabs Array<TabInterface>
     * @returns void
     */
    addTabs(tabs) {
        if (tabs && tabs.length) {
            this.asset.config.tabs.push(...tabs);
            this.asset.map.tabs = ArrayMapSetter(this.asset.config.tabs, 'id');
        }
        this._emitChange('tabs');
    }
    /**
     * This fx will cause this srv to remove the cache when it is destroyed
     */
    clearCache() {
        this.asset.clearCache = true;
    }
    /**
     * Remove all Buttons from the Tab Menu
     * @param buttons Array<TabButtonInterface>)
     * @returns void
     */
    clearButtons(buttons) {
        this.asset.config.buttons = [];
        this.asset.map.buttons = ArrayMapSetter(this.asset.config.buttons, 'id');
        this._emitChange('buttons');
    }
    /**
     * Get latest path
     */
    getPathSession() {
        return GetSessionSiteVar(`Entity.${TitleCase(this.asset.core.params.internal_name)}.Menu.path`);
    }
    /**
     * Clear the tab system session
     * Auto called on go back button click
     * @param name
     * @returns void
     */
    clearSession() {
        if (this.asset.core && this.asset.core.params && this.asset.core.params.internal_name) {
            SetSessionSiteVar(`Entity.${TitleCase(this.asset.core.params.internal_name)}.Menu`, null);
        }
    }
    /**
     * Get Misc Data for each tab
     * @param path
     * @returns object
     */
    getTab(id) {
        if (!this.asset.id)
            id = this.asset.path;
        if (this.asset.map.tabs && id in this.asset.map.tabs) {
            return Object.assign({}, this.asset.config.tabs[this.asset.map.tabs[id]]);
        }
        return null;
    }
    /**
     * Get the global metadata stored for the Tab Menu
     * If key is passed, return that specific data else entire object
     * @param key string
     * @returns boolean
     */
    getCore() {
        return this.asset.core;
    }
    /**
     * Set the TabMenuConfig of the Tab Menu
     * The Tab Menu Component auto calls this on creation
     * @param config TabMenuConfig
     * @returns void
     */
    registerConfig(core, config, dom) {
        if (config) {
            this.asset.core = IsObject(core, true) ? core : null;
            this.ui.entityParams = IsObject(this.asset.core, ['params']) ? this.asset.core.params : null;
            this.asset.config = new TabMenuConfig(config);
            // get the users access
            this.asset.map.tabs = ArrayMapSetter(this.asset.config.tabs, 'path');
            this.asset.map.buttons = ArrayMapSetter(this.asset.config.buttons, 'id');
            if (this.asset.core && this.asset.core.params)
                this.dom.session.scroll = GetSessionSiteVar(`Entity.${TitleCase(this.asset.core.params.internal_name)}.Menu.scroll`);
            if (!this.dom.session.scroll)
                this.dom.session.scroll = {};
            // Subscribe to the CRUD events
            this.asset.path = window.location.pathname.split('/').pop();
            // bind to router to detect entity change detection .. effective for cloning, navigation changes
            this.dom.setSubscriber('route-change', this.srv.router.events.subscribe((e) => this._navigationHandler(e)));
            this.dom.state.loaded = true;
            this._resetMenu();
            this._emitChange('config');
            if (this.srv.log.enabled('config', this.name))
                console.log(this.srv.log.message(`${this.name}:registerConfig`), this.srv.log.color('config'), this.asset.config);
            return this.asset.config;
        }
    }
    /**
     * Register an outlet to enable scroll session
     * @param outlet ElementRef
     * @returns void
     */
    registerOutlet(outlet) {
        this.asset.outlet = outlet;
        this._emitChange('outlet');
    }
    /**
     * Register a route to enable entity change detection and enforce the id on the route
     * @param outlet ElementRef
     * @returns void
     */
    registerRoute(route) {
        if (!this.asset.route) {
            this.asset.route = route;
            this._emitChange('route');
            if (+this.asset.route.snapshot.params.id) {
                if (!this.asset.core.entity || +this.asset.core.entity.id !== +this.asset.route.snapshot.params.id) {
                    this.resetTab(true);
                    // this.refreshEntity( this.asset.route.snapshot.params.id, this.asset.dom, null, `${this.name}:registerRoute:conflict` ).then( () => this.resetTab()  );
                }
            }
        }
    }
    /**
     * Register a outletReset function that you want called when on crud operations
     * @param outlet ElementRef
     * @returns void
     */
    registerOutletReset(resetOutlet) {
        this.asset.resetOutlet = resetOutlet;
        this._emitChange('outlet-reset');
    }
    /**
     * This fx will refresh the entity that exist on the this.asset.core
     * @param entityId
     * @param dom
     * @param queryParams
     * @param caller
     */
    refreshEntity(entityId = null, dom, queryParams, caller) {
        return new Promise((resolve) => {
            if (this.asset.core) {
                this.showAsLoading(false);
                this.srv.log.warn(this.name, `refreshEntity:${caller}`);
                if (!this.asset.config) {
                    this.showAsLoading(false);
                    return resolve(false);
                }
                this.dom.setTimeout('refresh', () => {
                    if (!entityId && this.asset.core.entity && +this.asset.core.entity.id)
                        entityId = +this.asset.core.entity.id;
                    if (+entityId) {
                        this.asset.core.params.entityId = entityId;
                        this.srv.entity.refreshCoreEntity(this.asset.core, dom, queryParams).then((entity) => {
                            this._resetMenu();
                            this.asset.core.params.refresh = false;
                            if (typeof this.asset.resetOutlet === 'function') {
                                setTimeout(() => {
                                    this.asset.resetOutlet();
                                    this.showAsLoading(false);
                                    return resolve(true);
                                }, 0);
                            }
                            else {
                                return resolve(true);
                            }
                        });
                    }
                    else {
                        this.showAsLoading(false);
                        return resolve(false);
                    }
                }, 0);
            }
            else {
                this.showAsLoading(false);
                return resolve(false);
            }
        });
    }
    /**
     * This fx will reset the current tab
     * @param clearCache
     */
    resetTab(clearCache = false) {
        if (clearCache) {
            SetPopCacheRedirectUrl(this.srv.router);
        }
        else {
            this._resetMenu();
            // this.asset.core.params.refresh = false;
            if (typeof this.asset.resetOutlet === 'function')
                this.asset.resetOutlet();
        }
    }
    /**
     * This fx will reset a specific position of the current tab
     * @param position
     */
    reloadTabPosition(position = null) {
        if (typeof this.asset.resetOutlet === 'function')
            this.asset.resetOutlet(position);
    }
    /**
     * This will set a flag the the tab will need to refresh
     */
    setTabRefresh() {
        if (this.asset.core && this.asset.core.params) {
            this.asset.core.params.refresh = true;
        }
    }
    /**
     * This fx will set the scroll position of the current tab if was was previously visited
     */
    setTabScrollPosition() {
        if (this.asset.path && this.dom.session.scroll[this.asset.path]) {
            this._setTabScrollPosition(this.dom.session.scroll[this.asset.path]);
        }
    }
    /**
     * This fx will trigger a loading indicator in the current tab
     * @param value
     */
    showAsLoading(value) {
        if (IsObject(this.asset.config, true)) {
            this.asset.config.loading = value ? true : false;
        }
    }
    /**
     * Store the current tab into session memory
     * @param name
     * @returns void
     */
    setPathSession(tab) {
        if (this.asset.core && this.asset.core.params)
            SetSessionSiteVar(`Entity.${TitleCase(this.asset.core.params.internal_name)}.Menu.path`, tab.path);
    }
    /**
     * Add Tabs to the Tab Menu
     * @param path string
     * @returns void
     */
    removeTab(path) {
        if (path in this.asset.map.tabs) {
            this.asset.config.tabs.splice(this.asset.map.tabs[path], 1);
            this.asset.map.tabs = ArrayMapSetter(this.asset.config.tabs, 'id');
        }
        this._emitChange('tabs');
    }
    /**
     * Toggle whether a Button is hidden
     * If value is set to true(show), false(hide), else toggle
     * @param buttons Array<TabButtonInterface>)
     * @returns boolean
     */
    toggleButton(id, value) {
        if (id in this.asset.map.buttons) {
            if (typeof value !== 'undefined') {
                this.asset.config.buttons[this.asset.map.buttons[id]].hidden = value;
            }
            else {
                this.asset.config.buttons[this.asset.map.buttons[id]].hidden = !this.asset.config.buttons[this.asset.map.buttons[id]].hidden;
            }
            this._emitChange('buttons');
            return true;
        }
        return false;
    }
    /**
     * This fx will update main header of the current Tab Menu
     * @param name
     */
    updateName(name) {
        if (IsString(name, true) && this.asset && this.asset.config) {
            this.asset.config.name = name;
        }
    }
    ngOnDestroy() {
        if (this.asset.clearCache) {
            if (IsObject(this.asset.core)) {
                this.asset.core.repo.clearAllCache();
            }
        }
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * If you do not extend of an extension service these have to be set manually
     */
    _setDomExtensions() {
        this.dom = Object.assign(Object.assign({}, this.dom), {
            setSubscriber: (subscriptionKey, subscription = null) => {
                if (subscriptionKey && this.dom.subscriber && subscriptionKey in this.dom.subscriber && this.dom.subscriber[subscriptionKey] && typeof this.dom.subscriber[subscriptionKey].unsubscribe === 'function') {
                    this.dom.subscriber[subscriptionKey].unsubscribe();
                }
                if (subscription) {
                    this.dom.subscriber[subscriptionKey] = subscription;
                }
            },
            setTimeout: (timeoutKey, callback = null, delay = 250) => {
                if (timeoutKey && this.dom.delay && timeoutKey in this.dom.delay && this.dom.delay[timeoutKey]) {
                    clearTimeout(this.dom.delay[timeoutKey]);
                }
                if (typeof callback === 'function') {
                    this.dom.delay[timeoutKey] = setTimeout(callback, delay);
                }
            },
        });
    }
    /**
     * Return to last active tab
     * @returns void
     */
    _isPathSession() {
        this.dom.session.path = this.getPathSession();
        if (this.dom.session.path && this.dom.session.path !== this.asset.path && this.dom.session.path in this.asset.map.tabs) {
            return false;
        }
        return true;
    }
    /**
     * Store current tab scroll position
     * @returns void
     */
    _storeTabScrollPosition() {
        if (this.asset.core && this.asset.core.params && this.asset.path) {
            this.dom.session[this.asset.path] = this._getTabScrollPosition();
            SetSessionSiteVar(`Entity.${TitleCase(this.asset.core.params.internal_name)}.Menu.scroll`, this.dom.session.scroll);
        }
    }
    /**
     * Set current tab scroll position
     * @returns void
     */
    _setTabScrollPosition(scrollTop) {
        if (this.asset.outlet && this.asset.outlet.nativeElement)
            this.asset.outlet.nativeElement.scrollTop = scrollTop;
    }
    /**
     * Get the current tab scroll position
     * @returns number
     */
    _getTabScrollPosition() {
        if (this.asset.outlet && this.asset.outlet.nativeElement)
            return this.asset.outlet.nativeElement.scrollTop;
        return 0;
    }
    /**
     * Verify the id on the route matches the id of the configuration entity
     * @returns number
     */
    _checkId() {
        if (this.asset.route && +this.asset.route.snapshot.params.id) {
            if (!this.asset.config && this.srv.log.enabled('error', this.name))
                console.log(this.srv.log.message(`${this.name}:_checkId:error - Could not find config`), this.srv.log.color('error'));
            if (this.srv.log.enabled('info', this.name))
                console.log(this.srv.log.message(`${this.name}:_checkId route id(${this.asset.route.snapshot.params.id} matches config(${this.asset.core.entity.id}):refresh is ${+this.asset.route.snapshot.params.id !== +this.asset.core.entity.id}`), this.srv.log.color('info'));
            if (!this.asset.core.entity || +this.asset.route.snapshot.params.id !== +this.asset.core.entity.id) {
                this.resetTab(true);
            }
        }
    }
    /**
     * This fx will track the current scroll position of the current tab when navigating away, and session it
     * @param event
     * @private
     */
    _navigationHandler(event) {
        // On a NavigationStart event record the current scroll position of the current tab
        // On a NavigationEnd check to see if a scroll position for the current tab has been stored and apply it
        if (event instanceof NavigationStart && this.asset.path)
            this._storeTabScrollPosition();
        if (event instanceof NavigationEnd) {
            this.asset.path = String(event.url).split('/').pop();
            if (this.asset.route && this._isPathSession() || !this.asset.route) {
                this._checkId();
                if (this.dom.session.scroll[this.asset.path]) {
                    setTimeout(() => {
                        this._setTabScrollPosition(this.dom.session.scroll[this.asset.path]);
                    }, 0);
                }
            }
            else {
                if (this.asset.route)
                    return this.srv.router.navigate([this.dom.session.path], { relativeTo: this.asset.route });
            }
        }
    }
    /**
     * This fx will reseet the current menu options
     * @private
     */
    _resetMenu() {
        if (this.asset.core && this.asset.config) {
            if (this.asset.core.entity && this.asset.core.entity.id)
                this.asset.config.name = DetermineEntityName(this.asset.core.entity);
            if (Array.isArray(this.asset.config.buttons) && this.asset.config.buttons.length && this.asset.core.entity) {
                const archiveKey = StorageGetter(this.asset.core, ['repo', 'model', 'menu', 'archiveKey'], 'archived');
                const btnMap = ArrayMapSetter(this.asset.config.buttons, 'id');
                if ('archive' in btnMap)
                    this.asset.config.buttons[btnMap['archive']].hidden = this.asset.core.entity[archiveKey] ? true : false;
                if ('activate' in btnMap)
                    this.asset.config.buttons[btnMap['activate']].hidden = this.asset.core.entity[archiveKey] ? false : true;
                if ('close' in btnMap)
                    this.asset.config.buttons[btnMap['close']].hidden = this.asset.config.portal ? false : true;
            }
        }
    }
    /**
     * Change detection Emitter
     * @param type strings
     * @returns void
     */
    _emitChange(name, data = '') {
        PopLog.info(this.name, name, data);
        this.change.next({ source: this.name, type: 'tab-menu', name: name, data: data });
    }
}
PopTabMenuService.prov = i0.defineInjectable({ factory: function PopTabMenuService_Factory() { return new PopTabMenuService(); }, token: PopTabMenuService, providedIn: "root" });
PopTabMenuService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopTabMenuService.ctorParameters = () => [];

class PopTabMenuComponent extends PopExtendComponent {
    constructor(el, route, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this.route = route;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopTabMenuComponent';
        this.srv = {
            history: ServiceInjector.get(PopRouteHistoryResolver),
            router: ServiceInjector.get(Router),
            tab: undefined
        };
        /**
         * Configure the component tailored to its specific needs
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                PopTemplate.turnOffFilter();
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configure: - this.config`) ? this.config : null;
                if (this.config.goBack)
                    this.config.goBack = this.srv.history.isPreviousHistory();
                this.dom.setHeight(window.innerHeight - 55, 10);
                this.log.info(`Determined height:${this.dom.height.inner}`);
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._registerConfig().then(() => {
                    setTimeout(() => {
                        this.srv.tab.setTabScrollPosition();
                        this.srv.tab.registerOutlet(this.outletRef);
                    });
                    return resolve(true);
                });
            });
        };
    }
    /**
     * This component should have a purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Go back in history
     * @returns void
     */
    onBackButtonClick() {
        this.srv.tab.clearSession();
        this.srv.history.goBack();
    }
    /**
     * Trigger a menu click event
     * @returns void
     */
    onMenuButtonClick(button) {
        this.log.info(`${this.name}:button`, button);
        this.dom.setTimeout(`stop-loader`, null, 0);
        this.config.loading = true;
        const eventData = {
            source: this.name,
            type: 'button',
            id: button.id,
            name: button.name,
            metadata: (button.metadata ? button.metadata : false)
        };
        this.onBubbleEvent(eventData);
        this.dom.setTimeout(`stop-loader`, () => {
            this.config.loading = false;
        }, 3000);
    }
    /**
     * Trigger a tab click event
     * @returns void
     */
    onTabMenuClick(tab) {
        this.log.info(`onTabMenuClick`, tab);
        this.srv.tab.setPathSession(tab);
        const eventData = {
            source: this.name,
            type: 'tab',
            id: tab.id,
            name: tab.name,
            metadata: (tab.metadata ? tab.metadata : false)
        };
        this.onBubbleEvent(eventData);
    }
    /**
     * Event Emitter
     * @returns void
     */
    onBubbleEvent(eventData) {
        this.events.emit(eventData);
    }
    /**
     * Clean up the dom of this component
     *
     * Clear out data stored for this Tab Menu out of the global service
     */
    ngOnDestroy() {
        if (this.core && this.core.params && this.core.params.entityId)
            this.core.repo.clearCache('entity', String(this.core.params.entityId), `PopTabMenuComponent:ngOnDestroy`);
        // this.srv.tab.reset();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _registerConfig() {
        return new Promise((resolve) => {
            this.config = IsObjectThrowError(this.config, true, `${this.name}:registerConfig: - this.config`) ? this.srv.tab.registerConfig(this.core, this.config, this.dom.repo) : {};
            resolve(true);
        });
    }
}
PopTabMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-tab-menu',
                template: "<div class=\"tab-menu-container\" [style.height.px]=\"dom.height.outer\" [ngClass]=\"{'tab-menu-loading': config.loading}\">\n  <div class=\"mat-elevation-z2\" [ngClass]=\"{'tab-menu-header': config?.goBack, 'tab-menu-header-without-back': !config?.goBack }\" >\n    <div class=\"tab-menu-nav-container\" >\n      <div class=\"tab-menu-back-container\" *ngIf=\"config.goBack\" >\n        <div id=\"back-button\" class=\"tab-menu-back-btn\"  (click)=\"onBackButtonClick();\">\n          <mat-icon>keyboard_arrow_left</mat-icon>\n          <div >Back</div>\n        </div>\n        <div *ngIf=\"config.buttons.length\" class=\"tab-menu-button-container\">\n          <button class=\"tab-menu-button\"\n                  *ngFor=\"let button of config.buttons\"\n                  [ngClass]=\"{'sw-hidden': button.hidden}\"\n                  [disabled]=\"button.disabled\"\n                  mat-raised-button\n                  (click)=\"onMenuButtonClick(button)\">\n            {{button.name}}\n          </button>\n        </div>\n      </div>\n\n    </div>\n    <div class=\"tab-menu-button-header\" >\n      <div class=\"tab-menu-label-container\">{{config.name}}</div>\n\n    </div>\n    <div class=\"tab-menu-link-container\">\n      <nav mat-tab-nav-bar>\n        <a mat-tab-link class=\"mat-body tab-menu-link\"\n           *ngFor=\"let tab of config.tabs\"\n           [routerLink]=\"tab.path\"\n           [ngClass]=\"{'active':rla.isActive}\"\n           (click)=\"onTabMenuClick(tab)\"\n           routerLinkActive #rla=\"routerLinkActive\"\n           [active]=\"rla.isActive\">\n          {{tab.name}}\n        </a>\n      </nav>\n    </div>\n  </div>\n  <div #outlet class=\"sw-target-outlet tab-menu-router-outlet-container\" [style.height.px]=\"dom.height.inner\">\n    <div class=\"tab-menu-loader\">\n      <mat-progress-bar *ngIf=\"config.loading\" mode=\"indeterminate\"></mat-progress-bar>\n    </div>\n    <router-outlet></router-outlet>\n  </div>\n</div>\n",
                styles: [".tab-menu-back-container{padding:var(--gap-xxs) var(--gap-lm) 0 var(--gap-s);display:flex;justify-content:space-between}.tab-menu-back-container mat-icon{width:22px}.tab-menu-back-container .tab-menu-back-btn{color:var(--foreground-base);font-size:14px;min-width:150px;display:flex;align-items:center;justify-content:flex-start;cursor:pointer}.tab-menu-nav-container{height:var(--gap-lm)}.tab-menu-container{position:relative;display:flex;width:auto;flex-direction:column;justify-content:stretch;box-sizing:border-box;overflow-y:hidden}.tab-menu-container .tab-menu-header{height:108px;max-height:108px;background:var(--background-main-menu)}.tab-menu-container .tab-menu-header-without-back{height:108px;max-height:108px}.tab-menu-label-container{padding:0 0 10px 30px;min-width:200px;font-size:20px;color:var(--foreground-base);flex:1 1 auto}.tab-menu-loading{opacity:.9!important;pointer-events:none!important}.tab-menu-container>div{flex:1}.tab-menu-button-header{position:relative;top:5px;display:flex;justify-content:space-between;margin:0;height:37px}.tab-menu-button-container{display:flex!important;justify-content:flex-end;align-items:center;flex:1 1 auto;position:relative;top:var(--gap-m)}.tab-menu-loader{position:absolute;height:2px;overflow:hidden;top:0;left:0;right:0;width:100%;clear:both}.tab-menu-button{margin:0 0 0 var(--gap-s)!important;min-width:100px;height:30px}.tab-menu-link-container{position:relative;top:-7px;display:block;margin:0;padding-left:var(--gap-lm)}.mat-tab-link.active{font-weight:500}.mat-tab-nav-bar{border-bottom:none}.mat-tab-link{min-width:0!important;font-weight:400;color:var(--foreground-base);padding:0 5px;margin-right:var(--gap-m);text-align:left;justify-content:left}.mat-ink-bar{position:absolute;bottom:0;height:10px;transition:.5s cubic-bezier(.35,0,.25,1)}.tab-menu-router-outlet-container{margin-top:2px;position:relative;overflow-y:auto}:host ::ng-deep .mat-raised-button{line-height:20px!important}.tab-menu-link{opacity:1}"]
            },] }
];
PopTabMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ActivatedRoute },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopTabMenuComponent.propDecorators = {
    config: [{ type: Input }],
    header: [{ type: ViewChild, args: ['header', { static: true },] }],
    outletRef: [{ type: ViewChild, args: ['outlet', { static: true },] }]
};

class EntitySchemeSectionConfig {
    constructor(params) {
        this.compact = true;
        this.mapping = {};
        this.modified = false;
        if (params)
            for (const i in params)
                this[i] = params[i];
    }
}

class FieldItemGroupConfig {
    constructor(config) {
        this.fieldItems = [];
        this.layout = 'column';
        this.inDialog = undefined;
        this.position = 1;
        this.entity = null;
        this.http = 'POST';
        this.debug = false;
        for (const i in config)
            this[i] = config[i];
        if (!config.inDialog)
            this.inDialog = null;
        if (config.inDialog && config.inDialog.cancel !== false)
            config.inDialog.cancel = true;
    }
}

class PopActionDialogComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, dialog, data) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.dialog = dialog;
        this.data = data;
        this.name = 'PopActionDialogComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            events: ServiceInjector.get(PopEntityEventService),
            field: ServiceInjector.get(PopEntityUtilFieldService),
            request: ServiceInjector.get(PopRequestService),
            router: ServiceInjector.get(Router),
        };
        this.asset = {
            componentType: undefined,
            entity: {},
            facadeDuration: 250,
            fieldItems: [],
            fieldItemMap: undefined,
            submitText: 'Submit',
            visible: 0,
            http: 'POST',
            postUrl: null,
            goToUrl: null,
        };
        this.ui = {
            form: new FormGroup({}),
            submitText: 'Submit',
            header: 'New'
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this._setInitialConfig();
                yield this._setAction();
                yield this._setFieldItems();
                yield this._setAdditionalConfig();
                yield this._buildFormGroup();
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._renderFieldItems();
                this._renderComponent();
                const hasChild = this.asset.fieldItems.find((fieldItem) => StorageGetter(fieldItem, ['model', 'options', 'child'], null));
                this._resetComponentListHidden();
                if (hasChild) {
                    this._triggerParentChildUpdates(hasChild.model.name);
                }
                else {
                    this._triggerFormValidation();
                }
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Intercept the enter press to check if the form can be submitted
     * @param event
     */
    onEnterPress(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.dom.state.validated) {
            this.dom.setTimeout(`submit-form`, () => {
                return this.onFormSubmit();
            }, 250);
        }
    }
    /**
     * The user can click a cancel btn to close the action dialog
     */
    onFormCancel() {
        this.dom.state.loaded = false;
        this.dom.state.loading = true;
        this.dom.setTimeout(`close-modal`, () => {
            this.dialog.close(-1);
        }, 250);
    }
    /**
     * The user will press enter or click a submit btn to submit the form
     */
    onFormSubmit() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.dom.state.validated && !this.dom.state.pending) {
                this._onSubmissionStart();
                const params = this.ui.form.value; // get form value before disabling form
                // this.dom.asset.form_group.disable(); //bad idea disabled through css
                if (!this.action.facade) {
                    const method = `do${TitleCase(this.asset.http)}`;
                    const request = this.srv.request[method](this.asset.postUrl, params, 1, false);
                    request.subscribe((result) => __awaiter(this, void 0, void 0, function* () {
                        result = GetHttpResult(result);
                        const goToUrl = this.asset.goToUrl;
                        this.asset.entity = result;
                        yield this._onSubmissionSuccess();
                        this.dialog.close(this.asset.entity);
                        if (IsString(goToUrl, true)) {
                            const newGoToUrl = ParseLinkUrl(String(goToUrl).slice(), this.asset.entity);
                            this.log.info(`onFormSubmit:goToUrl`, newGoToUrl);
                            this.log.info(`onFormSubmit:entity`, this.asset.entity);
                            this.srv.router.navigate([newGoToUrl]).catch((e) => {
                                console.log(e);
                            });
                        }
                        return resolve(true);
                    }), err => {
                        this._onSubmissionFail();
                        this._setErrorMessage(GetHttpErrorMsg(err));
                        return resolve(false);
                    });
                }
                else {
                    yield Sleep(this.asset.facadeDuration);
                    yield this._onSubmissionSuccess();
                    let response = IsObject(params) ? params : {};
                    if (this.action.responseType === 'boolean') {
                        response = true;
                    }
                    else if (this.action.responseType === 'store') {
                        response = IsObject(this.action.store) ? this.action.store : {};
                    }
                    this.dialog.close(response);
                    return resolve(true);
                }
            }
        }));
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *               These are protected instead of private so that they can be overridden          *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx will perform the intial config of this component
     * @private
     */
    _setInitialConfig() {
        return new Promise((resolve) => {
            if (!this.dom.state.loaded) {
                this.template.attach('container'); // container references the @viewChild('container')
                if (IsObject(this.data.core, true))
                    this.core = this.data.core;
                if (IsObject(this.data.action, true))
                    this.action = this.data.action;
                if (IsString(this.data.actionName, true))
                    this.actionName = this.data.actionName;
                if (IsObject(this.data.extension, true))
                    this.extension = this.data.extension;
                if (!IsObject(this.extension, true))
                    this.extension = {};
                // actionFieldItems.sort( DynamicSort( 'sort' ) );
                if (!(IsString(this.ui.submitText, true)))
                    this.ui.submitText = 'Submit';
                this.dom.state.validated = false;
                this.dom.state.template = 'collection';
                delete this.data;
                this.dom.handler.bubble = (core, event) => __awaiter(this, void 0, void 0, function* () {
                    this.log.event(`bubble:handler`, event);
                    if (this.action.responseType === 'store')
                        this._handleStoreEvent(event);
                    if (IsCallableFunction(this.action.onEvent))
                        yield this.action.onEvent(core, Object.assign(Object.assign({}, event), {
                            entity: this.asset.entity,
                            form: this.ui.form,
                            metadata: {
                                fieldItems: this.asset.fieldItems
                            }
                        }));
                    // Todo:: Are we seeing this event here, on single input forms submit button is not be activated
                    if (event.name === 'onKeyUp' || event.name === 'onInvalidChange') {
                        this.dom.state.validated = false;
                        this.dom.setTimeout(`trigger-validation`, () => {
                            this._triggerFormValidation();
                        }, 250);
                    }
                    else if (IsValidFieldPatchEvent(this.core, event)) {
                        if (event.config.name in this.asset.entity) {
                            const newValue = isNaN(event.config.control.value) ? event.config.control.value : +event.config.control.value;
                            this.asset.entity[event.config.name] = newValue;
                            if (this.asset.fieldItems.length > 1) {
                                this._resetComponentListHidden();
                                this.dom.setTimeout(`update-relations`, () => {
                                    this._triggerParentChildUpdates(event.config.name);
                                }, 0);
                            }
                            else {
                                this._triggerFormValidation();
                            }
                        }
                    }
                    // if( event.config.bubble || [ 'patch' ].includes( event.name ) ){
                    this.events.emit(event);
                    // }
                });
            }
            return resolve(true);
        });
    }
    /**
     * This fx will perform additional config of this component that has initial config dependencies
     * @private
     */
    _setAdditionalConfig() {
        return new Promise((resolve) => {
            let goToUrl = IsString(this.extension.goToUrl, true) ? this.extension.goToUrl : (this.action.goToUrl ? this.action.goToUrl : null);
            if (goToUrl)
                goToUrl = ParseModelValue(goToUrl, this.core, true);
            const storage = IsObject(this.core.entity, ['id', 'name']) && !this.action.blockEntity ? this.core.entity : (IsObject(this.asset.entity, true) ? this.asset.entity : {});
            let postUrl = IsString(this.extension.postUrl, true) ? this.extension.postUrl : (this.action.postUrl ? ParseLinkUrl(String(this.action.postUrl).slice(), storage) : this.core.params.path);
            if (postUrl)
                postUrl = ParseModelValue(postUrl, this.core, true);
            if (+this.action.facadeDuration)
                this.asset.facadeDuration = this.action.facadeDuration;
            if (+this.action.facadeDuration > 2000) {
                this.action.facadeDuration = 2000;
            }
            this.asset.goToUrl = goToUrl;
            this.asset.postUrl = postUrl;
            this.ui.submitText = IsString(this.action.submitText, true) ? this.action.submitText : 'Submit';
            this.asset.submitText = this.action.submitText;
            if (IsString(this.action.http))
                this.asset.http = this.action.http;
            this.ui.header = IsString(this.action.header, true) ? this.action.header : `${TitleCase(this.action.name)} ${SnakeToPascal(this.core.repo.getDisplayName())}`;
            return resolve(true);
        });
    }
    /**
     * This fx will trigger the form validation
     * @private
     */
    _buildFormGroup() {
        return new Promise((resolve) => {
            if (IsArray(this.asset.fieldItems, true)) {
                this.asset.fieldItems.map((field) => {
                    if (field.config && field.config.control) {
                        this.ui.form.addControl(field.config.name, field.config.control);
                        this.asset.visible++;
                    }
                });
            }
            return resolve(true);
        });
    }
    /**
     * This fx will take any patch event that occurs and store the key value pair
     * @param event
     * @private
     */
    _handleStoreEvent(event) {
        this.log.event(`_handleStoreEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event)) {
            if (!(IsObject(this.action.store)))
                this.action.store = {};
            this.action.store[event.config.name] = event.config.control.value;
        }
        this.log.info(`_handleStoreEvent: store`, this.action.store);
    }
    /**
     * This fx will trigger the form validation
     * @private
     */
    _triggerFormValidation() {
        this.dom.setTimeout(`trigger-form-validation`, () => {
            this._validateForm().then((valid) => {
                this.dom.state.validated = valid;
            });
        }, 50);
    }
    /**
     * The form needs to able to make api calls to verify info for certain fields
     * ToDo:: Allow the config to be able to pass in api validation calls for certain fields
     * @private
     */
    _validateForm() {
        return new Promise((resolve) => {
            this.dom.state.validated = false;
            this.dom.setTimeout(`trigger-form-validation`, null);
            this.dom.setTimeout(`validate-form`, () => {
                this.ui.form.updateValueAndValidity();
                setTimeout(() => {
                    this.dom.state.validated = true; // mock stub for now
                    return resolve(this.ui.form.valid);
                }, 0);
            }, 0);
        });
    }
    /**
     * This fx will handle the error messaging
     * @param message
     * @private
     */
    _setErrorMessage(message) {
        this.dom.error.message = message;
        // this.dom.setTimeout('message', () => {
        //   this.dom.error.message = '';
        //   this.dom.setTimeout('message', null, 0);
        // }, 3000);
    }
    /**
     * This hook is called when the form is submitting
     * @private
     */
    _onSubmissionStart() {
        this.dom.setTimeout('message', null, 0);
        this.dom.error.message = '';
        this.dom.state.pending = true;
        this.ui.submitText = '';
    }
    /**
     * This hook is called when the form submission has failed
     * @private
     */
    _onSubmissionFail() {
        // Re-Enable Form and show error
        this.dom.state.pending = false;
        this.dom.state.template = 'fail';
        this.ui.submitText = IsString(this.action.submitText, true) ? this.action.submitText : 'Submit';
    }
    /**
     * This hook is called when the form has submitted successfully
     * @private
     */
    _onSubmissionSuccess() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.state.template = 'success';
            this.dom.state.pending = false;
            this.core.repo.clearAllCache(this.name);
            if (IsCallableFunction(this.action.callback)) {
                this.dom.setTimeout(`action-callback`, () => __awaiter(this, void 0, void 0, function* () {
                    const actionEvent = {
                        type: 'entity',
                        source: this.name,
                        name: this.action.name,
                        entity: this.asset.entity,
                        action: this.action,
                        data: this.ui.form.value
                    };
                    yield this.action.callback(this.core, actionEvent, this.dom);
                }), 0);
            }
            const crudEvent = {
                source: this.name,
                method: 'create',
                type: 'entity',
                name: this.core.params.name,
                internal_name: this.core.params.internal_name,
                data: this.asset.entity
            };
            this.srv.events.sendEvent(crudEvent);
            return resolve(true);
        }));
    }
    /**
     * This fx will render all of the fields that were passed through in the action config
     * @private
     */
    _renderFieldItems() {
        const componentList = [];
        this.asset.fieldItems.map((fieldItem, index) => {
            if (fieldItem && IsObject(fieldItem.model, ['name']) && fieldItem.config && fieldItem.component) {
                const existingValue = 'control' in fieldItem.config ? fieldItem.config.control.value : null;
                this.asset.entity[fieldItem.model.name] = existingValue;
                if (this.action.bubbleAll)
                    fieldItem.config.bubble = true;
                const component = {
                    type: fieldItem.component,
                    inputs: {
                        config: fieldItem.config,
                        position: fieldItem.config['metadata'].position ? fieldItem.config['metadata'].position : 1,
                        hidden: IsArray(fieldItem.model.when, true) ? !(EvaluateWhenCondition(this.core, fieldItem.model.when, this.core)) : false,
                        when: IsArray(fieldItem.model.when, true) ? fieldItem.model.when : null
                    }
                };
                componentList.push(component);
            }
        });
        this.template.render(componentList, [], true);
    }
    /**
     * This fx will render the a component that was passed in through the action config
     * @private
     */
    _renderComponent() {
        if (IsObject(this.action.component, ['type']) && this.portal) {
            if (this.portal.attachedRef)
                this.portal.detach();
            this.dom.setSubscriber('portal-events', null);
            const componentRef = this.portal.attach(new ComponentPortal(this.action.component.type));
            componentRef.instance['core'] = this.core;
            if (IsObject(this.action.component, ['inputs'])) {
                Object.keys(this.action.component.inputs).map((key) => {
                    componentRef.instance[key] = this.action.component.inputs[key];
                });
            }
            componentRef.changeDetectorRef.detectChanges();
            if (componentRef.instance['events']) {
                this.dom.setSubscriber('portal-events', componentRef.instance['events'].subscribe((event) => __awaiter(this, void 0, void 0, function* () {
                    if (this.action.responseType === 'store') {
                        this._handleStoreEvent(event);
                    }
                    if (IsCallableFunction(this.action.onEvent))
                        yield this.action.onEvent(this.core, Object.assign(Object.assign({}, event), {
                            entity: this.asset.entity,
                            form: this.ui.form,
                            metadata: {
                                fieldItems: this.asset.fieldItems
                            }
                        }));
                })));
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx will resolve the config of action that pop is suppose to perform
     * @private
     */
    _setAction() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(this.action, true)) {
                if (!(IsDefined(this.action.responseType)))
                    this.action.responseType = 'form';
                this.dom.state.hasComponent = IsObject(this.action.component, ['type']);
                this.dom.state.hasFields = IsObject(this.action.fields, true);
                return resolve(true);
            }
            else if (IsString(this.actionName) && IsObject(this.core.repo.model.action, [this.actionName]) && IsObject(this.core.repo.model.action[this.actionName], true)) {
                this.action = this.core.repo.model.action[this.actionName];
                if (!(IsDefined(this.action.responseType)))
                    this.action.responseType = 'form';
                this.dom.state.hasComponent = IsObject(this.action.component, ['type']);
                this.dom.state.hasFields = IsObject(this.action.fields, true);
                return resolve(true);
            }
            else {
                this.dom.state.hasComponent = false;
                this.dom.state.hasFields = false;
                return resolve(false);
            }
        }));
    }
    /**
     * A helper method that sets build the field item definitions
     * @param entityConfig
     * @param goToUrl
     */
    _setFieldItems() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(this.action, ['fields']) && IsObject(this.action.fields, true)) {
                const actionFieldItems = {};
                this.asset.fieldItems = [];
                this.asset.fieldItemMap = {};
                let needsResource = false;
                Object.keys(this.action.fields).map((name) => {
                    let field = {};
                    if (!this.action.blockEntity && name in this.core.repo.model.field) {
                        field = this.core.repo.model.field[name];
                    }
                    let model = {};
                    if (field.when)
                        model.when = JsonCopy(field.when);
                    if (IsObject(field.model, true)) {
                        model = Object.assign(Object.assign({}, model), field.model);
                    }
                    let actionTransformation;
                    if (IsObject(this.action.fields[name], true)) {
                        actionTransformation = IsString(this.action.fields[name].transformation, true) ? this.action.fields[name].transformation : null;
                        model = Object.assign(Object.assign({}, model), this.action.fields[name]);
                    }
                    // delete model.metadata;
                    delete model.transformation;
                    if (actionTransformation)
                        model.transformation = actionTransformation; // only want to apply transformation if it was set directly on action
                    model.value = IsDefined(model.value) ? ParseModelValue(model.value, this.core) : null;
                    // model.value = IsDefined( model.value ) ? ParseModelValue(model.value, core) : null;
                    if (!model.value && IsObject(model.options, ['defaultValue'])) {
                        model.value = ParseModelValue(model.options.defaultValue, this.core);
                    }
                    model.hidden = !EvaluateWhenConditions(this.core, model.when, this.core);
                    if (IsObject(this.extension, true) && model.name in this.extension) {
                        model.value = ParseModelValue(this.extension[model.name]);
                        model.readonly = true;
                        this.asset.entity[model.name] = model.value;
                    }
                    model.tabOnEnter = true;
                    actionFieldItems[name] = model;
                    if (model.options && model.options.resource) {
                        needsResource = true;
                    }
                });
                // if needsMetadata go grab it before you try to build out the fields
                if (needsResource) {
                    const resource = yield this.core.repo.getUiResource(this.core);
                    if (IsObject(resource, true))
                        DeepMerge(this.core.resource, resource);
                    PopLog.init(this.name, `doAction:needed resource`, resource);
                    Object.keys(actionFieldItems).map((name) => {
                        const fieldItem = actionFieldItems[name];
                        const actionItemModel = FieldItemModel(this.core, JsonCopy(fieldItem), false);
                        const actionItem = this.srv.field.buildCoreFieldItem(this.core, actionItemModel);
                        if (IsObject(actionItem.config, true)) {
                            actionItem.config.facade = true;
                            if (IsObject(actionItem.config.patch)) {
                                const patch = actionItem.config.patch;
                                patch.duration = 0;
                                patch.path = null;
                                patch.displayIndicator = false;
                            }
                        }
                        this.asset.fieldItemMap[name] = this.asset.fieldItems.length;
                        this.asset.fieldItems.push(actionItem);
                    });
                }
                else {
                    // no metadata was needed for any of these fields
                    Object.keys(actionFieldItems).map((name) => {
                        const actionItemModel = FieldItemModel(this.core, actionFieldItems[name], false);
                        const actionItem = this.srv.field.buildCoreFieldItem(this.core, actionItemModel);
                        if (IsObject(actionItem.config, true)) {
                            actionItem.config.facade = true;
                            if (IsObject(actionItem.config.patch)) {
                                const patch = actionItem.config.patch;
                                patch.duration = 0;
                                patch.path = null;
                                patch.displayIndicator = false;
                            }
                        }
                        this.asset.fieldItemMap[name] = this.asset.fieldItems.length;
                        this.asset.fieldItems.push(actionItem);
                    });
                    PopTemplate.clear();
                }
                // console.log('this.asset.fieldItems', this.asset.fieldItems);
                this.asset.fieldItems.map((fieldItem) => {
                    if (IsArray(StorageGetter(fieldItem, ['config', 'options', 'values']), true)) {
                        // console.log('here', fieldItem);
                        fieldItem.config.height = 180;
                    }
                });
                return resolve(true);
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * Determine if field should be auto filled with the first item in the list
     * @param name
     */
    _fieldHasAutoFill(name) {
        if (name in this.asset.fieldItemMap && this.asset.fieldItems[this.asset.fieldItemMap[name]].model && this.asset.fieldItems[this.asset.fieldItemMap[name]].model.options) {
            if (this.asset.fieldItems[this.asset.fieldItemMap[name]].model.autoFill) {
                return true;
            }
        }
        return false;
    }
    /**
     * Determine if field has a child relation in the list
     * @param name
     */
    _fieldHasChild(name) {
        if (name in this.asset.fieldItemMap && this.asset.fieldItems[this.asset.fieldItemMap[name]].model && this.asset.fieldItems[this.asset.fieldItemMap[name]].model.options) {
            if (this.asset.fieldItems[this.asset.fieldItemMap[name]].model.options.child) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get a linear list of the parent child relations from a given point
     * @param self the name to start from (usually the field that has just been changed by user)
     * @param list
     */
    _getRelationList(name, list = []) {
        let item;
        if (name && name in this.asset.fieldItemMap) {
            item = this.asset.fieldItems[this.asset.fieldItemMap[name]];
            if (IsObject(item, ['config', 'model'])) {
                list.push({
                    name: item.config.name,
                    autoFill: this._fieldHasAutoFill(name),
                });
                if (this._fieldHasChild(name)) {
                    this._getRelationList(this.asset.fieldItems[this.asset.fieldItemMap[name]].model.options.child, list);
                }
            }
        }
        return list;
    }
    /**
     * Whenever a update to the entity happens the fields in the group should be re-evaluated if there are when conditionals set
     * @private
     */
    _resetComponentListHidden() {
        let name;
        this.template.refs.filter((componentRef) => {
            return IsObject(componentRef.instance.config, true) && IsArray(componentRef.instance.when, true);
        }).map((componentRef) => {
            name = componentRef.instance.config.name;
            if (name && name in this.asset.fieldItemMap) {
                componentRef.instance.hidden = !EvaluateWhenCondition(this.asset, componentRef.instance.when);
            }
        });
    }
    /**
     * This fx will manage if the form fields have parent child relations, ie if an account select needs to be filtered by a client select that exists in the form
     * @param name
     * @private
     */
    _triggerParentChildUpdates(name) {
        if (this._fieldHasChild(name)) {
            let values;
            let child_fk;
            let childField;
            let autoFill = false;
            let set;
            let resource;
            const relations = this._getRelationList(name);
            relations.some((relation) => {
                if (relation.autoFill) {
                    autoFill = true;
                    return true;
                }
            });
            if (name && name in this.asset.fieldItemMap) {
                child_fk = this.asset.fieldItems[this.asset.fieldItemMap[name]].model.options.child;
                if (child_fk && child_fk in this.asset.fieldItemMap) {
                    childField = this.asset.fieldItems[this.asset.fieldItemMap[child_fk]];
                    if (childField.model.form === 'select') {
                        if (childField.model.options.resource) {
                            if (IsObject(this.core.resource[childField.model.options.resource], ['data_values'])) {
                                resource = this.core.resource[childField.model.options.resource].data_values;
                            }
                        }
                        if (IsArray(resource, true)) {
                            values = ConvertArrayToOptionList(resource, {
                                // ensure that an option shows up in list in case other conditions remove it, aka it has been archived
                                prevent: [],
                                // parent means this options should all have a common field trait like client_fk, account_fk ....
                                parent: childField.model.options.parent ? {
                                    field: childField.model.options.parent,
                                    value: this.asset.entity[childField.model.options.parent]
                                } : null,
                                empty: childField.model.options.empty ? childField.model.options.empty : null,
                            });
                        }
                        else {
                            values = [];
                        }
                        if (autoFill && values.length) {
                            set = values[values.length - 1].value;
                        }
                        else {
                            set = null;
                        }
                        childField.config.options.values = values;
                        autoFill = autoFill && values.length ? values[0].value : null;
                        if (typeof childField.config.triggerOnChange === 'function')
                            childField.config.triggerOnChange(set);
                        this.dom.setTimeout(`clear-message-${child_fk}`, () => {
                            if (typeof childField.config.clearMessage === 'function') {
                                childField.config.clearMessage();
                            }
                        }, 0);
                    }
                }
            }
        }
        this._triggerFormValidation();
    }
}
PopActionDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-action-dialog',
                template: "<div [ngClass]=\"{'sw-hidden': !dom.state.loaded}\" class=\"pop-action-close-btn sw-pointer\" (click)=\"onFormCancel();\">\n  <mat-icon>close</mat-icon>\n</div>\n<div class=\"pop-action-container\" [ngClass]=\"{'sw-hidden': !dom.state.loaded}\">\n  <div class=\"pop-action-dialog-header\" *ngIf=\"ui.header\">{{ui.header}}</div>\n  <div class=\"pop-action-dialog-content\">\n    <form (keyup.enter)=\"onEnterPress($event);\" [formGroup]=\"ui.form\" [className]=\"dom.state.pending ? 'pop-action-dialog-field-lock' : ''\">\n      <div class=\"import-flex-row\">\n        <div class=\"import-flex-column-break\" [ngClass]=\"{'sw-hidden': !dom.state.hasFields}\">\n          <template #container></template>\n        </div>\n        <div class=\"pop-action-spacer\" *ngIf=\"dom.state.hasFields && dom.state.hasComponent\" [style.width.px]=\"20\">\n\n        </div>\n        <div class=\"import-flex-column-break pop-action-portal-container\" [ngClass]=\"{'sw-hidden': !dom.state.hasComponent}\">\n          <ng-template [cdkPortalOutlet]></ng-template>\n        </div>\n      </div>\n    </form>\n  </div>\n  <div class=\"pop-action-dialog-buttons\">\n    <button class=\"pop-action-dialog-cancel\" mat-raised-button (click)=\"onFormCancel();\" [disabled]=\"dom.state.pending\">\n      Cancel\n    </button>\n    <button class=\"pop-action-dialog-other\" mat-raised-button color=\"accent\" (click)=\"onFormSubmit()\" [disabled]=\"!dom.state.validated || dom.state.pending\">\n      <span *ngIf=\"!dom.state.pending\">{{ui.submitText}}</span>\n      <div *ngIf=\"dom.state.pending\">\n        <mat-spinner diameter=\"20\"></mat-spinner>\n      </div>\n    </button>\n  </div>\n  <div class=\"pop-action-dialog-message-layout\" *ngIf=\"dom.state.success || dom.error?.message\" [@slideInOut]>\n    <div *ngIf=\"dom.state.success\" class=\"pop-action-dialog-success\" [innerHTML]=dom.state.success></div>\n    <div *ngIf=\"dom.error.message\" class=\"pop-action-dialog-errors\" [innerHTML]=dom.error.message></div>\n  </div>\n</div>\n<div class=\"pop-action-spinner-box\" *ngIf=\"dom.state.loading\">\n  <lib-main-spinner></lib-main-spinner>\n</div>\n",
                animations: [
                    slideInOut
                ],
                styles: [".pop-action-container{flex:1;padding-bottom:50px}.pop-action-close-btn{position:absolute;top:-20px;right:-20px}.pop-action-dialog-header{font-weight:500;text-align:center;margin-bottom:var(--gap-s)}.pop-action-dialog-content{position:relative;display:block;width:100%;min-height:30px;margin-bottom:10px;padding-bottom:50px}.pop-action-dialog-content .pop-action-dialog-field{margin-bottom:10px}.pop-action-dialog-content .pop-action-dialog-field-lock{pointer-events:none!important}.pop-action-dialog-content .pop-action-dialog-field-spinner{position:absolute;left:50%;top:50%;margin-left:-22px;margin-top:-40px}.pop-action-dialog-buttons{margin-top:20px;margin-bottom:10px;display:flex;justify-content:flex-end}.pop-action-dialog-buttons .pop-action-dialog-cancel{order:1;display:flex;align-items:center;justify-content:center;min-height:35px;min-width:120px}.pop-action-dialog-buttons .pop-action-dialog-other{order:2;display:flex;align-items:center;justify-content:center;margin-left:10px;min-width:120px;min-height:35px}.pop-action-dialog-errors{color:var(--warn);text-align:center;word-break:break-word}.pop-action-dialog-success{color:var(--success);text-align:center;word-break:break-word}.pop-action-dialog-message-layout{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:center;text-align:center;margin-top:var(--gap-xl)}.pop-action-dialog-disabled{pointer-events:none}.pop-action-spinner-box{height:150px}.import-flex-column-break{min-width:350px;max-width:350px}.pop-action-portal-container{padding-top:18px}"]
            },] }
];
PopActionDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
PopActionDialogComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    portal: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }],
    action: [{ type: Input }],
    actionName: [{ type: Input }],
    extension: [{ type: Input }]
};

class PopEntityActionService extends PopExtendService {
    constructor() {
        super();
        this.name = 'PopEntityActionService';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            field: ServiceInjector.get(PopEntityUtilFieldService)
        };
        this.asset = {
            dialogRef: undefined,
            field: ServiceInjector.get(PopEntityUtilFieldService)
        };
    }
    do(core, action, extension, blockEntity = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.asset.dialogRef && this._checkArgs(core, action)) {
                this.asset.dialogRef = this.srv.dialog.open(PopActionDialogComponent, {
                    disableClose: true,
                    width: extension && extension.width ? (IsNumber(extension.width) ? `${extension.width}px` : `${extension.width}`) : '400px',
                    data: {
                        core: core,
                        extension: extension,
                        actionName: IsString(action, true) ? action : null,
                        action: IsObject(action, true) ? action : null,
                    },
                    panelClass: 'sw-mat-dialog-flex'
                });
                this.dom.setSubscriber('pop-action-dialog-close', this.asset.dialogRef.beforeClosed().subscribe((res) => {
                    res = GetHttpResult(res);
                    this.asset.dialogRef = null;
                    return resolve(res);
                }));
            }
            else {
                return resolve(null);
            }
        }));
    }
    _checkArgs(core, action, extension) {
        if (IsObject(core, ['params', 'access'])) {
            if (IsString(action, true) || IsObject(action, ['name'])) {
                return true;
            }
        }
        return false;
    }
    /**
     * A helper method that sets up a FieldGroupConfig for a create/new pop-table-dialog
     * @param entityConfig
     * @param goToUrl
     */
    doAction(core, actionName, extension) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            PopTemplate.buffer();
            if (IsObject(core.repo.model.action, [actionName]) && IsObject(core.repo.model.action[actionName], true)) {
                const action = core.repo.model.action[actionName];
                PopLog.info(this.name, `doAction`, { core: core, actionName: actionName, action: action, extension: extension });
                const actionItems = [];
                let needsResource = false;
                let model;
                const actionFieldItems = {};
                // start with getting fields labeled for new doAction
                if (IsObject(action.fields, true)) {
                    Object.keys(action.fields).map((name) => {
                        let field = {};
                        if (name in core.repo.model.field) {
                            field = core.repo.model.field[name];
                        }
                        model = {};
                        if (field.when)
                            model.when = JsonCopy(field.when);
                        if (IsObject(field.model, true)) {
                            model = Object.assign(model, field.model);
                        }
                        let actionTransformation;
                        if (IsObject(action.fields[name], true)) {
                            actionTransformation = IsString(action.fields[name].transformation, true) ? action.fields[name].transformation : null;
                            model = Object.assign(model, action.fields[name]);
                        }
                        // delete model.metadata;
                        delete model.transformation;
                        if (actionTransformation)
                            model.transformation = actionTransformation; // only want to apply transformation if it was set directly on action
                        model.value = IsDefined(model.value) ? ParseModelValue(model.value, core) : null;
                        // model.value = IsDefined( model.value ) ? ParseModelValue(model.value, core) : null;
                        if (!model.value && IsObject(model.options, ['defaultValue'])) {
                            model.value = ParseModelValue(model.options.defaultValue, core);
                        }
                        model.hidden = !EvaluateWhenConditions(core, model.when, core);
                        if (IsObject(extension, true) && model.name in extension) {
                            model.value = ParseModelValue(extension[model.name]);
                            model.readonly = true;
                        }
                        model.tabOnEnter = true;
                        actionFieldItems[name] = model;
                        if (model.options && model.options.resource) {
                            needsResource = true;
                        }
                    });
                }
                // if needsMetadata go grab it before you try to build out the fields
                if (needsResource) {
                    const resource = yield core.repo.getUiResource(core);
                    if (IsObject(resource, true))
                        DeepMerge(core.resource, resource);
                    PopLog.init(this.name, `doAction:needed resource`, resource);
                    Object.keys(actionFieldItems).map((name) => {
                        const actionItemModel = FieldItemModel(core, actionFieldItems[name], false);
                        const actionItem = this.srv.field.buildCoreFieldItem(core, actionItemModel);
                        if (IsObject(actionItem.config, true)) {
                            actionItem.config.facade = true;
                            if (IsObject(actionItem.config.patch)) {
                                const patch = actionItem.config.patch;
                                patch.duration = 0;
                                patch.path = null;
                                patch.displayIndicator = false;
                            }
                        }
                        actionItems.push(actionItem);
                    });
                    PopTemplate.clear();
                    console.log('actionItems', actionItems);
                    return resolve(this.getActionDialogConfig(core, action, actionItems, core.resource));
                }
                else {
                    // no metadata was needed for any of these fields
                    Object.keys(actionFieldItems).map((name) => {
                        const actionItemModel = FieldItemModel(core, actionFieldItems[name], false);
                        const actionItem = this.srv.field.buildCoreFieldItem(core, actionItemModel);
                        if (IsObject(actionItem.config, true)) {
                            actionItem.config.facade = true;
                            if (IsObject(actionItem.config.patch)) {
                                const patch = actionItem.config.patch;
                                patch.duration = 0;
                                patch.path = null;
                                patch.displayIndicator = false;
                            }
                        }
                        actionItems.push(actionItem);
                    });
                    PopTemplate.clear();
                    console.log('actionItems', actionItems);
                    const actionConfig = this.getActionDialogConfig(core, action, actionItems, (IsObject(core.entity, true) ? core.entity.ui : {}));
                    PopLog.info(this.name, `doAction: config`, actionConfig);
                    return resolve(actionConfig);
                }
            }
            else {
                PopTemplate.clear();
                PopTemplate.error({ message: `${TitleCase(actionName)} not configured.`, code: 500 });
                return resolve(null);
            }
        }));
    }
    /**
     * Callback helper to newEntity
     * @param entityConfig
     * @param fields
     * @param metadata
     * @param goToUrl
     */
    getActionDialogConfig(core, action, actionFieldItems, metadata, extension) {
        if (!IsObject(extension))
            extension = {};
        actionFieldItems.sort(DynamicSort('sort'));
        let goToUrl = IsString(extension.goToUrl, true) ? extension.goToUrl : (action.goToUrl ? action.goToUrl : null);
        if (goToUrl)
            goToUrl = ParseModelValue(goToUrl, core, true);
        let postUrl = IsString(extension.postUrl, true) ? extension.postUrl : (action.postUrl ? ParseLinkUrl(String(action.postUrl).slice(), (IsObject(core.entity, true) ? core.entity : {})) : core.params.path);
        if (postUrl)
            postUrl = ParseModelValue(postUrl, core, true);
        const dialogConfig = new FieldItemGroupConfig({
            id: action.name,
            params: core.params,
            fieldItems: actionFieldItems,
            metadata: metadata,
            inDialog: {
                postUrl: postUrl,
                postUrlVersion: 1,
                submit: TitleCase(action.submitText),
                title: action.header ? action.header : `${TitleCase(action.name)} ${SnakeToPascal(core.repo.getDisplayName())}`,
                goToUrl: goToUrl,
                callback: IsCallableFunction(action.callback) ? action.callback : null
            }
        });
        PopLog.init(this.name, `ActionDialog`, dialogConfig);
        return dialogConfig;
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityActionService.prov = i0.defineInjectable({ factory: function PopEntityActionService_Factory() { return new PopEntityActionService(); }, token: PopEntityActionService, providedIn: "root" });
PopEntityActionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntityActionService.ctorParameters = () => [];

class PopEntitySchemeCustomComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntitySchemeCustomComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            action: ServiceInjector.get(PopEntityActionService),
            tab: undefined,
        };
        this.asset = {
            dialogRef: undefined
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.template.attach('container');
                yield this._setInitialConfig();
                yield this._setInitialState();
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (IsObject(this.config, true)) {
                    yield this._setInitialProceed();
                    yield this._renderComponent();
                }
                return resolve(true);
            }));
        };
    }
    /**
     * INit
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This fx will present a pop up for the user to configure the options of this widget
     */
    onEditComponentOptions() {
        // TODO implement like edit popup
        this.dom.setTimeout(`edit-item`, () => __awaiter(this, void 0, void 0, function* () {
            if (StorageGetter(this.config, ['option', 'component', 'type'], null)) {
                const actionConfig = {
                    name: 'widgets',
                    header: 'Edit Widget',
                    component: {
                        type: this.config.option.component.type,
                        inputs: {
                            config: JsonCopy(this.config)
                        }
                    },
                    // onEvent: (core: CoreConfig, event: PopBaseEventInterface): Promise<boolean> => {
                    //   return new Promise(async(resolve) => {
                    //     return resolve(true);
                    //   });
                    // },
                    submitText: 'SAVE',
                    facade: true,
                    postUrl: null,
                    blockEntity: true,
                    responseType: 'store', // track all the key-value pairs that are updated
                };
                const result = yield this.srv.action.do(this.core, actionConfig);
                console.log('result', result);
                if (IsObject(result, true)) {
                    this.dom.setTimeout(`reset-component`, () => __awaiter(this, void 0, void 0, function* () {
                        yield this._renderComponent();
                        this.log.info(`options-reset:complete`);
                    }), 0);
                }
            }
            else {
                // ToDo:: handle this case
            }
        }));
    }
    /**
     * This user can click on a refresh icon to refresh the widget
     */
    onRefreshComponent() {
        this.dom.state.loaded = false;
        this.dom.state.loader = true;
        this.template.clear();
        this.dom.setTimeout(`refresh-component`, () => __awaiter(this, void 0, void 0, function* () {
            yield this._renderComponent();
        }), 500);
    }
    /**
     * Handle the bubble events that come up
     * @param event
     */
    onBubbleEvent(name, extension, event) {
        if (!event)
            event = { source: this.name, type: 'field', name: name };
        if (extension)
            event = Object.assign(Object.assign({}, event), extension);
        this.log.event(`bubbleEvent`, event);
        this.events.emit(event);
        return true;
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                   Base Protected Methods                                     *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config
     * Intended to be overridden per field
     */
    _setInitialConfig() {
        return new Promise((resolve) => {
            this.id = IsObject(this.config, ['id']) ? this.config.id : PopUid();
            if (!IsString(this.internal_name))
                this.internal_name = 'profile_specialist_1';
            if (!IsObject(this.config, true)) {
                const params = PopSchemeComponent.getParams(this.internal_name);
                this.config = new SchemeComponentConfig({
                    name: params.name ? params.name : 'Custom Component',
                    internal_name: this.internal_name,
                    component_id: this.componentId,
                    component: PopSchemeComponent.getComponent(this.internal_name),
                    option: PopSchemeComponent.getOption(this.internal_name),
                    setting: PopSchemeComponent.getOption(this.internal_name),
                    resource: PopSchemeComponent.getResource(this.internal_name),
                    param: PopSchemeComponent.getResource(this.internal_name),
                });
            }
            return resolve(true);
        });
    }
    /**
     * Set the initial config
     * Intended to be overridden per field
     */
    _setInitialState() {
        return new Promise((resolve) => {
            const isOptionComponent = StorageGetter(this.config, ['option', 'component']);
            this.dom.state.hasOptions = this.config.setting.edit && isOptionComponent && isOptionComponent.type ? true : false;
            this.dom.state.hasRefresh = this.config.setting.refresh;
            this.dom.state.isEditable = this.config.setting.edit ? true : false;
            // const userPreferences = StorageGetter( this.core, ['preference', this.config.id], {} );
            // if( IsObject( userPreferences, true ) ){
            //   this.config.option = { ...this.config.option, ...userPreferences.option };
            // }
            return resolve(true);
        });
    }
    /**
     * Set the initial config
     * Intended to be overridden per field
     */
    _setInitialProceed() {
        return new Promise((resolve) => {
            return resolve(true);
        });
    }
    /**
     * This fx will render the custom component for this widget
     * @private
     */
    _renderComponent() {
        return new Promise((resolve) => {
            this.dom.setTimeout(`render-widget`, () => {
                if (IsObject(this.config.component, ['type'])) {
                    this.template.render([this.config.component], ['core', 'position', 'config']);
                }
                this.dom.ready();
            }, 0);
            return resolve(true);
        });
    }
}
PopEntitySchemeCustomComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-custom-component',
                template: "<div class=\"entity-custom-component-container import-flex-column\">\n  <div class=\"entity-custom-component-header mat-body\" style=\"flex-grow:0\">\n    <div class=\"entity-custom-component-title\">{{config?.name}}</div>\n    <div class=\"entity-custom-component-spacer\"></div>\n    <div class=\"entity-custom-component-refresh\" *ngIf=\"dom.state.hasRefresh\">\n      <mat-icon class=\"sw-pointer\" (mousedown)=\"onRefreshComponent()\">refresh</mat-icon>\n    </div>\n    <div class=\"entity-custom-component-edit\" *ngIf=\"dom.state.hasOptions\">\n      <mat-icon class=\"sw-pointer\" (mousedown)=\"onEditComponentOptions()\">settings</mat-icon>\n    </div>\n\n  </div>\n  <div class=\"entity-custom-component-loader\" *ngIf=\"dom.state.loader\">\n    <lib-main-spinner></lib-main-spinner>\n  </div>\n  <div class=\"entity-custom-component-content\">\n    <ng-template #container></ng-template>\n  </div>\n</div>\n",
                styles: [".entity-custom-component-container{position:relative;flex:1;min-height:300px;margin-top:var(--gap-m);margin-bottom:var(--gap-m);padding:var(--gap-xs);border:1px solid var(--border)}.entity-custom-component-header{display:flex;flex-grow:1;min-height:50px;align-items:center;justify-content:space-between;box-sizing:border-box;clear:both;background:var(--background-main-menu);color:var(--foreground-base);padding:0 var(--gap-sm)}.entity-custom-component-title{font-weight:700}.entity-custom-component-delete mat-icon,.entity-custom-component-edit mat-icon,.entity-custom-component-refresh mat-icon{font-size:20px;color:var(--foreground-disabled);position:relative;top:-2px;cursor:pointer}.entity-custom-component-spacer{flex-grow:1}.entity-custom-component-content{flex:1;overflow-x:hidden;overflow-y:auto;padding:var(--gap-sm)}.entity-custom-component-loader{height:150px}"]
            },] }
];
PopEntitySchemeCustomComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopEntitySchemeCustomComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    componentId: [{ type: Input }],
    config: [{ type: Input }],
    section: [{ type: Input }]
};

class PopEntityTabComponent extends PopExtendComponent {
    /**
     * @param el
     * @param cdr
     * @param route
     * @param _tabRepo - transfer
     * @param _domRepo - transfer
     */
    constructor(el, cdr, route, _tabRepo, _domRepo) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.route = route;
        this._tabRepo = _tabRepo;
        this._domRepo = _domRepo;
        this.name = 'PopEntityTabComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
            router: ServiceInjector.get(Router),
            events: ServiceInjector.get(PopEntityEventService),
            entity: ServiceInjector.get(PopEntityService),
            tab: undefined,
        };
        this.asset = {
            scheme: undefined,
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // Require a CoreConfig
                // Pull in the route extension settings
                if (!this.extension)
                    this.extension = {};
                if (this.route.snapshot.data && Object.keys(this.route.snapshot.data).length) {
                    Object.keys(this.route.snapshot.data).map((key) => {
                        this.extension[key] = this.route.snapshot.data[key];
                    });
                }
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // Require a CoreConfig
                this._setCore().then(() => {
                    if (!(IsObject(this.core.entity, ['id'])))
                        this.srv.router.navigate(['/system/route'], { skipLocationChange: true });
                    // #1: Enforce a CoreConfig && TabConfig
                    // this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                    this._setTab().then(() => {
                        // set the outer height boundary of this component
                        this.dom.overhead = this.tab.wrap ? 40 : 10;
                        this.dom.overhead = this.tab.overhead ? this.dom.overhead + this.tab.overhead : this.dom.overhead;
                        this.dom.height.default = window.innerHeight - 70;
                        this.dom.setHeight(this.dom.height.default, 150);
                        // #3: Set tab group container
                        this.tab.groups = {};
                        // #4: Transfer in the ui rescources
                        // if( IsObject(this.core.entity, true) && IsObject(this.core.entity.ui, true) ){
                        //   Object.keys(this.core.entity.ui).map((key: string) => {
                        //     this.ui.resource[ key ] = this.core.entity.ui[ key ]; // ? maybe this should make a copy
                        //   });
                        // }
                        // #5: Build a view with a scheme or a model
                        this.asset.scheme = IsObject(this.core.entity, true) && this.core.entity.scheme_id && IsObject(this.core.resource.scheme, ['data']) ? CleanObject(this.core.resource.scheme.data) : null;
                        // console.log( 'this.asset.scheme', this.asset.scheme );
                        // #6: Bind Event handlers
                        this.dom.handler.core = (core, event) => this._coreEventHandler(event);
                        // #7: Build the view
                        this.tab.view = this._buildTabView();
                        // #8: Register the outlet so the tabRepo can reset the view if needed
                        if (true || this.tab.syncPositions)
                            this.srv.tab.registerOutletReset((position = null) => this.onResetView(position));
                        this._callOnLoadEvent();
                        this.dom.setTimeout(`determine-layout`, () => {
                            this._determineLayout();
                        }, 0);
                        return resolve(true);
                    });
                });
            }));
        };
        this.dom.unload = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.srv.tab.showAsLoading(false);
                return resolve(true);
            }));
        };
    }
    /**
     * Setup this component
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Bubble event handler
     * @param event
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (event.type === 'field_group' && event.name === 'init') {
            this.tab.groups[event.id] = event.group;
            this._callOnEvent(event, { reset: true });
        }
        else if (event.type === 'sidebyside' && event.name === 'portal') {
            const entityParams = this.srv.entity.getEntityParamsWithPath(String(event.data).split('/')[0], +String(event.data).split('/')[1]);
            if (entityParams) {
                this.onViewEntityPortal(entityParams.internal_name, entityParams.entityId);
            }
        }
        else if (IsValidFieldPatchEvent(this.core, event)) {
            this.log.event(`IsValidFieldPatchEvent`, event);
            if (event.config.name === 'name' || event.config.name === 'label') {
                this.srv.tab.updateName(event.config.control.value);
            }
            const reset = this._needsPositionReset(event);
            if (!reset) {
                if (typeof this.tab.onEvent === 'function') {
                    this._callOnEvent(event);
                }
            }
            else {
                if (typeof this.tab.onEvent === 'function') {
                    this._callOnEvent(event);
                }
                this.srv.events.sendEvent(event);
            }
        }
        else if (event.type === 'context_menu') {
            if (event.name === 'portal' && event.internal_name && event.id) {
                setTimeout(() => {
                    this.onViewEntityPortal(event.internal_name, +event.id);
                }, 0);
            }
        }
        else if (event.type === 'dom') {
            if (event.name === 'refresh') {
                setTimeout(() => {
                    this.onResetView(+event.position);
                }, 0);
            }
        }
    }
    /**
     * Triggers when the window is resized
     */
    onWindowResize() {
        this.dom.setTimeout('window-resize', () => {
            this._determineLayout();
            this.srv.tab.resetTab();
        }, 500);
    }
    /**
     * Triggers when a user clicks on an entityId link to see the details of that entityId in a modal
     * @param internal_name
     * @param id
     */
    onViewEntityPortal(internalName, entityId) {
        // ToDo:: Due to circular injection errors, the portals are not working
        this.tab.view.map((column) => {
            column.reset.next('scrollTop');
        });
        // this.srv.router.navigateByUrl(`entities/fields/${entityId}`).catch(e => true);
        PopPortal.view(internalName, entityId).then((changed) => {
            if (changed) {
                this.dom.refreshing();
                this.srv.tab.refreshEntity(this.core.params.entityId, this.dom.repo, {}, 'PopEntityTabComponent:viewEntityPortal').then((res) => {
                    this.dom.ready();
                });
            }
        });
    }
    /**
     * Trigger to reset the view
     * @param position
     */
    onResetView(position = null) {
        if (this.dom.state.loaded) {
            if (position === null) {
                this.tab.view.map((section) => {
                    section.reset.next(true);
                });
            }
            else {
                this.tab.view[position].reset.next(true);
            }
            setTimeout(() => {
                this.dom.ready();
            }, 0);
        }
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        this._callUnloadEvent();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Tie in hook that is called when ever a event if fired
     *
     */
    _callOnEvent(event, options = {}) {
        if (this.tab && typeof this.tab.onEvent === 'function') {
            event.tab = this.tab;
            // event.component = component;
            // event.core = this.core;
            if (options.reset)
                event.cdr = this.cdr;
            this.tab.onEvent.bind(this)(this.core, event);
        }
    }
    /**
     * Tie in hook that is called when the tab is initialized
     *
     */
    _callOnLoadEvent() {
        if (this.tab && typeof this.tab.onLoad === 'function') {
            this.tab.onLoad.bind(this)(this.core, this.tab);
        }
    }
    /**
     * Tie in hook that is called when the tab is destroyed
     *
     */
    _callUnloadEvent() {
        if (this.tab && typeof this.tab.onUnload === 'function') {
            this.tab.onUnload.bind(this)(this.core, this.tab);
        }
    }
    /**
     * Helper funtion to determine the correct header to display
     * @param header
     */
    _getHeaderText(header) {
        if (IsString(header, true)) {
            return TitleCase(ParseModelValue(header, this.core).replace(/_/g, ' ')).trim();
        }
        return null;
    }
    /**
     * Core Event Handler
     * @param event
     */
    _coreEventHandler(event) {
        this.log.event(`_coreEventHandler`, event);
        if (this.tab.wrap && event.type === 'component') {
            if (event.name === 'start-refresh') {
                this.dom.state.refresh = 1;
            }
            else if (event.name === 'stop-refresh') {
                this.dom.state.refresh = 0;
            }
            else if (event.name === 'reset-view') {
                this.onResetView();
            }
        }
    }
    /**
     * Detects if a mobile layout should be used based on the width of the screen
     */
    _determineLayout() {
        const client = this.el.nativeElement.getBoundingClientRect();
        this.dom.width.inner = client.width;
        this.dom.state.mobile = this.dom.width.inner <= 1340 ? true : false;
        if (this.dom.state.mobile) {
            this.tab.view.map((column) => {
                column.maxHeight = null;
                column.minHeight = null;
            });
        }
        else {
            this.tab.view.map((column) => {
                column.minHeight = column.header ? this.dom.height.inner - 50 : this.dom.height.inner;
                column.maxHeight = column.header ? this.dom.height.inner - 50 : this.dom.height.inner;
            });
        }
        // if( this.log.repo.enabled('dom', this.name) || this.extension.debug ) console.log(this.log.repo.message(`${this.name}:${this.tab.entityId}:_determineLayout:width:${this.dom.width.inner}: mobile: ${this.dom.state.mobile}`), this.log.repo.color('dom'));
    }
    /**
     * Determines if an event should cause a view reset
     * @param event
     */
    _needsPositionReset(event) {
        let position;
        if (this.tab.syncPositions) {
            // console.log('pass 1');
            if (event.config && event.config.metadata && event.config.metadata.position) {
                // console.log('pass 2');
                position = event.config.metadata.position;
                if (event.name === 'patch' && ['field', 'sidebyside', 'permissions'].includes(event.type)) {
                    // console.log('pass 3');
                    if (!this.tab.syncPositionFields || this.tab.syncPositionFields.includes(event.config.column)) {
                        // console.log('pass 4');
                        if (!IsObject(this.tab.syncPositionMap, true) || (position in this.tab.syncPositionMap && IsArray(this.tab.syncPositionMap[position]))) {
                            // console.log('pass 5');
                            if (IsObject(this.tab.syncPositionMap, true)) {
                                // console.log('pass 6');
                                if (IsArray(this.tab.syncPositionMap[position])) {
                                    // console.log('pass 7');
                                    this.tab.syncPositionMap[position].map((pos) => {
                                        this.onResetView(+pos);
                                    });
                                }
                                return true;
                            }
                            else {
                                this.onResetView();
                            }
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Allows for a pre built core to be passed in else it will build the core itself
     */
    _setCore() {
        return new Promise((resolve) => {
            if (!(IsObject(this.core, true))) {
                const tabCore = this.srv.tab.getCore();
                if (IsObject(tabCore, ['entity'])) {
                    this.core = tabCore;
                    this.log.info(`_setCore: initial`);
                    return resolve(true);
                }
                if (this.route.snapshot.data.core) {
                    this.core = IsObjectThrowError(this.route.snapshot.data.core, true, `${this.name}:: - this.route.snapshot.data.core`) ? this.route.snapshot.data.core : {};
                    this.log.info(`_setCore: route`);
                    return resolve(true);
                }
                const coreParams = this.srv.tab && this.srv.tab.ui && this.srv.tab.ui.entityParams ? this.srv.tab.ui.entityParams : {};
                if (IsObject(coreParams, true)) {
                    this.srv.entity.getCoreConfig(coreParams.internal_name, +coreParams.entity).then((core) => {
                        this.core = IsObjectThrowError(core, true, `${this.name}:: - core`) ? core : {};
                        this.log.info(`_setCore: tab params`);
                        return resolve(true);
                    });
                }
                else {
                    this.srv.entity.getCoreConfig(this.srv.entity.getRouteInternalName(this.route, this.extension), this.route.snapshot.params.entity).then((core) => {
                        this.core = IsObjectThrowError(core, true, `${this.name}:: - core`) ? core : null;
                        this.log.info(`_setCore: route internal _name`);
                        return resolve(true);
                    });
                }
            }
            else {
                return resolve(true);
            }
        });
    }
    /**
     * Allows for a pre built tab to be passed in else it will find try to find one
     */
    _setTab() {
        return new Promise((resolve) => {
            if (!(IsObject(this.tab, true))) {
                const tab = this.srv.tab.getTab();
                this.tab = IsObjectThrowError(tab, true, `${this.name}:_setTab: - tab`) ? tab : {};
                return resolve(true);
            }
            else {
                return resolve(true);
            }
        });
    }
    /**
     * Determine the structure of the tab view
     *
     */
    _buildTabView() {
        const view = [];
        //     console.log('this.tab.scheme', this.tab.scheme);
        if (this.tab.scheme && IsObject(this.asset.scheme, ['children'])) {
            //       console.log('should use the scheme provided', this.asset.scheme);
            const sections = this.asset.scheme.children;
            const sectionKeys = Object.keys(sections);
            const lastSectionKey = sectionKeys[sectionKeys.length - 1];
            let section;
            sectionKeys.map((sectionKey) => {
                section = sections[sectionKey];
                section.position = +sectionKey + 1;
                if (typeof section.flex === 'undefined') {
                    section.flex = +lastSectionKey === +sectionKey ? 2 : 1;
                }
                let height = +this.dom.height.outer;
                height = section.header ? (height - 50) : height;
                this.dom.repo.position[sectionKey] = {
                    height: height,
                };
                view.push({
                    id: sectionKey,
                    position: section.position,
                    reset: new Subject(),
                    components: this._getSchemeSectionAssetComponents(this.core, this.asset.scheme, section),
                    header: this._getHeaderText(section.name),
                    flex: section.flex,
                    minWidth: +sectionKey < 3 ? 350 : null,
                    maxWidth: +sectionKey < 2 ? 450 : null,
                    maxHeight: height,
                    active: true,
                });
            });
        }
        else {
            const positions = IsObjectThrowError(this.tab.positions, true, `${this.name}:configureDom: - this.tab.positions`) ? this.tab.positions : {};
            Object.keys(positions).map((position) => {
                let height = +this.dom.height.outer;
                height = this.tab.positions[position].header ? (height - 50) : height;
                this.dom.repo.position[position] = {
                    height: height,
                };
                view.push({
                    id: position,
                    position: position,
                    reset: new Subject(),
                    components: this.tab.positions[position].components,
                    extension: this.extension,
                    header: this._getHeaderText(this.tab.positions[position].header),
                    flex: this.tab.positions[position].flex,
                    maxWidth: this.tab.positions[position].max,
                    minWidth: this.tab.positions[position].min,
                    maxHeight: height,
                    active: true,
                });
            });
        }
        return view;
    }
    /**
     * Gather all the assets that should be rendered in a specific section
     * @param core
     * @param assets
     */
    _getSchemeSectionAssetComponents(core, scheme, section) {
        const componentList = [];
        const Field = this.dom.repo.ui.fields;
        // console.log('Field', Field);
        const tableFields = this._getSectionTableFieldsAssets(section);
        section.children = [...tableFields, ...(IsArray(section.children) ? section.children : [])];
        if (IsObject(section.mapping, ['sort_order'])) {
            section.children = section.children.sort(function (a, b) {
                const a1 = section.mapping.sort_order.indexOf(a.id);
                const a2 = section.mapping.sort_order.indexOf(b.id);
                if (a1 < a2)
                    return -1;
                if (a1 > a2)
                    return 1;
                return 0;
            });
        }
        section.children.map((child) => {
            if (String(String(child.asset_type).toLowerCase()).includes('field')) {
                child.asset_type = 'field';
            }
            else if (String(String(child.asset_type).toLowerCase()).includes('component')) {
                child.asset_type = 'component';
            }
            else if (String(String(child.asset_type).toLowerCase()).includes('widget')) {
                child.asset_type = 'widget';
            }
            if (child.asset_type && IsDefined(child.asset_id)) {
                switch (child.asset_type) {
                    case 'table': {
                        // console.log( 'table', child );
                        // const fieldItem = child.name ? Field.get( child.name ) : null;
                        // if( fieldItem ){
                        //   componentList.push( fieldItem );
                        // }
                        break;
                    }
                    case 'field': {
                        const field = Field.get(+child.asset_id);
                        if (field) {
                            componentList.push(scheme, field);
                        }
                        break;
                    }
                    case 'component': {
                        // ToDo:: Figure how custom components are going to be managed
                        const internalName = StorageGetter(child, ['asset', 'internal_name'], String(SpaceToSnake(child.name)).toLowerCase() + '_1');
                        const component = {
                            type: PopEntitySchemeCustomComponent,
                            inputs: {
                                core: core,
                                config: undefined,
                                componentId: child.asset_id,
                                internal_name: internalName
                            }
                        };
                        componentList.push(component);
                        break;
                    }
                    default:
                        // if( this.srv.log.enabled('error', this.name) ) console.log(this.srv.log.message(`${this.name}:getSchemeSectionAssetComponents`), this.srv.log.color('error'), asset);
                        break;
                }
            }
        });
        return componentList;
    }
    /**
     * Retrieve the default columns tht exist on an entity table
     * @param section
     */
    _getSectionTableFieldsAssets(section) {
        const tableAssets = [];
        if (this.core) {
            const Field = StorageGetter(this.core, 'repo.model.field'.split('.'));
            if (IsObject(Field, true)) {
                Object.values(Field).map((field) => {
                    if (!field.ancillary && field.position === section.position) {
                        tableAssets.push(new EntitySchemeSectionConfig({
                            id: 0,
                            name: field.model.name,
                            label: field.model.label,
                            asset_type: 'table',
                            asset_id: 0,
                            asset: field,
                            scheme_id: +section.id,
                            sort_order: field.sort,
                            position: section.position,
                        }));
                    }
                });
            }
        }
        section.startIndex = tableAssets.length;
        return tableAssets.sort((a, b) => {
            if (a.sort < b.sort)
                return -1;
            if (a.sort > b.sort)
                return 1;
            return 0;
        });
    }
}
PopEntityTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-tab',
                template: "<div class=\"pop-entity-tab-container\" [style.maxHeight.px]=dom.height.outer (window:resize)=\"onWindowResize();\" [ngClass]=\"{'sw-hidden': !dom.state.loaded, 'pop-entity-tab-container-wrap': tab?.wrap, 'pop-entity-tab-refresh':dom.state['refresh']}\">\n  <div class=\"import-flex-row-wrap\">\n    <div class=\"pop-entity-tab-column\"  [ngClass]=\"{'pop-entity-tab-column-wrap': tab.columnWrap}\" *ngFor=\"let col of tab?.view\" [style.flexGrow]=\"col.flex\" [style.maxWidth.px]=\"col.maxWidth\" [style.minWidth.px]=\"col.minWidth\">\n      <div class=\"pop-entity-tab-column-header\" *ngIf=\"col.header\">\n        <div class=\"sw-label-container-sm\">{{col.header}}</div>\n      </div>\n      <div class=\"pop-entity-tab-column-content pop-entity-tab-column-{{col.id}}\" [style.minHeight.px]=col.minHeight [style.maxHeight.px]=\"col.maxHeight\">\n        <lib-pop-entity-tab-column [core]=\"core\" [column]=col (events)=\"onBubbleEvent($event);\"></lib-pop-entity-tab-column>\n      </div>\n    </div>\n  </div>\n  <div class=\"pop-entity-tab-loader\" *ngIf=\"tab?.wrap\">\n    <mat-progress-bar *ngIf=\"dom.state['refresh']\" mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n</div>\n<lib-pop-errors *ngIf=\"dom.error.code\" [error]=\"dom.error\"></lib-pop-errors>\n",
                styles: [".pop-entity-tab-container{flex:1 1 100%;height:100%;box-sizing:border-box}.pop-entity-tab-container-wrap{padding:30px 15px 15px;box-sizing:border-box}.pop-entity-tab-column-header{position:relative;height:50px;clear:both}.pop-entity-tab-column{position:relative;flex:1;box-sizing:border-box;display:flex;flex-flow:column;align-items:stretch;min-height:0}.pop-entity-tab-column-wrap{margin:0 15px}.pop-entity-tab-column-content{position:relative;overflow-x:hidden;flex:1 1 auto;padding-bottom:2px}.pop-entity-tab-loader{position:absolute;bottom:0;left:0;right:0;height:7px;clear:both;z-index:2;opacity:1!important}.pop-entity-tab-refresh{opacity:.5;pointer-events:none}"]
            },] }
];
PopEntityTabComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ActivatedRoute },
    { type: PopTabMenuService },
    { type: PopDomService }
];
PopEntityTabComponent.propDecorators = {
    tab: [{ type: Input }],
    extension: [{ type: Input }]
};

class PopEntityPortalMenuComponent extends PopExtendComponent {
    constructor(el, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopTabMenuComponent';
        this.srv = {
            crud: ServiceInjector.get(PopEntityEventService),
            tab: undefined
        };
        this.id = 2;
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // set the outer height boundary
                yield this.dom.setHeightWithParent('cdk-overlay-pane', 100, window.innerHeight - 180);
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                // #2: Enforce a TabMenuConfig
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configureDom: - this.core`) ? this.config : {};
                yield PopEntity.setCoreDomAssets(this.core, this.dom.repo);
                // #3: Register the outlet with the tabRepo, gives the tabRepo the ability to reset the view if needed
                this.srv.tab.registerOutlet(this.outlet);
                // #4: Preset a default tab so the view will have something to render
                if (IsArray(this.config.tabs, true))
                    this.onSetPortal(this.config.tabs[0]);
                this.dom.setSubscriber('events', this.srv.crud.events.subscribe((event) => {
                    if (IsValidCoreSignature(this.core, event)) {
                        if (IsValidFieldPatchEvent(this.core, event)) {
                            if (event.config.name === 'name' || event.config.name === 'label') {
                                this.config.name = (event.config.control.value);
                            }
                        }
                    }
                }));
                return resolve(true);
            }));
        };
    }
    /**
     * Setup this component
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Trigger a portal tab click event
     * @returns void
     */
    onMenuClick(tab) {
        this.onSetPortal(tab);
        this.onBubbleEvent({
            source: this.name,
            type: 'menu',
            id: tab.id,
            name: tab.name,
        });
    }
    /**
     * Whenever a user click on tab av button, the portal needs reset to that tab
     * Has specific render so does not use the built-in render intentionally
     * @param tab
     */
    onSetPortal(tab) {
        if (this.log.repo.enabled('config', this.name))
            console.log(this.log.repo.message(`${this.name}:setPortal:tab`), this.log.repo.color('config'), tab);
        if (tab && tab.id) {
            if (this.portal && this.portal.attachedRef)
                this.portal.detach();
            this.dom.state.tab = tab;
            Object.keys(this.dom.subscriber).map((name) => {
                if (this.dom.subscriber[name]) {
                    this.dom.subscriber[name].unsubscribe();
                }
            });
            const componentRef = this.portal.attach(new ComponentPortal(PopEntityTabComponent));
            componentRef.instance['core'] = this.core;
            componentRef.instance.tab = tab;
            componentRef.changeDetectorRef.detectChanges();
            if (componentRef.instance['events']) {
                this.dom.setSubscriber('portal', componentRef.instance['events'].subscribe((event) => {
                    this.onBubbleEvent(event);
                }));
            }
        }
    }
    /**
     * Trigger a button click event
     * @returns void
     */
    onButtonClick(button) {
        this.onBubbleEvent({
            source: this.name,
            type: 'button',
            id: button.id,
            name: button.name,
        });
    }
    /**
     * This will bubble a event up to a parent component
     * @param event
     */
    onBubbleEvent(event) {
        this.events.emit(event);
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.portal.detach();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _onCrudEvent(event) {
    }
}
PopEntityPortalMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-portal-menu',
                template: "<div class=\"portal-menu-container\" [style.height.px]=dom.height.outer>\n  <div class=\"portal-menu-header mat-elevation-z2\">\n    <div class=\"host-name-button-container\">\n      <div class=\"host-label-container\">{{config.name}}</div>\n      <div *ngIf=\"config.buttons?.length\" class=\"host-button-container\">\n        <button class=\"host-button\"\n                *ngFor=\"let button of config.buttons\"\n                [ngClass]=\"{'sw-hidden': button.hidden}\"\n                [disabled]=\"button.disabled\"\n                mat-raised-button\n                (click)=\"onButtonClick(button)\">\n          {{button.name}}\n        </button>\n      </div>\n    </div>\n    <div class=\"host-link-container\">\n      <nav mat-tab-nav-bar>\n        <a mat-tab-link\n           *ngFor=\"let tab of config?.tabs\"\n           [ngClass]=\"{'active':dom.state.tab?.id === tab.id}\"\n           (click)=\"onMenuClick(tab)\"\n           [active]=\"dom.state.tab?.id === tab.id\">\n          {{tab.name}}\n        </a>\n      </nav>\n    </div>\n  </div>\n  <div #outlet class=\"sw-target-outlet portal-outlet-container\" [style.height.px]=dom.height.inner>\n    <ng-template [cdkPortalOutlet]></ng-template>\n  </div>\n</div>\n",
                providers: [PopTabMenuService, PopDomService],
                styles: [".portal-menu-container{display:flex;width:100%;flex-direction:column;justify-content:stretch}.portal-menu-container .portal-menu-header{padding-top:30px;min-height:70px;max-height:70px}.portal-menu-container>div{flex:1;overflow:auto}.host-header{overflow:hidden}.host-back-container{display:inline-flex!important;padding:6px 0 0 8px;justify-content:flex-start;align-items:center;cursor:pointer}.host-back-container mat-icon{width:22px}.host-name-button-container{display:flex;justify-content:space-between;margin:0}.host-label-container{padding:0 0 10px 30px;position:relative;min-width:200px;font-size:24px;flex:1 1 auto}.host-button-container{display:flex!important;justify-content:flex-end;align-items:center;flex:1 1 auto;margin-right:30px}.host-button{margin-left:10px;min-width:100px}.host-link-container{position:relative;display:block;margin:0;padding:3px 30px 0 25px}.portal-outlet-container{overflow:hidden}.mat-tab-link.active{font-weight:500}.mat-tab-nav-bar{border-bottom:none}.mat-tab-link{height:30px!important;min-width:50px!important;font-weight:400;font-size:16px;color:var(--text);padding:0 5px 16px;margin-right:30px!important}"]
            },] }
];
PopEntityPortalMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopEntityPortalMenuComponent.propDecorators = {
    config: [{ type: Input }],
    outlet: [{ type: ViewChild, args: ['outlet', { static: true },] }],
    portal: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]
};

class PopEntityTabMenuComponent extends PopExtendDynamicComponent {
    constructor(el, cdr, route, _domRepo, _tabRepo, APP_GLOBAL, dialogRef) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.route = route;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.APP_GLOBAL = APP_GLOBAL;
        this.dialogRef = dialogRef;
        this.name = 'PopEntityTabMenuComponent';
        this.srv = {
            action: ServiceInjector.get(PopEntityActionService),
            dialog: ServiceInjector.get(MatDialog),
            events: ServiceInjector.get(PopEntityEventService),
            tab: undefined
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.APP_GLOBAL.isVerified();
                if (!IsObject(this.extension, true))
                    this.extension = {};
                if (!this.extension.goToUrl)
                    this.extension.goToUrl = null;
                if (this.route.snapshot.data && Object.keys(this.route.snapshot.data).length) {
                    Object.keys(this.route.snapshot.data).map((key) => {
                        this.extension[key] = this.route.snapshot.data[key];
                    });
                }
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // Require a CoreConfig
                yield this._setCore();
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                if (this.core.flag.routeCheck) { // check this child routes for any aliasing
                    this.route.routeConfig.children.map((childRoute) => {
                        const internal_name = GetSingularName(childRoute.path);
                        if (IsAliasable(childRoute.path) && IsEntity(TitleCase(internal_name))) {
                            childRoute.path = GetRouteAlias(internal_name);
                        }
                    });
                    this.core.flag.routeCheck = false;
                }
                this.log.info('tab-menu config', this.config);
                this.dom.height.default = window.innerHeight - 100;
                this.dom.setHeight(this.dom.height.default, 100);
                // this component set the outer height boundary
                this.log.info(`Determined height:${this.dom.height.inner}`);
                // Bind events to handlers
                this.dom.handler.bubble = (core, event) => this.onBubbleEvent(event);
                // Require a TabMenuConfig, and pull in extension params from the route
                yield this._setTabMenuConfig();
                if (this.config.portal)
                    this.dom.height.inner = this.dom.height.inner - 50;
                //  Attach Template Container
                this.template.attach('container');
                //  Render the dynamic list of components
                this._templateRender();
                return resolve(true);
            }));
        };
    }
    /**
     * Helper function that renders the list of dynamic components
     *
     */
    _templateRender() {
        if (this.config.portal) {
            this.asset.component = this.template.render([{
                    type: PopEntityPortalMenuComponent,
                    inputs: {
                        config: this.config
                    }
                }]);
            // componentRef.instance.events.subscribe((event: PopBaseEventInterface) => {
            //   if( typeof this.dom.handler.bubble === 'function' ){
            //     this.dom.handler.bubble(event);
            //   }else{
            //     if( this.trait.bubble ) this.events.emit(event);
            //   }
            // })
        }
        else {
            this.template.render([{
                    type: PopTabMenuComponent,
                    inputs: {
                        config: this.config
                    }
                }]);
        }
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Tie in for a parent component to pass in a TabMenuConfig
     * @param config
     */
    registerTabMenuConfig(config) {
        this.config = IsObjectThrowError(config, true, `${this.name}:registerTabMenuConfig: - config`) ? config : {};
        this.dom.setSubscriber('config-change', this.srv.tab.change.subscribe((event) => {
        }));
        try {
            this.cdr.detectChanges();
        }
        catch (e) {
        }
        this._registerTabMenuConfig();
    }
    /**
     * A TabMenu  will generate a slew of action and event triggers
     * @param event
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event)) {
            if (event.config.name === 'name' || event.config.name === 'label') {
                this.config.name = event.config.control.value;
            }
        }
        else {
            switch (event.type) {
                case 'button':
                    switch (event.id) {
                        case 'reset':
                            this.srv.tab.refreshEntity(null, this.dom.repo, {}, 'PopEntityTabMenuComponent:handleMenuEvent:reset').then(() => true);
                            break;
                        // case 'archive':
                        //   this.onArchiveButtonClicked(true);
                        //   break;
                        // case 'activate':
                        //   this.onArchiveButtonClicked(false);
                        //   break;
                        case 'clone':
                            this.onCloneButtonClicked();
                            break;
                        case 'close':
                            if (this.dialogRef)
                                this.dialogRef.close();
                            break;
                        default:
                            this.events.emit(event);
                            break;
                    }
                    break;
                case 'portal':
                    break;
                case 'default':
                    break;
            }
        }
    }
    /**
     * A user can click on an archive/active button to change the status of this active entity
     * @param archive
     */
    onArchiveButtonClicked(archive) {
        if (this.dom.subscriber.entity)
            this.dom.subscriber.entity.unsubscribe();
        this.dom.subscriber.entityId = this.core.repo.archiveEntity(this.core.params.entityId, archive).subscribe(() => {
            PopEntity.bustAllCache();
            this.srv.events.sendEvent({
                source: this.name,
                method: 'archive',
                type: 'entity',
                name: this.core.params.name,
                internal_name: this.core.params.internal_name,
                id: this.core.params.entityId,
                data: archive
            });
            if (archive && !this.config.portal) {
                if (false) { // Disabled navigation back to the entity list for now
                    this.core.repo.navigateToEntities().catch(e => {
                        this.srv.tab.refreshEntity(null, this.dom.repo, {}, 'PopEntityTabMenuComponent:setArchived').then(() => PopTemplate.clear());
                    });
                }
                else {
                    this.srv.tab.refreshEntity(null, this.dom.repo, {}, 'PopEntityTabMenuComponent:setArchived').then(() => PopTemplate.clear());
                }
            }
            else {
                this.srv.tab.refreshEntity(null, this.dom.repo, {}, 'PopEntityTabMenuComponent:setArchived').then(() => PopTemplate.clear());
            }
        }, err => {
            this.dom.error.code = err.error.code;
            this.dom.error.message = err.error.message;
        });
    }
    /**
     * A user can click a clone button to trigger this active entity to be cloned
     */
    onCloneButtonClicked() {
        // this.dom.setTimeout( `clone-action`, async() => {
        //   const actionConfig = await this.srv.action.doAction( <CoreConfig>this.core, 'clone', this.extension );
        //   this.ui[ 'actionModal' ] = IsObject( actionConfig, true ) ? actionConfig : null;
        // }, 0 );
        this.dom.setTimeout(`do-action`, () => __awaiter(this, void 0, void 0, function* () {
            yield this.srv.action.do(this.core, 'clone', this.extension);
        }), 0);
    }
    /**
     * When the modal to clone the active entity is closed the asset needs to be cleared
     */
    onActionModalClose() {
        this.ui['actionModal'] = null;
    }
    /**
     * Cleanup the do of this component
     */
    ngOnDestroy() {
        if (this.core && this.core.params && this.core.params.entityId)
            this.core.repo.clearCache('entity', String(this.core.params.entityId), 'PopEntityTabMenuComponent:ngOnDestroy');
        // this.srv.tab.reset();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This allows a CoreConfig to be passed in else it will generate one
     *
     */
    _setCore() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!(IsObject(this.core, true))) {
                if (IsObject(this.portal, ['internal_name', 'entity_id'])) {
                    this.core = yield PopEntity.getCoreConfig(this.portal.internal_name, this.portal.entity_id);
                    return resolve(true);
                }
                else if (IsObject(this.route.snapshot.data.core, true)) {
                    this.core = this.route.snapshot.data.core;
                    yield PopEntity.setCoreDomAssets(this.core, this.dom.repo);
                    return resolve(true);
                }
                else {
                    this.core = yield PopEntity.getCoreConfig(PopEntity.getRouteInternalName(this.route, this.extension), this.route.snapshot.params.id, this.dom.repo);
                    return resolve(true);
                }
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * This allows a TabMenuConfig to be passed in else it will generate one
     *
     */
    _setTabMenuConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!IsObject(this.config, true)) {
                this.config = GetTabMenuConfig(this.core, PopEntity.getEntityTabs(this.core));
                this.config = IsObjectThrowError(this.config, true, `${this.name}:configureDom: - this.config`) ? this.config : {};
                this._registerTabMenuConfig();
                return resolve(true);
            }
            else {
                this._registerTabMenuConfig();
                return resolve(true);
            }
        }));
    }
    /**
     * This will transfer the TabMenuConfig up to the tabRepo so other components can communicate with it
     *
     */
    _registerTabMenuConfig() {
        if (this.core && this.config) {
            // turn off the filter bar (unless a portal dialog) since it is wasted space
            if (IsObject(this.portal, ['internal_name'])) {
                this.config.portal = true;
            }
            if (!this.config.portal)
                ServiceInjector.get(PopCacFilterBarService).setActive(false);
            if (typeof this.extension === 'object' && Object.keys(this.extension).length) {
                Object.keys(this.extension).map((key) => {
                    if (key in this.config) {
                        this.config[key] = this.extension[key];
                    }
                });
            }
            // Register the config on the Tab Menu Service since it is the master control
            // We store the config of the Tab Menu since other components(Tabs,...) interact with it
            this.config = this.srv.tab.registerConfig(this.core, this.config, this.dom.repo);
            this.srv.tab.registerRoute(this.route);
            try {
                this.cdr.detectChanges();
            }
            catch (e) {
            }
        }
    }
}
PopEntityTabMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-tab-menu',
                template: "<div class=\"entity-tab-menu-container\" [style.height.px]=dom.height.outer>\n  <ng-container #container>\n    <div class=\"entity-tab-menu-spinner-box\" *ngIf=\"dom.state.loader\">\n      <lib-main-spinner></lib-main-spinner>\n    </div>\n  </ng-container>\n  <lib-pop-field-item-group *ngIf=\"ui.actionModal\" [config]=\"ui.actionModal\" (close)=\"onActionModalClose();\"></lib-pop-field-item-group>\n  <lib-pop-errors *ngIf=\"dom.error?.message\" [error]=\"dom.error\"></lib-pop-errors>\n</div>\n",
                providers: [PopTabMenuService, PopDomService],
                styles: [".entity-tab-menu-container{display:flex;height:auto;flex-direction:column;box-sizing:border-box}.entity-tab-menu-container-margin{margin:25px}.entity-tab-menu-loader{position:absolute;height:2px;overflow:hidden;top:0;left:0;right:0;width:100%;clear:both}.entity-tab-menu-spinner-box{height:75vh}"]
            },] }
];
PopEntityTabMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ActivatedRoute },
    { type: PopDomService },
    { type: PopTabMenuService },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: MatDialogRef, decorators: [{ type: Optional }] }
];
PopEntityTabMenuComponent.propDecorators = {
    config: [{ type: Input }],
    extension: [{ type: Input }],
    portal: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class PopEntityUtilPortalService {
    constructor(dialogRepo) {
        this.dialogRepo = dialogRepo;
        this.state = {
            blockModal: false,
        };
    }
    view(internal_name, id) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.state.blockModal) {
                this.state.blockModal = true;
                if (internal_name && id) {
                    let dialogRef = this.dialogRepo.open(PopEntityTabMenuComponent, {
                        width: `${window.innerWidth - 20}px`,
                        height: `${window.innerHeight - 50}px`,
                        panelClass: 'sw-portal'
                    });
                    let component = dialogRef.componentInstance;
                    component.portal = { internal_name: internal_name, entity_id: id };
                    component.cdr.detectChanges();
                    dialogRef.afterClosed().subscribe((changed) => {
                        this.state.blockModal = false;
                        component.core.repo.clearAllCache();
                        dialogRef = null;
                        component = null;
                        resolve(true);
                    });
                }
                else {
                    resolve(false);
                }
            }
            else {
                console.log('blockModal');
                resolve(false);
            }
        }));
    }
}
PopEntityUtilPortalService.prov = i0.defineInjectable({ factory: function PopEntityUtilPortalService_Factory() { return new PopEntityUtilPortalService(i0.inject(i1$2.MatDialog)); }, token: PopEntityUtilPortalService, providedIn: "root" });
PopEntityUtilPortalService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopEntityUtilPortalService.ctorParameters = () => [
    { type: MatDialog }
];

class PopEntityFieldGroupComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntityFieldGroupComponent';
        this.position = 1;
        this.fieldType = null;
        this.srv = {
            field: ServiceInjector.get(PopEntityUtilFieldService),
            tab: undefined
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configure: - this.core`) ? this.core : null;
                // handles events
                this.trait.bubble = true;
                this.dom.handler.bubble = (core, event) => this.onBubbleEvent(event);
                // this.dom.handler.core = ( core: CoreConfig, event: PopBaseEventInterface ) => this._coreEventHandler( event );
                this.id = this.position;
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.overhead = this.interface && this.interface.header ? 60 : 0;
                this.dom.setHeightWithParent(null, this.dom.overhead, 600).then(() => true);
                // Get the list of fields and render them into the view
                const fieldComponentList = yield this._getFieldComponentList();
                this.template.attach('container');
                this.template.render(fieldComponentList);
                return resolve(true);
            }));
        };
    }
    /**
     * This component receives a list of fields to render
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This will retrieve any fields that have been marked for the position of this field group
     */
    _getFieldComponentList() {
        return new Promise((resolve) => {
            let fields = this.srv.field.getDomFields(this.position, this.dom.repo);
            if (this.fieldType === 'custom') {
                fields = fields.filter((field) => {
                    return field.custom;
                });
            }
            else if (this.fieldType === 'table') {
                fields = fields.filter((field) => {
                    return !(field.custom);
                });
            }
            this.asset.fields = {};
            fields.map((field) => {
                const config = StorageGetter(field, ['inputs', 'config'], null);
                if (config) {
                    this.asset.fields[config.name] = config;
                }
            });
            const componentList = fields;
            return resolve(componentList);
        });
    }
    /**
     * The fields will trigger a slew of events
     * @param event
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event) || event.type === 'context_menu') {
            this.log.info(`IsValidFieldPatchEvent`, event);
            if (event.type === 'field' && event.config.name in this.core.entity) {
                const newValue = isNaN(event.config.control.value) ? event.config.control.value : +event.config.control.value;
                this.core.entity[event.config.name] = newValue;
                if (Object.keys(this.asset.fields).length > 1) {
                    this.dom.setTimeout('reset-hidden', () => {
                        this._triggerParentChildUpdates(event.config.name);
                        // this._resetComponentListHidden();
                    }, 0);
                }
                else {
                    this.dom.setTimeout('reset-hidden', () => {
                        // this._resetComponentListHidden();
                    }, 0);
                }
            }
            this.events.emit(event);
            this.srv.tab.clearCache();
        }
    }
    //
    // /**
    //  * This handler handles any events that come across the core cross channel
    //  * @param event
    //  * @private
    //  */
    // private _coreEventHandler( event: PopBaseEventInterface ){
    //   this.log.event(`_coreEventHandler`, event);
    //   if( IsValidFieldPatchEvent( this.core, event ) ){
    //     // A values has been patched recheck the list of fields to see if any of them should be hidden
    //
    //   }
    // }
    /**
     * Whenever a _update to the core entity happens the fields in the group should be re-evaluated if there are when conditionals set
     * @private
     */
    _resetComponentListHidden() {
        let name, def;
        const Fields = this.dom.repo.ui.fields;
        this.template.refs.filter((componentRef) => {
            return IsObject(componentRef.instance.config, true) && IsArray(componentRef.instance.when, true);
        }).map((componentRef) => {
            name = componentRef.instance.config.name;
            if (name) {
                def = Fields.get(name);
                if (def) {
                    componentRef.instance.hidden = def.inputs.hidden = !EvaluateWhenCondition(this.core, componentRef.instance.when, this.core);
                    Fields.set(name, def);
                }
            }
        });
    }
    /**
     * This will update the option values of related parent/child fields
     * @param name
     * @private
     */
    _triggerParentChildUpdates(name) {
        this.log.info(`_triggerParentChildUpdates`, name);
        if (this._fieldHasChild(name)) {
            let values;
            let child_fk;
            let childField;
            let autoFill = false;
            let set;
            const relations = this._getRelationList(name);
            relations.some((relation) => {
                if (relation.autoFill) {
                    autoFill = true;
                    return true;
                }
            });
            if (name && name in this.asset.fields) {
                child_fk = this.asset.fields[name].options.child;
                if (child_fk && child_fk in this.asset.fields) {
                    childField = this.asset.fields[child_fk];
                    if (IsArray(childField.options.rawValues)) {
                        values = ConvertArrayToOptionList(childField.options.rawValues, {
                            // ensure that an option shows up in list in case other conditions remove it, aka it has been archived
                            prevent: [],
                            // parent means this options should all have a common field trait like client_fk, account_fk ....
                            parent: childField.options.parent ? {
                                field: childField.options.parent,
                                value: this.core.entity[childField.options.parent]
                            } : null,
                            empty: childField.options.empty ? childField.options.empty : null,
                        });
                        if (autoFill && values.length) {
                            set = values[values.length - 1].value;
                        }
                        else {
                            set = null;
                        }
                        childField.options.values = values;
                        autoFill = autoFill && values.length ? values[0].value : null;
                        this.dom.setTimeout(`clear-message-${child_fk}`, () => {
                            if (typeof childField.triggerOnChange === 'function')
                                childField.triggerOnChange(set);
                            if (typeof childField.clearMessage === 'function') {
                                childField.clearMessage();
                            }
                        }, 0);
                    }
                }
            }
        }
    }
    /**
     * Get a linear list of the parent child relations from a given point
     * @param self the name to start from (usually the field that has just been changed by user)
     * @param list
     */
    _getRelationList(name, list = []) {
        let item;
        if (name && name in this.asset.fields) {
            item = this.asset.fields[name];
            if (IsObject(item, true)) {
                list.push({
                    name: item.name,
                    autoFill: this._fieldHasAutoFill(name),
                });
                if (this._fieldHasChild(name)) {
                    this._getRelationList(item.options.child, list);
                }
            }
        }
        return list;
    }
    /**
     * Determine if field has a child relation in the list
     * @param name
     */
    _fieldHasChild(name) {
        if (name in this.asset.fields && this.asset.fields[name].options) {
            if (this.asset.fields[name].options.child) {
                return true;
            }
        }
        return false;
    }
    /**
     * Determine if field should be auto filled with the first item in the list
     * @param name
     */
    _fieldHasAutoFill(name) {
        if (name in this.asset.fields && this.asset.fields[name]) {
            if (this.asset.fields[name].autoFill) {
                return true;
            }
        }
        return false;
    }
}
PopEntityFieldGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-group',
                template: "<div class=\"pop-entity-field-group-container\">\n  <ng-container #container></ng-container>\n</div>\n",
                styles: [".pop-entity-field-group-container{max-width:450px}"]
            },] }
];
PopEntityFieldGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopEntityFieldGroupComponent.propDecorators = {
    position: [{ type: Input }],
    fieldType: [{ type: Input }],
    interface: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class TableOptionsConfig {
    constructor(params) {
        this.columns = [];
        this.allowColumnDisplayToggle = true;
        this.allowColumnStickyToggle = true;
        this.allowColumnSearchToggle = true;
        this.allowColumnSortToggle = true;
        this.allowHeaderStickyToggle = true;
        this.allowHeaderDisplayToggle = true;
        this.allowPaginatorToggle = true;
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (this.defaultOptions.headerDisplay !== false)
            this.defaultOptions.headerDisplay = true;
        if (this.defaultOptions.headerSticky !== false)
            this.defaultOptions.headerSticky = true;
        if (!this.defaultOptions.paginator)
            this.defaultOptions.paginator = 0;
        if (this.defaultOptions.search !== false)
            this.defaultOptions.search = true;
        if (this.defaultOptions.searchColumns !== true)
            this.defaultOptions.searchColumns = false;
        if (this.defaultOptions.sort !== true)
            this.defaultOptions.sort = false;
    }
}
class TableConfig {
    constructor(params) {
        // General Params
        this.buttons = [];
        this.columnDefinitions = {};
        this.dealWithAngularChangeDetectionFailure = false;
        this.data = [];
        this.height = 500; // static height px
        this.initialSort = null;
        this.initialSortDirection = 'asc';
        this.loading = false;
        this.metadata = null;
        this.options = null;
        this.sort = false;
        this.route = '';
        this.linkBehavior = 'route';
        // Optionable Params
        //  - These can be toggled in options so if any default are changed here make sure to also subject them in TableOptionsConfig
        this.headerDisplay = true;
        this.headerSticky = false;
        this.paginator = false;
        this.search = true;
        this.searchValue = '';
        this.searchColumns = false;
        this.advanced_search = false;
        // Built through updates.
        this.matData = new MatTableDataSource();
        this.columnConfig = { visible: [], templates: {} };
        if (params)
            for (const i in params)
                this[i] = params[i];
        if (!(['route', 'portal'].includes(this.linkBehavior)))
            this.linkBehavior = 'route';
        // Run these in case params had conflicting info.
        if (this.paginator) {
            this.headerSticky = false;
        }
    }
}

class PopEntityHistoryComponent extends PopExtendComponent {
    constructor(el, cdr) {
        super();
        this.el = el;
        this.cdr = cdr;
        this.name = 'PopEntityHistoryComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.setHeight(PopTemplate.getContentHeight(), 100);
                yield this.buildTable();
                this.dom.state.hasData = IsArray(StorageGetter(this.config, ['matData', 'data'], []), true);
                return resolve(true);
            }));
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    buildTable() {
        return new Promise((resolve) => {
            this.dom.setSubscriber('history-api-call', this.core.repo.getHistory(+this.core.params.entityId).subscribe(history => {
                // Build the config.
                // Prepare and load the data.
                history = this._prepareTableData(history, this.core.repo.model.field);
                const tableConfig = {
                    height: this.dom.height.inner,
                    search: true,
                    columnDefinitions: {
                        user: { visible: true, order: 1, internal_name: 'user', route: '/admin/users/:user_fk' },
                        action: { visible: true, order: 2 },
                        message: { visible: true, order: 3 },
                        timestamp: { visible: true, order: 4 },
                    },
                    data: Array.isArray(history) ? history : [],
                };
                this.config = new TableConfig(tableConfig);
                try {
                    this.cdr.detectChanges();
                }
                catch (e) {
                }
                return resolve(true);
            }, err => {
                this.dom.error = {
                    code: (err.error ? err.error.code : err.status),
                    message: (err.error ? err.error.message : err.statusText)
                };
                try {
                    this.cdr.detectChanges();
                }
                catch (e) {
                }
                return resolve(false);
            }));
        });
    }
    eventHandler(event) {
        if (event.type === 'table') {
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * A method that preps entityId list data for tables
     * @param dataSet
     * @param fieldMap
     */
    _prepareTableData(dataSet, fieldMap = {}, entityConfig = null) {
        // Determine which fields should be acted upon.
        const transformations = GetObjectTransformations(fieldMap);
        return IsArray(dataSet, true) ? dataSet.map(row => PopPipe.transformObjectValues(Object.assign({}, row), transformations, entityConfig)) : dataSet;
    }
}
PopEntityHistoryComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-history',
                template: "<div class=\"entity-history-container\">\n  <div class=\"entity-history-loader-bar\" *ngIf=\"dom.state.loading\">\n    <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n  <div *ngIf=\"!dom.state.hasData\" class=\"entity-history-empty-container\">\n    <div class=\"entity-history-row\">\n      <mat-icon class=\"sw-helper-icon\" [style.marginLeft]=\"'-24px'\">sentiment_dissatisfied</mat-icon>\n    </div>\n    <div class=\"sw-label-container\" [style.textAlign]=\"'center'\">Such Empty!</div>\n  </div>\n  <lib-pop-table *ngIf=\"dom.state.hasData\"  (events)=\"eventHandler($event);\" [config]=\"config\"></lib-pop-table>\n</div>\n<lib-pop-errors *ngIf=\"dom.error.code\" [error]=\"dom.error\"></lib-pop-errors>\n",
                styles: [".entity-history-container{display:flex;width:100%;height:100%;flex-direction:column;justify-content:stretch}.entity-history-container>lib-pop-table{flex:1}.entity-history-empty-container{flex:1 1;min-height:200px;flex-direction:column;justify-content:stretch;align-items:center}.entity-history-row{flex:1 1;min-height:200px;flex-direction:row;justify-content:center;align-items:center;min-height:30px;text-align:center}.entity-history-loader-bar{position:absolute;left:0;right:0;bottom:0}::ng-deep td,:host ::ng-deep th{min-width:50px;max-width:300px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;height:48px;max-height:48px}:host ::ng-deep th>.mat-sort-header-container{display:flex;min-width:50px;max-width:300px}:host ::ng-deep td[class*=fk],:host ::ng-deep th[class*=fk]{min-width:50px;max-width:100px;text-align:center!important;justify-content:center}:host ::ng-deep th[class*=fk]>.mat-sort-header-container{min-width:50px!important;max-width:100px!important;justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=id],:host ::ng-deep th[class*=id]{min-width:50px;max-width:100px;text-align:center!important;justify-content:center}:host ::ng-deep th[class*=id]>.mat-sort-header-container{min-width:100px!important;max-width:100px!important;justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=-message],:host ::ng-deep th[class*=-name]{text-align:left!important;padding-left:20px!important;min-width:50px!important;max-width:500px!important}:host ::ng-deep th[class*=-message] .mat-sort-header-container{min-width:50px!important;max-width:500px!important;padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-description],:host ::ng-deep th[class*=-name]{text-align:left!important;padding-left:20px!important;min-width:50px!important;max-width:500px!important}:host ::ng-deep th[class*=-description] .mat-sort-header-container{min-width:50px!important;max-width:500px!important;padding-left:0!important;justify-content:left!important}"]
            },] }
];
PopEntityHistoryComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
PopEntityHistoryComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopEntityProviderDialogComponent {
    constructor(data, entityUtilRepo, entityPortalRepo, baseRepo, dialogRepo, dialog) {
        this.entityUtilRepo = entityUtilRepo;
        this.entityPortalRepo = entityPortalRepo;
        this.baseRepo = baseRepo;
        this.dialogRepo = dialogRepo;
        this.dialog = dialog;
        this.state = {
            blockModal: false,
            assignmentChange: false,
            changed: false
        };
        this.subscriber = {
            crud: undefined,
            dialog: undefined,
        };
        this.display = data.display;
        this.config = data.config;
        this.table = data.table;
        this.resource = data.resource;
    }
    ngOnInit() {
        if (!this.display)
            this.display = this.getDisplay();
        this.subscriber.crud = ServiceInjector.get(PopEntityEventService).events.subscribe((event) => this.crudEventHandler(event));
        this.subscriber.dialog = this.dialog.beforeClosed().subscribe(_ => {
            this.dialog.close(this.state.changed);
        });
    }
    getDisplay() {
        const entityName = this.config.entity.display_name ? this.config.entity.display_name : this.config.entity.name;
        const resourceType = this.resource.entity ? this.resource.entity : 'Entity';
        const resourceName = this.resource.name ? this.resource.name : 'Resource';
        return `${entityName} - (${resourceName} - ${resourceType} ) - Provider List`;
    }
    crudEventHandler(event) {
        console.log('crudEventHandler', event);
        if (event.method === 'create' || event.method === 'delete') {
            this.state.changed = true;
        }
        else {
            if (event.type === 'entity') {
                if (event.name === 'archive') {
                    this.state.changed = true;
                }
            }
            else if (event.type === 'field' && event.name === 'patch') {
                const patch = {};
                patch[event.config.column] = event.config.control.value;
                const signature = event.config.metadata;
                const signatureMatches = this.table.matData.data.filter(function (row, i) {
                    return ((row['internal_name'] === signature.internal_name && +row['id'] === +signature.id));
                });
                if (Array.isArray(signatureMatches) && signatureMatches.length) {
                    signatureMatches.map((row) => {
                        Object.keys(patch).map((column) => {
                            if (column in row) {
                                row[column] = patch[column];
                                this.state.changed = true;
                            }
                        });
                    });
                }
            }
            else if (event.type === 'sidebyside' && event.name === 'patch') {
                const signature = Object.assign({}, event.config.metadata);
                const signatureMatches = this.table.matData.data.filter(function (row, i) {
                    return ((row['internal_name'] === signature.internal_name && +row['id'] === +signature.id));
                });
                if (Array.isArray(signatureMatches) && signatureMatches.length) {
                    this.state.changed = true;
                    this.state.assignmentChange = true;
                }
            }
        }
    }
    eventHandler(event) {
        if (event.type === 'table') {
            switch (event.data.link) {
                case 'provider':
                    this.viewEntityPortal(event.data.row.internal_name, +event.data.row.id);
                    break;
                default:
                    break;
            }
        }
    }
    viewEntityPortal(internal_name, id) {
        // placeholder
        this.entityPortalRepo.view(internal_name, id);
    }
    cancel() {
        this.dialog.close(this.state.changed);
    }
    ngOnDestroy() {
        Object.keys(this.subscriber).map((name) => {
            if (this.subscriber[name]) {
                this.subscriber[name].unsubscribe();
            }
        });
    }
}
PopEntityProviderDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-provider-dialog',
                template: "<h2 *ngIf=\"display\">{{display}}</h2>\n<lib-pop-table *ngIf=\"table\" (events)=\"eventHandler($event);\" [config]=\"table\"></lib-pop-table>\n<div class=\"buttons\">\n  <div class=\"cancel\">\n    <button mat-raised-button (click)=\"cancel()\">Close</button>\n  </div>\n</div>",
                styles: [":host{flex:1 1 100%;min-width:200px;min-height:200px}::ng-deep mat-dialog-container{position:relative}.buttons{margin:10px 0;display:flex;justify-content:space-between}.buttons .cancel{order:1;flex-grow:1;display:flex;justify-content:flex-end}"]
            },] }
];
PopEntityProviderDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: PopEntityService },
    { type: PopEntityUtilPortalService },
    { type: PopBaseService },
    { type: MatDialog },
    { type: MatDialogRef }
];

class PopEntityAssignmentsComponent extends PopExtendComponent {
    constructor(el, cdr, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this.cdr = cdr;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntityAssignmentsComponent';
        this.srv = {
            base: ServiceInjector.get(PopBaseService),
            dialog: ServiceInjector.get(MatDialog),
            events: ServiceInjector.get(PopEntityEventService),
            entity: ServiceInjector.get(PopEntityService),
            tab: undefined,
        };
        this.asset = {
            entityParamsMap: {},
            assignedUserMap: undefined
        };
        /**
         * This should transformValue and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                this.dom.state = Object.assign(Object.assign({}, this.dom.state), {
                    directBaseline: false,
                    dataHasDirect: false,
                    dataHasParent: false,
                    dataHasProviders: false,
                    dataHasType: false,
                    blockModal: false,
                    loaded: false,
                    loading: true,
                    error: { code: 0, message: '' },
                });
                this.ui.table = {
                    config: undefined,
                };
                this.dom.setHeight(PopTemplate.getContentHeight(), 100);
                this.buildTable();
                this.dom.state.hasData = IsArray(StorageGetter(this.ui.table.config, ['matData', 'data'], []), true);
                return resolve(true);
            }));
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    buildTable() {
        let parentLabel;
        const isDialogLimit = this.srv.dialog.openDialogs.length > 3;
        if (this.core && this.core.params)
            this.core.params.refresh = false;
        const columnDefinitions = {};
        // this.subscribers.entity = this.entityRepo.events.subscribe((e) => this.crudEventHandler(e));
        if (this.fieldType && String(this.fieldType).includes('assigned_') === false)
            this.fieldType = `assigned_${this.fieldType}`;
        // this.fieldType should reference a entity.metadata key <'assigned_XXXXXX'> if not this.fieldType grab anything with the 'assigned_' prefix in entity.metadata;
        const data = this.getTableData();
        if (this.fieldType && this.dom.state.dataHasParent) {
            parentLabel = TitleCase(SnakeToPascal(PopPipe.transform(data[0].parent.internal_name, { type: 'entity', arg1: 'alias', arg2: 'singular' }))).trim();
        }
        this.ui.table.config = new TableConfig({
            height: this.dom.height.outer,
            paginator: false,
            search: data.length >= 10 ? true : false,
            searchColumns: false,
            columnDefinitions: {
                name: {
                    visible: true,
                    helper: isDialogLimit ? null : { text: 'Jump To: <name>', position: 'right' },
                    link: isDialogLimit ? false : 'entity',
                    order: 0,
                },
                entity: {
                    visible: !this.fieldType ? true : false,
                    order: 1,
                },
                direct: {
                    visible: this.dom.state.dataHasDirect ? true : false,
                    order: 2,
                },
                type: {
                    visible: this.dom.state.dataHasType ? true : false,
                    order: 3,
                },
                parent_name: {
                    visible: this.fieldType && this.dom.state.dataHasParent && parentLabel ? true : false,
                    display: parentLabel,
                    link: 'parent',
                    order: 4,
                },
                has_providers: {
                    display: 'Provider',
                    visible: this.dom.state.dataHasProviders ? true : false,
                    link: 'providers',
                    // helper: { text: 'Jump To: <name>', position: 'right' },
                    order: 5,
                },
                // assigned: {
                //   visible: true,
                //   link: 'section_users',
                //   // helper: { text: 'Jump To: <name>', position: 'right' },
                //   order: 4,
                // },
                // id: {
                //   visible: this.fieldType ? true : false,
                //   order: 100,
                // },
            },
            data: data,
        });
        this.dom.state.loading = false;
        this.dom.state.loaded = true;
        try {
            this.cdr.detectChanges();
        }
        catch (e) {
        }
    }
    crudEventHandler(event) {
        if (this.dom.subscriber.dialog) {
            if (event.method === 'create' || event.method === 'delete') {
                if (this.core && this.core.params)
                    this.core.params.refresh = true;
            }
            else if (event.method === 'update') {
                if (event.type === 'entity') {
                    if (event.name === 'archive') {
                        if (this.core && this.core.params)
                            this.core.params.refresh = true;
                    }
                }
                else if ((event.type === 'field' || event.type === 'sidebyside') && event.name === 'patch') {
                    if (this.core && this.core.params)
                        this.core.params.refresh = true;
                }
            }
        }
    }
    getKeyInternalName(key) {
        return String(key).replace(/(pt_leader|pt_member|_fk|assigned_)/g, '');
    }
    getEntityParams(key, id = null) {
        let entityParams;
        key = this.getKeyInternalName(key);
        if (key in this.asset.entityParamsMap) {
            return this.asset.entityParamsMap[key];
        }
        if (key === 'user') {
            entityParams = {
                app: 'admin',
                internal_name: 'user',
                api: 'user',
            };
        }
        else {
            entityParams = this.srv.entity.getEntityParams(key);
        }
        if (!entityParams) {
            entityParams = this.srv.entity.getEntityParamsWithPath(key);
        }
        this.asset.entityParamsMap[key] = entityParams;
        if (this.log.repo.enabled())
            console.log(this.log.repo.message('PopEntityAssignmentsComponent:entityParams'), this.log.repo.color('info'), DeepCopy(this.asset.entityParamsMap[key]));
        return DeepCopy(this.asset.entityParamsMap[key]);
    }
    getTableData() {
        this.asset.assignedUserMap = {};
        const data = [];
        let rows;
        let userRows = [];
        let user;
        if (this.core && this.core.entity && IsObject(this.core.entity.metadata, true)) {
            if (IsString(this.fieldType, true)) {
                if (IsArray(this.core.entity.metadata[this.fieldType], true)) {
                    rows = this.core.entity.metadata[this.fieldType].map((row) => {
                        return this.transformRow(this.fieldType, row);
                    });
                    if (this.fieldType.includes('user') === false) { // users are handled special because they inherit assignments from multiple sources
                        data.push(...rows);
                    }
                    else {
                        userRows = rows;
                    }
                }
            }
            else {
                Object.keys(this.core.entity.metadata).map((key) => {
                    if (key && String(key).includes('assigned_') && this.getEntityParams(key) && IsArray(this.core.entity.metadata[key], true)) {
                        rows = this.core.entity.metadata[key].map((row) => {
                            return this.transformRow(key, row);
                        });
                        if (key.includes('user') === false) { // users are handled special because they inherit assignments from multiple sources
                            data.push(...rows);
                        }
                        else {
                            userRows = rows;
                        }
                    }
                });
            }
        }
        if (IsArray(userRows, true)) {
            userRows.map((row) => {
                if (row.id in this.asset.assignedUserMap)
                    this.asset.assignedUserMap[row.id].direct = true;
            });
        }
        if (IsObject(this.asset.assignedUserMap, true)) {
            rows = Object.keys(this.asset.assignedUserMap).map((id) => {
                user = this.asset.assignedUserMap[id];
                return {
                    id: +id,
                    internal_name: 'user',
                    name: user.name,
                    entity: 'User',
                    direct: user.direct,
                    providers: user.providers,
                };
            });
            data.push(...rows);
        }
        data.sort(function (a, b) {
            // Sort by Entity
            if (a.entity > b.entity)
                return 1;
            if (a.entity < b.entity)
                return -1;
            // Sort by Title
            if (a.name > b.name)
                return 1;
            if (a.name < b.name)
                return -1;
        });
        data.map((row) => {
            if (!this.dom.state.directBaseline)
                this.dom.state.directBaseline = row.direct;
            if (row.direct !== this.dom.state.directBaseline)
                this.dom.state.dataHasDirect = true;
            if (row.parent) {
                row.parent_name = row.parent.name;
                this.dom.state.dataHasParent = true;
            }
            row.has_providers = IsArray(row.providers, true) ? 'Yes' : null;
            if (row.has_providers) {
                this.dom.state.dataHasProviders = true;
                row.providers = ArrayRemoveDupliates(row.providers, 'uid');
                row.has_providers = this.getProvidersName(row.providers);
                row.providers.map((provider) => {
                    if (provider.internal_name)
                        provider.entityId = TitleCase(SnakeToPascal(PopPipe.transform(provider.internal_name, {
                            type: 'entity',
                            arg1: 'alias',
                            arg2: 'singular'
                        }))).trim();
                    if (provider.type)
                        provider.type = TitleCase(SnakeToPascal(provider.type)).trim();
                    if (provider.direct)
                        row.direct = true;
                });
            }
            row.direct = row.direct ? 'Yes' : 'No';
            if (row.type) {
                this.dom.state.dataHasType = true;
                row.type = TitleCase(SnakeToPascal(row.type)).trim();
            }
        });
        if (this.log.repo.enabled())
            console.log(this.log.repo.message('PopEntityAssignmentsComponent:data'), this.log.repo.color('data'), data);
        return data;
    }
    assignUsers(users, provider) {
        if (IsArray(users, true)) {
            users.map((user) => {
                if (+user.id && user.name) {
                    if (!this.asset.assignedUserMap[user.id])
                        this.asset.assignedUserMap[user.id] = { id: user.id, name: user.name, direct: false, providers: [] };
                    this.asset.assignedUserMap[user.id].providers.push(provider);
                }
            });
        }
    }
    getProvidersName(providers) {
        let types = [];
        if (IsArray(providers, true)) {
            providers.map((provider) => {
                if (provider.internal_name)
                    types.push(TitleCase(SnakeToPascal(PopPipe.transform(provider.internal_name, {
                        type: 'entity',
                        arg1: 'alias',
                        arg2: 'singular'
                    }))).trim());
            });
            types = ArrayOnlyUnique(types);
            types.sort();
        }
        if (this.log.repo.enabled())
            console.log(this.log.repo.message('PopEntityAssignmentsComponent:providersName'), this.log.repo.color('info'), IsArray(types, true) ? types.join(', ') : 'Yes');
        return IsArray(types, true) ? types.join(', ') : 'Yes';
    }
    transformRow(key, row) {
        const entityParams = this.getEntityParams(key);
        // entityParams.entity = row.id;
        // console.log('entityParams', entityParams);
        let direct = row.direct ? true : false;
        let providers = IsArray(row.providers, true) ? row.providers : [];
        let provider;
        const keyInternalName = this.getKeyInternalName(key);
        row.internal_name = keyInternalName;
        const entity = TitleCase(SnakeToPascal(PopPipe.transform(keyInternalName, { type: 'entity', arg1: 'alias', arg2: 'singular' }))).trim();
        let type = row.type ? row.type : '';
        if (entityParams.internal_name) {
            const matches = Object.keys(row).filter((field) => {
                if (field.includes(this.core.params.internal_name) && +row[field] === +this.core.params.entityId) {
                    return true;
                }
            });
            switch (row.internal_name) {
                case 'pod_type':
                    if (IsArray(matches, true)) {
                        direct = true;
                    }
                    if (IsArray(row.pods)) {
                        row.pods.map((pod) => {
                            if (pod.assigned_leaders)
                                this.assignUsers(pod.assigned_leaders, {
                                    id: +pod.id,
                                    name: pod.name,
                                    entity: entity,
                                    type: 'Leader',
                                    internal_name: 'pod',
                                    uid: `pod_${pod.id}_leader`
                                });
                            if (pod.assigned_members)
                                this.assignUsers(pod.assigned_members, {
                                    id: +pod.id,
                                    name: pod.name,
                                    entity: entity,
                                    type: 'Member',
                                    internal_name: 'pod',
                                    uid: `pod_${pod.id}_member`
                                });
                        });
                    }
                    break;
                case 'pod':
                    matches.map((matchFieldName) => {
                        if (IsArray(matches, true)) {
                            if (this.core.params.internal_name === 'security_profile') {
                                type = String(matchFieldName).includes('leader') ? 'Leader' : 'Member';
                                if (String(matchFieldName).includes('pt_')) {
                                    provider = { id: row.pod_type_fk, name: row.pod_type, internal_name: 'pod_type', type: type, uid: `pod_type_${row.pod_type_fk}_${type}` };
                                    providers = [provider];
                                }
                                else {
                                    direct = true;
                                }
                            }
                        }
                        if (row.assigned_leaders)
                            this.assignUsers(row.assigned_leaders, {
                                id: row.id,
                                name: row.name,
                                entity: entity,
                                type: 'Leader',
                                internal_name: 'pod',
                                uid: `pod_${row.id}_leader`
                            });
                        if (row.assigned_members)
                            this.assignUsers(row.assigned_members, {
                                id: row.id,
                                name: row.name,
                                entity: entity,
                                type: 'Member',
                                internal_name: 'pod',
                                uid: `pod_${row.id}_member`
                            });
                    });
                    break;
                case 'role':
                    if (IsArray(matches, true)) {
                        direct = true;
                        if (row.assigned_user)
                            this.assignUsers(row.assigned_user, {
                                id: +row.id,
                                name: row.name,
                                entity: entity,
                                internal_name: 'role',
                                uid: `role_${row.id}`
                            });
                    }
                    break;
                case 'user':
                    if (IsArray(matches, true)) {
                        direct = true;
                        this.assignUsers([row], { id: +row.id, name: row.name, entity: entity, internal_name: 'user', type: 'User', uid: `user_${row.id}_${type}` });
                    }
                    break;
                default:
                    break;
            }
        }
        return {
            id: row.id,
            internal_name: row.internal_name,
            name: row.display_name ? row.display_name : row.name,
            parent: row.parent,
            entity: TitleCase(SnakeToPascal(PopPipe.transform(keyInternalName, { type: 'entity', arg1: 'alias', arg2: 'singular' }))).trim(),
            direct: direct,
            type: type,
            providers: providers,
            uid: type ? `${keyInternalName}_${row.id}_${type}` : `${keyInternalName}_${row.id}`
        };
    }
    eventHandler(event) {
        if (event.type === 'table') {
            if (this.log.repo.enabled())
                console.log(this.log.repo.message('PopEntityAssignmentsComponent:event'), this.log.repo.color('event'), event);
            switch (event.data.link) {
                case 'entity':
                    this.viewEntityPortal(event.data.row.internal_name, +event.data.row.id);
                    break;
                case 'parent':
                    if (event.data.row && event.data.row.parent) {
                        this.viewEntityPortal(event.data.row.parent.internal_name, +event.data.row.parent.id);
                    }
                    break;
                case 'providers':
                    this.viewRowProviders(event.data.row);
                    break;
                default:
                    break;
            }
        }
    }
    viewEntityPortal(internal_name, id) {
        // placeholder
        if (!this.dom.state.blockModal) {
            this.dom.state.blockModal = true;
            if (internal_name && +id) {
                this.srv.entity.getCoreConfig(internal_name, +id).then((entityConfig) => {
                    let tabMenuConfig = this._buildTabMenuConfig(entityConfig);
                    tabMenuConfig.portal = true;
                    let dialogRef = this.srv.dialog.open(PopEntityTabMenuComponent, {
                        width: `${window.innerWidth - 20}px`,
                        height: `${window.innerHeight - 50}px`,
                        data: entityConfig,
                        panelClass: 'sw-relative'
                    });
                    let component = dialogRef.componentInstance;
                    component.registerTabMenuConfig(tabMenuConfig);
                    this.dom.subscriber.dialog = dialogRef.beforeClosed().subscribe(() => {
                        this.dom.state.blockModal = false;
                        this.srv.tab.refreshEntity(this.core.params.entityId, null, {}, 'PopEntityAssignmentsComponent:viewEntityPortal').then(() => {
                            dialogRef = null;
                            tabMenuConfig = null;
                            component = null;
                        });
                    });
                });
            }
        }
    }
    viewRowProviders(row) {
        if (!this.dom.state.blockModal) {
            this.dom.state.blockModal = true;
            const data = [];
            const tableConfig = new TableConfig({
                search: false,
                searchColumns: false,
                headerSticky: true,
                // paginator: 5,
                columnDefinitions: {
                    name: {
                        visible: true,
                        helper: { text: 'Jump To: <name>', position: 'right' },
                        link: 'provider',
                        order: 0,
                    },
                    entity: {
                        visible: true,
                        // link: 'assigned',
                        // helper: { text: 'Jump To: <name>', position: 'right' },
                        order: 1,
                    },
                    type: {
                        visible: true,
                        // link: 'assigned',
                        // helper: { text: 'Jump To: <name>', position: 'right' },
                        order: 2,
                    },
                    id: {
                        visible: true,
                        order: 100,
                    },
                },
                data: row.providers
            });
            const dialogRef = this.srv.dialog.open(PopEntityProviderDialogComponent, {
                data: {
                    table: tableConfig,
                    config: this.core,
                    resource: row,
                }
            });
            this.dom.setSubscriber('pop-table-dialog-close', dialogRef.beforeClosed().subscribe((changed) => {
                this.dom.state.blockModal = false;
                if (true) {
                    this.srv.tab.refreshEntity(null, this.dom.repo, {}, 'PopEntityAssignmentsComponent:viewRowProviders').then(() => true);
                }
            }));
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _buildTabMenuConfig(core) {
        return GetTabMenuConfig(core, this.srv.entity.getEntityTabs(core));
    }
}
PopEntityAssignmentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-assignments',
                template: "<div class=\"entity-assignment-container\">\n  <div class=\"entity-assignment-loader-bar\" *ngIf=\"dom.state.loading\">\n    <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n  <div *ngIf=\"ui.table && ui.table.config\">\n    <div *ngIf=\"!dom.state.hasData\" class=\"host-empty-container\">\n      <div class=\"host-row\">\n        <mat-icon class=\"sw-helper-icon\" [style.marginLeft]=\"'-24px'\">sentiment_dissatisfied</mat-icon>\n      </div>\n      <div class=\"sw-label-container\" [style.textAlign]=\"'center'\">Such Empty!</div>\n    </div>\n    <lib-pop-table *ngIf=\"dom.state.hasData\" [config]=\"ui.table.config\" (events)=\"eventHandler($event);\"></lib-pop-table>\n  </div>\n</div>\n<lib-pop-errors *ngIf=\"dom.error.code\" [error]=\"dom.error\"></lib-pop-errors>\n",
                styles: [".entity-assignment-container{border:1px solid var(--border)}.host-empty-container{min-height:200px;flex-direction:column;justify-content:stretch;align-items:center}.host-row{flex-direction:row;justify-content:center;align-items:center;min-height:30px;text-align:center}::ng-deep td,:host ::ng-deep th{min-width:50px;max-width:100px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;height:48px;max-height:48px}.entity-assignment-loader-bar{position:absolute;left:0;right:0;bottom:0}:host ::ng-deep th>.mat-sort-header-container{display:flex}::ng-deep th[class*=fk],:host ::ng-deep td[class*=fk]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=fk]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=id],:host ::ng-deep th[class*=id]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=id]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=-name],:host ::ng-deep th[class*=-name]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-name] .mat-sort-header-container{padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-type],:host ::ng-deep th[class*=-type]{text-align:center!important}:host ::ng-deep th[class*=-type] .mat-sort-header-container{justify-content:center}"]
            },] }
];
PopEntityAssignmentsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopEntityAssignmentsComponent.propDecorators = {
    fieldType: [{ type: Input }],
    header: [{ type: Input }]
};

class PopEntityFieldSettingsComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _domRepo - transfer
     * @param _fieldRepo - transfer
     */
    constructor(el, _domRepo, _fieldRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this.name = 'PopEntityFieldSettingsComponent';
        this.srv = {
            field: undefined,
        };
        this.asset = {
            schemeFieldSetting: {},
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configure: - this.core`) ? this.core : null;
                this.field = this.core.entity;
                if (StorageGetter(this.dom, ['repo', 'position', String(this.position), 'height'], false)) {
                    this.dom.overhead = 60;
                    this.dom.height.outer = +this.dom.repo.position[this.position].height - 300;
                    this.dom.setHeight(this.dom.repo.asset[this.dom.height.outer], this.dom.overhead);
                }
                if (IsObject(this.scheme)) {
                    this.asset.schemeFieldSetting = this.srv.field.getSchemeFieldSetting(this.scheme, +this.field.id);
                    //           console.log( 'scheme field', this.asset.schemeFieldSetting );
                }
                this.dom.state.hasScheme = IsObject(this.scheme, true) ? true : false;
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityFieldSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-settings',
                template: "<div class=\"entity-field-editor-header\" *ngIf=\"!this.dom.state.hasScheme\">\n  <div class=\"entity-field-editor-header-section\">\n    <div class=\"sw-label-container-sm\">Field Attributes</div>\n  </div>\n  <div class=\"pop-entity-field-editor-header-section\">\n    <p>Assign field value and attributes for this field.</p>\n  </div>\n</div>\n<div class=\"pop-entity-field-editor-settings-container\">\n  <div #entries class=\"import-flex-row\">\n    <lib-pop-entity-field-entries [core]=\"core\" [field]=\"field\" [scheme]=\"scheme\"></lib-pop-entity-field-entries>\n  </div>\n\n  <mat-divider [style.width.%]=100 [style.marginBottom.px]=15></mat-divider>\n\n  <div class=\"import-flex-row\" [style.maxHeight.px]=\"dom.height.outer\">\n    <div class=\"import-flex-item-md import-flex-grow-md\">\n      <lib-field-builder-items [core]=\"core\" [scheme]=\"scheme\"></lib-field-builder-items>\n    </div>\n    <div class=\"import-flex-item-md import-flex-grow-md\">\n      <lib-field-builder-items-params [core]=core [scheme]=\"scheme\"></lib-field-builder-items-params>\n    </div>\n  </div>\n</div>\n",
                styles: [":host{flex:1;flex-grow:1}.pop-entity-field-editor-settings-container{display:flex;flex-direction:column;border:1px solid var(--border);padding:var(--gap-s) var(--gap-sm) var(--gap-sm) var(--gap-sm);background:var(--bg-3);margin:var(--gap-sm) 0}"]
            },] }
];
PopEntityFieldSettingsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService }
];
PopEntityFieldSettingsComponent.propDecorators = {
    field: [{ type: Input }],
    scheme: [{ type: Input }]
};

class PopEntitySchemeFieldSettingComponent extends PopExtendDynamicComponent {
    constructor(el, dialog, _domRepo, _fieldRepo, _utilFieldRepo) {
        super();
        this.el = el;
        this.dialog = dialog;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this._utilFieldRepo = _utilFieldRepo;
        this.config = {};
        this.name = 'PopEntitySchemeFieldSettingComponent';
        this.srv = {
            field: undefined,
            utilField: undefined,
        };
        this.asset = {
            currentFieldTraitEntryMapping: undefined,
            currentPrimary: undefined,
            fieldTraitEntryMapping: undefined,
            fieldCore: undefined,
            field: undefined,
            scheme: undefined,
            storage: undefined,
        };
        this.ui = {
            name: undefined,
            makePrimary: undefined,
            showName: undefined,
            showNameCore: undefined,
            profileRequired: undefined,
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this._setInitialConfig();
                this.template.attach('container');
                this._templateRender();
                return resolve(true);
            }));
        };
    }
    onEscapeHandler(event) {
        console.log('esc', event);
        this.onFormClose();
    }
    onFormClose() {
        if (IsObject(this.dialog)) {
            this.dialog.close(this.core.entity);
        }
    }
    onOutsideCLick() {
        console.log('onOutsideCLick');
        // if( IsObject( this.dialog ) ){
        //   this.dialog.close(this.config);
        // }
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setInitialConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.asset.fieldCore = yield PopEntity.getCoreConfig('field', this.config.asset_id);
            this.asset.field = this.asset.fieldCore.entity;
            this.asset.scheme = this.core.entity;
            // this.asset.scheme.traits = this.srv.field.getFieldTraits( this.asset.field.fieldgroup.name );
            this.dom.state.isMultipleValues = +this.asset.field.multiple === 1;
            yield this.srv.field.register(this.asset.fieldCore, this.dom.repo, this.asset.scheme);
            this.ui.showName = StorageGetter(this.dom.repo, 'ui.customSetting.show_name.inputs.config'.split('.'), null);
            this.ui.showNameCore = StorageGetter(this.dom.repo, 'ui.customSetting.show_name.inputs.core'.split('.'), null);
            this.srv.utilField.clearCustomFieldCache(+this.core.entity.id);
            this.ui.name = new InputConfig({
                name: 'label',
                label: 'Name',
                value: this.config.asset.label,
                readonly: true,
                facade: true,
                patch: {
                    field: 'label',
                    path: ''
                }
            });
            if ('make_primary' in this.asset.field.setting) {
                const primary = this.srv.field.getSchemePrimary(this.asset.scheme);
                const fieldGroupName = StorageGetter(this.asset.field, ['fieldgroup', 'name']);
                const isPrimary = +primary[fieldGroupName] === +this.asset.field.id;
                this.asset.currentPrimary = IsNumber(primary[fieldGroupName]) ? +primary[fieldGroupName] : null;
                this.asset.currentFieldTraitEntryMapping = this.srv.field.getSchemeFieldSection(this.asset.scheme, +this.asset.field.id, 'trait_entry');
                this.asset.storage = this.srv.field.getSchemeFieldSetting(this.asset.scheme, +this.asset.field.id);
                // console.log( 'currentPrimary', this.asset.currentPrimary );
                // console.log( 'currentFieldEntityMapping', this.asset.currentFieldTraitEntryMapping );
                this.asset.fieldTraitEntryMapping = {};
                if (IsArray(this.asset.field.trait, true)) {
                    this.asset.field.trait.map((trait) => {
                        this.asset.fieldTraitEntryMapping[trait.name] = this.asset.field.entries[0].id;
                    });
                }
                // console.log( 'fieldTraitEntryMapping', this.asset.fieldTraitEntryMapping );
                if (IsObject(primary) && IsString(fieldGroupName, true)) {
                    this.ui.makePrimary = new SwitchConfig({
                        label: `Primary ${this.asset.field.fieldgroup.label}`,
                        value: isPrimary,
                        disabled: isPrimary,
                        facade: true,
                        patch: {
                            field: '',
                            path: '',
                            callback: (core, event) => __awaiter(this, void 0, void 0, function* () {
                                this.dom.setTimeout(`update-primary`, () => __awaiter(this, void 0, void 0, function* () {
                                    if (event.config.control.value) {
                                        primary[fieldGroupName] = +this.asset.field.id;
                                        this.asset.storage.entity_trait = this.asset.fieldTraitEntryMapping;
                                    }
                                    else {
                                        primary[fieldGroupName] = this.asset.currentPrimary;
                                        this.asset.storage.entity_trait = this.asset.currentFieldTraitEntryMapping;
                                    }
                                    yield this.srv.field.updateSchemePrimaryMapping(this.asset.scheme);
                                    this._templateRender();
                                }));
                            })
                        }
                    });
                }
            }
            const required = this.srv.field.getSchemeRequired(this.asset.scheme);
            const isRequired = required.includes(+this.asset.field.id);
            this.ui.profileRequired = new SwitchConfig({
                label: `Required To Save ${PopPipe.transform('profile', { type: 'entity', arg1: 'alias', arg2: 'singular' })}`,
                value: isRequired,
                facade: true,
                patch: {
                    field: '',
                    path: '',
                    callback: (core, event) => {
                        if (event.config.control.value) {
                            required.push(+this.asset.field.id);
                        }
                        else {
                            required.splice(required.indexOf(+this.asset.field.id));
                        }
                        this.srv.field.updateSchemeRequiredMapping(this.asset.scheme);
                    }
                }
            });
            return resolve(true);
        }));
    }
    /**
     * Helper function that renders the list of dynamic components
     *
     */
    _templateRender() {
        this.template.render([{
                type: PopEntityFieldSettingsComponent,
                inputs: {
                    core: this.asset.fieldCore,
                    field: this.asset.field,
                    scheme: this.asset.scheme
                }
            }], [], true);
    }
}
PopEntitySchemeFieldSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-scheme-field-setting',
                template: "<div class=\"entity-scheme-field-loader\" *ngIf=\"dom.state.loader\">\n  <lib-main-spinner></lib-main-spinner>\n</div>\n<div class=\"import-flex-column import-flex-item-full\" [ngClass]=\"{'sw-hidden': !dom.state.loaded}\">\n  <div class=\"import-flex-row import-flex-end-center\">\n    <div class=\"sw-pointer\" (click)=\"onFormClose();\">\n      <mat-icon>close</mat-icon>\n    </div>\n  </div>\n  <div class=\"import-flex-row\">\n    <div class=\"import-flex-column-md\">\n      <lib-pop-input *ngIf=\"ui.name\" [config]=\"ui.name\"></lib-pop-input>\n    </div>\n    <div class=\"import-flex-column-md import-flex-end-center\">\n    </div>\n  </div>\n  <div class=\"entity-scheme-field-setting-container import-flex-column\" (libClickOutside)=\"onOutsideCLick();\">\n    <div class=\"import-flex-row\">\n      <div class=\"import-flex-column-md\">\n        <lib-pop-switch *ngIf=\"!dom.state.isMultipleValues && ui.showName\" [core]=\"ui.showNameCore\" [config]=\"ui.showName\"></lib-pop-switch>\n        <lib-pop-switch *ngIf=\"ui.makePrimary\" [core]=\"ui.showNameCore\" [config]=\"ui.makePrimary\"></lib-pop-switch>\n        <lib-pop-switch *ngIf=\"ui.profileRequired\" [core]=\"ui.profileRequired\" [config]=\"ui.profileRequired\"></lib-pop-switch>\n      </div>\n      <div class=\"import-flex-column-md\">\n      </div>\n    </div>\n    <mat-divider [style.width.%]=\"100\" [style.marginTop.px]=\"5\"></mat-divider>\n    <div class=\"import-flex-row import-flex-item-full\">\n      <ng-template #container></ng-template>\n      <!--<lib-pop-entity-field-settings [core]=ui.fieldCore [field]=\"ui.field\" [scheme]=\"ui.scheme\"></lib-pop-entity-field-settings>-->\n    </div>\n  </div>\n\n  <div class=\"entity-scheme-dialog-buttons\" *ngIf=\"dom.state.loaded\">\n    <button class=\"entity-scheme-dialog-cancel\" mat-raised-button (click)=\"onFormClose();\" [disabled]=\"dom.state.pending\">\n      Close\n    </button>\n  </div>\n</div>\n\n",
                providers: [PopFieldEditorService, PopDomService],
                styles: [".entity-scheme-field-setting-container{flex:1;min-width:650px;border:1px solid var(--border);padding:0 var(--gap-m);margin-top:var(--gap-m);box-sizing:border-box}.entity-scheme-field-loader{height:800px}.entity-scheme-close-btn{position:absolute;top:-20px;right:-20px}.entity-scheme-dialog-buttons{margin-top:20px;margin-bottom:10px;display:flex;justify-content:flex-end}.entity-scheme-dialog-buttons .entity-scheme-dialog-close{order:1;display:flex;align-items:center;justify-content:center;min-height:35px;min-width:120px}"]
            },] }
];
PopEntitySchemeFieldSettingComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: PopDomService },
    { type: PopFieldEditorService },
    { type: PopEntityUtilFieldService }
];
PopEntitySchemeFieldSettingComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    config: [{ type: Input }],
    onEscapeHandler: [{ type: HostListener, args: ['document:keydown.escape', ['$event'],] }]
};

class PopEntitySchemeService extends PopExtendService {
    constructor(// This service is unique to every component, provided in the PopEntityTabComponent
    tabRepo) {
        super();
        this.tabRepo = tabRepo;
        this.name = 'PopEntitySchemeService';
        this.ui = {
            refresh: new Subject(),
            attachedMap: {},
            assetPool: {},
            assignableConfigs: {},
            primary: {},
            primaryIds: [],
            sections_keys: [],
            sections: undefined
        };
        this.asset = {
            attachingSet: {},
            assetMap: {
                field: new Map(),
                component: new Map(),
            },
            core: undefined,
            tab: undefined,
        };
        this._setServiceContainer();
        PopLog.init(this.name, `created:${this.id}`);
    }
    _setServiceContainer() {
        this.srv = {
            action: ServiceInjector.get(PopEntityActionService),
            dialog: ServiceInjector.get(MatDialog),
            tab: this.tabRepo
        };
        delete this.tabRepo;
    }
    /**
     * This fx takes the initial data and configures it to the expected structure and sets up all the ancillary assets needed
     * @param core
     * @param tab
     */
    init(core, tab) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.asset.core = IsObjectThrowError(core, true, `${this.name}:core`) ? core : null;
            this.asset.tab = IsObjectThrowError(tab, true, `${this.name}:init: - tab`) ? tab : {};
            // this.asset.attach = { fields: {}, components: {} };
            // let value;
            this.ui.sections_keys = [];
            if (!(IsObject(core.entity.mapping))) {
                core.entity.mapping = {};
            }
            if (!(IsObject(core.entity.mapping.field))) {
                core.entity.mapping.field = {};
            }
            if (!(IsObject(core.entity.mapping.primary))) {
                core.entity.mapping.primary = {};
            }
            if (!(IsArray(core.entity.mapping.required))) {
                core.entity.mapping.required = [];
            }
            else {
                core.entity.mapping.required = ArrayOnlyUnique(core.entity.mapping.required);
            }
            // if( !( IsObject( core.entity.mapping.field ) ) ){
            //   core.entity.mapping.field = <KeyMap<any>>{};
            // }
            // console.log('orig scheme', core.entity.name, core.entity.mapping);
            this.ui.primary = StorageGetter(core, ['entity', 'mapping', 'primary'], {});
            this.ui.primaryIds = Object.values(this.ui.primary).map((i => +i)).sort();
            const fields = ArrayKeyBy(StorageGetter(this.asset.core, 'resource.custom_fields.data_values'.split('.'), []), 'id');
            Object.keys(fields).map((fieldId) => {
                const field = fields[fieldId];
                field.primary = this.ui.primaryIds.includes(+fieldId);
            });
            const components = ArrayKeyBy(StorageGetter(this.asset.core, 'resource.custom_components.data_values'.split('.'), []), 'id');
            Object.keys(components).map((componentId) => {
                components[componentId].primary = false;
            });
            this.ui.assetPool = {
                field: fields,
                component: components
            };
            PopLog.init(this.name, `ui.assetPool`, this.ui.assetPool);
            Object.keys(this.ui.assetPool).map((assetType) => {
                this._ensureAssetTypeContainers(assetType);
                Object.keys(this.ui.assetPool[assetType]).map((assetId) => {
                    this.asset.assetMap[assetType].set(+assetId, CleanObject(this.ui.assetPool[assetType][assetId]));
                    this.ui.assetPool[assetType][assetId].compact = typeof this.ui.assetPool[assetType][assetId].compact !== 'undefined' ? +this.ui.assetPool[assetType][assetId].compact : 1;
                });
            });
            const defaultSections = [
                {
                    id: 0,
                    name: ``,
                    business_id: PopBusiness.id,
                    scheme_id: +core.entity.id,
                    sort_order: 0,
                    container: true,
                    children: [],
                    mapping: {},
                    modified: true
                },
                {
                    id: 0,
                    name: ``,
                    business_id: PopBusiness.id,
                    scheme_id: +core.entity.id,
                    sort_order: 1,
                    container: true,
                    children: [],
                    mapping: {},
                    modified: true
                },
                {
                    id: 0,
                    name: ``,
                    business_id: PopBusiness.id,
                    scheme_id: +core.entity.id,
                    sort_order: 2,
                    container: true,
                    children: [],
                    mapping: {},
                    modified: true
                }
            ];
            this.ui.sections = IsArrayThrowError(core.entity.children, false, `Entity did not contain children`) ? core.entity.children.slice(0, 3) : []; // turned off copy for now since other components are looking at the _server_sections for looping
            if (!(IsArray(this.ui.sections, true)))
                this.ui.sections = defaultSections;
            const remainingFlex = 4 - this.ui.sections.length;
            this.ui.sections.map((section, index) => {
                section = this._transformSection(section, index);
                // const tableAssets = this._getSectionTableFieldsAssets( section );
                // section.children = [ ...tableAssets, ...section.children ];
                section.predicate = (item) => {
                    const data = item.data;
                    return data.compact;
                };
                this.ui.sections_keys.push(section.position);
            });
            if (this.ui.sections && this.ui.sections.length > 1) {
                const lastSection = this.ui.sections[this.ui.sections.length - 1];
                lastSection.predicate = (item) => {
                    return true;
                };
                if (remainingFlex)
                    lastSection.flex += remainingFlex;
            }
            Object.keys(this.ui.assetPool).map((assetType) => {
                let value;
                Object.keys(this.ui.assetPool[assetType]).map((assetId) => {
                    value = this.ui.attachedMap[assetType].has(+assetId);
                    this.ui.assignableConfigs[assetType][assetId] = new CheckboxConfig({
                        bubble: true,
                        value: value,
                        disabled: value,
                    });
                });
            });
            const requests = [];
            this.ui.sections.map((section) => {
                requests.push(this._resolveSectionId(section).then((id) => {
                    section.id = id;
                }));
            });
            yield forkJoin(requests);
            let primaryIds = JsonCopy(this.ui.primaryIds);
            this.ui.sections.sort(DynamicSort('sort_order'));
            primaryIds = this._checkForTraits(core, this.ui.sections, primaryIds);
            if (IsArray(this.ui.sections, true) && primaryIds.length) {
                primaryIds.map((fieldId) => {
                    this.onAssetAttaching('field', +fieldId, true);
                });
                this.ui.sections[0].children = yield this.onAttachingAssetsToPosition(this.ui.sections[0]);
            }
            return resolve(true);
        }));
    }
    /**
     * This fx is used to remove an asset/child from the scheme
     * @param position
     * @param asset
     */
    onRemoveChildFromLayout(position, child) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const positionIndex = position - 1;
            if (this.asset.core.entity.children[positionIndex]) {
                const container = this.ui.sections[positionIndex];
                if (child && typeof child.sort_order === 'number') {
                    this.srv.tab.showAsLoading(true);
                    yield this._removeSection(child);
                    container.children = container.children.filter((section) => {
                        return section.id !== child.id;
                    });
                    // transferArrayItem( container.children, [], child.sort_order, 0 );
                    container.mapping.sort_order = [];
                    container.children.map((item, index) => {
                        if (item.id)
                            container.mapping.sort_order.push(item.id);
                        item.sort_order = index;
                    });
                    this._setChildAsAttachable(child);
                    this.srv.tab.showAsLoading(false);
                    // this.onTriggerUpdate(1000);
                    return resolve(true);
                }
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * A user can dragSort aassets from one column to another in the scheme layout
     * @param event
     */
    onAssetSortDrop(event) {
        // console.log( 'onAssetSortDrop', event );
        let data;
        let prev;
        if (event.previousContainer === event.container) {
            data = this._getEventContainerData(event.container);
            if (+event.currentIndex < +data.startIndex)
                event.currentIndex = +data.startIndex;
            moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
            this._storePositionSortOrder(this._getSectionByPosition(data.position));
        }
        else {
            data = this._getEventContainerData(event.container);
            prev = this._getEventContainerData(event.previousContainer);
            if (+event.currentIndex < +data.startIndex)
                event.currentIndex = +data.startIndex;
            transferArrayItem(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex);
            this._storePositionSortOrder(this._getSectionByPosition(prev.position));
            this._storePositionSortOrder(this._getSectionByPosition(data.position));
        }
        const droppedItem = event.item.data;
        let section = event.container.data.find((i) => {
            return +i.id === +droppedItem.id;
        });
        if (IsObject(section, ['id'])) {
            section = section;
            if (+data.id !== +section.scheme_id) {
                section.scheme_id = +data.id;
                PopRequest.doPatch(`profile-schemes/${section.id}`, { scheme_id: +data.id }, 1, false).subscribe(() => true);
            }
        }
    }
    /**
     * This fx used to register that a user has check an asset in the asset poll intending to attach it to a column in the scheme
     * @param asset_type
     * @param itemId
     * @param value
     */
    onAssetAttaching(asset_type, itemId, value) {
        if (this.asset.attachingSet[asset_type]) {
            if (value) {
                this.asset.attachingSet[asset_type].add(+itemId);
            }
            else {
                this.asset.attachingSet[asset_type].delete(+itemId);
            }
        }
    }
    /**
     * This fx is used to attach assets to a column in the scheme
     * The user will select which assets from a pool and then click a button representing the column where the assets should be pushed into
     * @param section
     */
    onAttachingAssetsToPosition(section) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            section.id = yield this._resolveSectionId(section);
            if (section.id) {
                const items = this._getAssetsToAttach();
                let child, asset;
                let children = [];
                const requests = [];
                if (IsObject(items, true)) {
                    Object.keys(items).map((assetType) => {
                        Object.keys(items[assetType]).map((itemId) => {
                            asset = this.asset.assetMap[assetType].get(+itemId);
                            child = {
                                id: null,
                                name: asset.name,
                                scheme_id: +section.id,
                                asset_type: assetType,
                                asset_id: +itemId,
                                asset: asset,
                                compact: assetType === 'component' ? asset.compact ? 1 : 0 : 1,
                                position: section.position,
                            };
                            this._setChildAsAttached(child);
                            children.push(child);
                            requests.push(this._resolveSectionId(child).then((id) => {
                                child.id = id;
                            }));
                        });
                    });
                }
                forkJoin(requests).subscribe(() => {
                    const tmp = IsArray(section.children, true) ? section.children : [];
                    section.mapping.sort_order = [];
                    children = [...tmp, ...children];
                    children.map((x, i) => {
                        if (x.id)
                            section.mapping.sort_order.push(x.id);
                        x.sort_order = i;
                    });
                    // this.onTriggerUpdate();
                    this._resetAssetAttachingData();
                    return resolve(children);
                });
            }
            else {
                return resolve(null);
            }
        }));
    }
    /**
     * This fx will take an array of sections an update any of the modified sections
     * @param sections
     */
    onUpdate(sections) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsArray(sections, true)) {
                yield this._update(sections, true);
                return resolve(true);
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * This fx is used to trigger an api call to save the current state of the scheme
     * @param delay
     */
    onTriggerUpdate(delay = 500) {
        this.dom.setTimeout('update-api', () => {
            // this._update();
        }, delay);
    }
    /**   * A user can click on an edit button an edit the config settings of an asset
  
     * @param asset
     */
    onEditAsset(asset) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.dom.state.blockModal) {
                this.dom.state.blockModal = true;
                let componentType = null;
                // console.log('asset', asset);
                if (asset.asset_type === 'field') {
                    componentType = PopEntitySchemeFieldSettingComponent;
                }
                else if (asset.asset_type === 'component') {
                    // console.log('here');
                }
                if (componentType) {
                    const dialogRef = this.srv.dialog.open(PopEntitySchemeFieldSettingComponent, {
                        width: `900px`,
                        height: `1080px`,
                        panelClass: 'sw-mar-sm',
                        disableClose: true
                    });
                    let component = dialogRef.componentInstance;
                    component.core = this.asset.core;
                    component.config = asset;
                    this.dom.setSubscriber('asset-modal', dialogRef.beforeClosed().subscribe((scheme) => {
                        if (scheme) {
                            this.init(this.asset.core, this.asset.tab);
                            component = null;
                        }
                        else {
                            component = null;
                        }
                        this.dom.state.blockModal = false;
                        return resolve(true);
                    }));
                }
                else {
                    this.dom.state.blockModal = false;
                    return resolve(false);
                }
            }
            else {
                this.dom.state.blockModal = false;
                return resolve(false);
            }
        }));
    }
    getFieldMapping(fieldId) {
        const storage = this.asset.core.entity.mapping.field;
        return StorageSetter(storage, [`field_${fieldId}`]);
    }
    ngOnDestroy() {
        PopLog.warn(this.name, `destroyed:${this.id}`);
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * There a by default 3 columns, 1,2,3, this fx allows to find the section that represent one of those columns with
     * @param position number 1,2,3
     * @private
     */
    _getSectionByPosition(position) {
        let section = {};
        // console.log( 'position', position );
        if (+position) {
            const sectionIndex = position - 1;
            // console.log( 'sectionIndex', sectionIndex, this.ui.sections );
            if (sectionIndex in this.ui.sections) {
                section = this.ui.sections[sectionIndex];
            }
        }
        return section;
    }
    /**
     * This fx is used to map the the sort_order of all a section's children
     * @param section
     * @private
     */
    _storePositionSortOrder(section) {
        // console.log( '_storePositionSortOrder', section );
        if (IsObject(section, ['id', 'children'])) {
            section.mapping.sort_order = [];
            if (IsArray(section.children)) {
                section.children.map((item, index) => {
                    // console.log('item', item);
                    if (item.id)
                        section.mapping.sort_order.push(item.id);
                    item.sort_order = index;
                });
                const patch = {
                    mapping: {
                        sort_order: section.mapping.sort_order
                    }
                };
                PopRequest.doPatch(`profile-schemes/${section.id}`, patch, 1, false).subscribe(() => true);
            }
        }
    }
    /**
     * This fx will extract the data attributes stored on a html element
     * @param container
     * @private
     */
    _getEventContainerData(container) {
        const data = DeepCopy(StorageGetter(container, 'element.nativeElement.dataset'.split('.'), {}));
        if (IsObject(data, true)) {
            Object.keys(data).map((key) => {
                data[key] = ParseModelValue(data[key]);
            });
        }
        return data;
    }
    /**
     * Ensure that a section has an id that is stored int the api database
     * @param section
     */
    _resolveSectionId(section) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(section, true)) {
                if (+section.id) {
                    return resolve(+section.id);
                }
                else {
                    const data = this._extractSectionData(section);
                    this.dom.setSubscriber(PopUid(), PopRequest.doPost(`profile-schemes`, data, 1, false).subscribe((res) => {
                        if (res.data)
                            res = res.data;
                        return resolve(+res.id);
                    }, () => {
                        return resolve(0);
                    }));
                }
            }
            else {
                return resolve(0);
            }
        }));
    }
    /**
     * This fx will make the api call to remove a section in the api database
     * @param section
     */
    _removeSection(section) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(section, ['id'])) {
                this.dom.setSubscriber(PopUid(), PopRequest.doDelete(`profile-schemes/${section.id}`, {}, 1, false).subscribe((res) => {
                    if (res.data)
                        res = res.data;
                    // console.log( '_removeSection', res );
                    return resolve(true);
                }, () => {
                    return resolve(false);
                }));
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * This fx is used to make api call to the backend to save the scheme
     * @param store
     * @private
     */
    _update(sections, store = true) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.asset.core) {
                const modified = this._extractModifiedSections(sections, []);
                if (store && IsArray(modified, true)) {
                    const request = [];
                    modified.map((section) => {
                        if (+section.id) {
                            request.push(PopRequest.doPatch(`profile-schemes/${section.id}`, section, 1, false));
                        }
                        else {
                            request.push(PopRequest.doPost(`profile-schemes`, section, 1, false));
                        }
                    });
                    yield forkJoin(request);
                    return resolve(true);
                }
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * This fx is used to pull out all the scheme sections that need to be saved
     * @param sections
     * @private
     */
    _extractModifiedSections(sections, extracted = []) {
        if (IsArray(sections, true)) {
            sections.map((section, index) => {
                section.sort_order = index;
                if (section.modified) {
                    extracted.push(this._extractSectionData(section));
                    section.modified = false;
                }
                if (IsArray(section.children, true)) {
                    section.children.map((child, childIndex) => {
                        child.sort_order = childIndex;
                        if (child.modified) {
                            extracted.push(this._extractSectionData(child));
                            child.modified = false;
                        }
                        if (IsArray(child.children, true)) {
                            extracted = this._extractModifiedSections(child.children, extracted);
                        }
                    });
                }
            });
        }
        return extracted;
    }
    /**
     * This fx extracts the data off a section that should be store in the api database
     * @param section
     * @private
     */
    _extractSectionData(section) {
        return CleanObject({
            id: section.id,
            entity_id: 111,
            name: section.name ? section.name : null,
            asset_type: section.asset_type ? section.asset_type : null,
            asset_id: section.asset_type ? section.asset_id : null,
            scheme_id: section.scheme_id ? section.scheme_id : null,
            mapping: IsObject(section.mapping) ? section.mapping : { children: {} },
            sort_order: IsDefined(section.sort_order) ? section.sort_order : 99
        });
    }
    /**
     * Determine what assets have been set from the asset pool
     * This fx is called when a user click on a <column button> intending to attach assets into a specific column of the scheme
     */
    _getAssetsToAttach() {
        const attaching = {};
        Object.keys(this.asset.attachingSet).map((assetTypeKey) => {
            this.asset.attachingSet[assetTypeKey].forEach((assetId) => {
                if (!attaching[assetTypeKey])
                    attaching[assetTypeKey] = {};
                const assetable = this.asset.assetMap[assetTypeKey].get(assetId);
                if (assetTypeKey === 'component') {
                    attaching[assetTypeKey][assetId] = { compact: assetable.compact ? 1 : 0 };
                }
                else {
                    attaching[assetTypeKey][assetId] = { compact: 1 };
                }
            });
        });
        return attaching;
    }
    /**
     * Retrieve the default columns tht exist on an entity table
     * @param section
     */
    _getSectionTableFieldsAssets(section) {
        const tableAssets = [];
        if (this.asset.core) {
            const Field = StorageGetter(this.asset.core, 'repo.model.field'.split('.'));
            if (IsObject(Field, true)) {
                Object.values(Field).map((field) => {
                    if (!field.ancillary && field.position === section.position) {
                        tableAssets.push(new EntitySchemeSectionConfig({
                            id: 0,
                            name: field.model.label,
                            asset_type: 'table',
                            asset_id: 0,
                            asset: field,
                            scheme_id: +section.id,
                            sort_order: field.sort,
                            position: section.position,
                        }));
                    }
                });
            }
        }
        section.startIndex = tableAssets.length;
        return tableAssets.sort((a, b) => {
            if (a.sort < b.sort)
                return -1;
            if (a.sort > b.sort)
                return 1;
            return 0;
        });
    }
    /**
     * Convert child sections to the expected structure
     * @param child
     * @private
     */
    _transformSection(section, index) {
        section = CleanObject(section, { blacklist: ['flattened'] }); // first level are only containers
        section.container = true;
        section.position = index + 1;
        section.flex = 1;
        section.sort_order = index;
        if (!(IsObject(section.mapping)))
            section.mapping = {};
        if (!(IsArray(section.mapping.sort_order)))
            section.mapping.sort_order = [];
        if (!(IsArray(section.children)))
            section.children = [];
        section.children = section.children.filter((child) => {
            if (String(String(child.asset_type).toLowerCase()).includes('field')) {
                child.asset_type = 'field';
            }
            else if (String(String(child.asset_type).toLowerCase()).includes('component')) {
                child.asset_type = 'component';
            }
            else if (String(String(child.asset_type).toLowerCase()).includes('widget')) {
                child.asset_type = 'widget';
            }
            // console.log('type', child.asset_type);
            if (child.asset_type && child.asset_type != 'table') {
                if (+child.asset_id) {
                    return this.asset.assetMap[child.asset_type].has(child.asset_id);
                }
                else {
                    return true;
                }
            }
            return child.asset_type != 'table';
        });
        section.children.map((child) => {
            child = this._transformChild(child);
            child.sort_order = section.mapping.sort_order.includes(child.id) ? +section.mapping.sort_order.indexOf(child.id) : 99;
            if (IsObject(child.asset, true)) {
                if (IsString(child.asset_type, true)) {
                    child.compact = (IsObject(child.asset, ['compact']) && IsDefined(child.asset.compact) ? child.asset.compact : false);
                    this._ensureAssetTypeContainers(child.asset_type);
                    this.ui.attachedMap[child.asset_type].set(+child.asset_id, section.position);
                }
                else {
                    this._transformSection(child, index);
                }
            }
        });
        section.children.sort(DynamicSort('sort_order'));
        return section;
    }
    /**
     * Convert child of a section to the expected structure
     * @param child
     */
    _transformChild(child) {
        child = CleanObject(child);
        if (!(IsObject(child.mapping)))
            child.mapping = {};
        if (IsDefined(child.asset_id) && +child.asset_id) {
            delete child.children;
            if (String(String(child.asset_type).toLowerCase()).includes('field'))
                child.asset_type = 'field';
            if (child.asset_type === 'field' && this.asset.assetMap.field.has(child.asset_id)) {
                child.asset = this.asset.assetMap.field.get(child.asset_id);
                child.name = child.asset.name;
                child.compact = true;
            }
            else if (child.asset_type === 'component' && this.asset.assetMap.component.has(child.asset_id)) {
                child.asset_type = 'component';
                child.asset = this.asset.assetMap.component.get(child.asset_id);
                child.name = child.asset.name;
            }
            child.container = false;
        }
        else {
            child.container = true;
        }
        return child;
    }
    /**
     * This fx is used ensures that an asset type has the all ancillary assets needed
     * @param assetType
     */
    _ensureAssetTypeContainers(assetType) {
        if (!this.asset.attachingSet[assetType])
            this.asset.attachingSet[assetType] = new Set();
        if (!this.asset.assetMap[assetType])
            this.asset.assetMap[assetType] = new Map();
        if (!this.ui.attachedMap[assetType])
            this.ui.attachedMap[assetType] = new Map();
        if (!this.ui.assignableConfigs[assetType])
            this.ui.assignableConfigs[assetType] = {};
    }
    /**
     * Clear out all the attaching set data
     */
    _resetAssetAttachingData() {
        Object.keys(this.asset.attachingSet).map((key) => {
            this.asset.attachingSet[key].clear();
        });
    }
    /**
     * Refresh the core entity
     * @param dom
     */
    _refreshEntity(dom = null) {
        this.asset.core.channel.emit({
            source: this.name,
            target: 'PopEntityTabComponent',
            type: 'component',
            name: 'start-refresh'
        });
        this.srv.tab.refreshEntity(null, dom, {}, `${this.name}:viewEntityPortal`).then((res) => {
            this.init(this.asset.core, this.asset.tab);
            this.dom.state.blockModal = false;
            this.asset.core.channel.emit({
                source: this.name,
                target: 'PopEntityTabComponent',
                type: 'component',
                name: 'stop-refresh'
            });
        });
    }
    /**
     * This fx is used to mark an asset in the asset pool as attachable
     * @param asset
     */
    _setChildAsAttachable(child) {
        if (!child.container) {
            this.ui.attachedMap[child.asset_type].delete(child.asset_id);
            this.ui.assignableConfigs[child.asset_type][child.asset_id].control.setValue(0);
            this.ui.assignableConfigs[child.asset_type][child.asset_id].control.enable();
        }
    }
    /**
     * This fx is used to mark an asset in as attached, setting it up to be transferred to a column in the scheme
     * @param asset
     */
    _setChildAsAttached(child, position = 1) {
        if (!child.container) {
            this.ui.attachedMap[child.asset_type].set(child.asset_id, position);
            this.ui.assignableConfigs[child.asset_type][child.asset_id].control.setValue(1);
            this.ui.assignableConfigs[child.asset_type][child.asset_id].control.disable();
        }
    }
    /**
     * This fx is used to pull out all the scheme sections that need to be saved
     * @param sections
     * @private
     */
    _checkForTraits(core, sections, primaryIds = []) {
        if (IsArray(sections, true)) {
            sections.map((section) => {
                if (IsArray(section.children, true)) {
                    section.children.map((child) => {
                        if (child.asset_type === 'field') {
                            child.asset.required = IsArray(core.entity.mapping.required) ? core.entity.mapping.required.includes(child.asset_id) : false;
                            if (primaryIds.includes(child.asset_id)) {
                                primaryIds.splice(primaryIds.indexOf(child.asset_id), 1);
                                child.asset.primary = true;
                            }
                            else {
                                child.asset.primary = false;
                            }
                        }
                        if (IsArray(child.children, true)) {
                            this._checkForTraits(core, child.children, primaryIds);
                        }
                    });
                }
            });
        }
        return primaryIds;
    }
}
PopEntitySchemeService.prov = i0.defineInjectable({ factory: function PopEntitySchemeService_Factory() { return new PopEntitySchemeService(i0.inject(PopTabMenuService)); }, token: PopEntitySchemeService, providedIn: "root" });
PopEntitySchemeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntitySchemeService.ctorParameters = () => [
    { type: PopTabMenuService }
];

class PopEntitySchemeAssetPoolComponent extends PopExtendComponent {
    /**
     *
     * @param el
     * @param _domRepo - transfer
     * @param _schemeRepo - transfer
     * @param _tabRepo - transfer
     */
    constructor(el, _domRepo, _schemeRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._schemeRepo = _schemeRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntitySchemeAssetPoolComponent';
        this.ui = {
            sections: undefined,
            assignBtnConfigs: undefined,
            assignableConfigs: undefined,
            assetPool: undefined,
            section_keys: undefined
        };
        this.asset = {
            primaryIds: []
        };
        this.srv = {
            scheme: undefined,
            tab: undefined,
            router: ServiceInjector.get(Router)
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.session.searchValue = '';
                // #1: Transfer in misc assets from the schemeRepo
                this.dom.state.searching = false;
                this.asset.primaryIds = this.srv.scheme.ui.primaryIds;
                yield this.dom.setWithComponentInnerHeight('PopEntityTabColumnComponent', this.position, 230, 600);
                this.dom.height.content = this.dom.height.inner - 95;
                this._setUiAssets();
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // #5: Reapply any onSession search that may have existed
                this.onApplyUiSearch(this.dom.session.searchValue);
                // #6: Disable the ui assign buttons for the initial view
                this.onDisableUiAssignButtons();
                return resolve(true);
            }));
        };
    }
    /**
     * The purpose of this component is to provide the user with lists of all available types that they can assign into a scheme layout
     */
    ngOnInit() {
        super.ngOnInit();
    }
    _setUiAssets() {
        this.ui.sections = this.srv.scheme.ui.sections; // transfer sections from schemeRepo
        this.ui.assignableConfigs = this.srv.scheme.ui.assignableConfigs; // transfer assignableConfigs for attaching assets from pools
        // #2: Build the config for the buttons that the user will push to assign items to a layout position
        this.ui.assignBtnConfigs = []; // create a button for each section to assign assets from the pools with
        this.ui.sections.map((section) => {
            this.ui.assignBtnConfigs[section.position] = new ButtonConfig({
                bubble: true,
                event: 'assign',
                value: 'Column ' + (+section.position),
                size: 30,
                text: 16,
                icon: null,
            });
        });
        // #4: Configure the asset ppol items that a user can choose from to position in the layout
        let assetPool = IsObjectThrowError(this.srv.scheme.ui.assetPool, true, `${this.name}:configureDom: - this.srv.scheme.asset.asset_pool`) ? JSON.parse(JSON.stringify(this.srv.scheme.ui.assetPool)) : {}; // transfer asset_pools from schemeRepo and mutate
        assetPool = Object.keys(assetPool).map((assetTypeKey) => {
            this.dom.state[assetTypeKey] = {
                expanded: true,
                visible: {},
                attach: {}, // used with the search mechanism
            };
            return {
                name: assetTypeKey,
                asset_type: assetTypeKey,
                display: TitleCase(assetTypeKey),
                data: assetPool[assetTypeKey],
                list: ToArray(assetPool[assetTypeKey])
            };
        });
        this.ui.assetPool = IsArrayThrowError(assetPool, true, `${this.name}:configureDom: - pools`) ? assetPool : [];
    }
    /**
     * Cear the search input and reset the asset pool list
     */
    onUiSearchValueClear() {
        this.dom.session.searchValue = '';
        this.onApplyUiSearch(this.dom.session.searchValue);
    }
    /**
     * Apply the search value the user entered to the asset pool list
     * @param searchValue
     * @param col
     */
    onApplyUiSearch(searchValue, col = '') {
        if (this.dom.delay.search)
            clearTimeout(this.dom.delay.search);
        this.dom.delay.search = setTimeout(() => {
            if (searchValue.length) {
                this.ui.assetPool.map((pool) => {
                    if (IsObject(this.dom.state[pool.name])) {
                        pool.list.map((item) => {
                            this.dom.state[pool.name].visible[item.id] = ObjectContainsTagSearch({
                                id: item.id,
                                name: item.name,
                            }, searchValue) === true;
                        });
                    }
                });
                setTimeout(() => {
                    this.dom.state.searching = true;
                });
            }
            else {
                this.ui.assetPool.map((pool) => {
                    if (IsObject(this.dom.state[pool.name])) {
                        pool.list.map((item) => {
                            this.dom.state[pool.name].visible[item.id] = 1;
                        });
                    }
                });
                this.dom.state.searching = false;
            }
        }, 200);
    }
    /**
     * The user can expand an asset pool type to be open or closed
     * @param pool
     */
    onTogglePoolExpansion(pool) {
        if (pool && pool.name in this.dom.state) {
            this.dom.state[pool.name].expanded = !this.dom.state[pool.name].expanded;
        }
    }
    /**
     * This is triggered when a user selects a checkbox indicating that it will be assigned to a position of the layout
     * @param asset_type
     * @param itemId
     * @param value
     */
    onAssetPoolItemAttaching(asset_type, itemId, value) {
        this.srv.scheme.onAssetAttaching(asset_type, itemId, value);
        this.onEnableUiAssignButtons();
    }
    /**
     * This is triggered when a user selects a position button indicating they want the selected asset pool items moved to a position of the layout
     * @param section
     * @param $event
     */
    onSectionAttachingItems(section, $event) {
        this.onDisableUiAssignButtons();
        section.modified = true;
        this.srv.tab.showAsLoading(true);
        this.srv.scheme.onAttachingAssetsToPosition(section).then((children) => {
            if (IsArray(children, true)) {
                section.children = children;
                this.srv.scheme.onUpdate([section]).then(() => {
                    // console.log( 'done with add ', section );
                    this.srv.tab.showAsLoading(false);
                    this.onDisableUiAssignButtons();
                });
            }
            else {
                // console.log( 'update section failed', section );
                this.srv.tab.showAsLoading(false);
                this.onDisableUiAssignButtons();
            }
        });
    }
    /**
     * This is triggered every time the user selects a checkbox of an asset pool item
     * This should determine which positions of the layout are eligible base on the set of the items selected
     * Asset Pool items should be designated as compact or not, the last position of the layout is reserved for larger modules and compact items should not go in it
     */
    onEnableUiAssignButtons() {
        if (!this.ui.section_keys) {
            this.ui.section_keys = this.ui.sections.map((s, i) => s.position);
        }
        if (this.dom.delay.configure_buttons)
            clearTimeout(this.dom.delay.configure_buttons);
        this.dom.delay.configure_buttons = setTimeout(() => {
            const items = this.srv.scheme._getAssetsToAttach();
            let notCompact;
            const assetTypes = Object.keys(items);
            assetTypes.some((assetType) => {
                notCompact = Object.keys(items[assetType]).filter((assetID) => {
                    if (assetType === 'component') {
                        return !items[assetType][assetID].compact;
                    }
                    return false;
                }).length;
                if (notCompact)
                    return true;
            });
            const positionKeys = this.ui.section_keys.slice();
            if (notCompact) {
                let lastPositionKey;
                if (positionKeys.length) {
                    lastPositionKey = positionKeys.pop();
                }
                positionKeys.map((positionKey) => {
                    this.ui.assignBtnConfigs[positionKey].disabled = true;
                });
                if (lastPositionKey)
                    this.ui.assignBtnConfigs[lastPositionKey].disabled = false;
            }
            else {
                positionKeys.map((positionKey) => {
                    this.ui.assignBtnConfigs[positionKey].disabled = false;
                    this.ui.assignBtnConfigs[positionKey].color = 'accent';
                });
            }
        }, 100);
    }
    /**
     * This will disable or clear the position assign buttons
     */
    onDisableUiAssignButtons() {
        this.core.entity.children.map((section) => {
            if (section.position) {
                this.ui.assignBtnConfigs[section.position].disabled = true;
                this.ui.assignBtnConfigs[section.position].color = 'default';
            }
        });
    }
    onAssetLink(type, id) {
        if (type === 'field') {
            this.srv.router.navigateByUrl(`/cis/fields/${id}`).catch((e) => {
                console.log('e', e);
            });
        }
    }
    /**
     * A user can click on an item in the asset pool to view a modal of that specific entityId item
     * @param internal_namea
     * @param id
     */
    onViewEntityPortal(internal_name, id) {
        if (internal_name === 'field') {
            this.core.channel.emit({ source: this.name, target: 'PopEntityTabColumnComponent', type: 'component', name: 'scrollTo' });
            PopPortal.view(internal_name, id).then(() => {
                this.srv.scheme.ui.refresh.next('reload');
            });
        }
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntitySchemeAssetPoolComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-asset-pool',
                template: "<div class=\"entity-scheme-asset-pool-container\" *ngIf=\"dom.state.loaded\" [style.height.px]=\"dom.height.inner\">\n  <div class=\"entity-scheme-asset-pool-search\">\n    <mat-form-field class=\"sw-search\" appearance=\"outline\" color=\"accent\">\n      <a matPrefix>\n        <mat-icon>search</mat-icon>\n      </a>\n      <mat-icon class=\"sw-pointer\" matSuffix (click)=\"onUiSearchValueClear();\">close\n      </mat-icon>\n      <input matInput [(ngModel)]=\"dom.session.searchValue\" (keyup)=\"onApplyUiSearch($event.target.value, '')\" placeholder=\"Search\">\n    </mat-form-field>\n  </div>\n  <div class=\"entity-scheme-asset-pool-content\" [style.height.px]=dom.height.content>\n    <mat-accordion multi=\"true\" [displayMode]=\"'flat'\">\n      <mat-expansion-panel class=\"mat-expansion-panel-first\" *ngFor=\"let pool of ui.assetPool\" [expanded]=\"dom.state[pool.name]?.expanded || this.dom.state['searching']\" hideToggle=\"true\">\n        <mat-expansion-panel-header>\n          <div class=\"entity-scheme-asset-pool-panel-header\" (click)=\"$event.stopPropagation();\">\n            <div class=\"entity-scheme-asset-pool-panel-expansion\">\n              <mat-icon *ngIf=\"!dom.state[pool.name]?.expanded\" (click)=\"onTogglePoolExpansion(pool);\" [ngClass]=\"{'sw-hidden':this.dom.state['searching']}\">\n                keyboard_arrow_right\n              </mat-icon>\n              <mat-icon *ngIf=\"dom.state[pool.name]?.expanded\" (click)=\"onTogglePoolExpansion(pool);\" [ngClass]=\"{'sw-hidden':this.dom.state['searching']}\">\n                keyboard_arrow_down\n              </mat-icon>\n            </div>\n            <div class=\"entity-scheme-asset-pool-panel-name\">{{pool.display}}</div>\n          </div>\n        </mat-expansion-panel-header>\n        <div *ngIf=\"!pool.list.length\" class=\"theme-error\">\n          None\n        </div>\n        <div class=\"entity-scheme-asset-pool-row\"  *ngFor=\"let item of pool.list;\" [ngClass]=\"{'sw-hidden': !this.dom.state[pool.asset_type]?.visible[item.id]}\">\n          <div class=\"entity-scheme-asset-pool-row-container import-flex-column-xs\">\n            <lib-pop-checkbox [config]=\"ui['assignableConfigs'][pool.asset_type][item.id]\" (events)=\"onAssetPoolItemAttaching(pool.asset_type, item.id, $event.config.control.value)\"></lib-pop-checkbox>\n          </div>\n\n          <div class=\"entity-scheme-asset-pool-row-container import-flex-column-md import-flex-grow-sm\">\n            <div class=\"sw-pointer\" [ngClass]=\"{'theme-accent':pool.asset_type === 'field'}\" (click)=\"onViewEntityPortal(pool.asset_type, item.id);\">{{item.name}}</div>\n          </div>\n          <div class=\"entity-scheme-asset-pool-row-container entity-scheme-asset-pool-type import-flex-column-sm\" [ngSwitch]=\"pool.asset_type\">\n            <div *ngSwitchCase=\"'field'\">{{item.fieldgroup.label}}</div>\n            <div *ngSwitchCase=\"'component'\">Component</div>\n          </div>\n        </div>\n      </mat-expansion-panel>\n    </mat-accordion>\n  </div>\n  <div class=\"entity-scheme-asset-pool-assign\">\n    <lib-pop-button *ngFor=\"let section of ui.sections\" class=\"entity-scheme-assign-btn\" [config]=\"ui.assignBtnConfigs [section.position]\" (events)=\"onSectionAttachingItems(section, $event);\"></lib-pop-button>\n  </div>\n</div>\n",
                styles: [".entity-scheme-asset-pool-container{flex:1;padding:var(--gap-s);border:1px solid var(--border);overflow:hidden}.entity-scheme-asset-pool-search{position:relative;display:flex;box-sizing:border-box;width:100%;align-items:stretch;justify-content:stretch;height:40px;margin-bottom:var(--gap-s);clear:both}.entity-scheme-asset-pool-search mat-form-field{width:100%;box-sizing:border-box}.entity-scheme-asset-pool-assign{position:relative;display:flex;box-sizing:border-box;width:100%;align-items:center;justify-content:space-evenly;height:35px;padding:var(--gap-s);margin:var(--gap-s) 0 0 0;clear:both}.entity-scheme-asset-pool-content{position:relative;clear:both;overflow-y:scroll;overflow-x:hidden}.entity-scheme-asset-pool-panel-header{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:center;background:var(--darken02);border-bottom:1px solid var(--border)}.entity-scheme-asset-pool-panel-expansion{display:flex;margin:0 20px 0 8px;align-items:center;height:35px;width:25px}.entity-scheme-asset-pool-panel-name{font-size:var(--text-sm);font-weight:700;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-scheme-asset-pool-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:center;height:35px}.entity-scheme-asset-pool-row-container{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-scheme-asset-pool-row-container ::ng-deep .pop-checkbox-container{margin-top:0!important}.entity-scheme-asset-pool-type{font-size:var(--text-sm);padding-top:var(--gap-s)}:host ::ng-deep mat-expansion-panel{background:none;border-left:1px solid var(--border);border-right:1px solid var(--border);border-bottom:1px solid var(--border)}.mat-expansion-panel-first{border-top:1px solid var(--border)!important}:host ::ng-deep .mat-expansion-panel-body{padding:var(--gap-s)!important}:host ::ng-deep mat-expansion-panel-header{padding:0!important;height:35px!important;border-bottom-left-radius:0;border-bottom-right-radius:0}.entity-scheme-assign-btn{display:flex;flex-grow:1;margin-left:var(--gap-xs);margin-right:var(--gap-xs)}.entity-scheme-assign-btn ::ng-deep .pop-button-container{width:100%}.entity-scheme-assign-btn ::ng-deep button{display:flex;width:100%;flex-grow:1}:host ::ng-deep .pop-checkbox-container{min-height:30px}:host ::ng-deep .pop-button-container{background:var(--darken02)}:host ::ng-deep .entity-scheme-asset-pool-search .mat-form-field-prefix{margin-left:2px!important}"]
            },] }
];
PopEntitySchemeAssetPoolComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopEntitySchemeService },
    { type: PopTabMenuService }
];

// https://medium.com/codetobe/learn-how-to-drag-drop-items-in-angular-7-20395c262ab0
class PopEntitySchemeAssetLayoutComponent extends PopExtendComponent {
    constructor(el, _domRepo, _schemeRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._schemeRepo = _schemeRepo;
        this.name = 'PopEntitySchemeAssetLayoutComponent';
        this.srv = {
            scheme: undefined
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.dom.setWithComponentInnerHeight('PopEntityTabColumnComponent', this.position, 210, 600);
                this.ui.sections = this.srv.scheme.ui.sections;
                return resolve(true);
            }));
        };
    }
    /**
     * Setup this component
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntitySchemeAssetLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-asset-layout',
                template: "<div class=\"entity-scheme-asset-layout-container\"  [style.height.px]=\"dom.height.inner\" cdkDropListGroup >\n  <lib-entity-scheme-layout-section *ngFor=\"let section of ui.sections\" [core]=core [section]=section [style.flexGrow]=section.flex></lib-entity-scheme-layout-section>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".entity-scheme-asset-layout-container{display:flex;flex-direction:row;border-top:1px solid var(--border);border-left:1px solid var(--border);border-bottom:1px solid var(--border);box-sizing:border-box;overflow:hidden}lib-entity-scheme-layout-section{flex:1;flex-basis:150px;border-right:1px solid var(--border)}.entity-scheme-asset-layout-section{flex:1}.entity-scheme-asset-list-content{overflow-y:auto;overflow-x:hidden}.entity-scheme-asset{box-sizing:border-box;margin:10px;border:1px solid var(--border);background:var(--bg-3);font-size:12px}.entity-scheme-asset-menu{position:absolute;justify-content:space-around;top:15px;right:5px;opacity:.8;width:55px;padding-left:5px;z-index:2}.entity-scheme-asset-menu,.entity-scheme-asset-menu-icon{display:flex;align-items:center;height:20px;background:var(--bg-3)}.entity-scheme-asset-menu-icon{justify-content:center;opacity:1!important;width:20px}.entity-scheme-asset-menu-icon .material-icons{font-size:18px}.entity-scheme-asset-handle{position:relative;box-sizing:border-box;cursor:move;width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-scheme-asset-handle-disabled{pointer-events:none;cursor:none}.entity-scheme-asset-field-container{display:flex;flex-direction:column}.entity-scheme-asset-layout-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:center;height:25px;font-size:14px;padding:0 10px;z-index:1}.entity-scheme-asset-layout-row-expanded{border-bottom:1px solid var(--border)}.entity-scheme-asset-layout-subrow{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:flex-start;height:20px;color:var(--disabled);padding:0 10px;font-size:12px;top:2px}.entity-scheme-asset-layout-content-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:column;min-height:30px}.entity-scheme-asset-item-row{justify-content:flex-start;height:30px;padding:0 10px;border-top:1px solid var(--border);z-index:1}.entity-scheme-asset-item-row,.entity-scheme-asset-toggle-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;align-items:center}.entity-scheme-asset-toggle-row{justify-content:center;height:10px;margin-bottom:5px;overflow:hidden;z-index:3}.entity-scheme-asset-toggle-row .material-icons{position:relative;top:2px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-size:18px}.entity-scheme-primary{color:var(--primary-background)}.entity-scheme-required{color:var(--error);font-size:30px;line-height:0px;margin:0;width:10px;position:relative;top:20px;z-index:2}.cdk-drag-preview{overflow:hidden;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);height:35px}.cdk-drag-preview .entity-scheme-asset-handle{box-sizing:border-box}.cdk-drag-preview .entity-scheme-asset-menu{display:none!important}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating,.entity-scheme-asset-list.cdk-drop-list-dragging .entity-scheme-asset:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
            },] }
];
PopEntitySchemeAssetLayoutComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopEntitySchemeService }
];

class PopEntitySchemeDetailsComponent extends PopExtendComponent {
    constructor(_domRepo, _tabRepo, _schemeRepo) {
        super();
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this._schemeRepo = _schemeRepo;
        this.name = 'PopEntitySchemeDetailsComponent';
        this.srv = {
            scheme: undefined,
            tab: undefined
        };
        this.ui = {};
    }
    ngOnInit() {
        super.ngOnInit();
    }
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event) || event.type === 'context_menu') {
            this.log.info(`IsValidFieldPatchEvent`, event);
            this.events.emit(event);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntitySchemeDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-details',
                template: "<div>\n  <lib-pop-entity-field-group *ngIf=\"core\" [core]=\"core\" (events)=\"onBubbleEvent($event);\"></lib-pop-entity-field-group>\n</div>\n\n",
                styles: [""]
            },] }
];
PopEntitySchemeDetailsComponent.ctorParameters = () => [
    { type: PopDomService },
    { type: PopTabMenuService },
    { type: PopEntitySchemeService }
];

class PopEntitySchemeComponent extends PopExtendComponent {
    /**
     *
     * @param el
     * @param _domRepo - transfer
     * @param _schemeRepo - transfer
     * @param _tabRepo - transfer
     */
    constructor(el, _domRepo, _schemeRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._schemeRepo = _schemeRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntitySchemeComponent';
        this.srv = {
            scheme: undefined,
            tab: undefined
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.ui.tab = new TabConfig({
                    id: 'general',
                    positions: {
                        1: {
                            header: 'Details',
                            flex: 1,
                            components: [
                                {
                                    type: PopEntitySchemeDetailsComponent,
                                    inputs: {
                                        id: 1
                                    },
                                },
                            ]
                        },
                        2: {
                            flex: 1,
                            header: 'Available Fields & Components',
                            components: [
                                {
                                    type: PopEntitySchemeAssetPoolComponent,
                                    inputs: {
                                        id: 2
                                    },
                                },
                            ]
                        },
                        3: {
                            flex: 2,
                            header: 'Profile Layout',
                            components: [
                                {
                                    type: PopEntitySchemeAssetLayoutComponent,
                                    inputs: {
                                        id: 3
                                    },
                                },
                            ]
                        },
                    },
                    wrap: false,
                    columnWrap: true,
                    overhead: 0,
                    onLoad: (config, tab) => {
                        // console.log('config', config);
                        // console.log('tab', tab);
                    },
                    onEvent: (core, event) => {
                        // console.log('event', event);
                    },
                });
                yield this.srv.scheme.init(this.core, this.ui.tab);
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setSubscriber(`refresh`, this.srv.scheme.ui.refresh.subscribe((val) => {
                    if (val === 'reload') {
                        this.srv.tab.resetTab(true);
                        // this.srv.tab.refreshEntity(this.core.params.entityId, this.dom.repo, { bypassCache: true }, this.name).then(async()=>{
                        //   await this.srv.scheme.init( this.core, this.ui.tab );
                        //   this.srv.tab.resetTab();
                        // });
                    }
                }));
                return resolve(true);
            });
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntitySchemeComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-customer-scheme',
                template: `
    <lib-main-spinner *ngIf="dom.state.loader"></lib-main-spinner>
    <lib-pop-entity-tab *ngIf="dom.state.loaded" [tab]=ui.tab [core]="core"></lib-pop-entity-tab>`,
                providers: [PopEntitySchemeService]
            },] }
];
PopEntitySchemeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopEntitySchemeService },
    { type: PopTabMenuService }
];

class PopEntityFieldDetailsComponent extends PopExtendComponent {
    constructor(el, _domRepo, fieldRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.fieldRepo = fieldRepo;
        this.name = 'PopEntityFieldDetailsComponent';
        this.asset = {};
        this.ui = {
            field: undefined,
            customSetting: {},
            multiple: undefined,
        };
        this.extendServiceContainer();
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                if (!this.field)
                    this.field = IsObjectThrowError(this.core, ['entity'], `Invalid Core`) && IsObjectThrowError(this.core.entity, ['id', 'fieldgroup'], `Invalid Field`) ? this.core.entity : null;
                this._buildCustomSettings();
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    extendServiceContainer() {
        this.srv = {
            field: this.fieldRepo,
        };
        delete this.fieldRepo;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Event handler for the parent tab to tell this name to reset itself
     * @param reset
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event)) {
            this.events.emit(event);
        }
    }
    // /**
    //  * Catch changes on custom setting fields and update them
    //  * @param event
    //  */
    // onCustomSettingEvent(event: PopBaseEventInterface){
    //   if( IsValidFieldPatchEvent(this.core, event) ){
    //     this.dom.setTimeout(event.config.name, () => {
    //       this.srv.field.storeCustomSetting(this.core, event).then(() => true);
    //     }, 250);
    //   }
    // }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _buildCustomSettings() {
        const allowMultiple = this.srv.field.getViewMultiple(this.field.fieldgroup.name);
        if (allowMultiple) {
            let multiple = StorageGetter(this.core.repo, ['model', 'field', 'multiple']);
            if (IsObject(multiple, ['model'])) {
                multiple = JsonCopy(multiple);
                this.ui.multiple = new SwitchConfig(FieldItemModelConfig(this.core, FieldItemModel(this.core, multiple.model)));
                this.ui.multiple.patch.callback = (core, event) => {
                    SessionEntityFieldUpdate(this.core, event);
                    this.srv.field.triggerFieldPreviewUpdate();
                };
            }
        }
        // if( IsObject(this.ui.field.custom_setting, true) ){
        //   Object.keys(this.ui.field.custom_setting).map((settingName) => {
        //     const setting = this.ui.field.custom_setting[ settingName ];
        //     const component = this.srv.field.getCustomSettingComponent(this.core, this.ui.field, setting);
        //     component.position = this.position;
        //     this.ui.customSetting[ setting.name ] = component;
        //   });
        // }
    }
}
PopEntityFieldDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-details',
                template: "<div class=\"entity-field-details-container\" *ngIf=\"dom.state.loaded\">\n  <lib-pop-entity-status [core]=\"core\"></lib-pop-entity-status>\n  <lib-pop-entity-field-group [core]=\"core\" (events)=\"onBubbleEvent($event);\"></lib-pop-entity-field-group>\n  <lib-pop-switch *ngIf=\"ui.multiple\" [config]=\"ui.multiple\"></lib-pop-switch>\n  <lib-pop-switch *ngIf=\"!field.multiple && dom.repo.ui.customSetting.show_name\" [config]=\"dom.repo.ui.customSetting.show_name.inputs.config\"></lib-pop-switch>\n  <!--<lib-pop-switch *ngIf=\"!ui.field.multiple && ui.customSetting.show_name\" [config]=\"ui.customSetting.show_name.inputs.config\" (events)=\"onCustomSettingEvent($event)\"></lib-pop-switch>-->\n  <!--<lib-pop-min-max *ngIf=\"ui.field.multiple\" (events)=\"onMinMaxSetting($event);\" [config]=ui.customSetting.minMax></lib-pop-min-max>-->\n\n</div>\n",
                styles: [".import-flex-row,.import-flex-row-wrap{display:flex;flex-direction:row}.import-flex-row-wrap{flex-wrap:wrap;padding:0;flex-basis:100%;box-sizing:border-box}.import-flex-row-break{flex-basis:100%;height:0}.import-flex-column-break{flex-basis:100%;width:0}.import-flex-item-icon{min-width:var(--field-icon-width);height:var(--field-icon-height);display:flex;justify-content:center;align-items:center}.import-flex-column-xs{display:flex;flex-direction:column;width:12.5%;min-height:30px}.import-flex-column-sm{flex:1;flex-direction:column;width:25%;min-height:30px}.import-flex-column-md{flex:1;flex-direction:column;width:50%}.import-flex-column-lg{flex:1;flex-direction:column;width:75%;min-height:30px}.import-flex-item-xs{flex-basis:12.5%}.import-flex-item-sm{flex-basis:25%}.import-flex-item-md{flex-basis:50%}.import-flex-item-full{flex-basis:100%}.import-flex-grow-xs{flex-grow:1}.import-flex-grow-sm{flex-grow:2}.import-flex-grow-md{flex-grow:3}.import-flex-grow-lg{flex-grow:4}.import-flex-column{display:flex;flex-direction:column}.import-flex-center{display:flex;align-items:center;justify-content:center}.import-flex-space-center{justify-content:space-around;align-items:center}.import-flex-space-between-center{justify-content:space-between;align-items:center}.import-flex-center-start{display:flex;justify-content:center;align-items:flex-start}.import-flex-start-center{display:flex;justify-content:flex-start;align-items:center}.import-flex-end-center{display:flex;justify-content:flex-end;align-items:center}.import-flex-end{display:flex;align-items:flex-end;justify-content:flex-end}.import-flex-align-end{display:flex;align-self:flex-end}.import-flex-stretch-center{display:flex;justify-content:stretch;align-items:center}.entity-field-details-container{max-width:var(--field-max-width)}.entity-field-details-row{display:flex;flex-direction:row;height:35px;margin-top:1px}"]
            },] }
];
PopEntityFieldDetailsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService }
];
PopEntityFieldDetailsComponent.propDecorators = {
    field: [{ type: Input }]
};

class PopEntityFieldPreviewComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.name = 'PopEntityFieldPreviewComponent';
        this.asset = {
            field: undefined,
            fieldgroup: undefined,
            columnKeys: undefined,
        };
        this.ui = {
            stateSelector: new SelectConfig({
                label: 'State',
                value: 'template_edit',
                options: {
                    values: [
                        { value: 'template_edit', name: 'Template Access' },
                        { value: 'template_readonly', name: 'Template Readonly' },
                        { value: 'text_single', name: 'Text Single' },
                        { value: 'text_format', name: 'Text Format' },
                    ]
                }
            }),
            field: undefined
        };
        this.srv = {
            entity: ServiceInjector.get(PopEntityService),
            editor: ServiceInjector.get(PopFieldEditorService),
            field: ServiceInjector.get(PopEntityUtilFieldService),
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.handler.bubble = (core, event) => this.onBubbleEvent(event);
                //  Verify configs
                this.core = IsObjectThrowError(this.core, ['entity'], `${this.name}:configureDom: - this.core`) ? this.core : null;
                this.field = IsObjectThrowError(this.core.entity, ['fieldgroup', 'entries'], `${this.name}:configureDom: - this.core`) ? this.core.entity : null;
                this.asset.fieldgroup = this.field.fieldgroup;
                // Create form session container to persist use input values
                this.dom.session.form = {};
                // Attach the container for the preview html
                this.template.attach('container');
                // Get a default set of data to populate the preview field items with
                this.asset.columnKeys = this.core.entity.items.map((item) => {
                    return String(SpaceToSnake(item.name)).toLowerCase();
                });
                // this.asset.defaultData = this.srv.field.getDefaultValues(String(this.core.entityId.corefield.internal_name).toLowerCase(), this.asset.columnKeys);
                if (this.dom.session.stateSelector)
                    this.ui.stateSelector.control.setValue(this.dom.session.stateSelector, { emitEvent: true });
                // Handle events
                this.dom.handler.core = (core, event) => {
                    this.log.event(`_coreEventHandler`, event);
                    if (IsValidFieldPatchEvent(this.core, event) || (event.type === 'component' && (event.name === 'active-item' || event.name === 'update'))) {
                        this._triggerFieldPreview();
                    }
                    else {
                        PopLog.warn(this.name, `Preview did not recognize event`, event);
                    }
                };
                this._triggerFieldPreview(250);
                return resolve(true);
            });
        };
        /**
         * This function will call after the dom registration
         */
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._setDataSession();
                return resolve(true);
            });
        };
    }
    /**
     * We expect the core to represent a field
     * This component represents what the view of the current field will look like
     * The component relies upon the FieldBuilderItemsComponent && FieldBuilderItemSettingsComponent to communicate when settings are changed so that the view can render the changes
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This handler manages events that come up from the preview fields, mostly just to session any values that the user enters, and simulate adding removing value entries
     * The field input is saved because the setFieldPreview destroys the component and is called often, and the user should not have to re-enter test data every time a setting is changed
     * @param event
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsObject(event, ['type', 'name']) && event.type === 'field') {
            if (event.name === 'onFocus') {
                // stub
            }
            else if (event.name === 'onBlur' || event.name === 'patch') { // whenever a user blurs out of field save the data that is in it
                if (event.config && event.config.control && event.config.control.value) {
                    this.dom.session.form[event.config.name] = event.config.control.value;
                    this.dom.store('onSession'); // dom.store must be called to for the dom to transfer its data up to the domRepo
                }
            }
            else if (event.name === 'add') { // whenever a user blurs out of field save the data that is in it
                this._addFieldValue();
            }
            else if (event.name === 'remove') { // whenever a user blurs out of field save the data that is in it
                this._removeFieldValue();
            }
        }
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        this.template.destroy();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Create a new field label
     */
    _addFieldValue() {
        if (IsObject(this.ui.field, true)) {
            if (this.dom.session.records < this.ui.field.multiple_max_limit) {
                this.dom.session.records++;
                this._triggerFieldPreview(0);
            }
        }
    }
    /**
     * Remove an existing label
     */
    _removeFieldValue() {
        if (IsObject(this.ui.field, true)) {
            if (this.dom.session.records > this.ui.field.multiple_min) {
                this.dom.session.records--;
                this._triggerFieldPreview(0);
            }
        }
    }
    /**
     * Create sets of mock data for the fields entries
     */
    _setDataSession() {
        if (!this.dom.session.records)
            this.dom.session.records = this.field.multiple_min;
        let index = 0;
        if (!this.dom.session.data) {
            this.dom.session.data = new Map();
            while (index < 10) {
                const defaultValues = this.srv.editor.getDefaultValues(String(this.asset.fieldgroup.name).toLowerCase());
                this.dom.session.data.set(index, defaultValues);
                index++;
            }
            this.dom.store('session');
        }
    }
    /**
     * Debounce the requests to reset the preview
     * @param delay
     */
    _triggerFieldPreview(delay = 250) {
        this.dom.setTimeout('field-preview', () => {
            this._setFieldPreview();
        }, delay);
    }
    /**
     * This will create a facade field that will a dynamically try to replicate how the field will look when it is in use
     */
    _setFieldPreview() {
        if (this.dom.repo.ui.activeItems) {
            PopTemplate.clear();
            const items = this.field.items;
            const entries = IsArray(this.field.entries, true) ? this.field.entries.filter((entry) => {
                return !entry.orphaned_at;
            }).sort(DynamicSort('sort_order')) : [];
            const fieldInterface = {
                id: 1,
                facade: true,
                canAdd: false,
                canRemove: false,
                configs: this.field.configs,
                name: this.field.name,
                label: this.field.label,
                entries: entries,
                fieldgroup: this.asset.fieldgroup,
                internal_name: String(this.asset.fieldgroup.name).toLowerCase(),
                multiple: this.field.multiple,
                // multiple_min: this.field.multiple_min,
                multiple_min: entries.length,
                // multiple_max: this.field.multiple_max,
                multiple_max: entries.length,
                multiple_max_limit: 4,
                data: {},
                show_name: !!this.core.entity.show_name,
                sort: 0,
                state: this.ui.stateSelector.control.value,
                items: []
            };
            if (fieldInterface.multiple) {
                // if( !fieldInterface.multiple_min ) fieldInterface.multiple_min = 1;
                if (!fieldInterface.multiple_min)
                    fieldInterface.multiple_min = entries.length;
                // let valueIndex = 0;
                let records = this.dom.session.records;
                if (records < +fieldInterface.multiple_min)
                    records = +fieldInterface.multiple_min;
                if (+fieldInterface.multiple_max && records > fieldInterface.multiple_max)
                    records = fieldInterface.multiple_max;
                // while( valueIndex < records ){
                //   fieldInterface.data[ valueIndex ] = this.dom.session.data.get( valueIndex );
                //   valueIndex++;
                // }
                entries.map((entry, index) => {
                    fieldInterface.data[entry.id] = this.dom.session.data.get(index);
                });
            }
            else {
                const singleEntry = entries[0];
                fieldInterface.data[singleEntry.id] = this.dom.session.data.get(0);
            }
            fieldInterface.items = items.filter((item) => {
                return +this.dom.repo.ui.activeItems[item.id] === 1;
            }).map((item) => {
                item.facade = true;
                item.showMask = true;
                item.bubble = true;
                delete item.api;
                return item;
            });
            this.ui.field = this.srv.field.buildCustomField(this.core, fieldInterface);
            if (this.ui.field) {
                const previewComponentList = [];
                const component = {
                    type: PopEntityFieldComponent,
                    inputs: {
                        core: this.core,
                        field: this.ui.field,
                    }
                };
                previewComponentList.push(component);
                this.template.render(previewComponentList, [], true);
            }
        }
        this.dom.ready();
    }
}
PopEntityFieldPreviewComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-editor-preview',
                template: "<div class=\"entity-field-editor-header\">\n  <div class=\"pop-entity-field-editor-header-section\">\n    <div class=\"sw-label-container-sm\">Field Preview</div>\n  </div>\n  <div class=\"pop-entity-field-editor-header-section\">\n    <!--<p>Assign field value and attributes for this field.</p>-->\n  </div>\n</div>\n<div class=\"entity-field-preview-container\">\n  <div class=\"entity-field-preview-content\">\n    <ng-container #container></ng-container>\n  </div>\n</div>\n",
                styles: [".entity-field-editor-header{display:flex;flex-direction:column;height:97px}.entity-field-editor-header-section{position:relative;width:100%;box-sizing:border-box;height:30px;clear:both}.entity-field-editor-container{min-height:100px;position:relative}.entity-field-editor-border{border:1px solid var(--border)}.entity-field-editor-section-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 10px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box;background:var(--darken02)}.entity-field-editor-section-header-helper-icon{width:20px;height:20px;font-size:1em;z-index:2}.entity-field-editor-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.entity-field-editor-active-config{border-left:5px solid var(--primary)}.entity-field-preview-container{position:relative;border:1px solid var(--border)}.entity-field-preview-content{padding:0 var(--gap-s) var(--gap-s) var(--gap-s)}"]
            },] }
];
PopEntityFieldPreviewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService }
];
PopEntityFieldPreviewComponent.propDecorators = {
    field: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class PopEntityFieldEditorComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _domRepo
     * @param _fieldRepo
     * @param _tabRepo
     */
    constructor(el, _domRepo, _fieldRepo, _utilFieldRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this._utilFieldRepo = _utilFieldRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntityFieldEditorComponent';
        this.srv = {
            field: undefined,
            utilField: undefined,
            history: ServiceInjector.get(PopRouteHistoryResolver),
            tab: undefined,
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                if (!(IsObject(this.core, true)))
                    this.core = this.srv.tab.getCore();
                const fieldgroup = StorageGetter(this.core, ['entity', 'fieldgroup', 'name']);
                if (fieldgroup) {
                    this.ui.tab = new TabConfig({
                        id: 'general',
                        positions: {
                            1: {
                                header: 'Details',
                                flex: 1,
                                components: [
                                    {
                                        type: PopEntityFieldDetailsComponent,
                                        inputs: {
                                            id: 1
                                        },
                                    },
                                ]
                            },
                            2: {
                                flex: 2,
                                components: [
                                    {
                                        type: PopEntityFieldSettingsComponent,
                                        inputs: {
                                            id: 2
                                        },
                                    },
                                ]
                            },
                            3: {
                                flex: 1,
                                components: [
                                    {
                                        type: PopEntityFieldPreviewComponent,
                                        inputs: {
                                            id: 3
                                        },
                                    },
                                ]
                            },
                        },
                        wrap: true,
                        columnWrap: true,
                        overhead: 0,
                        onLoad: (config, tab) => {
                            // console.log('config', config);
                            // console.log('tab', tab);
                        },
                        onEvent: (core, event) => {
                            // console.log('event', event);
                        },
                    });
                    this.srv.field.register(this.core, this.dom.repo).then(() => {
                        this.srv.utilField.clearCustomFieldCache(+this.core.entity.id);
                        return resolve(true);
                    });
                }
                else {
                    window.location.href = window.location.origin + '/' + PopHref;
                }
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityFieldEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-editor',
                template: `
    <lib-pop-entity-tab *ngIf="dom.state.loaded" [tab]=ui.tab [core]="core"></lib-pop-entity-tab>`,
                providers: [PopFieldEditorService],
                encapsulation: ViewEncapsulation.None,
                styles: [".entity-field-editor-header{display:flex;flex-direction:column;height:97px}.entity-field-editor-header-section{position:relative;width:100%;box-sizing:border-box;height:30px;clear:both}.entity-field-editor-container{min-height:100px;position:relative}.entity-field-editor-border{border:1px solid var(--border)}.entity-field-editor-section-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 10px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box;background:var(--darken02)}.entity-field-editor-section-header-helper-icon{width:20px;height:20px;font-size:1em;z-index:2}.entity-field-editor-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.entity-field-editor-active-config{border-left:5px solid var(--primary)}"]
            },] }
];
PopEntityFieldEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService },
    { type: PopEntityUtilFieldService },
    { type: PopTabMenuService }
];

class PopEntityStatusComponent extends PopExtendComponent {
    constructor(_domRepo, _tabRepo) {
        super();
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntityStatusComponent';
        this.ui = {
            archive: undefined,
            valueButton: undefined,
            createdDate: undefined,
            showCopied: false
        };
        this.srv = {
            events: ServiceInjector.get(PopEntityEventService),
            tab: undefined,
            date: ServiceInjector.get(PopDatetimeService)
        };
        this.dom.configure = () => {
            // this component set the outer height boundary of this view
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // Ensure that a CoreConfig exists for this component
                this.dom.state.archived = this.core.entity.archived ? true : false;
                this._setDate(this.core.entity.created_at);
                this._setArchiveSwitch();
                this.srv.tab.showAsLoading(false);
                this.id = this.core.params.internal_name;
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    onLabelCopy() {
        const nav = navigator;
        const body = String(this.core.entity.id).slice();
        nav.clipboard.writeText(body);
        this.ui.showCopied = true;
        setTimeout(() => {
            this.ui.showCopied = false;
        }, 3000);
    }
    onArchiveChange(event) {
        if (IsValidChangeEvent(this.core, event)) {
            this._handleArchive(!event.config.control.value);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setDate(date) {
        this.ui.createdDate = this.srv.date.transform(date, 'date');
    }
    _setArchiveSwitch() {
        this.ui.valueButton = new ButtonConfig({
            icon: 'file_copy',
            value: `ID ${this.core.entity.id}`,
            size: 20,
            radius: 5,
            text: 12,
            bubble: true,
            event: 'click',
            type: 'mat-flat-button'
        });
        this.ui.archive = new SwitchConfig({
            name: 'archived',
            bubble: true,
            label: this.core.entity.archived ? 'ACTIVE' : 'ACTIVE',
            labelPosition: 'before',
            value: !this.core.entity.archived ? true : false,
            patch: {
                duration: 0,
                field: '',
                path: '',
            },
        });
    }
    _handleArchive(archive) {
        console.log('_handleArchive', archive);
        this.dom.state.archived = archive;
        this.ui.archive.label = archive ? 'ACTIVE' : 'ACTIVE';
        this.core.entity.archived = archive;
        this.ui.archive.control.disable();
        this.srv.tab.showAsLoading(true);
        this.dom.setSubscriber('archive-entity', this.core.repo.archiveEntity(this.core.params.entityId, archive).subscribe(() => {
            this.srv.events.sendEvent({
                source: this.name,
                method: 'archive',
                type: 'entity',
                name: this.core.params.name,
                internal_name: this.core.params.internal_name,
                id: this.core.params.entityId,
                data: archive
            });
            this.srv.tab.showAsLoading(false);
            this.ui.archive.control.enable();
            this.srv.tab.resetTab(true);
            // this.srv.tab.refreshEntity( null, this.dom.repo, {}, `${this.name}:setArchived` ).then( () => PopTemplate.clear() );
        }, err => {
            this.dom.error.code = err.error.code;
            this.dom.error.message = GetHttpErrorMsg(err);
            this.ui.archive.control.enable();
            this.srv.tab.showAsLoading(false);
        }));
    }
}
PopEntityStatusComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-status',
                template: "<div class=\"pop-entity-status-container import-field-item-container\">\n  <div>\n    <div class=\"copied-signal site-shadow-04\" *ngIf=\"ui.showCopied\">Copied!</div>\n    <lib-pop-button\n      *ngIf=\"ui.valueButton; let config;\"\n      class=\"pop-entity-status-label\"\n      (click)=\"onLabelCopy()\"\n      [config]=\"config\">\n    </lib-pop-button>\n  </div>\n  <div class=\"pop-entity-archive-container\" [ngClass]=\"dom.state.archived ? 'pop-entity-status-archived' :'pop-entity-status-active'\">\n    <lib-pop-switch\n      *ngIf=\"ui.archive; let config\"\n      [config]=\"config\"\n      (events)=\"onArchiveChange($event)\">\n    </lib-pop-switch>\n  </div>\n</div>\n<div class=\"pop-entity-status-row mat-caption\">\n  <span>Created</span> <span>{{ui.createdDate}}</span>\n</div>\n<lib-pop-errors *ngIf=\"dom.error?.message\" [error]=\"dom.error\"></lib-pop-errors>\n",
                styles: [".pop-entity-status-container{position:relative;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;-moz-box-sizing:border-box;margin:0!important;font-size:12px}.pop-entity-status-container .pop-entity-archive-container{display:flex;flex-direction:row;align-items:center;justify-content:stretch;color:#fff!important;box-shadow:none!important;text-transform:none!important;padding-left:8px;padding-right:8px;border-radius:5px;margin:0!important;box-sizing:border-box}.pop-entity-status-container ::ng-deep .pop-switch-container{min-height:15px!important;max-height:20px}.pop-entity-status-container ::ng-deep .import-field-item-container{margin:0!important}.pop-entity-status-container ::ng-deep .pop-entity-status-active .mat-slide-toggle-thumb{background-color:var(--background-base)!important}.pop-entity-status-container ::ng-deep .pop-entity-status-active .mat-slide-toggle-bar{background-color:var(--background-selected-disabled-button)!important}.pop-entity-status-container ::ng-deep .mat-icon{position:relative;top:-1px;color:var(--background-base)}.pop-entity-status-container ::ng-deep .mat-slide-toggle{display:flex!important;flex-grow:1!important;width:100%;box-sizing:border-box}:host ::ng-deep .pop-entity-archive-container h4{font-size:12px}.pop-entity-status-label{min-width:100px!important;display:flex;flex-direction:row;align-items:center}.pop-entity-status-label ::ng-deep button{background-color:var(--background-code);color:var(--background-base);min-width:100px!important}.pop-entity-status-label ::ng-deep button span{position:relative;top:-1px}.pop-entity-status-row{position:relative;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;-moz-box-sizing:border-box;margin:0;font-size:12px;color:var(--foreground-base);max-width:var(--field-max-width)}.pop-entity-status-active{background:var(--valid)!important}.pop-entity-status-archived{background:var(--background-border)!important}lib-pop-switch ::ng-deep span.mat-body{font-size:12px;line-height:12px;color:var(--background-base)}lib-pop-switch ::ng-deep .mat-slide-toggle-bar{height:10px;width:30px}lib-pop-switch ::ng-deep .mat-slide-toggle-bar .mat-slide-toggle-thumb{height:16px;width:16px}div.copied-signal{border-radius:var(--radius-xs);position:absolute;left:0;top:0;z-index:1;font-size:12px;min-height:var(--gap-sm);padding:3px var(--gap-xs) 2px var(--gap-xs);color:var(--foreground-base);background-color:var(--background-base);border:1px solid var(--foreground-disabled)}"]
            },] }
];
PopEntityStatusComponent.ctorParameters = () => [
    { type: PopDomService },
    { type: PopTabMenuService }
];

const EntityGeneralTab = new TabConfig({
    id: 'general',
    positions: {
        1: {
            flex: 1,
            components: [
                {
                    type: PopEntityStatusComponent,
                    inputs: {
                        position: 1
                    },
                },
                {
                    type: PopEntityFieldGroupComponent,
                    inputs: {
                        position: 1
                    },
                },
            ]
        },
        2: {
            flex: 1,
            components: [
                {
                    type: PopEntityFieldGroupComponent,
                    inputs: {
                        position: 2
                    },
                },
            ]
        },
        3: {
            flex: 2,
            components: [
                {
                    type: PopEntityFieldGroupComponent,
                    inputs: {
                        position: 2
                    },
                },
            ]
        }
    },
});
const EntityAssignmentTab = new TabConfig({
    id: 'assignments',
    positions: {
        1: {
            header: null,
            flex: 1,
            components: [
                { type: PopEntityAssignmentsComponent, inputs: {} }
            ]
        },
    },
});
const EntitySchemeTab = new TabConfig({
    id: 'general',
    positions: {
        1: {
            flex: 1,
            components: [
                {
                    type: PopEntitySchemeComponent,
                    inputs: {
                        id: '1',
                    },
                },
            ]
        },
    },
    columnWrap: false,
    // wrap: false, // turn wrapper off ie. margin,  since  PopProfileSchemeComponent is another tab instance
    onLoad: (config, tab) => {
        // console.log('config', config);
        // console.log('tab', tab);
    },
    onEvent: (core, event) => {
        // console.log('event', event);
    },
});
const EntityHistoryTab = new TabConfig({
    id: 'history',
    positions: {
        1: {
            header: null,
            flex: 1,
            components: [
                {
                    type: PopEntityHistoryComponent,
                    inputs: {},
                }
            ]
        }
    },
});
const FieldEditorTab = new TabConfig({
    id: 'general',
    syncPositions: false,
    positions: {
        1: {
            flex: 1,
            components: [
                {
                    type: PopEntityFieldEditorComponent,
                    inputs: {}
                },
            ]
        },
    },
    onLoad: (config, tab) => {
        //       console.log('config', this);
        // console.log('tab', tab);
    },
    onEvent: (core, event) => {
        // console.log('event', event);
    },
});

class HeaderInterceptor {
    constructor(base) {
        this.base = base;
    }
    intercept(request, next) {
        let headers;
        // If SkipHeaderInterceptor has been set then skip this interceptor
        if (request.headers.has('SkipAuthHeaderInterceptor')) {
            headers = request.headers.delete('SkipAuthHeaderInterceptor');
            return next.handle(request.clone({ headers }));
        }
        headers = new HttpHeaders({
            'Authorization': this.base.getBearerToken(),
            'X-Popcx-Business': request.headers.get('x-popcx-business'),
            'Content-Type': request.headers.get('content-type') || 'application/json',
            'Api-Version': request.headers.get('api-version') || '1',
        });
        const newReq = request.clone({ headers });
        // send cloned request with header to the next handler.
        return next.handle(newReq);
    }
}
HeaderInterceptor.decorators = [
    { type: Injectable }
];
HeaderInterceptor.ctorParameters = () => [
    { type: PopBaseService }
];
class Response401Interceptor {
    constructor(baseService, router) {
        this.baseService = baseService;
        this.router = router;
    }
    intercept(request, next) {
        // If SkipResponse401Interceptor has been set then skip this interceptor.
        if (request && request.headers && request.headers.has('SkipResponse401Interceptor')) {
            const headers = request.headers.delete('SkipResponse401Interceptor');
            return next.handle(request.clone({ headers }));
        }
        return next.handle(request).pipe(tap(() => {
            this.baseService.setAuthTime();
        }), catchError((err) => {
            const currentPath = window.location.href.split(PopHref)[1];
            if (err.status >= 500) {
                const message = GetHttpErrorMsg(err);
                if (currentPath && !currentPath.includes('error/500')) {
                    SetPopMessage((isDevMode() ? message : 'Something went wrong!'));
                    this.router.navigate(['system/error/500'], { skipLocationChange: true });
                }
            }
            else if (err.status === 403) {
                const message = GetHttpErrorMsg(err);
                if (message === 'Your email address is not verified.') {
                    if (currentPath && !currentPath.includes('/user/email/resend')) {
                        window.location.href = window.location.protocol + '//' + window.location.host + '/user/email/resend';
                    }
                }
                else {
                    if (currentPath && !currentPath.includes('error/403')) {
                        SetPopMessage(isDevMode() ? message : 'Access Denied!');
                        this.router.navigate(['system/error/403'], { skipLocationChange: true });
                    }
                }
            }
            else if (err.status === 404) {
                const message = GetHttpErrorMsg(err);
                if (currentPath && !currentPath.includes('error/404')) {
                    SetPopMessage(isDevMode() ? message : 'Something went wrong!');
                    this.router.navigate(['system/error/404'], { skipLocationChange: true });
                }
            }
            else if (err.status === 401) {
                if (isDevMode()) {
                    if (IsObject(PopTemplate)) {
                        PopTemplate.error({ code: 401, message: 'UNAUTHENTICATED' });
                    }
                }
                else {
                    SetSiteVar('redirectAfterLogin', window.location.href);
                    this.baseService.clearAuthTime();
                    this.baseService.clearLocalStorage();
                    window.location.href = window.location.protocol + '//' + window.location.host + '/user/legacy/auth/clear';
                }
            }
            else {
                return next.handle(request);
            }
        }));
    }
}
Response401Interceptor.decorators = [
    { type: Injectable }
];
Response401Interceptor.ctorParameters = () => [
    { type: PopBaseService },
    { type: Router }
];

/** Adapts the native JS Date for use with cdk-based modules that work with dates. */
class CustomDateAdapter extends NativeDateAdapter {
    // parse the date from input component as it only expect dates in
    // mm-dd-yyyy format
    // parse(value: any): Date | null {
    //   if ((typeof value === 'string') && (value.indexOf('/') > -1)) {
    //     const str = value.split('/');
    //
    //     const year = Number(str[2]);
    //     const month = Number(str[1]) - 1;
    //     const date = Number(str[0]);
    //
    //     return new Date(year, month, date);
    //   }
    //   const timestamp = typeof value === 'number' ? value : Date.parse(value);
    //   return isNaN(timestamp) ? null : new Date(timestamp);
    // }
    getFirstDayOfWeek() {
        return 1;
    }
}
CustomDateAdapter.decorators = [
    { type: Injectable }
];

class PopErrorRedirectComponent extends PopExtendComponent {
    constructor(el, _domRepo, route) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this.route = route;
        this.name = 'PopErrorRedirectComponent';
        this.srv = {
            router: ServiceInjector.get(Router),
        };
        this.ui = {
            code: undefined,
            message: undefined
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.state.isDevMode = isDevMode();
                this.dom.setHeight(PopTemplate.getContentHeight(), 120);
                this._setRoute();
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        SetPopMessage(null);
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setRoute() {
        this.ui.code = this.route.snapshot.params.code || 404;
        this.ui.message = PopMessage;
    }
}
PopErrorRedirectComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-error-redirect',
                template: "<div *ngIf=\"dom.state.isDevMode\" class=\"pop-error-redirect-container  import-flex-row import-item-full import-flex-center\" [style.height.px]=\"dom.height.outer\">\n  <div class=\"import-flex-item-md import-flex-center site-pad-xxl import-flex-grow-xs\" [style.height.px]=\"dom.height.inner\">\n    <h1>{{ui.code}}</h1>\n  </div>\n  <div *ngIf=\"ui.message\" class=\"import-flex-item-md import-flex-center site-pad-xxl\" [style.height.px]=\"dom.height.inner\">\n    <p>{{ui.message}}</p>\n  </div>\n\n</div>\n<div *ngIf=\"!dom.state.isDevMode\" class=\"error-container\">\n  <div class=\"error-wrapper\">\n    <svg  height=\"100px\" viewBox=\"0 0 24 24\" width=\"100px\"><path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/></svg>\n    <h1 class=\"pop-error-main-text\">Oops!\n    </h1>\n    <h1>{{ui.message}}</h1>\n  </div>\n\n</div>\n",
                styles: [".pop-error-redirect-container h1{font-size:100px;color:var(--error)}.error-container{color:var(--text-2);height:calc(100vh - 60px);width:100%}.error-container,.error-container .error-wrapper{display:flex;align-items:center;flex-direction:column;justify-content:center}.error-container .error-wrapper svg{fill:var(--text-2)}.error-container .error-wrapper mat-icon{font-size:5rem}.error-container .error-wrapper h1{margin:0}.error-container .error-wrapper .pop-error-main-text{font-size:4rem;margin:var(--mar-md) 0}"]
            },] }
];
PopErrorRedirectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: ActivatedRoute }
];

class PopCacheRedirectComponent extends PopExtendComponent {
    constructor() {
        super();
        this.name = 'PopCacheRedirectComponent';
        this.srv = {
            router: ServiceInjector.get(Router),
            entity: ServiceInjector.get(PopEntityService),
        };
        this.ui = {
            code: undefined,
            message: undefined
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.setHeight(PopTemplate.getContentHeight(), 120);
                PopTemplate.clear();
                this.srv.entity.bustAllCache();
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.dom.setTimeout(`cache-redirect`, () => {
                    if (IsString(PopCacheRedirectUrl, true)) {
                        this.srv.router.navigate([PopCacheRedirectUrl], { skipLocationChange: true }).then(() => {
                            // console.log('cache redirect success');
                            return true;
                        });
                    }
                    else {
                        this.srv.router.navigate(['system/route']);
                    }
                }, 250);
                return resolve(true);
            }));
        };
    }
    /**
     * This component allows a redirect that will clear all cache and then return back to the url
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        SetPopCacheRedirectUrl(null);
        super.ngOnDestroy();
    }
}
PopCacheRedirectComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-cache-redirect',
                template: "<div class=\"pcr-container\">\n  <mat-card>\n    <mat-card-content>\n      <div class=\"pcr-spinner-box\">\n        <lib-main-spinner></lib-main-spinner>\n      </div>\n    </mat-card-content>\n  </mat-card>\n</div>\n",
                styles: [".pcr-container{position:relative;display:flex;flex-direction:row;padding:var(--gap-s) var(--gap-lm) var(--gap-lm) var(--gap-lm);box-sizing:border-box;justify-content:center;align-items:flex-start;min-height:200px}.pcr-container mat-card{width:300px}.pcr-container mat-card-title{text-align:center;margin-bottom:var(--gap-m)!important}.pcr-container form{margin:var(--gap-s) 0!important}.pcr-spinner-box{height:80vh}"]
            },] }
];
PopCacheRedirectComponent.ctorParameters = () => [];

class PopGuardRedirectComponent extends PopExtendComponent {
    constructor(_baseRepo, _routerRepo) {
        super();
        this._baseRepo = _baseRepo;
        this._routerRepo = _routerRepo;
        this.srv = {
            base: undefined,
            router: undefined
        };
        this.asset = {
            sentimentIndex: 0,
            sentiments: [
                'sentiment_very_dissatisfied',
                'sentiment_dissatisfied',
                'sentiment_satisfied',
                'sentiment_satisfied_alt',
                'sentiment_very_satisfied',
            ],
            exclamations: [
                `DUH!`,
                `THIS SUCKS!`,
                `TRY AGAIN!`,
                `WASN'T ME!`,
                `SHOOT!`,
                `GO HOME, I'M DRUNK!`,
                `Y U NO FIND ROUTE!`,
                `WHERE AM I!`,
            ],
            route: undefined
        };
        this.ui = {
            exclamation: undefined,
            sentiment: undefined,
            spinner: undefined,
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([
                    this.setInitialConfig()
                ]);
                // this._improveSentiment();
                // this._routeApp();
                return resolve(true);
            }));
        };
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    setInitialConfig() {
        return new Promise((resolve) => {
            this.dom.state.isDevMode = isDevMode();
            this.ui.sentiment = this.asset.sentiments[this.asset.sentimentIndex];
            this.ui.exclamation = RandomArrayElement(this.asset.exclamations);
            this.asset.route = this.srv.router.config.find((r) => {
                return IsString(r.path, true) && !r.canActivate && !r.redirectTo;
            });
            this.ui.spinner = {
                color: 'accent'
            };
            return resolve(true);
        });
    }
    _improveSentiment() {
        this.dom.setTimeout(`improve-sentiment`, () => {
            if (this.asset.sentiments[this.asset.sentimentIndex + 1]) {
                this.asset.sentimentIndex++;
                this.ui.sentiment = this.asset.sentiments[this.asset.sentimentIndex];
                this._improveSentiment();
            }
            else {
                this.dom.setTimeout(`improve-sentiment`, null);
                this.ui.exclamation = 'ALL GOOD!';
                this._routeApp();
            }
        }, 400);
    }
    /**
     *
     * @private
     */
    _routeApp() {
        this.dom.setTimeout(`re-route`, () => {
            if (IsObject(PopBusiness, ['id'])) {
                if (IsObject(this.asset.route, ['path'])) {
                    console.log('DIAGNOSE Redirect ISSUE: Redirect Path', this.asset.route.path);
                    if (this.srv.base.checkAppAccess(PopHref, true)) {
                        this.srv.router.navigateByUrl(this.asset.route.path).catch((e) => console.log('e', e));
                    }
                }
                else {
                    if (!this.dom.state.isDevMode && IsString(PopHref, true) && PopHref !== 'home')
                        window.location.href = window.location.protocol + '//' + window.location.host + '/home';
                }
            }
            else {
                if (!this.dom.state.isDevMode && IsString(PopHref, true) && PopHref !== 'user')
                    window.location.href = window.location.protocol + '//' + window.location.host + '/user/profile';
            }
        }, 400);
    }
}
PopGuardRedirectComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-guard-redirect',
                template: "<!--  <mat-icon class=\"pgr-icon\">{{ui.sentiment}}</mat-icon>-->\n<!--  <div class=\"pgr-message\">{{ui.exclamation}}</div>-->\n<div class=\"pgr-container\" *ngIf=\"dom.state.isDevMode\">\n  <mat-card>\n    <mat-card-content>\n      <div class=\"pcg-spinner-box\">\n        <!-- <lib-main-spinner [options]=\"ui.spinner\"></lib-main-spinner> -->\n\n      </div>\n    </mat-card-content>\n  </mat-card>\n</div>\n\n<div class=\"pcr-container\" *ngIf=\"!dom.state.isDevMode\">\n  <mat-card>\n    <mat-card-content>\n      <div class=\"pgr-spinner-box\">\n        <lib-main-spinner></lib-main-spinner>\n      </div>\n    </mat-card-content>\n  </mat-card>\n</div>\n\n",
                styles: [".pgr-container{display:flex;flex-direction:column;padding:var(--gap-s);box-sizing:border-box;justify-content:center;align-items:center;height:calc(100vh - 90px)}.pgr-container mat-card{width:300px}.pgr-container mat-card-title{text-align:center;margin-bottom:var(--gap-m)!important}.pgr-container form{margin:var(--gap-s) 0!important}.pgr-icon{position:relative;font-size:250px;color:var(--accent);width:250px;height:250px;top:-125px}.pgr-message{padding:var(--gap-s);width:400px;height:20px;display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:var(--gap-lm)}.pcg-spinner-box{height:80vh}"]
            },] }
];
PopGuardRedirectComponent.ctorParameters = () => [
    { type: PopBaseService },
    { type: Router }
];

class PopRedirectsModule {
}
PopRedirectsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopErrorRedirectComponent,
                    PopCacheRedirectComponent,
                    PopGuardRedirectComponent
                ],
                imports: [
                    CommonModule,
                    MaterialModule,
                    PopIndicatorsModule
                ],
                providers: [],
                exports: [
                    PopErrorRedirectComponent,
                    PopCacheRedirectComponent,
                    PopGuardRedirectComponent
                ]
            },] }
];

class PopRedirectGuard {
    constructor(router) {
        this.router = router;
    }
    canActivate(route) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsString(PopMessage, true)) {
                return resolve(true);
            }
            else {
                return this.router.navigateByUrl('system/route');
            }
        }));
    }
}
PopRedirectGuard.prov = i0.defineInjectable({ factory: function PopRedirectGuard_Factory() { return new PopRedirectGuard(i0.inject(i1$1.Router)); }, token: PopRedirectGuard, providedIn: "root" });
PopRedirectGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PopRedirectGuard.ctorParameters = () => [
    { type: Router }
];

class PopCacheRedirectGuard {
    constructor(router) {
        this.router = router;
    }
    canActivate(route) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsString(PopCacheRedirectUrl, true)) {
                return resolve(true);
            }
            else {
                return this.router.navigateByUrl('system/route');
            }
        }));
    }
}
PopCacheRedirectGuard.prov = i0.defineInjectable({ factory: function PopCacheRedirectGuard_Factory() { return new PopCacheRedirectGuard(i0.inject(i1$1.Router)); }, token: PopCacheRedirectGuard, providedIn: "root" });
PopCacheRedirectGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PopCacheRedirectGuard.ctorParameters = () => [
    { type: Router }
];

class PopRequestExternalService extends PopExtendService {
    constructor(httpBackend) {
        super();
        this.httpBackend = httpBackend;
        this.name = 'PopRequestExternalService';
        this.urlRegex = new RegExp('^(https?:\\/\\/)?' + // protocol
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
            '((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
            '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
            '(\\#[-a-z\\d_]*)?$', 'i');
        this.http = new HttpClient(this.httpBackend);
    }
    getBaseUrl() {
        return this.baseUrl.slice();
    }
    setBaseUrl(baseUrl) {
        if (IsString(baseUrl, true)) {
            this.baseUrl = baseUrl;
        }
    }
    doGet(url, params = {}, headers = {}) {
        if (this._checkUrl(url)) {
            const options = {
                headers: new HttpHeaders(headers),
                params: this._setParams(params)
            };
            return this.http.get(`${url}`, options);
        }
        else {
            return of(null);
        }
    }
    doDelete(url, body = null, headers = {}) {
        if (this._checkUrl(url)) {
            const options = {
                headers: new HttpHeaders(headers),
                body: body,
            };
            return this.http.delete(url, options);
        }
        else {
            return of(null);
        }
    }
    doPatch(url, data, headers = {}) {
        if (this._checkUrl(url)) {
            const options = {
                headers: new HttpHeaders(headers),
            };
            return this.http.patch(url, JSON.stringify(data), options);
        }
        else {
            return of(null);
        }
    }
    doPost(url, data, headers = {}) {
        if (this._checkUrl(url)) {
            const options = {
                headers: new HttpHeaders(headers),
            };
            return this.http.post(url, JSON.stringify(data), options);
        }
        else {
            return of(null);
        }
    }
    _setParams(body) {
        let params = new HttpParams();
        for (const key of Object.keys(body)) {
            if (body[key]) {
                if (body[key] instanceof Array) {
                    body[key].forEach((item) => {
                        params = params.append(`${key.toString()}[]`, item);
                    });
                }
                else {
                    params = params.append(key.toString(), body[key]);
                }
            }
        }
        return params;
    }
    _checkUrl(url) {
        const valid = !!this.urlRegex.test(url);
        if (!valid) {
            throw new Error(`Invalid Url: ${url}`);
        }
        return true;
    }
}
PopRequestExternalService.prov = i0.defineInjectable({ factory: function PopRequestExternalService_Factory() { return new PopRequestExternalService(i0.inject(i1.HttpBackend)); }, token: PopRequestExternalService, providedIn: "root" });
PopRequestExternalService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopRequestExternalService.ctorParameters = () => [
    { type: HttpBackend }
];

class PopEntitySchemeComponentService extends PopExtendService {
    /**
     * This srv is used in the
     * @param env
     */
    constructor(resource, APP_GLOBAL, env) {
        super();
        this.resource = resource;
        this.APP_GLOBAL = APP_GLOBAL;
        this.env = env;
        this.asset = {
            action: new Map(),
            base: new Map(),
            setting: new Map(),
            component: new Map(),
            param: new Map(),
            resource: new Map(),
            option: new Map(),
            tabs: new Map(),
            baseImageUrl: '',
        };
        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield APP_GLOBAL.isVerified();
            this.asset.baseImageUrl = IsString(this.env.s3BucketUrl, true) ? this.env.s3BucketUrl : 'https://popcx-dev-public.s3-us-west-2.amazonaws.com';
        }), 0);
    }
    /**
     * Configure/Extend the default behavior of an entity
     * @param internal_name
     * @param extend
     */
    configure(internal_name, extend) {
        if (IsObject(extend.component, ['type']))
            this.setComponent(internal_name, extend.component);
        if (IsArray(extend.tab, true))
            this.setTab(internal_name, extend.tab);
        if (IsObject(extend.action, true))
            this.setAction(internal_name, extend.action);
        if (IsObject(extend.resource, true))
            this.setResource(internal_name, extend.resource);
        if (IsObject(extend.setting, true))
            this.setSetting(internal_name, extend.setting);
        if (IsObject(extend.option, true))
            this.setOption(internal_name, extend.option);
    }
    /**
     * A method to get a Core Config for an entity
     * Uses cache service to improve performance
     * ALL ENTITY RELATED COMPONENTS RELY ON THIS !!!!
     * @param entityParams
     * @param metadata
     */
    getConfig(internal_name, item) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let config = yield this._getBaseConfig(internal_name);
            if (item && item.id) {
                config.id = item.id;
                config.param.id = item.id;
                config.preferences = yield this._getPreferences(config.param);
                const settingComponent = config.setting.component;
                config = DeepMerge(config, item);
                config.setting.component = settingComponent ? settingComponent : null;
            }
            yield this.getResources(config);
            return resolve(config);
        }));
    }
    /**
     * This will do all of the work of building and storing the base config for each entity
     * @param internal_name
     * @param routes
     * @private
     */
    _getBaseConfig(internal_name) {
        return new Promise((resolve) => {
            if (!this.asset.base.has(internal_name)) {
                const param = this.getParams(internal_name);
                const base = new SchemeComponentConfig({
                    param: param,
                    component: this.getComponent(internal_name),
                    setting: this.getSetting(internal_name),
                    option: this.getOption(internal_name),
                    resource: this.getResource(internal_name),
                });
                this.asset.base.set(internal_name, base);
                return resolve(base);
            }
            else {
                return resolve(Object.assign({}, this.asset.base.get(internal_name)));
            }
        });
    }
    /**
     * Get the base set of the entity definitions
     * These is the starting point when it comes to entities
     * @param internal_name
     * @param entityId
     */
    getParams(internal_name) {
        let widgetParams = null;
        if (this.asset.param.has(internal_name)) {
            widgetParams = Object.assign({}, this.asset.param.get(internal_name));
        }
        else {
            // temporary
            widgetParams = { internal_name: internal_name, name: TitleCase(SnakeToPascal(internal_name)) };
        }
        return widgetParams;
    }
    /**
     * Get the set of tab configs that belong to an entity
     */
    getTabs(widget) {
        if (IsObject(widget, ['param']) && this.asset.tabs.has(widget.param.internal_name)) {
            const tabs = this.asset.tabs.get(widget.param.internal_name).filter((tab) => {
                return EvaluateWhenConditions(widget, tab.when);
            });
            return [...tabs];
        }
        else {
            return [];
        }
    }
    /**
     * A Http call that gets the entity metadata
     * @param id Primary Key of the entity
     */
    getResources(widget) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(widget.resource, true)) {
                const success = yield this.resource.setCollection(widget.resource);
                if (success) {
                    this.resource.getCollection(widget.resource);
                    return resolve(true);
                }
                else {
                    resolve(false);
                }
            }
            else {
                resolve(false);
            }
        }));
    }
    /**
     * Set the base definitions for an entity
     * Each entity needs to define these so we know how to talk to the api in regards to it
     * The api should provide this details as part of the auth token
     * @param internal_name
     * @param entityId
     */
    setParam(param) {
        if (IsObject(param, ['internal_name', 'name'])) {
            PopLog.info(this.name, `Params set for ${param.internal_name}`, param);
            this.asset.param.set(param.internal_name, param);
        }
    }
    /**
     * Attach a set of tab configs to an entity
     * @param internal_name
     * @param tabs
     */
    setTab(internal_name, tabs) {
        if (IsString(internal_name, true) && Array.isArray(tabs)) {
            PopLog.info(this.name, `Entity Tabs set for ${internal_name}`, tabs);
            this.asset.tabs.set(internal_name, tabs);
        }
    }
    /**
     * Attach a component to a widget
     * @param internal_name
     * @param tabs
     */
    setComponent(internal_name, component) {
        if (IsString(internal_name, true) && IsObject(component, ['type'])) {
            PopLog.info(this.name, `Component set for ${internal_name}`, component);
            this.asset.component.set(internal_name, component);
        }
    }
    /**
     * Attach a set of actions to an entity
     * @param internal_name
     * @param tabs
     */
    setAction(internal_name, action) {
        if (IsString(internal_name, true) && IsObject(action)) {
            PopLog.info(this.name, `Action set for ${internal_name}`, action);
            this.asset.action.set(internal_name, action);
        }
    }
    /**
     * Attach a set of resources to an entity
     * @param internal_name
     * @param tabs
     */
    setResource(internal_name, resource) {
        if (IsString(internal_name, true) && IsObject(resource)) {
            PopLog.info(this.name, `Entity Resource set for ${internal_name}`, resource);
            this.asset.resource.set(internal_name, resource);
        }
    }
    /**
     * Attach a set of options to widget
     * @param internal_name
     * @param tabs
     */
    setOption(internal_name, option) {
        if (IsString(internal_name, true) && IsObject(option)) {
            PopLog.info(this.name, `Option set for ${internal_name}`, option);
            this.asset.option.set(internal_name, option);
        }
    }
    /**
     * Attach a set of options to widget
     * @param internal_name
     * @param tabs
     */
    setSetting(internal_name, setting) {
        if (IsString(internal_name, true) && IsObject(setting)) {
            PopLog.info(this.name, `Setting set for ${internal_name}`, setting);
            this.asset.setting.set(internal_name, setting);
        }
    }
    /**
     * Get extended fields attached to an entity
     * @param internal_name
     * @param tabs
     */
    getResource(internal_name) {
        if (IsString(internal_name, true)) {
            const resource = this.asset.resource.get(internal_name);
            return resource ? resource : {};
        }
    }
    /**
     * Get extended actions attached to an entity
     * @param internal_name
     * @param tabs
     */
    getAction(internal_name) {
        if (IsString(internal_name, true)) {
            const action = this.asset.action.get(internal_name);
            return action ? action : {};
        }
    }
    /**
     * Get extended actions attached to an entity
     * @param internal_name
     * @param tabs
     */
    getSetting(internal_name) {
        if (IsString(internal_name, true)) {
            const setting = this.asset.setting.get(internal_name);
            return setting ? setting : {};
        }
    }
    /**
     * Get extended actions attached to an entity
     * @param internal_name
     * @param tabs
     */
    getOption(internal_name) {
        if (IsString(internal_name, true)) {
            const option = this.asset.option.get(internal_name);
            return option ? option : {};
        }
    }
    /**
     * Get extended actions attached to an entity
     * @param internal_name
     * @param tabs
     */
    getComponent(internal_name) {
        if (IsString(internal_name, true)) {
            const component = this.asset.component.get(internal_name);
            return component ? component : null;
        }
    }
    ngOnDestroy() {
        console.log(this.name, `destroyed:${this.id}`);
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _getPreferences(param) {
        return new Promise((resolve) => {
            return resolve({});
        });
    }
    getDefaultComponentSetting(internalName) {
        const setting = {
            client_id: [],
            account_id: [],
            campaign_id: [],
            edit: true,
            refresh: true
        };
        return setting;
    }
    getDefaultComponentOption(internalName) {
        const option = {
            client_id: [],
            account_id: [],
            campaign_id: [],
            edit: true,
            refresh: true
        };
        return option;
    }
}
PopEntitySchemeComponentService.prov = i0.defineInjectable({ factory: function PopEntitySchemeComponentService_Factory() { return new PopEntitySchemeComponentService(i0.inject(PopResourceService), i0.inject("APP_GLOBAL"), i0.inject("env")); }, token: PopEntitySchemeComponentService, providedIn: "root" });
PopEntitySchemeComponentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopEntitySchemeComponentService.ctorParameters = () => [
    { type: PopResourceService },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class AppMenus {
    constructor() {
        this._menus = [];
    }
    get() {
        return this._menus;
    }
    set(menus) {
        this._menus = menus;
    }
    init(menus) {
        return menus;
    }
}
class AppWidgets {
    constructor() {
        this._widgets = [];
    }
    get() {
        return this._widgets;
    }
    set(widgets) {
        this._widgets = widgets;
    }
}
class AppTheme {
    constructor() {
        this._theme = 'default';
        this._contrast = 'light';
        this._name = 'default-light.css';
        this.init = new BehaviorSubject(false);
    }
    get() {
        return this._name;
    }
    set(theme = 'default', contrast = 'light') {
        this._theme = theme;
        this._contrast = contrast;
        this._name = `${this._theme}-${this._contrast}.css`;
        const themeLink = document.getElementById('themeFileEle');
        if (themeLink) {
            const existingTheme = StringReplaceAll(themeLink.href.split(PopHref).pop(), '/', '');
            if (this._name !== existingTheme) {
                themeLink.href = this._name;
            }
        }
        else {
            const themeFile = document.createElement('link');
            themeFile.setAttribute('rel', 'stylesheet');
            themeFile.setAttribute('type', 'text/css');
            themeFile.setAttribute('href', this._name);
            themeFile.setAttribute('id', 'themeFileEle');
            themeFile.onload = () => {
                this.init.next(true);
            };
            if (typeof themeFile != 'undefined')
                document.getElementsByTagName('head')[0].appendChild(themeFile);
        }
    }
    isLoaded() {
        return this.init.getValue();
    }
}
class AppGlobal {
    constructor() {
        this._verified = false;
        this._modals = 0;
        this._open = false;
        this.init = new BehaviorSubject(false);
        this.verification = new Subject();
        this._unload = new Subject();
    }
    isVerified() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const wait = setInterval(() => {
                if (this._verified) {
                    clearInterval(wait);
                    return resolve(true);
                }
            }, 5, 5);
        }));
    }
    setVerified() {
        this._verified = true;
    }
    setModal() {
        this._modals++;
    }
    isModal() {
        return this._modals;
    }
    removeModal() {
        if (this._modals) {
            this._modals--;
        }
    }
    isFilterBar() {
        return this._filter;
    }
    setFilterBar(value) {
        this._filter = value;
    }
    isPipes() {
        return this._pipes;
    }
    setPipes(value) {
        this._pipes = value;
    }
    isAliases() {
        return this._aliases;
    }
    setAliases(value) {
        this._aliases = value;
    }
    isEntities() {
        return this._entities;
    }
    setEntities(value) {
        this._entities = value;
    }
    setSecurity(value) {
        this._security = value;
    }
    isSecurity() {
        return this._security;
    }
    isPermissions() {
        return this._permissions;
    }
    setPermissions(value) {
        this._permissions = value;
    }
    isOpen() {
        return this._open;
    }
    setOpen(value) {
        this._open = value;
    }
}
class PopInitializerModule {
    constructor(base, cacFilter, componentFactoryResolver, credential, date, entity, externalApi, log, history, iconRegistry, pipe, portal, request, router, sanitizer, schemeComponent, template, platform, injector, tasks, APP_GLOBAL, APP_GLOBAL_PARAMS, APP_THEME, env) {
        this.base = base;
        this.cacFilter = cacFilter;
        this.componentFactoryResolver = componentFactoryResolver;
        this.credential = credential;
        this.date = date;
        this.entity = entity;
        this.externalApi = externalApi;
        this.log = log;
        this.history = history;
        this.iconRegistry = iconRegistry;
        this.pipe = pipe;
        this.portal = portal;
        this.request = request;
        this.router = router;
        this.sanitizer = sanitizer;
        this.schemeComponent = schemeComponent;
        this.template = template;
        this.platform = platform;
        this.injector = injector;
        this.tasks = tasks;
        this.APP_GLOBAL = APP_GLOBAL;
        this.APP_GLOBAL_PARAMS = APP_GLOBAL_PARAMS;
        this.APP_THEME = APP_THEME;
        this.env = env;
        this.name = `PopInitializerModule`;
        this.verification = {
            pending: false,
            subscription: undefined,
            debouncer: undefined,
            trigger: () => {
                if (this.verification.debouncer)
                    clearTimeout(this.verification.debouncer);
                this.verification.debouncer = setTimeout(() => {
                    return this._verifyAuthStorage();
                }, 5);
            },
            unload: () => {
                if (this.verification.subscription) {
                    this.verification.subscription.unsubscribe();
                }
                if (this.verification.debouncer) {
                    clearTimeout(this.verification.debouncer);
                }
            }
        };
        this.unload = {
            pending: false,
            subscription: undefined,
            debouncer: undefined,
            trigger: () => {
                if (this.unload.debouncer)
                    clearTimeout(this.unload.debouncer);
                this.unload.debouncer = setTimeout(() => {
                    this.unload.run();
                }, 0);
            },
            run: () => {
                if (this.unload.subscription) {
                    this.unload.subscription.unsubscribe();
                }
                this.verification.unload();
            }
        };
        this.iconRegistry.addSvgIcon('admin', this.sanitizer.bypassSecurityTrustResourceUrl('assets/images/admin.svg'));
        const setup = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const auth = this.base.getAuthDetails();
            const login = GetSessionSiteVar('Login.time', 0);
            try {
                this._setBusinessId(auth);
            }
            catch (e) {
                console.log(e);
            }
            const publicFacingApp = this.APP_GLOBAL_PARAMS.open ? true : false;
            if (!publicFacingApp && IsObject(auth, ['id', 'businesses', 'users', 'token', 'email_verified_at']) && !(this.base.isAuthExpired())) {
                yield this._loadAppTheme();
                yield this._init(auth);
                PopLog.init(this.name, `:publicFacingApp`, publicFacingApp);
                /** This is experimental testing if app can be speed up  **/
                if (this.businessId && StorageGetter(auth, ['businesses', this.businessId, 'apps']) && !login) {
                    PopLog.init(this.name, `:fire app early?`);
                    this.APP_GLOBAL.setVerified();
                    this.APP_GLOBAL.init.next(true);
                }
                /** *********************** **/
                const verified = yield this._verifyAuthStorage();
                if (!verified) {
                    if (!isDevMode()) {
                        if (false) {
                            this.base.clearAuthDetails(`PopInitializerModule:setup`);
                            window.location.href = window.location.protocol + '//' + window.location.host + '/user/legacy/auth/clear';
                        }
                        else {
                            PopLog.init(this.name, `:verification failed`);
                            this.APP_GLOBAL.setVerified();
                            this.APP_GLOBAL.init.next(true);
                            return resolve(true);
                        }
                    }
                    else {
                        PopLog.init(this.name, `:verification failed`);
                        this.APP_GLOBAL.init.next(true);
                        return resolve(true);
                    }
                }
                else {
                    this._welcome();
                    return resolve(true);
                }
                // if(this.APP_GLOBAL.isSecurity() && IsString(PopHref, true)) {
                //   this.base.checkAppAccess(PopHref, true);
                // }
            }
            else {
                SetSessionSiteVar('App.theme', null);
                SetSessionSiteVar('App.themeContrast', null);
                yield this._loadAppTheme();
                yield this._setDependencies(false, null);
                if (this.APP_GLOBAL.isOpen()) {
                    this.APP_GLOBAL.setVerified();
                    this.APP_GLOBAL.init.next(true);
                    return resolve(true);
                }
                else {
                    this.APP_GLOBAL.init.next(true);
                    return resolve(true);
                }
            }
        }));
        setup.catch((e) => {
            if (isDevMode())
                console.log('e', e);
            this.APP_GLOBAL.init.next(true);
        });
    }
    static forRoot(tasks = [], appGlobalsParams = {}) {
        return {
            ngModule: PopInitializerModule,
            providers: [
                {
                    provide: 'APP_GLOBAL',
                    useClass: AppGlobal
                },
                {
                    provide: 'APP_GLOBAL_PARAMS',
                    useValue: appGlobalsParams
                },
                { provide: HTTP_INTERCEPTORS, useClass: HeaderInterceptor, multi: true },
                { provide: HTTP_INTERCEPTORS, useClass: Response401Interceptor, multi: true },
                { provide: DateAdapter, useClass: CustomDateAdapter },
                {
                    provide: 'APP_INITIALIZER_TASKS',
                    useValue: tasks
                },
                {
                    provide: 'APP_MENUS',
                    useClass: AppMenus
                },
                {
                    provide: 'APP_WIDGETS',
                    useClass: AppWidgets
                },
                {
                    provide: 'APP_THEME',
                    useClass: AppTheme
                },
            ]
        };
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Load the app dependencies
     * @param business
     */
    _setDependencies(authenticated, auth) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.APP_GLOBAL.setAliases(IsDefined(this.env.aliases) ? this.env.aliases : (IsDefined(this.APP_GLOBAL_PARAMS.aliases) ? this.APP_GLOBAL_PARAMS.aliases : true));
            this.APP_GLOBAL.setFilterBar(IsDefined(this.env.filter) ? this.env.filter : (IsDefined(this.APP_GLOBAL_PARAMS.filter) ? this.APP_GLOBAL_PARAMS.aliases : true));
            this.APP_GLOBAL.setPipes(IsDefined(this.env.pipes) ? this.env.pipes : (IsDefined(this.APP_GLOBAL_PARAMS.pipes) ? this.APP_GLOBAL_PARAMS.pipes : true));
            this.APP_GLOBAL.setEntities(IsDefined(this.env.entities) ? this.env.entities : (IsDefined(this.APP_GLOBAL_PARAMS.entities) ? this.APP_GLOBAL_PARAMS.entities : true));
            this.APP_GLOBAL.setOpen(IsDefined(this.env.open) ? this.env.open : (IsDefined(this.APP_GLOBAL_PARAMS.open) ? this.APP_GLOBAL_PARAMS.open : false));
            this.APP_GLOBAL.setSecurity(IsDefined(this.env.security) ? this.env.security : (IsDefined(this.APP_GLOBAL_PARAMS.security) ? this.APP_GLOBAL_PARAMS.security : false));
            this.APP_GLOBAL.setPermissions(IsDefined(this.env.permissions) ? this.env.permissions : (IsDefined(this.APP_GLOBAL_PARAMS.permissions) ? this.APP_GLOBAL_PARAMS.permissions : false));
            SetServiceInjector(this.injector);
            SetPopEnv(this.env ? this.env : {});
            SetPopExternalApi(this.externalApi);
            SetPopHref(StringReplaceAll(this.platform.getBaseHrefFromDOM(), '/', ''));
            SetPopLogger(this.log);
            SetPopRequest(this.request);
            SetPopTemplate(this.template);
            SetPopComponentResolver(this.componentFactoryResolver);
            if (authenticated) {
                SetPopDate(this.date);
                SetPopHistory(this.history);
                SetPopEntity(this.entity);
                SetPopPipe(this.pipe);
                SetPopPortal(this.portal);
                SetPopSchemeComponent(this.schemeComponent);
                this._setAuthGlobal(auth);
                this._setBusinessId(auth);
                yield Promise.all([
                    this._setRouteCacheClear(),
                    this._setRouteErrorHandling(),
                    this._setBusinessAssets(auth),
                    this._loadPipeResources(),
                ]);
                yield this._loadFilterData();
            }
            return resolve(true);
        }));
    }
    _init(auth) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            yield this._setDependencies(true, auth);
            yield this._setAncillary(auth);
            yield this._configure(auth);
            this.APP_GLOBAL.init.next(true);
            if (!this.unload.subscription) {
                PopLog.init(this.name, `registering unload request subscription`);
                this.unload.subscription = this.APP_GLOBAL._unload.subscribe(() => {
                    PopLog.init(this.name, `unload: requested`);
                    this.unload.trigger();
                });
            }
            return resolve(true);
        }));
    }
    _setAncillary(auth) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            yield this._tasks();
            return resolve(true);
        }));
    }
    _configure(auth) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(auth, ['id', 'businesses', 'users', 'token']) && !(this.base.isAuthExpired()) && PopHref) {
                if (IsObject(PopBusiness, ['id'])) {
                    yield Promise.all([
                        this._setBusinessUserSettings(),
                        this._setFilterAliases(),
                        this._setRouteAliasMap(),
                        this._setDefaultTabs(),
                    ]);
                    return resolve(true);
                }
                else {
                    PopLog.init(this.name, `No Business Found`);
                    return resolve(true);
                }
            }
            else {
                return resolve(true);
            }
        }));
    }
    _tasks() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(PopBusiness, true)) {
                if (IsArray(this.tasks, true)) {
                    this.tasks.map((task) => {
                        if (IsCallableFunction(task)) {
                            task();
                        }
                    });
                }
            }
            return resolve(true);
        }));
    }
    _setAuthGlobal(auth) {
        SetPopAuth({
            id: auth.id,
            name: auth.name,
            first_name: auth.first_name,
            last_name: auth.last_name,
            initials: auth.initials,
            email: auth.email,
            email_verified_at: auth.email_verified_at,
            avatarLink: StorageGetter(auth, ['profile', 'avatar_link'], null),
            username: auth.username,
            created_at: auth.created_at
        });
    }
    _setBusinessId(auth) {
        if (IsUndefined(this.businessId))
            this.businessId = 0;
        if (IsObject(auth.businesses, true)) {
            if (!this.businessId)
                this.businessId = String(GetSiteVar('Business.last', 0));
            if (!(+this.businessId && this.businessId in auth.businesses)) {
                this.businessId = this.base.getCurrentBusinessId();
            }
            if (+this.businessId && this.businessId in auth.businesses) {
                this.businessId = +this.businessId;
            }
            else if (+auth.business_fk && auth.business_fk in auth.businesses) {
                this.businessId = +auth.business_fk;
            }
            else {
                this.businessId = IsObject(auth.businesses, true) ? +Object.keys(auth.businesses)[0] : 0;
            }
        }
    }
    /**
     * Verify that the current auth storage is still relevant
     * @private
     */
    _verifyAuthStorage() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(PopAuth, ['created_at']) && IsDefined(PopAuth.email_verified_at, false) && !this.verification.pending) {
                PopLog.init(this.name, `Verification: In Progress`);
                if (!this.businessId) {
                    PopLog.init(this.name, `Verification:Complete - no business`);
                    this.APP_GLOBAL.setVerified();
                    return resolve(true);
                }
                this.verification.pending = true;
                const auth = yield this.credential.verify(this.businessId);
                if (auth) {
                    this._setAuthGlobal(auth);
                    this._setBusinessId(auth);
                    yield Promise.all([
                        this._setBusinessAssets(auth),
                        this._loadAppTheme(),
                        this._setAncillary(auth),
                        this._configure(auth),
                        this._setRouteAliases()
                    ]);
                    this.APP_GLOBAL.setVerified();
                    PopLog.init(this.name, `Verification: Complete`);
                    this.verification.pending = false;
                    this.APP_GLOBAL.init.next(true);
                    if (!this.verification.subscription) {
                        PopLog.init(this.name, `registering verification request subscription`);
                        this.verification.subscription = this.APP_GLOBAL.verification.subscribe(() => {
                            PopLog.init(this.name, `_verifyAuthStorage: requested`);
                            this.verification.trigger();
                        });
                    }
                    return resolve(true);
                }
                else {
                    return resolve(false);
                }
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * This fx will set up all the necessary business assets that are needed
     * @param auth
     * @private
     */
    _setBusinessAssets(auth) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (+this.businessId && IsObject(auth, ['id', 'businesses', 'users', 'token'])) {
                this.base.setCurrentBusinessId(+this.businessId);
                SetPopUser(IsObject(auth.users, true) && this.businessId in auth.users ? auth.users[this.businessId] : null);
                SetPopBusiness(IsObject(auth.businesses, true) && this.businessId in auth.businesses ? auth.businesses[this.businessId] : null);
                SetPopApp(IsObject(PopBusiness.apps, [PopHref]) ? PopBusiness.apps[PopHref] : null);
                // if (!IsObject(PopApp, ['id', 'name'])) {
                //   if (!isDevMode()) {
                //     window.location.href = window.location.protocol + '//' + window.location.host + '/home';
                //   }
                // }
                yield this._setBusinessAppEntities();
            }
            return resolve(true);
        }));
    }
    /**
     * This fx will loop through all the apps in the current business, and for each entity in that business register the details
     */
    _setBusinessAppEntities() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const auth = this.base.getAuthDetails();
            if (IsObject(PopBusiness, ['id', 'apps']) && IsObject(PopBusiness.apps, true)) {
                const inaccessibleApps = [];
                const permanentApps = ['library', 'home'];
                // console.log('PopUser', PopUser);
                Object.keys(PopBusiness.apps).map((appName) => {
                    const app = PopBusiness.apps[appName];
                    app.hasCreateAccess = false;
                    if (IsObject(app, true) && IsObject(app.entities, true)) {
                        Object.keys(app.entities).map((name) => {
                            if (IsObject(app.entities[name], ['id', 'name', 'internal_name'])) {
                                const entity = app.entities[name];
                                entity.access = {};
                                if (IsObject(PopUser, ['permissions']) && IsObject(PopUser.permissions, true) && entity.internal_name in PopUser.permissions) {
                                    entity.access = PopUser.permissions[entity.internal_name];
                                    // console.log(entity.internal_name, entity.access.can_read);
                                }
                                if (entity.access.can_create)
                                    app.hasCreateAccess = true;
                                PopEntity.setEntityParams(entity);
                                PopPipe.updateEntityAlias(entity.id, entity.alias);
                            }
                        });
                    }
                    if (this.APP_GLOBAL.isEntities() && !app.hasCreateAccess) {
                        if (!(permanentApps.includes((app.name)))) {
                            inaccessibleApps.push(app.name);
                        }
                    }
                });
                // console.log('inaccessibleApps', inaccessibleApps);
                if (IsArray(inaccessibleApps, true)) {
                    inaccessibleApps.map((appName2) => {
                        delete PopBusiness.apps[appName2];
                        delete auth.businesses[PopBusiness.id].apps[appName2];
                    });
                }
                this.base.setAuthDetails(auth);
            }
            return resolve(true);
        }));
    }
    /**
     * Load the client,account,campaign data required for the filter bar
     * @param business
     */
    _setBusinessUserSettings() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (IsObject(PopBusiness, ['id'])) {
                this.date.setCurrentBusinessUnitSettings();
                PopLog.init(this.name, `:BusinessUserSettings`);
                return resolve(true);
            }
            else {
                return resolve(true);
            }
        }));
    }
    _welcome() {
        if (IsObject(PopAuth, ['created_at'])) {
            const now = new Date().getTime() / 1000;
            const loginTime = new Date(PopAuth.created_at).getTime() / 1000;
            const secondsSinceLogin = (now - loginTime);
            const welcome = +secondsSinceLogin && +secondsSinceLogin < 20;
            if (welcome) {
                this.template.welcome();
            }
        }
    }
    /**
     * Load the client,account,campaign data required for the filter bar
     * @param business
     */
    _loadFilterData() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.APP_GLOBAL.isFilterBar() && IsObject(PopBusiness, ['id'])) {
                if (PopEntity.checkAccess('client', 'can_read')) {
                    yield this.cacFilter.setData(this.name);
                    PopLog.init(this.name, `:Filter Data Set`);
                }
                else {
                    PopTemplate.turnOffFilter();
                }
                return resolve(true);
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * Load the resources needed for the PopPipe service
     * @param business
     */
    _loadPipeResources() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.APP_GLOBAL.isPipes() && IsObject(PopBusiness, ['id'])) {
                this.pipe.loadResources().then(() => {
                    PopLog.init(this.name, `:Pipe Resources Set`);
                    return resolve(true);
                });
            }
            else {
                return resolve(false);
            }
        }));
    }
    /**
     * Set any aliases on the filter columns
     * @private
     */
    _setFilterAliases() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.APP_GLOBAL.isFilterBar() && this.APP_GLOBAL.isEntities() && this.APP_GLOBAL.isAliases())
                this.cacFilter.setConfigAliases();
            return resolve(true);
        }));
    }
    /**
     * Create a map lookup for route aliases
     * @private
     */
    _setRouteAliasMap() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const aliasMap = {};
            if (this.APP_GLOBAL.isEntities() && this.APP_GLOBAL.isAliases()) {
                const auth = GetSiteVar('Auth.details', {});
                if (+this.businessId && IsObject(auth, ['businesses']) && IsObject(auth.businesses[this.businessId], ['apps'])) {
                    if (IsObject(auth.businesses[this.businessId].apps, true)) {
                        Object.keys(auth.businesses[this.businessId].apps).map((appName) => {
                            const app = auth.businesses[this.businessId].apps[appName];
                            if (IsObject(app.entities, true)) {
                                Object.keys(app.entities).map((key) => {
                                    const entity = app.entities[key];
                                    if (IsObject(app.entities[key], true) && IsObject(app.entities[key].alias, ['plural'])) {
                                        aliasMap[entity.internal_name] = {
                                            singular: SpaceToHyphenLower(app.entities[key].alias.name),
                                            plural: SpaceToHyphenLower(app.entities[key].alias.plural)
                                        };
                                    }
                                });
                            }
                        });
                    }
                }
            }
            SetPopRouteAliasMap(aliasMap);
            return resolve(true);
        }));
    }
    /**
     * Get the router.config and load all lazy module using the configLoader
     */
    _setRouteAliases() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.APP_GLOBAL.isEntities() && this.APP_GLOBAL.isAliases()) {
                this.router.config = ParseModuleRoutesForAliases(this.router.config);
                this.router.config.reduce((acc, route) => {
                    if (route.loadChildren && route.data && route.data.routeAliases) {
                        this.router.configLoader.load(this.injector, route).subscribe({
                            next: (moduleConf) => {
                                route._loadedConfig = moduleConf;
                                ParseModuleRoutesForAliases(moduleConf.routes);
                                return route.path;
                            }
                        });
                    }
                    return acc;
                }, []);
                yield Sleep(5);
                return resolve(true);
            }
            else {
                yield Sleep(5);
                return resolve(true);
            }
        }));
    }
    /**
     * Get the router.config and load all lazy module using the configLoader
     */
    _setRouteCacheClear() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (true) {
                const cacheRoute = this.router.config.find((route) => route.path === 'system/cache/clear');
                if (!cacheRoute) {
                    this.router.config = [...this.router.config, ...[{
                                path: 'system/cache/clear',
                                pathMatch: 'full',
                                canActivate: [PopCacheRedirectGuard],
                                component: PopCacheRedirectComponent
                            }]];
                }
                return resolve(true);
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * Get the router.config and load all lazy module using the configLoader
     */
    _setRouteErrorHandling() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (true) {
                const guardBlockRoute = this.router.config.find((route) => route.path === 'system/route');
                if (!guardBlockRoute) {
                    this.router.config = [...this.router.config, ...[{
                                path: 'system/route',
                                pathMatch: 'full',
                                component: PopGuardRedirectComponent
                            }]];
                }
                const errorRoute = this.router.config.find((route) => route.path === 'system/error/:code');
                if (!errorRoute) {
                    this.router.config = [...this.router.config, ...[{
                                path: 'system/error/:code',
                                pathMatch: 'full',
                                canActivate: [PopRedirectGuard],
                                component: PopErrorRedirectComponent
                            }]];
                }
                return resolve(true);
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * Load the theme of the business and apply the theme contrast the user has specified
     * @param business
     */
    _loadAppTheme() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let businessTheme = IsObject(PopUser, ['id']) ? StorageGetter(PopUser, ['setting', 'theme'], null) : null;
            if (!businessTheme)
                businessTheme = GetSessionSiteVar(`App.theme`, 'default');
            let userThemeContrast = IsObject(PopUser, ['id']) ? StorageGetter(PopUser, ['setting', 'theme_contrast'], null) : null;
            if (!userThemeContrast)
                userThemeContrast = GetSessionSiteVar(`App.themeContrast`, 'light');
            SetSessionSiteVar('App.theme', businessTheme);
            SetSessionSiteVar('App.themeContrast', userThemeContrast);
            this.APP_THEME.set(businessTheme, userThemeContrast);
            return resolve(true);
        }));
    }
    /**
     * Set a default set of tabs that an entity should have, intended to be overridden
     * @param business
     */
    _setDefaultTabs() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.APP_GLOBAL.isEntities())
                PopEntity.setEntityTabs('default', [EntityGeneralTab, EntityHistoryTab]);
            return resolve(true);
        }));
    }
}
PopInitializerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    PopRedirectsModule
                ],
                declarations: [],
                exports: [],
                providers: [PopCredentialService]
            },] }
];
PopInitializerModule.ctorParameters = () => [
    { type: PopBaseService },
    { type: PopCacFilterBarService },
    { type: ComponentFactoryResolver },
    { type: PopCredentialService },
    { type: PopDatetimeService },
    { type: PopEntityService },
    { type: PopRequestExternalService },
    { type: PopLogService },
    { type: PopRouteHistoryResolver },
    { type: MatIconRegistry },
    { type: PopPipeService },
    { type: PopEntityUtilPortalService },
    { type: PopRequestService },
    { type: Router },
    { type: DomSanitizer },
    { type: PopEntitySchemeComponentService },
    { type: PopTemplateService },
    { type: PlatformLocation },
    { type: undefined, decorators: [{ type: Inject, args: [Injector,] }] },
    { type: Array, decorators: [{ type: Inject, args: ['APP_INITIALIZER_TASKS',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL_PARAMS',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_THEME',] }] },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class PopTabMenuSectionBarService {
    constructor(baseRepo, env) {
        this.baseRepo = baseRepo;
        this.env = env;
    }
    /**
     * Store the current tab into onSession memory
     * @param name
     * @returns void
     */
    setSectionSession(internal_name, slug) {
        if (internal_name)
            SetSessionSiteVar(`Business.${PopBusiness.id}.Entity.${TitleCase(internal_name)}.TabMenu.Main.section`, slug);
    }
    /**
     * Get latest path
     */
    getPathSession(internal_name) {
        return GetSessionSiteVar(`Business.${PopBusiness.id}.Entity.${TitleCase(internal_name)}.TabMenu.Main.section`);
    }
}
PopTabMenuSectionBarService.prov = i0.defineInjectable({ factory: function PopTabMenuSectionBarService_Factory() { return new PopTabMenuSectionBarService(i0.inject(PopBaseService), i0.inject("env")); }, token: PopTabMenuSectionBarService, providedIn: "root" });
PopTabMenuSectionBarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopTabMenuSectionBarService.ctorParameters = () => [
    { type: PopBaseService },
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];

class PopTabMenuSectionBarComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, _routeRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._routeRepo = _routeRepo;
        this._tabRepo = _tabRepo;
        this.overflow = false;
        this.name = 'PopTabMenuSectionBarComponent';
        this.srv = {
            location: ServiceInjector.get(Location),
            router: ServiceInjector.get(Router),
            route: undefined,
            section: ServiceInjector.get(PopTabMenuSectionBarService),
            tab: undefined
        };
        this.ui = {};
        this.asset = {
            tab: undefined,
            baseUrl: undefined,
            urlSection: undefined,
            map: {}
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this._setCore();
                yield this._setRoute();
                yield this._setSections();
                yield this._setHeight();
                yield this._attachContainer();
                return resolve(true);
            }));
        };
    }
    /**
     * Setup this component
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This will load the comonent of the selected section into the view container
     * @param section
     */
    onViewSection(section) {
        this.dom.active.section = section.id;
        this.srv.section.setSectionSession('profile', section.id);
        this.srv.location.go(this.asset.baseUrl + '?section=' + section.id);
        this.dom.setTimeout(`view-section`, () => {
            this.template.render([{
                    type: section.component,
                    inputs: section.inputs,
                    position: this.position,
                }]);
        }, 0);
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    _setCore() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            return resolve(true);
        }));
    }
    _setRoute() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const url = String(this.srv.router.url).split('?')[0];
            const slugs = url.split('/');
            this.asset.baseUrl = slugs.join('/');
            if (this.srv.section.getPathSession(this.core.params.internal_name))
                this.asset.urlSection = this.srv.section.getPathSession(this.core.params.internal_name);
            this.dom.setSubscriber('query-params', this.srv.route.queryParams.subscribe(params => {
                if (params.section)
                    this.asset.urlSection = params.section;
            }));
            return resolve(true);
        }));
    }
    _setSections() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.asset.tab = this.srv.tab.getTab();
            this.dom.active.section = undefined;
            if (!this.sections && this.asset.tab.sections) {
                this.sections = this.asset.tab.sections;
            }
            this.asset.map.sections = ArrayMapSetter(this.sections, 'id');
            return resolve(true);
        }));
    }
    _setHeight() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const defaultHeight = window.innerHeight - 230;
            this.dom.setHeight(defaultHeight, 60);
            return resolve(true);
        }));
    }
    _attachContainer() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.template.attach('container');
            if (IsArray(this.sections, true)) {
                if (this.asset.urlSection in this.asset.map.sections) {
                    this.onViewSection(this.sections[this.asset.map.sections[this.asset.urlSection]]);
                }
                else {
                    this.onViewSection(this.sections[0]);
                }
            }
            return resolve(true);
        }));
    }
}
PopTabMenuSectionBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-tab-section-bar',
                template: "<div class=\"pop-entity-tab-section-bar-header\">\n  <nav mat-tab-nav-bar>\n    <a mat-tab-link\n       *ngFor=\"let section of sections\"\n       (click)=\"onViewSection(section)\"\n       [active]=\"dom.active.section === section.id\">\n      {{section.name}}\n    </a>\n  </nav>\n</div>\n<div class=\"pop-entity-tab-section-bar-wrapper\" [ngClass]=\"{'pop-entity-tab-section-bar-overflow': this.overflow}\" [style.height.px]=\"dom.height.inner\">\n  <ng-template #container></ng-template>\n</div>\n",
                styles: [".pop-entity-tab-section-bar-header{position:relative;border:1px solid transparent;border-radius:3px;margin:-20px 0 0}.pop-entity-tab-section-bar-wrapper{flex:1 1 100%}.pop-entity-tab-section-bar-overflow{overflow-y:scroll}#back-button{font-size:14px;color:red}"]
            },] }
];
PopTabMenuSectionBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: ActivatedRoute },
    { type: PopTabMenuService }
];
PopTabMenuSectionBarComponent.propDecorators = {
    sections: [{ type: Input }],
    overflow: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class PopTabMenuModule {
}
PopTabMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    RouterModule,
                    MatIconModule,
                    MatTabsModule,
                    MatButtonModule,
                    MatProgressBarModule,
                    PopIndicatorsModule,
                ],
                declarations: [
                    PopTabMenuComponent,
                    PopTabMenuSectionBarComponent
                ],
                exports: [
                    PopTabMenuComponent
                ],
                providers: [],
            },] }
];

class ErrorComponent {
    constructor(data, dialog, history) {
        this.data = data;
        this.dialog = dialog;
        this.history = history;
    }
    goBack() {
        this.history.goBack();
        this.dialog.close();
    }
}
ErrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-error',
                template: "<h1>Error: {{data.code}} - {{data.message}}</h1>\n<button mat-raised-button (click)=\"goBack()\">Go Back</button>\n"
            },] }
];
ErrorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef },
    { type: PopRouteHistoryResolver }
];

class PopErrorsComponent {
    constructor(dialog) {
        this.dialog = dialog;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.loadErrorDialog();
        }, 500);
    }
    loadErrorDialog() {
        this.dialog.open(ErrorComponent, { data: { code: this.error.code, message: this.error.message } });
    }
}
PopErrorsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-errors',
                template: "",
                styles: [""]
            },] }
];
PopErrorsComponent.ctorParameters = () => [
    { type: MatDialog }
];
PopErrorsComponent.propDecorators = {
    error: [{ type: Input }]
};

class PopErrorsModule {
}
PopErrorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopErrorsComponent,
                    ErrorComponent,
                ],
                imports: [MaterialModule],
                exports: [
                    PopErrorsComponent,
                ],
            },] }
];

class InDialogComponent extends PopExtendComponent {
    constructor(el, dialog, config) {
        super();
        this.el = el;
        this.dialog = dialog;
        this.config = config;
        this.events = new EventEmitter();
        this.http = 'POST';
        this.name = 'InDialogComponent';
        this.srv = {
            events: ServiceInjector.get(PopEntityEventService),
            request: ServiceInjector.get(PopRequestService),
            router: ServiceInjector.get(Router),
        };
        this.asset = {
            visible: 0
        };
        this.ui = {
            form: undefined
        };
        /**
         * This should transformValue and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                const fieldItems = {};
                this.dom.state.validated = false;
                if (!this.config.inDialog.submit)
                    this.config.inDialog.submit = 'Submit';
                this.config.fieldItems.map((field) => {
                    if (field.config && field.config.control) {
                        fieldItems[field.config.name] = field.config.control;
                        this.asset.visible++;
                    }
                });
                this.dom.setHeight(this.asset.visible * 40, 0);
                this.ui.form = new FormGroup(fieldItems);
                resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this._triggerFormValidation();
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Intercept the enter press to check if the form can be submitted
     * @param event
     */
    onEnterPress(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.dom.state.validated) {
            this.dom.setTimeout(`submit-form`, () => {
                return this.onFormSubmit();
            }, 500);
        }
    }
    /**
     * The user will press enter or click a submit btn to submit the form
     */
    onFormSubmit() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.dom.state.validated && !this.dom.state.pending) {
                this._onSubmissionStart();
                const params = this.ui.form.value; // get form value before disabling form
                // this.dom.asset.form_group.disable(); //bad idea disabled through css
                const request = this.http === 'POST' ? this.srv.request.doPost(this.config.inDialog.postUrl, params, (this.config.inDialog.postUrlVersion !== null ? this.config.inDialog.postUrlVersion : 1)) : this.srv.request.doPatch(this.config.inDialog.postUrl, params, (this.config.inDialog.postUrlVersion !== null ? this.config.inDialog.postUrlVersion : 1));
                request.subscribe((result) => __awaiter(this, void 0, void 0, function* () {
                    const goToUrl = this.config.inDialog.goToUrl;
                    result = result.data ? result.data : result;
                    this.config.entity = result;
                    yield this._onSubmissionSuccess();
                    this.dialog.close(this.config.entity);
                    if (IsString(goToUrl, true)) {
                        const newGoToUrl = ParseLinkUrl(String(goToUrl).slice(), this.config.entity);
                        this.srv.router.navigate([newGoToUrl]).catch((e) => {
                            console.log(e);
                        });
                    }
                    return resolve(true);
                }), err => {
                    this._onSubmissionFail();
                    this._setErrorMessage(err);
                    return resolve(false);
                });
            }
        }));
    }
    /**
     * The user can click a canel btn to close the form dialog
     */
    onFormCancel() {
        this.dom.state.loaded = false;
        this.dom.setTimeout(`close-modal`, () => {
            this.config.entity = null;
            this.dialog.close(-1);
        }, 500);
    }
    /**
     * Handle the form events to trigger the form validation
     * @param event
     */
    onBubbleEvent(event) {
        if (event.name === 'onKeyUp') {
            this.dom.state.validated = false;
            this.dom.setTimeout(`trigger-validation`, () => {
                this._triggerFormValidation();
            }, 500);
        }
        if (IsValidFieldPatchEvent(this.core, event) || event.name === 'onBlur') {
            this.dom.setTimeout(`trigger-validation`, () => {
                this._triggerFormValidation();
            }, 500);
        }
        else {
            // if a field is focused we want a chance to validate again
            // this.dom.state.validated = false;
        }
        // if( event.type === 'field' && event.name === 'onChange' ) event.form = this.ui.form;
        this.events.emit(event);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx will trigger the form validation
     * @private
     */
    _triggerFormValidation() {
        this.dom.setTimeout(`trigger-form-validation`, () => {
            this._validateForm().then((valid) => {
                this.dom.state.validated = valid;
            });
        }, 50);
    }
    /**
     * The form needs to able to make api calls to verify info for certain fields
     * ToDo:: Allow the config to be able to pass in api validation calls for certain fields
     * @private
     */
    _validateForm() {
        return new Promise((resolve) => {
            this.dom.state.validated = false;
            this.dom.setTimeout(`trigger-form-validation`, null);
            this.dom.setTimeout(`validate-form`, () => {
                this.ui.form.updateValueAndValidity();
                setTimeout(() => {
                    this.dom.state.validated = true; // mock stub for now
                    return resolve(this.ui.form.valid);
                }, 0);
            }, 0);
        });
    }
    /**
     * This hook is called when the form is submitting
     * @private
     */
    _onSubmissionStart() {
        this.dom.state.pending = true;
        this.dom.setTimeout(`submit-form`, null);
        this.dom.setTimeout(`trigger-validation`, null);
        this.dom.setTimeout(`trigger-form-validation`, null);
        this.dom.setTimeout(`validate-form`, null);
        this.dom.error.message = '';
        this.dom.setTimeout(`set-error`, null);
    }
    /**
     * This hook is called when the form submission has failed
     * @private
     */
    _onSubmissionFail() {
        this.dom.state.pending = false;
        // this.dom.state.validated = false;
    }
    /**
     * This hook is called when the form has submitted successfully
     * @private
     */
    _onSubmissionSuccess() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.state.pending = false;
            this.dom.state.validated = false;
            this.dom.state.success = (this.config.entity.message !== null ? this.config.entity.message : 'Created');
            const event = {
                source: this.name,
                method: 'create',
                type: 'entity',
                name: this.config.params.name,
                internal_name: this.config.params.internal_name,
                data: this.config.entity
            };
            if (IsCallableFunction(this.config.inDialog.callback)) {
                yield this.config.inDialog.callback(this.core, event);
            }
            this.srv.events.sendEvent(event);
            return resolve(true);
        }));
    }
    /**
     * This fx will handle errors
     * @param message
     * @private
     */
    _setErrorMessage(err) {
        this.dom.setTimeout(`set-err-msg`, () => {
            this.dom.state.pending = false;
            this.dom.error.message = GetHttpErrorMsg(err);
            this.ui.form.markAsPristine();
            // this.dom.setTimeout( `clear-err-msg`, () => {
            //   this.dom.error.message = '';
            // }, 5000 );
        }, 500);
    }
}
InDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-in-dialog',
                template: "<div *ngIf=\"dom.state.loaded\" [@slideInOut]>\n  <div class=\"in-dialog-title\" *ngIf=\"config.inDialog.title !== null\">{{config.inDialog.title}}</div>\n  <div class=\"in-dialog-fields\">\n    <form (keyup.enter)=\"onEnterPress($event);\" [formGroup]=\"ui.form\" [className]=\"dom.state.pending ? 'in-dialog-field-lock' : ''\">\n      <lib-group [ngClass]=\"{'in-dialog-disabled': dom.state.pending}\" [config]=\"config\" (events)=\"onBubbleEvent($event);\"></lib-group>\n    </form>\n  </div>\n  <div class=\"in-dialog-buttons\">\n    <button *ngIf=\"config.inDialog.cancel\" class=\"in-dialog-cancel\" mat-raised-button (click)=\"onFormCancel();\" [disabled]=\"dom.state.pending\">\n      Cancel\n    </button>\n    <button class=\"in-dialog-other\" mat-raised-button color=\"accent\" (click)=\"onFormSubmit()\" [disabled]=\"!dom.state.validated || dom.state.pending\">\n      <span *ngIf=\"!dom.state.pending\">{{config.inDialog.submit}}</span>\n      <div *ngIf=\"dom.state.pending\">\n        <mat-spinner diameter=\"20\"></mat-spinner>\n      </div>\n    </button>\n  </div>\n  <div class=\"in-dialog-message-layout\" *ngIf=\"dom.state.success || dom.error?.message\" [@slideInOut]>\n    <div *ngIf=\"dom.state.success\" class=\"in-dialog-success\">{{dom.state.success}}</div>\n    <div *ngIf=\"dom.error.message\" class=\"in-dialog-errors\" [innerHTML]=dom.error.message></div>\n  </div>\n</div>\n",
                animations: [
                    slideInOut
                ],
                styles: [":host{position:relative;display:block;min-width:350px}:host .in-dialog-title{font-weight:500;text-align:center;margin-bottom:10px}:host .in-dialog-fields{position:relative;display:block;width:100%;margin-bottom:10px}:host .in-dialog-fields .in-dialog-field{margin-bottom:10px}:host .in-dialog-fields .in-dialog-field-lock{pointer-events:none!important}:host .in-dialog-fields .in-dialog-field-spinner{position:absolute;left:50%;top:50%;margin-left:-22px;margin-top:-40px}:host .in-dialog-buttons{margin-top:20px;margin-bottom:10px;display:flex;justify-content:flex-end}:host .in-dialog-buttons .in-dialog-cancel{order:1;display:flex;align-items:center;justify-content:center;min-height:35px;min-width:140px}:host .in-dialog-buttons .in-dialog-other{order:2;display:flex;align-items:center;justify-content:center;margin-left:10px;min-width:140px;min-height:35px}:host .in-dialog-errors{color:var(--warn);text-align:center;word-break:break-word}:host .in-dialog-success{color:var(--success);text-align:center;word-break:break-word}:host .in-dialog-message-layout{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:center;text-align:center}:host .in-dialog-disabled{pointer-events:none}"]
            },] }
];
InDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: FieldItemGroupConfig, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
InDialogComponent.propDecorators = {
    events: [{ type: Output }],
    http: [{ type: Input }]
};

class GroupComponent extends PopExtendDynamicComponent {
    constructor(el) {
        super();
        this.el = el;
        this.subscribers = [];
        this.name = 'GroupComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                // Attach the container for of the field item list element
                this.template.attach('container'); // container references the @viewChild('container')
                this.core.entity = {
                    id: 0,
                    name: null
                };
                this.config.fieldItemMap = {};
                const fieldItemComponentList = [];
                this.config.fieldItems.map((fieldItem) => {
                    const existingValue = 'control' in fieldItem.config ? fieldItem.config.control.value : null;
                    this.core.entity[fieldItem.model.name] = existingValue;
                });
                this.config.fieldItems.map((fieldItem, index) => {
                    if (fieldItem && IsObject(fieldItem.model, ['name']) && fieldItem.config && fieldItem.component) {
                        this.config.fieldItemMap[fieldItem.model.name] = index;
                        if (this.config.inDialog)
                            fieldItem.config.bubble = true;
                        const component = {
                            type: fieldItem.component,
                            inputs: {
                                config: fieldItem.config,
                                position: fieldItem.config['metadata'].position ? fieldItem.config['metadata'].position : 1,
                                hidden: IsArray(fieldItem.model.when, true) ? !(EvaluateWhenCondition(this.core, fieldItem.model.when, this.core)) : false,
                                when: IsArray(fieldItem.model.when, true) ? fieldItem.model.when : null
                            }
                        };
                        fieldItemComponentList.push(component);
                    }
                });
                this.template.render(fieldItemComponentList, [], true);
                this.dom.handler.bubble = (core, event) => {
                    if (IsValidFieldPatchEvent(this.core, event)) {
                        if (event.config.name in this.core.entity) {
                            const newValue = isNaN(event.config.control.value) ? event.config.control.value : +event.config.control.value;
                            this.core.entity[event.config.name] = newValue;
                            if (this.config.fieldItems.length > 1) {
                                this._resetComponentListHidden();
                                this.dom.setTimeout(`update-relations`, () => {
                                    this._triggerParentChildUpdates(event.config.name);
                                }, 0);
                            }
                        }
                    }
                    if (event.config.bubble || ['patch', 'portal'].includes(event.name)) {
                        this.events.emit(event);
                    }
                };
                this.config.getField = (name) => {
                    if (name && name in this.config.fieldItemMap) {
                        return this.config.fieldItems[this.config.fieldItemMap[name]];
                    }
                    return null;
                };
                this.events.emit({ source: 'GroupComponent', type: 'field_group', name: 'init', id: this.config.id, group: this.config });
                resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setTimeout(`parent-child`, () => {
                    this._triggerParentChildUpdates('client_id');
                });
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        this.subscribers.map(function (subscription) {
            if (subscription)
                subscription.unsubscribe();
        });
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Get a linear list of the parent child relations from a given point
     * @param self the name to start from (usually the field that has just been changed by user)
     * @param list
     */
    _getRelationList(name, list = []) {
        let item;
        if (name && name in this.config.fieldItemMap) {
            item = this.config.fieldItems[this.config.fieldItemMap[name]];
            if (IsObject(item, ['config', 'model'])) {
                list.push({
                    name: item.config.name,
                    autoFill: this._fieldHasAutoFill(name),
                });
                if (this._fieldHasChild(name)) {
                    this._getRelationList(this.config.fieldItems[this.config.fieldItemMap[name]].model.options.child, list);
                }
            }
        }
        return list;
    }
    /**
     * Determine if field has a child relation in the list
     * @param name
     */
    _fieldHasChild(name) {
        if (name in this.config.fieldItemMap && this.config.fieldItems[this.config.fieldItemMap[name]].model && this.config.fieldItems[this.config.fieldItemMap[name]].model.options) {
            if (this.config.fieldItems[this.config.fieldItemMap[name]].model.options.child) {
                return true;
            }
        }
        return false;
    }
    /**
     * Determine if field should be auto filled with the first item in the list
     * @param name
     */
    _fieldHasAutoFill(name) {
        if (name in this.config.fieldItemMap && this.config.fieldItems[this.config.fieldItemMap[name]].model && this.config.fieldItems[this.config.fieldItemMap[name]].model.options) {
            if (this.config.fieldItems[this.config.fieldItemMap[name]].model.autoFill) {
                return true;
            }
        }
        return false;
    }
    _triggerParentChildUpdates(name) {
        console.log('triggerParentChildUpdates', name);
        if (this._fieldHasChild(name)) {
            let values;
            let child_fk;
            let childField;
            let autoFill = false;
            let set;
            let resource;
            const relations = this._getRelationList(name);
            // console.log('relations', relations);
            relations.some((relation) => {
                if (relation.autoFill) {
                    autoFill = true;
                    return true;
                }
            });
            if (name && name in this.config.fieldItemMap) {
                child_fk = this.config.fieldItems[this.config.fieldItemMap[name]].model.options.child;
                if (child_fk && child_fk in this.config.fieldItemMap) {
                    childField = this.config.fieldItems[this.config.fieldItemMap[child_fk]];
                    // console.log('child field', childField);
                    if (childField.model.form === 'select') {
                        if (childField.model.options.resource) {
                            // console.log('has resource', childField.model.options.resource, this.config.metadata[ childField.model.options.resource ]);
                            if (IsObject(this.config.metadata[childField.model.options.resource], ['data_values'])) {
                                resource = this.config.metadata[childField.model.options.resource].data_values;
                            }
                        }
                        // console.log('resource', resource);
                        if (IsArray(resource, true)) {
                            values = ConvertArrayToOptionList(resource, {
                                // ensure that an option shows up in list in case other conditions remove it, aka it has been archived
                                prevent: [],
                                // parent means this options should all have a common field trait like client_fk, account_fk ....
                                parent: childField.model.options.parent ? {
                                    field: childField.model.options.parent,
                                    value: this.core.entity[childField.model.options.parent]
                                } : null,
                                empty: childField.model.options.empty ? childField.model.options.empty : null,
                            });
                        }
                        else {
                            values = [];
                        }
                        // console.log('values', values);
                        if (autoFill && values.length) {
                            set = values[values.length - 1].value;
                        }
                        else {
                            set = null;
                        }
                        childField.config.options.values = values;
                        autoFill = autoFill && values.length ? values[0].value : null;
                        if (typeof childField.config.triggerOnChange === 'function')
                            childField.config.triggerOnChange(set);
                        this.dom.setTimeout(`clear-message-${child_fk}`, () => {
                            if (typeof childField.config.clearMessage === 'function') {
                                childField.config.clearMessage();
                            }
                        }, 0);
                    }
                }
            }
        }
    }
    /**
     * Whenever a update to the core entity happens the fields in the group should be re-evaluated if there are when conditionals set
     * @private
     */
    _resetComponentListHidden() {
        //     console.log('_resetComponentListHidden', this.template.refs);
        let name;
        this.template.refs.filter((componentRef) => {
            return IsObject(componentRef.instance.config, true) && IsArray(componentRef.instance.when, true);
        }).map((componentRef) => {
            name = componentRef.instance.config.name;
            if (name && name in this.config.fieldItemMap) {
                componentRef.instance.hidden = !EvaluateWhenCondition(this.core, componentRef.instance.when, this.core);
            }
        });
    }
}
GroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-group',
                template: "<div class=\"field-group-container import-flex-column\">\n  <template #container></template>\n  <div style=\"width: 100%; display: block; clear:both;\"></div>\n</div>\n\n",
                styles: [".field-group-container{position:relative;display:block;min-height:40px;padding-bottom:15px}"]
            },] }
];
GroupComponent.ctorParameters = () => [
    { type: ElementRef }
];
GroupComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    config: [{ type: Input }]
};

class PopContextMenuComponent {
    constructor() {
    }
    ngOnInit() {
        this.config.toggle.subscribe(active => {
            if (active)
                this.trigger.openMenu();
            if (!active)
                this.trigger.closeMenu();
        });
    }
    onMenuClick(option) {
        if (option.type === 'new_tab')
            window.open(option.url, '_blank');
        if (option.type === 'portal')
            this.config.emitter.emit({
                source: 'PopContextMenuComponent',
                type: 'context_menu',
                name: 'portal',
                open: true,
                internal_name: option.metadata.internal_name,
                id: option.metadata.id,
                option: option
            });
    }
}
PopContextMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-context-menu',
                template: "<mat-menu #menu=\"matMenu\" >\n    <button *ngFor=\"let option of config.options\" mat-menu-item (click)=\"onMenuClick(option)\">\n        {{option.label}}\n    </button>\n</mat-menu>\n\n<div class=\"pcm-trigger-button\" [matMenuTriggerFor]=\"menu\" [ngStyle]=\"{'left.px': config.x, 'top.px': config.y}\" ></div>",
                styles: [".pcm-trigger-button{position:fixed}"]
            },] }
];
PopContextMenuComponent.ctorParameters = () => [];
PopContextMenuComponent.propDecorators = {
    config: [{ type: Input }],
    trigger: [{ type: ViewChild, args: [MatMenuTrigger, { static: true },] }]
};

class PopContextMenuModule {
}
PopContextMenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopContextMenuComponent
                ],
                imports: [
                    MaterialModule,
                    CommonModule
                ],
                exports: [
                    PopContextMenuComponent
                ],
            },] }
];

class CharacterIconPipe {
    transform(name) {
        let character_icon = "";
        const nameArray = name.split(" ");
        if (nameArray.length >= 2) {
            character_icon += nameArray[0].charAt(0).toLocaleUpperCase();
            character_icon += nameArray[1].charAt(0).toLocaleUpperCase();
        }
        else {
            character_icon += name.charAt(0).toLocaleUpperCase();
            character_icon += name.charAt(1).toLocaleLowerCase();
        }
        return (character_icon);
    }
}
CharacterIconPipe.decorators = [
    { type: Pipe, args: [{ name: 'characterIcon', pure: true },] }
];

class PopSideBySideModule {
}
PopSideBySideModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopSideBySideComponent,
                    CharacterIconPipe
                ],
                imports: [
                    CommonModule,
                    MaterialModule,
                    RouterModule,
                    PopFieldItemModule,
                    PopIndicatorsModule,
                    PopContextMenuModule,
                ],
                exports: [
                    PopSideBySideComponent
                ]
            },] }
];

class PopFieldItemGroupComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.close = new EventEmitter();
        this.name = 'PopFieldItemGroupComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
        };
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                resolve(true);
            });
        };
    }
    /**
     * This component will take a list of field item configs and render them in a column list
     */
    ngOnInit() {
        super.ngOnInit();
    }
    ngAfterViewInit() {
        if (this.config.inDialog) {
            this.dom.setTimeout(`load-modal`, () => {
                this._loadGroupInDialogBox();
            }, 0);
        }
    }
    /**
     * This fx will bubble events up the pipeline
     * @param event
     */
    onBubbleEvent(event) {
        this.events.emit(event);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This fx will load the field item list in a dialog modal, this is for typically for creating entities and such actions.
     * This will allow all the fields items to be placed in an angular form so all the data can be validated collectively.
     * @private
     */
    _loadGroupInDialogBox() {
        const dialogBox = this.srv.dialog.open(InDialogComponent, {
            data: this.config,
            disableClose: true
        });
        dialogBox.componentInstance['http'] = this.config.http;
        dialogBox.componentInstance['debug'] = this.config.debug;
        dialogBox.componentInstance.events.subscribe((event) => {
            event.group = this.config;
            this.events.emit(event);
        });
        dialogBox.afterClosed().subscribe((result) => {
            this.close.emit(result);
        });
    }
}
PopFieldItemGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-item-group',
                template: '<lib-group *ngIf="config && config.inDialog === null"  (events)="onBubbleEvent($event);" [config]=config></lib-group>'
            },] }
];
PopFieldItemGroupComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopFieldItemGroupComponent.propDecorators = {
    config: [{ type: Input }],
    close: [{ type: Output }]
};

class PopFieldItemGroupModule {
}
PopFieldItemGroupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopFieldItemGroupComponent,
                    InDialogComponent,
                    GroupComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    PopIndicatorsModule,
                    PopFieldItemModule,
                    PopSideBySideModule,
                ],
                exports: [
                    PopFieldItemGroupComponent,
                ],
            },] }
];

class PopCommonService {
    constructor() {
        this.name = 'PopCommonService';
    }
    arrayContainsAll(needles, haystack, strict = false) {
        return ArrayContainsAll(needles, haystack, strict);
    }
    // function for dynamic sorting an array of objects.
    // - Usage: someArray.sort(dynamicSort('key'));
    // @param key: The name of the key in each object to sort on.
    // @param order: asc (Ascending) or desc (Descending)
    // @return: sorted array.
    dynamicSort(key, order = 'asc') {
        return DynamicSort(key, order);
    }
    /**
     * Sorts on sort
     * @param a
     * @param b
     * returns int
     */
    sortBySort(a, b) {
        if (a.sort < b.sort)
            return -1;
        if (a.sort > b.sort)
            return 1;
        return 0;
    }
    /**
     * Sorts on name field
     * @param a
     * @param b
     * returns int
     */
    sortByName(a, b) {
        if (a.name < b.name)
            return -1;
        if (a.name > b.name)
            return 1;
        return 0;
    }
    /**
     * Sorts on position field
     * @param a
     * @param b
     * returns int
     */
    sortByPosition(a, b) {
        if (+a.position < +b.position)
            return -1;
        if (+a.position > +b.position)
            return 1;
        return 0;
    }
    /**
     * Sorts on entityId field
     * @param a
     * @param b
     * returns int
     */
    sortById(a, b) {
        if (a.id < b.id)
            return -1;
        if (a.id > b.id)
            return 1;
        return 0;
    }
    /**
     * Checks if two arrays match
     *
     * @param arr1
     * @param arr2
     * @param field -optional
     *
     * - if field is passed - check to see if the field is the same in both arrays
     *
     * @returns boolean
     */
    arraysMatch(arr1, arr2, field) {
        return ArraysMatch(arr1, arr2, field);
    }
    /**
     * Convert an object into an array
     * @param obj
     * @returns array
     */
    toArray(obj) {
        return ToArray(obj);
    }
    /**
     * A helper function to determine if a variable is numreric
     * @param value
     */
    isNumber(value, requireTruthy) {
        return IsNumber(value, requireTruthy);
    }
    isArray(arr, requireLength = false) {
        return IsArray(arr, requireLength);
    }
    /**
     * A helper function to determine if a variable is a qualified object
     *
     * @param value
     * @param requireKeys
     * @param throwError
     */
    isObject(value, requireKeys = false) {
        return IsObject(value, requireKeys);
    }
    /**
     *
     * A helper function to determine if a variable is a qualified string
     * @param value
     * @param requireLength
     * @param throwError
     */
    isString(value, requireLength = false) {
        return IsString(value, requireLength);
    }
    /**
     * Helper method to remove duplicate items from a  flat array [1,2,3,1,1], [['a','b','c','a']
     * @param arr
     */
    onlyArrayUnique(arr) {
        return ArrayOnlyUnique(arr);
    }
    /**
     * Helper method to remove duplicate objects in an array that share a specific property [{entityId:1, ...},{entityId:2, ...},{entityId:3, ...},{entityId:1, ...}, ]
     * @param arr
     */
    removeArrayDuplicates(array, prop) {
        return array.filter((obj, pos, arr) => {
            return arr.map(mapObj => mapObj[prop]).indexOf(obj[prop]) === pos;
        });
    }
    /**
     * Map an array by a array key field
     * @param obj
     * @returns array
     */
    mapArrayWithKey(array, array_key_field) {
        return ArrayMapSetter(array, array_key_field);
    }
    /**
     * Convert an Array to Object
     * @param arr
     * @returns Object
     */
    toObject(arr) {
        return ToObject(arr);
    }
    /**
     * Convert an Array of objects  to Dictionary(object)
     * @param arr
     * @returns Object
     */
    toDictionary(arr, key) {
        const dictionary = {};
        if (arr && Array.isArray(arr) && arr.length) {
            arr.map((item) => {
                if (typeof item[key] !== undefined)
                    dictionary[item[key]] = item;
            });
        }
        return dictionary;
    }
    toUri(obj) {
        return ConvertObjectToUri(obj);
    }
    /**
     * Capitalize the first Letter of every word in a string
     * @param str
     * @returns str
     */
    toTitleCase(str) {
        return TitleCase(str);
    }
    /**
     * Convert a date to yyyy:mm:dd 00:00:00
     * @param value date
     */
    dateTimeFormat(value) {
        return ConvertDateToDateTimeFormat(value);
    }
    /**
     * Convert a date to yyyy:mm:dd
     * @param value date
     */
    dateFormat(value, format = 'yyyy-mm-dd') {
        return ConvertDateFormat(value, format);
    }
    today(format = 'yyyy-mm-dd') {
        const today = new Date();
        const dd = String(today.getDate()).padStart(2, '0');
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const yyyy = today.getFullYear();
        return this.dateFormat(mm + '/' + dd + '/' + yyyy);
    }
    addDays(date, days) {
        const copy = new Date(Number(date));
        copy.setDate(date.getDate() + days);
        return copy;
    }
    /**
     * Replace all occurrences of an sequence within a string
     * @param str
     * @param find
     * @param replace
     */
    replaceAll(str, find, replace) {
        return StringReplaceAll(str, find, replace);
    }
    /**
     * Convert a string from snake case to Pascal Case
     * @param field
     * @returns string
     */
    snakeToPascal(field) {
        return SnakeToPascal(field);
    }
    /**
     * Convert a string with hyphens to Pascal Case
     * @param field
     * @returns string
     */
    hyphenToPascal(field) {
        return HyphenToPascal(field);
    }
    /**
     * Convert a string with spaces to snake case .. 'this is snake case' to 'this_is_snake_case'
     * @param field
     * @returns string
     */
    spaceToSnake(pascal) {
        return SpaceToSnake(pascal);
    }
    /**
     * A complex fuzzy search to determine if an object's values contains a series of filter "tags"
     * @param object obj: The Object that you want to see if the fieldItems match the filter
     * @param string tags: The filter string you want to match against obj.
     *                       Uses (!)not, (&)and, (,)or syntax for complex chaining.
     *                       example: 'john' returns true if a field value contains 'john'
     *                       example: 'john,jane,doe' returns true if a field value contains any of the values
     *                       example: 'john&doe' returns true only if obj contains 'john' and  contains 'doe'
     *                       example: 'john,!doe' returns true only if obj contains 'john' and does not contain 'doe'
     *
     *
     * @returns boolean
     */
    hasFilter(obj, tags) {
        return ObjectContainsTagSearch(obj, tags);
    }
    deepCopy(obj) {
        return DeepCopy(obj);
    }
    getHttpErrorMsg(err) {
        return GetHttpErrorMsg(err);
    }
    getStoragePath(storage, steps, defaultValue = null) {
        return StorageGetter(storage, steps, defaultValue);
    }
    uid() {
        return PopUid();
    }
}
PopCommonService.prov = i0.defineInjectable({ factory: function PopCommonService_Factory() { return new PopCommonService(); }, token: PopCommonService, providedIn: "root" });
PopCommonService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class PopTableDialogComponent {
    constructor(tableDialogRef, cs, ds, data) {
        this.tableDialogRef = tableDialogRef;
        this.cs = cs;
        this.ds = ds;
        this.data = data;
        this.dom = {
            state: {},
            asset: {},
            height: {
                outer: null,
                inner: null,
                default: null
            }
        };
        this.options = data.options;
    }
    ngOnInit() {
        this.dom.height.outer = window.innerHeight - 300;
        this.dom.height.inner = this.dom.height.outer - 150;
        this.buildToggles();
        this.buildColumns();
        this.buildLockedColumns();
        this.lockedColumns.control.valueChanges.subscribe((value) => this.updateLockedColumns(value));
    }
    buildLockedColumns() {
        let lockedColumns = 0;
        this.columns.forEach((col, index) => {
            if (col.sticky === true) {
                lockedColumns = ++index;
            }
        });
        this.lockedColumns = new SelectConfig({
            label: 'Locked columns',
            options: {
                values: [
                    { value: 0, name: 'No columns locked' },
                    { value: 1, name: 'Lock first column' },
                    { value: 2, name: 'Lock first 2 columns' },
                    { value: 3, name: 'Lock first 3 columns' },
                ]
            },
            value: lockedColumns
        });
    }
    updateLockedColumns(value) {
        this.clearColSticky();
        if (value > 0) {
            this.updateStickyColumns(value);
        }
    }
    clearColSticky() {
        this.columns.forEach(col => col.sticky = false);
    }
    updateStickyColumns(value) {
        this.columns.forEach((col, index) => {
            if (index < value) {
                col.sticky = true;
            }
        });
    }
    handleInputEvents(event) {
        console.log('event', event);
    }
    buildToggles() {
        this.toggles = {
            allowColumnSearchToggle: new SwitchConfig({
                bubble: true,
                label: 'Column Search',
                value: this.options.currentOptions.searchColumns,
                metadata: { option: 'searchColumns' }
            }),
            allowColumnSortToggle: new SwitchConfig({
                bubble: true,
                label: 'Column Sort',
                value: this.options.currentOptions.sort,
                metadata: { option: 'sort' }
            }),
            allowHeaderStickyToggle: new SwitchConfig({
                bubble: true,
                label: 'Sticky Header',
                value: this.options.currentOptions.headerSticky,
                metadata: { option: 'headerSticky' }
            }),
            allowHeaderDisplayToggle: new SwitchConfig({
                bubble: true,
                label: 'Display Header',
                value: this.options.currentOptions.headerDisplay,
                metadata: { option: 'headerDisplay' }
            }),
            allowPaginatorToggle: new SwitchConfig({
                bubble: true,
                label: 'Pagination',
                value: this.options.currentOptions.paginator,
                metadata: { option: 'paginator' }
            }),
        };
    }
    setAllShow(checked) {
        this.columns.map(c => c.visible = checked);
    }
    buildColumns() {
        // Display column order: Current order of visible items then alphabetized list of non visible items.
        const currentColumns = [];
        const otherColumns = [];
        // Account for current column def set.
        for (const col in this.options.currentOptions.columnDefinitions) {
            this.options.currentOptions.columnDefinitions[col].display = this.ds.set(col, this.options.currentOptions.columnDefinitions[col]);
            if (!this.options.currentOptions.columnDefinitions[col].name)
                this.options.currentOptions.columnDefinitions[col].name = col;
            if (this.options.currentOptions.columnDefinitions[col].visible) {
                currentColumns.push(this.options.currentOptions.columnDefinitions[col]);
            }
            else {
                otherColumns.push(this.options.currentOptions.columnDefinitions[col]);
            }
            // If this column has a checkbox then account for it in the list.
            if (this.options.currentOptions.columnDefinitions[col].checkbox) {
                if (this.options.currentOptions.columnDefinitions[col].checkbox.visible) {
                    currentColumns.push(Object.assign({ name: col + '_checkbox', ref: col, display: this.ds.set(col + '_checkbox') }, this.options.currentOptions.columnDefinitions[col].checkbox));
                }
                else {
                    otherColumns.push(Object.assign({ name: col + '_checkbox', ref: col, display: this.ds.set(col + '_checkbox') }, this.options.currentOptions.columnDefinitions[col].checkbox));
                }
            }
            // Remove from columns so we don't have duplicates.
            if (this.options.columns.indexOf(col) !== -1)
                this.options.columns.splice(this.options.columns.indexOf(col), 1);
        }
        // Account for other columns in the dataset.
        if (!otherColumns.length) {
            for (const col of this.options.columns) {
                otherColumns.push({ name: col, display: this.ds.set(col), visible: false, sticky: false, sort: 0 });
            }
        }
        // Sort current columns by their sort number and sort other columns by their name.
        currentColumns.sort(this.cs.dynamicSort('sort'));
        otherColumns.sort(this.cs.dynamicSort('name'));
        // Update the sort to reflect the new order.
        let order = 0;
        for (const col of currentColumns)
            col.sort = ++order;
        for (const col of otherColumns)
            col.sort = ++order;
        this.columns = [...currentColumns, ...otherColumns];
    }
    handleToggleEvents(event) {
        if (event.name === 'onChange') {
            const option = event.config.metadata.option;
            const value = event.config.control.value;
            this.options.currentOptions[event.config.metadata.option] = event.config.control.value;
            switch (option) {
                case 'headerDisplay':
                    if (!value) {
                        this.options.currentOptions.sort = false;
                        this.toggles.allowColumnSortToggle.switchRef.checked = false;
                        this.toggles.allowColumnSortToggle.control.setValue(false);
                        this.toggles.allowHeaderStickyToggle.switchRef.checked = false;
                        this.toggles.allowHeaderStickyToggle.control.setValue(false);
                        this.options.currentOptions.headerSticky = false;
                        this.toggles.allowColumnSearchToggle.switchRef.checked = false;
                        this.toggles.allowColumnSearchToggle.control.setValue(false);
                        this.options.currentOptions.searchColumns = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    onSave() {
        // Set our order to be the same as the index in the array.
        let order = 0;
        for (const col of this.columns)
            col.sort = ++order;
        // Build the column definitions based on user selection.
        const columnDefinitions = {};
        for (const col of this.columns) {
            if (col.ref)
                continue; // Ignore checkboxes for now as they belong under a specific field.
            columnDefinitions[col.name] = {
                display: col.display,
                helper: (col.helper ? col.helper : null),
                icon: (col.icon ? col.icon : null),
                sort: col.sort,
                route: (col.route ? col.route : null),
                sticky: col.sticky,
                visible: col.visible,
            };
        }
        // Account for checkboxes
        for (const col of this.columns) {
            if (!col.ref)
                continue;
            columnDefinitions[col.ref] = Object.assign(Object.assign({}, columnDefinitions[col.ref]), { checkbox: { sort: col.sort, sticky: col.sticky, visible: col.visible } });
        }
        this.options.currentOptions.columnDefinitions = columnDefinitions;
        this.tableDialogRef.close({ type: 'save', options: this.options });
    }
    onResetToDefault() {
        this.tableDialogRef.close({ type: 'reset', options: this.options });
    }
    onCancel() {
        this.tableDialogRef.close({ type: 'cancel', options: this.options });
    }
    drop(event) {
        moveItemInArray(this.columns, event.previousIndex, event.currentIndex);
    }
    ngOnDestroy() {
    }
}
PopTableDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-dialog',
                template: "<div>\n  <div>\n    <span class=\"mat-h3\">Settings</span>\n\n    <div class=\"options-container\">\n      <div class=\"options-column\">\n        <div class=\"dialog-option\" *ngIf=\"options.allowHeaderDisplayToggle\">\n          <lib-pop-switch [config]=\"toggles?.allowHeaderDisplayToggle\"\n                          (events)=\"handleToggleEvents($event)\"></lib-pop-switch>\n        </div>\n\n        <div class=\"dialog-option\" *ngIf=\"options.allowColumnSearchToggle && toggles.allowColumnSearchToggle\"\n             [hidden]=\"!this.options.currentOptions.headerDisplay\">\n          <lib-pop-switch [config]=\"toggles?.allowColumnSearchToggle\"\n                          (events)=\"handleToggleEvents($event)\"></lib-pop-switch>\n        </div>\n\n\n        <div class=\"dialog-option\" *ngIf=\"options.allowColumnSortToggle\"\n             [hidden]=\"!this.options.currentOptions.headerDisplay\">\n          <lib-pop-switch [config]=\"toggles.allowColumnSortToggle\"\n                          (events)=\"handleToggleEvents($event)\"></lib-pop-switch>\n        </div>\n\n\n        <div class=\"dialog-option\" *ngIf=\"options.allowHeaderStickyToggle\"\n             [hidden]=\"!this.options.currentOptions.headerDisplay\">\n          <lib-pop-switch [config]=\"toggles.allowHeaderStickyToggle\"\n                          (events)=\"handleToggleEvents($event)\"></lib-pop-switch>\n        </div>\n\n\n      </div>\n      <div style=\"flex: 1 1 auto;\"></div>\n      <div >\n        <div class=\"dialog-option\" style=\"overflow:hidden\">\n          <button class=\"dialog-button\" mat-raised-button (click)=\"onResetToDefault()\" style=\"float: right\">Reset to Default</button>\n        </div>\n        <div  class=\"dialog-option\" style=\"width: 175px;\" *ngIf=\"options.allowColumnStickyToggle\">\n          <lib-pop-select [config]=\"lockedColumns\" (events)=\"handleInputEvents($event)\"></lib-pop-select>\n        </div>\n      </div>\n    </div>\n\n\n    <div class=\"dialog-container\" [style.maxHeight.px]=dom.height.outer>\n      <div class=\"dialog-options\" [style.minHeight.px]=dom.height.inner>\n        <div class=\"dialog-draggable-header\">\n          <div class=\"dialog-draggable-show\">\n            <mat-checkbox (change)=\"setAllShow($event.checked)\" color=\"accent\"></mat-checkbox>\n          </div>\n          <div class=\"dialog-draggable-name\">Column Label</div>\n\n          <!--          <div class=\"dialog-draggable-sticky\">Sticky</div>-->\n          <div class=\"dialog-draggable-handle\"></div>\n        </div>\n\n        <div cdkDropList class=\"dialog-draggable-columns\" [style.maxHeight.px]=dom.height.inner\n             (cdkDropListDropped)=\"drop($event)\">\n          <div class=\"dialog-draggable-column\" *ngFor=\"let col of columns\" cdkDrag cdkDragLockAxis=\"y\"\n               cdkDragBoundary=\".dialog-draggable-columns\">\n            <mat-checkbox class=\"dialog-draggable-show\" [(ngModel)]=\"col.visible\" color=\"accent\"></mat-checkbox>\n            <div class=\"dialog-draggable-name\">{{col.display}}</div>\n\n            <!--            <mat-checkbox class=\"dialog-draggable-sticky\" [(ngModel)]=\"col.sticky\" color=\"accent\" disabled=\"true\"-->\n            <!--                          *ngIf=\"!options.allowColumnStickyToggle\"></mat-checkbox>-->\n            <!--            <mat-checkbox class=\"dialog-draggable-sticky\" [(ngModel)]=\"col.sticky\" color=\"accent\"-->\n            <!--                          *ngIf=\"options.allowColumnStickyToggle\"></mat-checkbox>-->\n            <mat-icon class=\"dialog-draggable-handle\" cdkDragHandle>drag_handle</mat-icon>\n          </div>\n        </div>\n      </div>\n      <!--      <div class=\"dialog-options\" [style.minHeight.px]=dom.height.inner>-->\n      <!--        &lt;!&ndash; Display Header Option &ndash;&gt;-->\n\n\n      <!--        &lt;!&ndash;Paginator Option &ndash;&gt;-->\n      <!--        &lt;!&ndash;<div class=\"pop-table-dialog-option\" *ngIf=\"options.allowPaginatorToggle\">&ndash;&gt;-->\n      <!--        &lt;!&ndash;<lib-pop-switch [config]=\"toggles.allowPaginatorToggle\" (events)=\"handleToggleEvents($event)\"></lib-pop-switch>&ndash;&gt;-->\n      <!--        &lt;!&ndash;</div>&ndash;&gt;-->\n      <!--      </div>-->\n      <!--    </div>-->\n\n    </div>\n    <div class=\"dialog-buttons\">\n      <button class=\"dialog-button\" mat-raised-button (click)=\"onCancel()\">Cancel</button>\n\n      <button class=\"dialog-button\" mat-raised-button (click)=\"onSave()\" color=\"accent\">Save</button>\n    </div>\n\n  </div>\n\n</div>\n",
                styles: [".options-container{display:flex;padding-bottom:var(--gap-m)}.dialog-container{display:flex;flex-direction:row;min-width:800px;min-height:300px;overflow:hidden}.dialog-options{flex:1 1 100%;flex-direction:column;min-height:300px;margin:5px}.dialog-option{margin-top:3px;padding:2px}.dialog-draggable-header{display:flex;flex-direction:row;justify-content:space-between;flex-wrap:nowrap;max-height:20px!important;border:1px solid var(--border);padding:15px 5px!important;align-items:center;background-color:var(--tableheader)}.dialog-draggable-columns{display:flex;flex-direction:column;overflow-y:auto;overflow-x:hidden;min-height:300px;max-height:calc(100vh - 300px)}.dialog-draggable-column{display:flex;flex-direction:row;justify-content:space-between;flex-wrap:nowrap;max-height:20px!important;border:1px solid var(--border);padding:15px 5px!important;align-items:center;background-color:var(--bg-3)}.dialog-draggable-name{flex-grow:5;padding-left:10px}.dialog-draggable-show{padding-left:var(--gap-s)}.dialog-draggable-sticky{width:50px}.dialog-draggable-handle{width:25px;text-align:right}.dialog-draggable-handle:hover{cursor:-webkit-grab;cursor:grab}.dialog-draggable-handle:active{cursor:grabbing;cursor:-webkit-grabbing;cursor:-moz-grabbing}.dialog-buttons{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:flex-end;margin-top:20px}.dialog-button{margin-left:10px}.dialog-cancel{margin-left:-10px;display:flex;flex-grow:2}"]
            },] }
];
PopTableDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: PopCommonService },
    { type: PopDisplayService },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class PopTableComponent extends PopExtendComponent {
    /**
     * @param el
     * @param cdr
     * @param _baseRepo
     * @param _dialogRepo
     * @param _domRepo
     * @param _routerRepo
     * @param _pipeRepo
     */
    constructor(el, cdr, _baseRepo, _dialogRepo, _domRepo, _routerRepo, _pipeRepo) {
        super();
        this.el = el;
        this.cdr = cdr;
        this._baseRepo = _baseRepo;
        this._dialogRepo = _dialogRepo;
        this._domRepo = _domRepo;
        this._routerRepo = _routerRepo;
        this._pipeRepo = _pipeRepo;
        this.name = 'PopTableComponent';
        this.srv = {
            base: undefined,
            dialog: undefined,
            router: undefined,
            pipe: undefined,
        };
        this.asset = {
            data: undefined,
            filter: {
                column: {},
                predicate: undefined,
                search: undefined
            }
        };
        /**
         * Configure the specifics of this component
         */
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([
                    this._setInitialConfig(),
                    this._setHeight(),
                    this._updateButtonControl(),
                    this._attachPaginator(),
                    this._handleConfigEvents(),
                    this._setConfigHooks(),
                    this._initSearchFilter(),
                    this._configureTable() // Prep the table for display.
                ]);
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this._setFilterPredicate(this.dom.session.searchValue); // Set up the filter predicates to use with this table
                return resolve(true);
            }));
        };
    }
    /**
     * This component should have a purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The table will generate a slew of action and event triggers that need passed up the chain
     * @param name
     * @param event
     */
    onBubbleEvent(name, event) {
        // All selections of table rows should come through here so _update the buttonControls.
        const tableEvent = {
            source: this.name,
            type: 'table',
            name: name,
            data: event,
            metadata: this.config.metadata
        };
        this.log.event(`onBubbleEvent`, tableEvent);
        // We want a copy being emitted not the actual objects.
        this.events.emit(JSON.parse(JSON.stringify(tableEvent)));
    }
    /**
     * This will apply the search value that the user enters behind a debouncer
     * @param searchValue
     * @param col
     */
    onApplySearchValue(searchValue, col) {
        this.dom.setTimeout('apply-search', () => {
            this.asset.filter.search(searchValue, col);
            this.onBubbleEvent('search', searchValue);
        }, 250);
    }
    /**
     * The user can click on a button to edit their preferences for this table in a modal
     */
    onEditTablePreferencesClick() {
        // Get a copy of the current options.
        const searchColumns = this.config.searchColumns;
        const options = JSON.parse(JSON.stringify(this.config.options));
        // Defaults and allowables should be set by the coder but if not they will use the TableOptionsConfig defaults.
        // But we still need to set the current options.
        options.currentOptions = {
            columnDefinitions: this.config.columnDefinitions,
            headerDisplay: this.config.headerDisplay,
            headerSticky: this.config.headerSticky,
            paginator: this.config.paginator,
            search: this.config.search,
            searchColumns: this.config.searchColumns,
            sort: this.config.sort,
        };
        // If the coder didn't pass into options the available columns then get a list of all possible columns from the data.
        if (!options.columns.length && this.asset.data && this.asset.data[0]) {
            for (const col in this.asset.data[0]) {
                if (!this.asset.data[0].hasOwnProperty(col))
                    continue;
                if (IsString(this.asset.data[0][col]) || IsNumber(this.asset.data[0][col])) {
                    options.columns.push(col);
                }
            }
        }
        this.onBubbleEvent('options_open', options);
        const dialogRef = this.srv.dialog.open(PopTableDialogComponent, {
            data: { options: options }
        });
        dialogRef.afterClosed().subscribe(dialog => {
            if (dialog) {
                console.log('here', dialog);
                if (dialog.type === 'save') {
                    this.dom.refreshing();
                    try {
                        this.cdr.detectChanges();
                    }
                    catch (e) {
                    }
                    const newOptions = JSON.parse(JSON.stringify(dialog.options));
                    this.onBubbleEvent('options_save', newOptions);
                    // Build a new config object instead of updating the old one so that Angular's change detection will auto _update the view.
                    // - Certain things (column sort / search) wont auto-_update otherwise.
                    // - Requires the updating of the column defs in the setTimeout.
                    // - Might be an Angular bug: https://github.com/angular/material2/issues/13030
                    this.config.headerDisplay = newOptions.currentOptions.headerDisplay;
                    this.config.headerSticky = newOptions.currentOptions.headerSticky;
                    this.config.paginator = newOptions.currentOptions.paginator;
                    this.config.searchColumns = newOptions.currentOptions.searchColumns;
                    this.config.sort = newOptions.currentOptions.sort;
                    this.config.updateColumnDefinitions(newOptions.currentOptions.columnDefinitions);
                    if (searchColumns !== this.config.searchColumns)
                        this._setFilterPredicate();
                    try {
                        this.cdr.detectChanges();
                    }
                    catch (e) {
                    }
                    this._resetTable();
                }
                else if (dialog.type === 'reset') {
                    this.dom.refreshing();
                    try {
                        this.cdr.detectChanges();
                    }
                    catch (e) {
                    }
                    // Build a new config object instead of updating the old one so that Angular's change detection will auto _update the view.
                    // - Certain things (column sort / search) wont auto-_update otherwise.
                    // - Requires the updating of the column defs in the setTimeout.
                    // - Might be an Angular bug: https://github.com/angular/material2/issues/13030
                    this.onBubbleEvent('options_reset', dialog.options);
                    this.config.headerDisplay = this.config.options.defaultOptions.headerDisplay;
                    this.config.headerSticky = this.config.options.defaultOptions.headerSticky;
                    // this.config.paginator = this.config.options.defaultOptions.paginator;
                    this.config.searchColumns = this.config.options.defaultOptions.searchColumns;
                    this.config.sort = this.config.options.defaultOptions.sort;
                    this.config.dealWithAngularChangeDetectionFailure = false;
                    const columnDefinitions = JSON.parse(JSON.stringify(dialog.options.defaultOptions.columnDefinitions));
                    this.config.updateColumnDefinitions(columnDefinitions);
                    if (searchColumns !== this.config.searchColumns)
                        this._setFilterPredicate();
                    try {
                        this.cdr.detectChanges();
                    }
                    catch (e) {
                    }
                    this._resetTable();
                }
                else if (dialog.type === 'cancel') {
                    this.onBubbleEvent('options_cancel', {});
                }
            }
            else {
                this.onBubbleEvent('options_cancel', {});
            }
        });
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                      *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Setup an intial config for this component here
     * @private
     */
    _setInitialConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Ensure config
            this.config = IsObjectThrowError(this.config, true, `${this.name}:configure: - this.config`) ? this.config : null;
            // Set a data container to hold raw data
            this.asset.data = [];
            if (IsDefined(this.config.id))
                this.id = this.config.id;
            return resolve(true);
        }));
    }
    /**
     * Handle table events
     * @param event
     */
    _onTableEvent(event) {
        let goToUrl;
        let routeApp;
        if (event.type === 'table') {
            switch (event.name) {
                case 'columnStandardClick':
                    // If global route was set then let the table handle the routing else emit the event.
                    if (this.config.route) {
                        goToUrl = this._parseGoToUrl(this.config.route, event.data.row);
                        routeApp = String(goToUrl).split('/');
                        if (routeApp[1] && routeApp[1] === PopHref) {
                            // Since we are in the same app then use Angular to route.
                            const route = routeApp.slice(2).join('/');
                            this.srv.router.navigate([route]).catch((e) => {
                                PopTemplate.error({ message: `Invalid Client Route: ${route}`, code: 500 });
                                console.log(e);
                            });
                        }
                        else {
                            // do a hard reload if we aren't.
                            SetSiteVar('redirect', goToUrl);
                            this.srv.base.redirect();
                        }
                    }
                    else {
                        this.onBubbleEvent('row_clicked', event.data.row);
                    }
                    break;
                case 'columnRouteClick':
                    if (this.config.linkBehavior === 'route') {
                        goToUrl = this._parseGoToUrl(this.config.columnDefinitions[event.data.name].route, event.data.row);
                        if (!goToUrl)
                            return false;
                        routeApp = String(goToUrl).split('/');
                        if (routeApp[1] && routeApp[1] === PopHref) {
                            const route = routeApp.slice(2).join('/');
                            this.srv.router.navigate([route]).catch((e) => {
                                console.log(e);
                                PopTemplate.error({ message: `Invalid Client Route: ${route}`, code: 500 });
                            });
                        }
                        else {
                            SetSiteVar('redirect', goToUrl);
                            this.srv.base.redirect();
                        }
                    }
                    else {
                        this.onBubbleEvent(event.name, event.data);
                    }
                    break;
                case 'columnLinkClick':
                    this.onBubbleEvent('columnLinkClick', {
                        link: this.config.columnDefinitions[event.data.name].link,
                        row: event.data.row,
                        col: event.data.name
                    });
                    break;
                case 'filter':
                    this.onApplySearchValue(event.data.filter, event.data.col);
                    break;
                default:
                    this.onBubbleEvent(event.name, event.data);
                    break;
            }
        }
        if (event.type === 'context_menu') {
            this.events.emit(event);
        }
    }
    /**
     * This determine what the height of the table should be
     * @param height
     */
    _setHeight(height = null) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.overhead = 0;
            if (this.config) {
                if (height)
                    this.config.height = height;
                if (this.config.height) {
                    if (this.config.options || this.config.buttons.length || (this.config.search && !this.config.searchColumns))
                        this.dom.overhead = this.dom.overhead + 55;
                    if (this.config.paginator)
                        this.dom.overhead = this.dom.overhead + 65;
                    this.dom.setHeight(this.config.height, this.dom.overhead);
                    return resolve(true);
                }
            }
            else {
                this.dom.setHeight(0, 0);
                this.dom.height.outer = null;
                this.dom.height.inner = null;
            }
            return resolve(false);
        }));
    }
    /**
     * The user can choose from a global search or a column search
     */
    _setFilterPredicate(searchValue = null) {
        if (this.config.searchColumns) {
            this.config.matData.filter = '';
            this.config.matData.filterPredicate = this.asset.filter.predicate.column;
        }
        else {
            this.config.matData.filterPredicate = this.asset.filter.predicate.tag;
            this.onApplySearchValue((searchValue ? searchValue : ''), '');
        }
    }
    _updateData(data) {
        this.dom.refreshing();
        if (!this.config.matData.paginator)
            this.config.matData.paginator = this.matPaginator;
        if (IsObject(this.config.columnDefinitions, true)) {
            if (IsArray(data)) {
                this.asset.data = data;
                this.config.matData.data = this.asset.data.slice();
                if (!this.config.searchColumns && this.dom.session.searchValue) {
                    this.asset.filter.search(this.dom.session.searchValue, '');
                }
                this._setTableLayout();
            }
        }
        else if (IsArray(data, true)) {
            this.config.data = data;
            this.onBubbleEvent('column_definitions', data[0]);
        }
    }
    _resetTable(data = null) {
        this.log.info(`_resetTable`);
        this.dom.setTimeout(`reset-table`, () => __awaiter(this, void 0, void 0, function* () {
            this.dom.refreshing();
            yield this._configureTable();
            yield this._updateButtonControl();
            if (Array.isArray(data)) {
                this._updateData(data);
            }
            else {
                this.dom.setTimeout(`view-ready`, () => __awaiter(this, void 0, void 0, function* () {
                    this.dom.ready();
                }), 200);
            }
        }), 0);
    }
    /**
     * This will bring in the table config,user preferences,data set and tie it all together
     * The structure of the data set is important to what the table will render
     */
    _configureTable() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`_configureTable`);
            this.config.matData.data.length = 0;
            const templates = {};
            const visible = [];
            let visibleOrdered = [];
            let validDefinition = false;
            if (!IsObject(this.config.columnDefinitions, true)) {
                this.dom.state.hasColumnDefinitions = true;
                this.config.columnDefinitions = {
                    description: { name: "description", label: "Description", visible: true, sort: 3 },
                    id: { name: "id", label: "ID", checkbox: { visible: true, sort: 0 }, visible: true, sort: 999 },
                    name: { name: "name", label: "Name", visible: true, sort: 2 }
                };
            }
            else {
                this.dom.state.hasColumnDefinitions = IsObject(this.config.columnDefinitions, true);
            }
            for (const col in this.config.columnDefinitions) {
                if (!this.config.columnDefinitions.hasOwnProperty(col))
                    continue;
                // Marking this as true so that the auto config does not run.
                validDefinition = true;
                // Figure out the template to use.
                let template = 'Standard';
                if (this.config.columnDefinitions[col].route) {
                    if (this.config.columnDefinitions[col].icon) {
                        template = this.config.columnDefinitions[col].helper ? 'RouteIconHelper' : 'RouteIcon';
                    }
                    else {
                        template = this.config.columnDefinitions[col].helper ? 'RouteHelper' : 'Route';
                    }
                }
                else if (this.config.columnDefinitions[col].link) {
                    if (this.config.columnDefinitions[col].icon) {
                        template = this.config.columnDefinitions[col].helper ? 'LinkIconHelper' : 'LinkIcon';
                    }
                    else {
                        template = this.config.columnDefinitions[col].helper ? 'LinkHelper' : 'Link';
                    }
                }
                else if (this.config.columnDefinitions[col].icon) {
                    template = this.config.columnDefinitions[col].helper ? 'IconHelper' : 'Icon';
                }
                else if (this.config.columnDefinitions[col].helper) {
                    template = 'StandardHelper';
                }
                // Populate the template with anything it may need.
                templates[col] = {
                    template: template,
                    name: col,
                    display: this.srv.pipe.label.transform(col, this.config.columnDefinitions[col]),
                    icon: this.config.columnDefinitions[col].icon,
                    helper: {
                        text: (!this.config.columnDefinitions[col].helper ? '' : (typeof this.config.columnDefinitions[col].helper === 'string' ? this.config.columnDefinitions[col].helper : this.config.columnDefinitions[col].helper.text)),
                        position: (!this.config.columnDefinitions[col].helper ? 'left' : (typeof this.config.columnDefinitions[col].helper === 'string' ? 'left' : this.config.columnDefinitions[col].helper.position)),
                    },
                    sticky: !this.config.columnDefinitions[col].sticky ? false : this.config.columnDefinitions[col].sticky
                };
                // If Visible
                if (this.config.columnDefinitions[col].visible)
                    visible.push({
                        name: col,
                        sort: this.config.columnDefinitions[col].sort
                    });
                // Check if this column should also have a checkbox.
                if (this.config.columnDefinitions[col].checkbox) {
                    const cbName = 'checkbox_' + col;
                    templates[cbName] = {
                        template: 'Checkbox',
                        name: col,
                        helper: { text: '', position: 'left' },
                        sticky: !this.config.columnDefinitions[col].checkbox.sticky ? false : this.config.columnDefinitions[col].checkbox.sticky
                    };
                    if (this.config.columnDefinitions[col].checkbox.visible) {
                        visible.push({
                            name: cbName,
                            sort: this.config.columnDefinitions[col].checkbox.sort ? this.config.columnDefinitions[col].checkbox.sort : 0
                        });
                    }
                }
            }
            // Put the visible columns are in the correct order.
            visible.sort(DynamicSort('sort'));
            for (const i in visible)
                visibleOrdered.push(visible[i].name);
            // If no column configs were passed in then use the data set and just display all the columns.
            if (!validDefinition && this.asset.data && this.asset.data[0]) {
                for (const col in this.asset.data[0]) {
                    if (!this.asset.data[0].hasOwnProperty(col))
                        continue;
                    visibleOrdered.push(col);
                    templates[col] = {
                        template: 'Standard',
                        name: col,
                        display: PopPipe.label.transform(col)
                    };
                }
            }
            // Just in case, remove any columns in the visibleOrdered that do not exist in the data set.
            if (Array.isArray(this.asset.data) && this.asset.data.length) {
                const availableFields = Object.keys(this.asset.data[0]);
                visibleOrdered = visibleOrdered.filter((col) => {
                    return (col.includes('checkbox_') ? true : availableFields.includes(col));
                });
            }
            // Set the config.
            this.config.columnConfig = { templates: templates, visible: visibleOrdered };
            // Clear previous selections.
            if (this.config.selection)
                this.config.selection.clear();
            // Set the data.
            if (IsArray(this.config.data, false)) {
                this._updateData(this.config.data);
            }
            setTimeout(() => {
                this.dom.ready();
                this.onBubbleEvent('ready', 1);
            });
            return resolve(true);
        }));
    }
    _setTablePagination() {
        if (this.config && this.config.height) {
            let viewableRows;
            if (this.config.paginator && this.matPaginator && IsArray(this.asset.data, false)) {
                this.dom.state.hasPagination = this.asset.data.length > 50;
                // viewableRows = this.asset.data ? this.asset.data.length : 0;
                // if( this.dom.state.hasPagination ){
                // viewableRows = parseInt(String(( ( this.dom.height.inner - 25 ) / 50 )), 10);
                viewableRows = 50;
                // if( this.config.headerSticky ) viewableRows--;
                // }
                setTimeout(() => {
                    this.config.matData.paginator.pageSize = 50;
                    this.config.matData.paginator.pageSizeOptions = [50];
                    this.config.matData.paginator.pageIndex = 0;
                    this.config.matData.paginator.page.next({ pageIndex: 0, pageSize: 50, length: 50 });
                });
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _updateColumnDefinitions(definitions) {
        this.config.columnDefinitions = definitions;
        this._configureTable().then(() => true);
    }
    /**
     * This function will attach and configure a paginator if it is needed
     */
    _attachPaginator() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.matPaginator) {
                this.matPaginator.hidePageSize = true;
                if (this.config && this.config.matData)
                    this.config.matData.paginator = this.matPaginator;
            }
            return resolve(false);
        }));
    }
    /**
     * This will manage the button interface
     * Buttons can have a dependency on what the user has currently selected(list items have a checkbox selection)
     */
    _updateButtonControl() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Initialize the ui button control
            if (IsUndefined(this.ui.buttonControl)) {
                this.ui.buttonControl = {
                    requireSelected: false,
                    requireOneSelected: false,
                    requireNoneSelected: true
                };
            }
            if (this.config.selection) {
                const selectCount = this.config.selection.selected.length;
                this.ui.buttonControl.requireSelected = +selectCount > 0;
                this.ui.buttonControl.requireOneSelected = +selectCount === 1;
                this.ui.buttonControl.requireNoneSelected = +selectCount === 0;
            }
            else {
                this.ui.buttonControl.requireSelected = false;
                this.ui.buttonControl.requireOneSelected = false;
                this.ui.buttonControl.requireNoneSelected = true;
            }
            return resolve(true);
        }));
    }
    /**
     * The table config has its own event emitter that need to be handled
     */
    _handleConfigEvents() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.config.onEvent)
                this.config.onEvent = new Subject();
            this.dom.setSubscriber('config-events', this.config.onEvent.subscribe((event) => {
                this._updateButtonControl().then(() => true);
                this._onTableEvent(event);
            }));
            return resolve(false);
        }));
    }
    /**
     * This will allow an outside component to trigger specific functionality through the config of this component
     */
    _setConfigHooks() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.config.setHeight = (height) => {
                this._setTableHeight(height);
            };
            this.config.clearSelected = () => {
                return new Promise((clearResolver) => __awaiter(this, void 0, void 0, function* () {
                    this.config.selection.clear();
                    yield Sleep(250);
                    this._updateButtonControl().then(() => {
                        return clearResolver(true);
                    });
                }));
            };
            this.config.updateColumnDefinitions = (definitions) => {
                this._updateColumnDefinitions(definitions);
            };
            this.config.updateData = (data) => {
                this._updateData(data);
            };
            this.config.setLayout = (height) => {
                this._setTableLayout(height);
            };
            this.config.reset = (data = null) => {
                this._resetTable(data);
            };
            this.config.applyFilter = (searchValue, col) => {
                if (!this.config.searchColumns) {
                    this.onApplySearchValue(searchValue, col);
                }
            };
            return resolve(true);
        }));
    }
    /**
     * Initialize and manage the filter predicates that this table will use
     */
    _initSearchFilter() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.session.searchValue = this.dom.session.searchValue ? this.dom.session.searchValue : (this.config.searchValue ? this.config.searchValue : '');
            this.asset.filter.predicate = {
                default: this.config.matData.filterPredicate,
                column: (data, filter) => {
                    let exists = true;
                    for (const i in this.asset.filter.column) {
                        if (data[i] && data[i].toLowerCase) {
                            exists = data[i].toLowerCase().includes(this.asset.filter.column[i]);
                        }
                        else {
                            // Cast numbers to strings.
                            exists = String(data[i]).includes(this.asset.filter.column[i]);
                        }
                        if (!exists)
                            return false;
                    }
                    return true;
                },
                tag: (data, filter) => {
                    return ObjectContainsTagSearch(data, filter);
                }
            };
            this.asset.filter.search = (searchValue, col) => {
                searchValue = searchValue.trim().toLocaleLowerCase();
                if (!col) {
                    this.config.matData.filter = searchValue;
                }
                else {
                    if (searchValue) {
                        // Make sure that this column is in the list.
                        this.asset.filter.column[col] = searchValue;
                    }
                    else if (this.asset.filter.column[col]) {
                        // Since filter is empty this column shouldn't be considered.
                        delete (this.asset.filter.column[col]);
                    }
                    this.config.matData.filter = searchValue;
                }
                if (this.config.paginator && this.config.matData.paginator)
                    this.config.matData.paginator.firstPage();
            };
            return resolve(true);
        }));
    }
    _setTableLayout(height = null) {
        this.dom.setTimeout('table-layout', () => {
            this.dom.loading();
            if (this.config && IsArray(this.asset.data, false)) {
                this._setHeight(height).then(() => {
                });
                setTimeout(() => {
                    this.dom.ready();
                    this._setTablePagination();
                }, 0);
            }
        }, 0);
    }
    _setTableHeight(height = null) {
        if (this.config && IsArray(this.asset.data, false)) {
            this._setHeight(height);
            setTimeout(() => {
                this.dom.ready();
                this._setTablePagination();
            }, 0);
        }
    }
    _parseGoToUrl(goToUrl = '', row) {
        if (!goToUrl)
            return goToUrl;
        // Check for alias
        if (goToUrl.includes('alias:')) {
            const start = goToUrl.indexOf('alias:');
            const end = goToUrl.indexOf('/', start) !== -1 ? goToUrl.indexOf('/', start) : goToUrl.length;
            const aliasString = goToUrl.substring(start, end);
            const aliasArray = aliasString.split(':');
            aliasArray.shift();
            const alias = PopPipe.label.getAlias(aliasArray.shift());
            goToUrl = goToUrl.replace(aliasString, alias);
        }
        // Check for other id.
        if (goToUrl.includes(':') && row) {
            goToUrl = ParseLinkUrl(goToUrl, row);
        }
        return goToUrl;
    }
}
PopTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-table',
                template: "<div class=\"pop-table-container\" [style.height.px]=dom.height.outer>\n  <div class=\"pt-dark-text pop-table-control\" *ngIf=\"config?.options || config?.buttons.length || ( config?.search && !config?.searchColumns )\">\n    <div class=\"search-control\">\n      <div *ngIf=\"config.search && !config.searchColumns\">\n        <mat-form-field class=\"sw-search\" appearance=\"outline\" color=\"accent\">\n          <a matPrefix>\n            <mat-icon>search</mat-icon>\n          </a>\n          <mat-icon class=\"sw-pointer\" matSuffix (click)=\"onApplySearchValue('',''); dom.session.searchValue = '';\">\n            close\n          </mat-icon>\n          <input matInput [(ngModel)]=\"dom.session.searchValue\" (keyup)=\"onApplySearchValue($event.target.value, '')\"\n                 placeholder=\"Search\">\n        </mat-form-field>\n      </div>\n    </div>\n    <div *ngIf=\"config.buttons.length && ui.buttonControl\">\n      <div class=\"pop-table-button-control\">\n        <div *ngFor=\"let button of config.buttons; last as isLast\">\n          <div [ngClass]=\"{'last-button': isLast && !config.options}\">\n            <button mat-raised-button class=\"pop-table-buttons\"\n                    (click)=\"onBubbleEvent((button.id ? button.id : button.name), config.selection?.selected)\" [ngClass]=\"{'sw-hidden': (\n                ( button.requireSelected && !ui.buttonControl.requireSelected ) ||\n                ( button.requireOneSelected && !ui.buttonControl.requireOneSelected ) ||\n                ( button.requireNoneSelected && !ui.buttonControl.requireNoneSelected )\n              )}\">\n              {{button.name}}\n            </button>\n          </div>\n        </div>\n        <button mat-raised-button *ngIf=\"config.options\" (click)=\"onEditTablePreferencesClick()\" class=\"sw-icon-button\">\n          <span class=\"sw-pop-icon\">Q</span>\n        </button>\n      </div>\n    </div>\n  </div>\n  <div class=\"pop-table-loader\">\n    <mat-progress-bar *ngIf=\"config?.loading\" mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n  <div #wrapper class=\"pop-table-wrapper\" [style.maxHeight.px]=null [style.minHeight.px]=dom.height.inner\n       [ngClass]=\"{'pop-table-wrapper-pagination': this.dom.state.hasPagination, 'pop-table-pagination-inactive pop-table-wrapper-scroll': !this.dom.state.hasPagination}\">\n    <!-- Needs some design process -->\n    <h1 *ngIf=\"!dom.state['hasColumnDefinitions']\">No Data Available</h1>\n    <!--  -->\n    <lib-pop-table-view *ngIf=\"dom.state.loaded && !dom.state.refresh\" [config]=config></lib-pop-table-view>\n  </div>\n  <div class=\"pop-table-footer\" class=\"sw-hidden\"[ngClass]=\"{'sw-hidden': true || !config?.paginator}\">\n    <div >\n      <mat-paginator></mat-paginator>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.Emulated,
                styles: [".pop-table-container{position:relative;display:flex;flex-direction:column;overflow:hidden;box-sizing:border-box;margin:0 5px}.pop-table-container .pop-table-control{display:flex;justify-content:space-between;height:45px}.pop-table-container .pop-table-control .search-control{flex-grow:0.5}.pop-table-container .pop-table-control .pop-table-button-control{display:flex;justify-content:flex-end;align-items:flex-end;flex-grow:1;margin-bottom:7px;margin-right:-5px}.pop-table-container .pop-table-control .pop-table-button-control button{font-size:14px;margin-top:1px;margin-right:10px!important;line-height:20px!important;height:34px}.pop-table-container .pop-table-wrapper{display:flex;flex-direction:column;overflow-x:auto}.pop-table-container .pop-table-footer{position:absolute;display:flex;flex-direction:column;left:0;right:0;bottom:0;height:40px;border:1px solid var(--background-border);background:var(--background-item-menu);border-bottom-left-radius:var(--radius-xs);border-bottom-right-radius:var(--radius-xs)}.pop-table-loader{position:relative;top:-1px;height:1px;overflow:hidden;clear:both;z-index:1}.pop-table-wrapper-pagination,.pop-table-wrapper-scroll{overflow-y:auto!important}:host ::ng-deep .pop-table-wrapper-scroll mat-paginator .mat-icon-button{opacity:.1;pointer-events:none}:host ::ng-deep .search-control .mat-form-field .mat-form-field-infix{width:200px}::ng-deep td.mat-cell,::ng-deep th.mat-header-cell{font-size:14px;height:0!important;padding:0}::ng-deep .mat-header-row{height:40px!important}::ng-deep .mat-header-row,::ng-deep .mat-row{height:40px!important}"]
            },] }
];
PopTableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: PopBaseService },
    { type: MatDialog },
    { type: PopDomService },
    { type: Router },
    { type: PopPipeService }
];
PopTableComponent.propDecorators = {
    config: [{ type: Input }],
    wrapper: [{ type: ViewChild, args: ['wrapper', { static: true },] }],
    footer: [{ type: ViewChild, args: ['footer',] }],
    matPaginator: [{ type: ViewChild, args: [MatPaginator, { static: true },] }]
};

class PopTableViewComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _displayRepo
     * @param _domRepo
     */
    constructor(el, _displayRepo, _domRepo) {
        super();
        this.el = el;
        this._displayRepo = _displayRepo;
        this._domRepo = _domRepo;
        this.name = 'PopTableViewComponent';
        this.srv = {
            display: undefined,
        };
        this.ui = {
            helperText: []
        };
        /**
         * Configure the specifics of this component
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this._attachContextMenu();
                // Assign this so it is available inside the filterBarConfig.
                this.config.matData.sort = this.tableSort;
                // Create a container for helper texts
                this.ui.helperText = [];
                // Add to the config so it's available to prepTable.
                this.config.selection = new SelectionModel(true, []);
                this.config.headerSticky = true;
                setTimeout(() => {
                    this.config.matData.sort = this.tableSort;
                    if (this.config.initialSort)
                        this.tableSort.sort({
                            id: this.config.initialSort,
                            start: this.config.initialSortDirection,
                            disableClear: true
                        });
                }, 500);
                resolve(true);
            });
        };
    }
    sortDisplay(col) {
        const isActive = this.tableSort.active === col ? true : false;
        let display = 'arrow_drop_down';
        if (isActive) {
            if (this.tableSort.direction === 'asc') {
                display = 'arrow_drop_up';
            }
        }
        return display;
    }
    // sort(column,direction){
    //   // console.log(this.tableSort);
    //   this.tableSort.direction = direction === 'asc' ? 'desc' : 'asc';
    //   this.tableSort.sort({ id: column, start: direction, disableClear: true });
    // }
    sort(col) {
        const isActive = this.tableSort.active === col ? true : false;
        let direction = 'asc';
        if (isActive) {
            direction = this.tableSort.direction === 'asc' ? 'desc' : 'asc';
        }
        else {
            direction = 'asc';
        }
        this.tableSort.direction = direction === 'asc' ? 'desc' : 'asc';
        this.tableSort.sort({ id: col, start: direction, disableClear: true });
    }
    /**
     * This component is a child component of pop table
     * This component specifically handles the view that renders the data
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Trigger an event when the user click on a name
     * @param name
     * @param row
     */
    onColumnStandardClick(name, row) {
        this.config.onEvent.next({
            source: this.name,
            type: 'table',
            name: 'columnStandardClick',
            data: {
                name: name,
                row: row
            }
        });
    }
    /**
     * Trigger an event when the user click on a name that is linked to a route
     * @param name
     * @param row
     */
    onColumnRouteClick(name, row) {
        this.config.onEvent.next({
            source: this.name,
            type: 'table',
            name: 'columnRouteClick',
            data: {
                name: name,
                row: row
            }
        });
    }
    /**
     * Create a helper text for a name
     * @param index
     * @param col
     * @param row
     */
    onHelperText(index, col, row) {
        if (!row[col])
            return '';
        let text = this.config.columnConfig.templates[col].helper.text;
        // Check for alias
        if (text.includes('alias:')) {
            const start = text.indexOf('alias:');
            const end = text.indexOf(' ', start) !== -1 ? text.indexOf(' ', start) : text.length;
            const aliasString = text.substring(start, end);
            const aliasArray = aliasString.split(':');
            aliasArray.shift();
            const alias = this.srv.display.alias(aliasArray.shift());
            text = text.replace(aliasString, alias);
        }
        // If no text is wrapped in < > then this is the text we want.
        if (text.indexOf('<') === -1) {
            this.ui.helperText[index] = text;
            return text;
        }
        // Replace any text between < > with the corresponding name data.
        const textArray = text.split('<');
        text = '';
        for (let i = 0; i < textArray.length; i++) {
            if (!textArray[i])
                continue;
            if (textArray[i].indexOf('>') === -1) {
                text += textArray[i];
            }
            else {
                const fieldArray = textArray[i].split('>');
                for (let ii = 0; ii < fieldArray.length; ii++) {
                    if (!fieldArray[ii])
                        continue;
                    if (ii === 0) {
                        text += (row[fieldArray[ii]] ? row[fieldArray[ii]] : '');
                    }
                    else {
                        text += fieldArray[ii];
                    }
                }
            }
        }
        this.ui.helperText[index] = text;
        return text;
    }
    /**
     * Trigger an doAction when a name link is clicked
     * @param name
     * @param row
     */
    onColumnLinkClick(name, row) {
        this.config.onEvent.next({
            source: this.name,
            type: 'table',
            name: 'columnLinkClick',
            data: {
                name: name,
                row: row
            }
        });
    }
    /**
     * Selects all rows if they are not all selected; otherwise clear all row selections.
     */
    onMasterRowToggleClick() {
        if (this.config.selection.hasValue() && !this.isAllRowsSelected()) {
            this.config.selection.clear();
            this.checkbox.checked = false;
        }
        else {
            this.isAllRowsSelected() ? this.config.selection.clear() : this.config.matData.filteredData.forEach(row => this.config.selection.select(row));
            this.config.onEvent.next({
                source: this.name,
                type: 'table',
                name: 'rows_selected',
                data: this.config.selection.selected
            });
        }
    }
    /**
     * This will pass up to the table component
     * @param filter
     * @param col
     */
    onApplySearchValue(filter, col) {
        this.config.onEvent.next({
            source: this.name,
            type: 'table',
            name: 'filter',
            data: {
                filter: filter,
                col: col,
            }
        });
    }
    /**
     * Asks whether the number of selected elements matches the total number of rows.
     */
    isAllRowsSelected() {
        const numSelected = this.config.selection.selected.length;
        const numRows = this.config.matData.filteredData.length;
        return numSelected === numRows;
    }
    /**
     * This will bubble events with the table signature
     * @param name
     * @param event
     */
    onBubbleEvent(name, event) {
        this.config.onEvent.next({
            source: this.name,
            type: 'table',
            name: name,
            data: event
        });
    }
    /**
     * *ngFor track by for columns
     * Prevents columns from re-rendering when the item is the same
     * @param index
     * @param item
     */
    trackColumnByItem(index, item) {
        if (!item)
            return null;
        return item;
    }
    /**
     * *ngFor track by for rows
     * Prevents rows from re-rendering when the item entityId is still the same
     * @param index
     * @param item
     */
    trackRowByItemId(index, item) {
        if (!item)
            return null;
        return item.id;
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * This will a build a context-menu that can used when user right clicks a certain element
     */
    _attachContextMenu() {
        this.dom.contextMenu.config = new PopContextMenuConfig();
        //
        this.dom.contextMenu.configure = (name, row, event) => {
            let goToUrl = '';
            let internal_name;
            // check if it is a route, get the url from the route given from name definition
            if (this.config.columnDefinitions[name].route) {
                goToUrl = ParseLinkUrl(this.config.columnDefinitions[name].route, row);
            }
            else if (this.config.route) {
                // else check if a global route exists on the table config. If it does, route to that
                // this will most likely be used to route to an entityId by their entityId
                goToUrl = ParseLinkUrl(this.config.route, row);
            }
            if (this.config.columnDefinitions[name].internal_name) {
                internal_name = this.config.columnDefinitions[name].internal_name;
            }
            else {
                internal_name = row.internal_name ? row.internal_name : this.config.internal_name ? this.config.internal_name : null;
            }
            if (!goToUrl && !internal_name)
                return false;
            // if we haven't returned, prevent the default behavior of the right click.
            event.preventDefault();
            // reset the context menu, and configure it to load at the position clicked.
            this.dom.contextMenu.config.resetOptions();
            if (internal_name) {
                this.dom.contextMenu.config.addPortalOption(internal_name, row.id ? +row.id : +row[internal_name + '_fk']);
            }
            if (goToUrl)
                this.dom.contextMenu.config.addNewTabOption(goToUrl);
            this.dom.contextMenu.config.x = event.clientX;
            this.dom.contextMenu.config.y = event.clientY;
            this.dom.contextMenu.config.toggle.next(true);
        };
        this.dom.setSubscriber('context-menu', this.dom.contextMenu.config.emitter.subscribe((event) => {
            this.config.onEvent.next(event);
        }));
    }
}
PopTableViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-table-view',
                template: "<table mat-table  [trackBy]=\"trackRowByItemId\" [dataSource]=\"config.matData\" matSort class=\"table\" full-width>\n\n  <ng-container\n    *ngFor=\"let col of config.columnConfig.visible;\"\n    matColumnDef=\"{{col}}\"\n    [ngSwitch]=\"config.columnConfig.templates[col].template\"\n    sticky=\"{{config.columnConfig.templates[col].sticky === true}}\">\n\n    <!-- DEFAULT -->\n    <div *ngSwitchDefault></div>\n\n    <!-- STANDARD -->\n    <div  *ngSwitchCase=\"'Standard'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td\n        mat-cell *matCellDef=\"let row;let index = index;\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnStandardClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n    <!-- STANDARD WITH HELPER TEXT -->\n    <div *ngSwitchCase=\"'StandardHelper'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td\n        (mouseenter)=\"ui.helperText[ii] = '';\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\" [ngClass]=\"{'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnStandardClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n\n    <!-- ROUTE -->\n    <div *ngSwitchCase=\"'Route'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td [ngClass]=\"row[col] ? 'sw-a' : ''\"\n        mat-cell *matCellDef=\"let row; let index = index\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnRouteClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n\n    <!-- ROUTE WITH HELPER TEXT -->\n    <div *ngSwitchCase=\"'RouteHelper'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td\n        [ngClass]=\"{'sw-a': row[col],  'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (mouseenter)=\"ui.helperText[ii] = ''\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\"\n        (click)=\"( row[col] ? onColumnRouteClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n\n    <!-- ROUTE WITH ICON -->\n    <div *ngSwitchCase=\"'RouteIcon'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td\n        class=\"sw-a site-pointer\"\n        mat-cell *matCellDef=\"let row; let index = i\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"onColumnRouteClick(col, row)\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n\n    <!-- ROUTE WITH ICON AND HELPER TEXT -->\n    <div *ngSwitchCase=\"'RouteIconHelper'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td\n        class=\"sw-a site-pointer\"\n        (mouseenter)=\"ui.helperText[ii] = '';\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\" [ngClass]=\"{'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (click)=\"onColumnRouteClick(col, row)\"\n        (contextmenu)=\"( row[col] ? dom.contextMenu.configure(col, row, $event) : onBubbleEvent('row_right_clicked', row) )\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n\n    <!-- LINK -->\n    <div *ngSwitchCase=\"'Link'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td class=\"site-pointer\"\n        [ngClass]=\"row[col] ? 'sw-a' : ''\"\n        mat-cell *matCellDef=\"let row; let index = index\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnLinkClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n    <!-- LINK WITH HELPER TEXT -->\n    <div *ngSwitchCase=\"'LinkHelper'\">\n      <th *ngIf=\"!config.searchColumns && !config.sort; then HeaderStandard\"></th>\n      <th *ngIf=\"config.searchColumns && !config.sort; then HeaderSearch\"></th>\n      <th *ngIf=\"!config.searchColumns && config.sort; then HeaderSort\"></th>\n      <th *ngIf=\"config.searchColumns && config.sort; then HeaderSortSearch\"></th>\n      <td class=\"site-pointer\"\n        [ngClass]=\"row[col] ? 'sw-a' : ''\"\n        (mouseenter)=\"ui.helperText[ii] = '';\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\" [ngClass]=\"{'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnLinkClick(col, row) : onBubbleEvent('row_clicked', row) )\"\n      >{{row[col]}}\n      </td>\n    </div>\n\n    <!-- LINK WITH ICON -->\n    <div *ngSwitchCase=\"'LinkIcon'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td\n        class=\"sw-a site-pointer\"\n        mat-cell *matCellDef=\"let row; let index = index\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"onColumnLinkClick(col, row)\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n    <!-- LINK WITH ICON AND HELPER TEXT -->\n    <div *ngSwitchCase=\"'LinkIconHelper'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td\n        class=\"sw-a site-pointer\"\n        (mouseenter)=\"ui.helperText[ii] = '';\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\" [ngClass]=\"{'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (click)=\"onColumnLinkClick(col, row)\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n\n    <!-- ICON -->\n    <div *ngSwitchCase=\"'Icon'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td class=\"site-pointer\"\n        mat-cell *matCellDef=\"let row; let index = index\" [ngClass]=\"{'first-row-no-header': index === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnStandardClick(col, row) : onBubbleEvent('row_right_clicked', row) )\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n\n    <!-- ICON WITH HELPER TEXT -->\n    <div *ngSwitchCase=\"'IconHelper'\">\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n      <td class=\"site-pointer\"\n        (mouseenter)=\"ui.helperText[ii] = '';\"\n        (mouseleave)=\"ui.helperText.splice(ii, 1)\"\n        matTooltip=\"{{ui.helperText[ii] ? ui.helperText[ii] : onHelperText(ii, col, row)}}\"\n        matTooltipPosition=\"{{config.columnConfig.templates[col].helper.position}}\"\n        mat-cell *matCellDef=\"let row; let ii = index\" [ngClass]=\"{'first-row-no-header': ii === 0 && !config.headerDisplay}\"\n        (click)=\"( row[col] ? onColumnStandardClick(col, row) : onBubbleEvent('row_right_clicked', row) )\"\n      >\n        <div [ngSwitch]=\"config.columnConfig.templates[col].icon.type\">\n          <div *ngSwitchCase=\"'IconImg'\">\n            <img src=\"{{config.columnConfig.templates[col].icon.name}}\" alt=\"{{row[col]}}\">\n          </div>\n          <div *ngSwitchCase=\"'IconMat'\">\n            <mat-icon class=\"sw-cursor-pointer\">{{config.columnConfig.templates[col].icon.name}}</mat-icon>\n          </div>\n          <div *ngSwitchCase=\"'IconPop'\">\n            <span class=\"sw-pop-icon\">{{config.columnConfig.templates[col].icon.name}}</span>\n          </div>\n          <div *ngSwitchDefault>{{row[col]}}</div>\n        </div>\n      </td>\n    </div>\n\n\n    <!-- CHECKBOX -->\n    <div *ngSwitchCase=\"'Checkbox'\">\n      <th mat-header-cell *matHeaderCellDef class=\"checkbox-column\">\n        <mat-checkbox [ngClass]=\"{'column-search-checkbox': config?.searchColumns}\" #checkbox color=\"accent\" (change)=\"$event ? onMasterRowToggleClick() : null\"\n                      [checked]=\"config.selection?.hasValue() && isAllRowsSelected()\"\n                      [indeterminate]=\"config.selection?.hasValue() && !isAllRowsSelected()\">\n        </mat-checkbox>\n      </th>\n      <td mat-cell *matCellDef=\"let row; let i = index\" class=\"checkbox-column\" [ngClass]=\"{'first-row-no-header': i === 0 && !config.headerDisplay}\">\n        <mat-checkbox color=\"accent\" (click)=\"$event.stopPropagation()\"\n                      (change)=\"($event ? config.selection?.toggle(row) : null); onBubbleEvent(($event.checked ? 'row_selected' : 'row_unselected'), row)\"\n                      [checked]=\"config.selection?.isSelected(row)\">\n        </mat-checkbox>\n      </td>\n    </div>\n\n    <!-- HEADER TEMPLATES -->\n    <ng-template #HeaderStandard>\n      <th mat-header-cell *matHeaderCellDef>{{config.columnConfig.templates[col].display}}</th>\n    </ng-template>\n\n    <ng-template #HeaderSort>\n      <th class=\"sortable-header\" mat-header-cell *matHeaderCellDef (click)=\"sort(config.columnConfig?.templates[col].name)\">\n\n\n        <div class=\"column-header-sort\">\n          <div>\n            {{config.columnConfig.templates[col].display}}\n          </div>\n\n          <div >\n            <mat-icon class=\"sort-top-searchable\"\n                      [ngClass]=\"{visible: tableSort.active === config.columnConfig?.templates[col].name, hidden: tableSort.active !== config.columnConfig?.templates[col].name}\"\n\n                      >{{sortDisplay(config.columnConfig?.templates[col].name)}}</mat-icon>\n\n<!--            <mat-icon class=\"sort-top-searchable\"-->\n<!--                      [ngClass]=\"{'sort-selected': tableSort.active === config.columnConfig?.templates[col].name && tableSort.direction === 'asc'}\"-->\n<!--                      (click)=\"sort(config.columnConfig?.templates[col].name, 'asc')\">arrow_drop_up</mat-icon>-->\n<!--            <mat-icon class=\"sort-bottom-searchable\"-->\n<!--                      [ngClass]=\"{'sort-selected': tableSort.active === config.columnConfig?.templates[col].name && tableSort.direction === 'desc'}\"-->\n<!--                      (click)=\"sort(config.columnConfig?.templates[col].name, 'desc')\">arrow_drop_down</mat-icon>-->\n          </div>\n        </div>\n      </th>\n    </ng-template>\n\n    <ng-template #HeaderSearch>\n      <th  mat-header-cell *matHeaderCellDef >\n        <div style=\"padding-top: var(--gap-m)\">{{config.columnConfig?.templates[col].display}}</div>\n\n        <div class=\"column-sort\">\n          <mat-form-field appearance=\"outline\" class=\"sw-search\" style=\"padding-bottom: var(--gap-s)\">\n            <!--          <mat-label><mat-icon>search</mat-icon> </mat-label>-->\n            <!--          <mat-label>{{config.columnConfig.templates[col].display}}</mat-label>-->\n            <!--          <a matPrefix><mat-icon>search</mat-icon></a>-->\n            <input matInput (keyup)=\"onApplySearchValue($event.target.value, col)\" placeholder=\"Search\">\n          </mat-form-field>\n        </div>\n\n      </th>\n    </ng-template>\n\n    <ng-template #HeaderSortSearch>\n      <th class=\"sortable-header\" mat-header-cell *matHeaderCellDef (click)=\"sort(config.columnConfig?.templates[col].name)\">\n        <div class=\"column-header-sort\" style=\"padding-top: var(--gap-m)\">\n          <div>\n            {{config.columnConfig?.templates[col].display}}\n          </div>\n\n          <div >\n            <mat-icon class=\"sort-top-searchable\"\n                      [ngClass]=\"{visible: tableSort.active === config.columnConfig?.templates[col].name, hidden: tableSort.active !== config.columnConfig?.templates[col].name}\"\n\n                      (click)=\"sort(config.columnConfig?.templates[col].name)\">{{sortDisplay(config.columnConfig?.templates[col].name)}}</mat-icon>\n<!--            <mat-icon class=\"sort-top-searchable\"-->\n<!--                      [ngClass]=\"{'sort-selected': tableSort.active === config.columnConfig.templates[col].name && tableSort.direction === 'asc'}\"-->\n<!--                      (click)=\"sort(config.columnConfig?.templates[col].name, 'asc')\">arrow_drop_up</mat-icon>-->\n<!--            <mat-icon class=\"sort-bottom-searchable\"-->\n<!--                      [ngClass]=\"{'sort-selected': tableSort.active === config.columnConfig.templates[col].name && tableSort.direction === 'desc'}\"-->\n<!--                      (click)=\"sort(config.columnConfig?.templates[col].name, 'desc')\">arrow_drop_down</mat-icon>-->\n          </div>\n        </div>\n\n        <div class=\"column-sort\" >\n          <mat-form-field appearance=\"outline\" class=\"sw-search\" style=\"padding-bottom: var(--gap-s)\">\n            <!--          <mat-label><mat-icon>search</mat-icon> </mat-label>-->\n            <!--          <mat-label>{{config.columnConfig.templates[col].display}}</mat-label>-->\n            <!--          <a matPrefix><mat-icon>search</mat-icon></a>-->\n            <input matInput (keyup)=\"onApplySearchValue($event.target.value, col)\" placeholder=\"Search\">\n          </mat-form-field>\n        </div>\n      </th>\n    </ng-template>\n\n  </ng-container>\n\n  <tr [ngClass]=\"{'sw-hidden': !config.headerDisplay}\" mat-header-row\n      *matHeaderRowDef=\"config.columnConfig?.visible; sticky:config.headerSticky\"></tr>\n  <tr mat-row *matRowDef=\"let row; columns: config.columnConfig?.visible;\"></tr>\n  <tr class=\"mat-row\" *matNoDataRow>\n    <td class=\"mat-cell\" colspan=\"12\">No Data Found</td>\n  </tr>\n</table>\n<lib-pop-context-menu *ngIf=\"dom.contextMenu?.config\" [config]=\"dom.contextMenu.config\"></lib-pop-context-menu>\n",
                animations: [
                    fadeInOut,
                ],
                styles: [".sw-a{color:var(--accent)}.mat-sort-header-container{align-items:center;color:red}.column-sort{display:flex;white-space:nowrap}.sticky-row{padding-top:55px}:host ::ng-deep .table{width:100%;overflow-x:auto}:host ::ng-deep .mat-form-field{width:100%}.sort-header{position:relative;top:10px}.sort-bottom,.sort-bottom:hover,.sort-top,.sort-top:hover{position:relative;opacity:.6;cursor:pointer}.sort-bottom,.sort-bottom:hover{top:12px;left:-24px}.sort-bottom:hover,.sort-top:hover{opacity:1;cursor:pointer}.sort-selected{color:var(--primary-foreground);opacity:1}.column-header-sort{display:flex}.column-search-checkbox{position:relative;top:10px}.sort-top-searchable{top:-4px;left:5px}.sort-bottom-searchable,.sort-top-searchable{display:inherit;height:0;position:relative;opacity:.6;cursor:pointer}.sort-bottom-searchable{top:0}.visible{visibility:visible}.hidden{visibility:hidden}.sort-bottom-searchable:hover{opacity:1}.sortable-header{cursor:pointer}.sortable-header:hover .hidden{visibility:visible}.mat-row:hover{background-color:var(--background-main-menu)}"]
            },] }
];
PopTableViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDisplayService },
    { type: PopDomService }
];
PopTableViewComponent.propDecorators = {
    config: [{ type: Input }],
    tableSort: [{ type: ViewChild, args: [MatSort, { static: true },] }],
    checkbox: [{ type: ViewChild, args: ['checkbox',] }]
};

class PopTableModule {
}
PopTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PopTableComponent,
                    PopTableDialogComponent,
                    PopTableViewComponent,
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    MaterialModule,
                    MatTableModule,
                    MatDialogModule,
                    MatSortModule,
                    MatPaginatorModule,
                    PopFieldItemModule,
                    PopContextMenuModule,
                    DragDropModule
                ],
                exports: [
                    PopTableComponent,
                    PopTableViewComponent,
                    DragDropModule
                ],
            },] }
];

class DialogComponent {
    constructor(data, dialog, history, requestService) {
        this.data = data;
        this.dialog = dialog;
        this.history = history;
        this.requestService = requestService;
    }
    ngOnInit() {
        this.setSpinnerOptions();
        if (this.data.patch)
            this.makeRequest();
        else
            this.closeDialogAfterDelay();
    }
    makeRequest() {
        this.loading = true;
        switch (this.data.patch.type) {
            case 'delete':
                this.doDelete();
                break;
            case 'get':
                this.doGet();
                break;
            case 'patch':
                this.doPatch();
                break;
            case 'post':
                this.doPost();
                break;
        }
    }
    doPatch() {
        this.requestService.doPatch(this.data.patch.path, this.data.patch.body, this.data.patch.version, false).subscribe(res => {
            this.data.response = res;
            this.loading = false;
            this.closeDialogAfterDelay();
        }, err => {
            this.loading = false;
            this.httpError = {
                error: typeof err.error !== 'undefined' ? err.error.message : err.statusText,
                code: err.status
            };
        });
    }
    doDelete() {
        this.requestService.doDelete(this.data.patch.path, this.data.patch.body, this.data.patch.version, false).subscribe(res => {
            this.data.response = res;
            this.loading = false;
            this.closeDialogAfterDelay();
        }, err => {
            this.loading = false;
            this.httpError.error = typeof err.error !== 'undefined' ? err.error.message : err.statusText;
            this.httpError.code = err.status;
        });
    }
    doPost() {
        this.requestService.doPost(this.data.patch.path, this.data.patch.body, this.data.patch.version, false).subscribe(res => {
            this.data.response = res;
            this.loading = false;
            this.closeDialogAfterDelay();
        }, err => {
            this.loading = false;
            this.httpError.error = typeof err.error !== 'undefined' ? err.error.message : err.statusText;
            this.httpError.code = err.status;
        });
    }
    doGet() {
        this.requestService.doGet(this.data.patch.path, {}, this.data.patch.version, false).subscribe(res => {
            this.loading = false;
            this.data.response = res;
            this.closeDialogAfterDelay();
        }, err => {
            this.loading = false;
            this.httpError.error = typeof err.error !== 'undefined' ? err.error.message : err.statusText;
            this.httpError.code = err.status;
        });
    }
    close() {
        this.dialog.close();
    }
    closeDialogAfterDelay() {
        setTimeout(() => {
            this.dialog.close();
        }, this.data.timeDelay ? this.data.timeDelay : 1000);
    }
    setSpinnerOptions() {
        this.mainSpinner = {
            diameter: 100,
            strokeWidth: 10,
        };
    }
}
DialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-dialog',
                template: "<lib-main-spinner *ngIf=\"loading\" [options]=\"mainSpinner\"></lib-main-spinner>\n\n<h1 *ngIf=\"!loading && data.message && !httpError\">{{data.message}} </h1>\n<h2 *ngIf=\"!loading && data.body && !httpError\" class=\"dc-data-body\"> {{data.body}} </h2>\n<h2 *ngIf=\"!loading && httpError\">Error: {{httpError.code}} - {{httpError.error}}</h2>\n<button *ngIf=\"!loading && httpError\" mat-raised-button (click)=\"close()\">Close</button>\n",
                styles: [".dc-data-body{font-size:var(--text-lg);text-transform:capitalize}"]
            },] }
];
DialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef },
    { type: PopRouteHistoryResolver },
    { type: PopRequestService }
];

class PopAjaxDialogComponent {
    constructor(dialog, baseService, router) {
        this.dialog = dialog;
        this.baseService = baseService;
        this.router = router;
        this.close = new EventEmitter();
    }
    ngOnInit() {
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.loadDialog();
        }, 250);
    }
    loadDialog() {
        const dialogBox = this.dialog.open(DialogComponent, {
            width: '500px',
            data: this.ajaxDialogConfig
        });
        dialogBox.afterClosed().subscribe(() => {
            this.close.emit(this.ajaxDialogConfig.response);
            if (this.ajaxDialogConfig.redirect)
                this.redirect();
        });
    }
    redirect() {
        if (this.ajaxDialogConfig.redirect.app == PopHref) {
            this.router.navigateByUrl(`${this.ajaxDialogConfig.redirect.path}`).catch(e => {
            });
        }
        else {
            SetSiteVar('redirect', `/${this.ajaxDialogConfig.redirect.app}/${this.ajaxDialogConfig.redirect.path}`);
            this.baseService.redirect();
        }
    }
}
PopAjaxDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-ajax-dialog',
                template: ''
            },] }
];
PopAjaxDialogComponent.ctorParameters = () => [
    { type: MatDialog },
    { type: PopBaseService },
    { type: Router }
];
PopAjaxDialogComponent.propDecorators = {
    ajaxDialogConfig: [{ type: Input }],
    close: [{ type: Output }]
};

class PopAjaxDialogModule {
}
PopAjaxDialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MaterialModule,
                    PopIndicatorsModule,
                    CommonModule
                ],
                declarations: [
                    PopAjaxDialogComponent,
                    DialogComponent,
                ],
                exports: [
                    PopAjaxDialogComponent,
                ],
            },] }
];

class PopNavigationDialogComponent {
    constructor(data, dialog, router) {
        this.data = data;
        this.dialog = dialog;
        this.router = router;
    }
    ngOnInit() {
        if (!this.data.display)
            this.data.display = 'Navigation List';
        if (!this.data.list || !Array.isArray(this.data.list))
            this.data.list = [];
        if (!this.data.basePath || !(typeof this.data.basePath === 'string'))
            this.data.basePath = null;
    }
    navigate(item) {
        this.dialog.close();
        if (item.path) {
            this.router.navigateByUrl(item.path).catch(e => false);
        }
        else if (this.data.basePath && item.id) {
            this.router.navigateByUrl(`${this.data.basePath}/${item.id}/general`).catch(e => false);
        }
    }
    cancel() {
        this.dialog.close(null);
    }
}
PopNavigationDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-navigation-dialog',
                template: "<h1 class=\"navigation-header\">{{data.display}}</h1>\n<mat-nav-list class=\"pt-10\">\n  <mat-list-item matRipple *ngFor=\"let item of data.list\" (click)=\"navigate(item);\"> {{item.name}}</mat-list-item>\n</mat-nav-list>\n",
                styles: [".navigation-header{text-align:center}mat-list-item{padding:2px 20px}mat-dialog-container{padding:12px!important}mat-nav-list{padding:2px!important;min-height:30px;max-height:400px;overflow-y:auto}"]
            },] }
];
PopNavigationDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef },
    { type: Router }
];

class PopSuccessDialogComponent extends PopExtendComponent {
    constructor(el, dialog, data) {
        super();
        this.el = el;
        this.dialog = dialog;
        this.data = data;
        this.name = 'PopSuccessDialogComponent';
        this.srv = {
            dialog: ServiceInjector.get(MatDialog),
        };
        this.asset = {};
        this.ui = {
            submitText: 'Ok',
            header: 'Success',
            message: 'Action was Successful'
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.ui = Object.assign(Object.assign({}, this.ui), this.data);
                return resolve(true);
            }));
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The user can click a cancel btn to close the action dialog
     */
    onFormClose() {
        this.dom.setTimeout(`close-modal`, () => {
            this.dialog.close(-1);
        }, 250);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopSuccessDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-success-dialog',
                template: "<div [ngClass]=\"{'sw-hidden': !dom.state.loaded}\" class=\"pop-success-close-btn sw-pointer\" (click)=\"onFormClose();\">\n  <mat-icon>close</mat-icon>\n</div>\n<div [ngClass]=\"{'sw-hidden': !dom.state.loaded}\">\n  <div class=\"pop-success-dialog-header\" *ngIf=\"ui.header\">{{ui.header}}</div>\n  <div class=\"pop-success-dialog-content\">\n    <p class=\"theme-background-success\" [innerHTML]=\"ui.message\"></p>\n  </div>\n  <div class=\"pop-success-dialog-buttons\">\n    <button class=\"pop-success-dialog-other\" mat-raised-button color=\"accent\" (click)=\"onFormClose()\">\n      {{ui.submitText}}\n    </button>\n  </div>\n\n</div>\n<div class=\"pop-success-spinner-box\" *ngIf=\"dom.state.loader\">\n  <lib-main-spinner></lib-main-spinner>\n</div>\n",
                styles: [":host{position:relative;display:block;min-width:350px}.pop-success-close-btn{position:absolute;top:-20px;right:-20px}.pop-success-dialog-header{font-weight:500;text-align:center;margin-bottom:var(--gap-s);color:var(--valid)}.pop-success-dialog-content{position:relative;display:block;width:100%;min-height:30px;margin-bottom:10px}.pop-success-dialog-content .pop-success-dialog-field{margin-bottom:10px}.pop-success-dialog-content .pop-success-dialog-field-lock{pointer-events:none!important}.pop-success-dialog-buttons{margin-top:20px;margin-bottom:10px;display:flex;justify-content:flex-end}.pop-success-dialog-buttons .pop-success-dialog-cancel{order:1;display:flex;align-items:center;justify-content:center;min-height:35px;min-width:120px}.pop-success-dialog-buttons .pop-success-dialog-other{order:2;display:flex;align-items:center;justify-content:center;margin-left:10px;min-width:120px;min-height:35px}.pop-success-dialog-message-layout{display:flex;flex-direction:row;min-height:40px;align-items:center;justify-content:center;text-align:center}.pop-success-dialog-disabled{pointer-events:none}.pop-success-spinner-box{height:150px}"]
            },] }
];
PopSuccessDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class PopMessageDialogComponent {
    constructor(config, dialog) {
        this.config = config;
        this.dialog = dialog;
    }
    ngOnInit() {
    }
    onCancel() {
        this.dialog.close(null);
    }
}
PopMessageDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-message-dialog',
                template: "<h1 class=\"pop-confirmation-dialog-header\">{{config.heading}}</h1>\n<div class=\"pop-confirmation-body\" [innerHTML]=\"config.message\"></div>\n\n<mat-divider [style.width.%]=100 [style.marginBottom.px]=15></mat-divider>\n\n<div class=\"pop-confirmation-dialog-footer\">\n  <button class=\"pop-confirmation-btn\" mat-raised-button (click)=\"onCancel()\" cdkFocusInitial>Close</button>\n</div>\n\n",
                styles: [".pop-confirmation-dialog-header{margin-top:0;text-align:center}.pop-confirmation-body{margin:var(--gap-s) 0 var(--gap-lm) 0;padding:var(--gap-m);min-height:30px;max-height:400px;overflow-y:auto;text-align:center}.pop-confirmation-dialog-footer{display:flex;min-height:var(--gap-m);justify-content:flex-end;align-items:center}.pop-confirmation-btn{margin-left:var(--gap-s)}"]
            },] }
];
PopMessageDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef }
];

class PopDialogsModule {
}
PopDialogsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MaterialModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    PortalModule,
                    PopIndicatorsModule,
                    PopTableModule,
                    PopErrorsModule,
                    PopFieldItemGroupModule
                ],
                declarations: [
                    PopConfirmationDialogComponent,
                    PopNavigationDialogComponent,
                    PopTableDialogComponent$1,
                    PopActionDialogComponent,
                    PopSuccessDialogComponent,
                    PopMessageDialogComponent
                ],
                exports: [
                    PopConfirmationDialogComponent,
                    PopNavigationDialogComponent,
                    PopTableDialogComponent$1,
                    PopActionDialogComponent,
                    PopSuccessDialogComponent,
                    PopMessageDialogComponent
                ],
            },] }
];

class PopBaseModule {
}
PopBaseModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    PopExtendComponent,
                    PopExtendDynamicComponent,
                ],
                exports: [
                    PopTabMenuModule,
                    PopFieldItemModule,
                    PopMenuModule,
                    PopTableModule,
                    PopIndicatorsModule,
                    PopErrorsModule,
                    PopFieldItemGroupModule,
                    PopSideBySideModule,
                    PopAjaxDialogModule,
                    PopDialogsModule,
                    PopContextMenuModule,
                ],
            },] }
];

class PopEntityAdvancedSearchComponent extends PopExtendComponent {
    constructor(el, advancedSearchDialogRef, route, data) {
        super();
        this.el = el;
        this.advancedSearchDialogRef = advancedSearchDialogRef;
        this.route = route;
        this.data = data;
        this.name = 'PopEntityAdvancedSearchComponent';
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.internal_name = 'role';
                this.ui.fields = [];
                const searchFields = {};
                let needsMetadata = false;
                let model;
                if (!this.internal_name)
                    this.internal_name = PopEntity.getRouteInternalName(this.route);
                this.dom.setHeightWithParent(null, 145, 600).then((res) => true);
                PopEntity.getCoreConfig(this.internal_name).then((entityConfig) => {
                    this.asset.entityId = entityConfig;
                    if (IsObject(this.asset.entity.repo.model.field, true)) {
                        Object.keys(this.asset.entity.repo.model.field).map((column) => {
                            if (column in this.asset.entity.repo.model.field[column]['itemMap']) {
                                model = Object.assign({}, this.asset.entity.repo.model.field[column].items[entityConfig.fields[column]['itemMap'][column]].model);
                                delete model.api; // doAction fields don't patch
                                delete model.metadata;
                                delete model.transformation;
                                searchFields[column] = model;
                                if (model.options && model.options.metadata) {
                                    needsMetadata = true;
                                }
                            }
                        });
                    }
                    // if needsMetadata go grab it before you try to build out the fields
                    if (needsMetadata) {
                        this.asset.entity.repo.getUiResources(this.core).subscribe((metadata) => {
                            if (!this.asset.entity.entity)
                                this.asset.entity.entityId = {};
                            this.asset.entity.entity.metadata = metadata;
                            Object.keys(searchFields).map((field) => {
                                // this.ui.fields.push(this.config.getCoreFieldItem(this.asset.entity, field, searchFields[ field ]));
                            });
                            this.ui.fields.sort(function (a, b) {
                                if (a.model.sort_top < b.model.sort_top)
                                    return -1;
                                if (a.model.sort_top > b.model.sort_top)
                                    return 1;
                                return 0;
                            });
                            console.log('fields', this.ui.fields);
                        });
                    }
                    else {
                        // no metadata was needed for any of these fields
                        Object.keys(searchFields).map((field) => {
                            // this.ui.fields.push(this.config.getCoreFieldItem(this.asset.entity, field, searchFields[ field ]));
                        });
                        this.ui.fields.sort(function (a, b) {
                            if (a.model.sort_top < b.model.sort_top)
                                return -1;
                            if (a.model.sort_top > b.model.sort_top)
                                return 1;
                            return 0;
                        });
                        console.log('fields', this.ui.fields);
                    }
                });
                resolve(true);
            });
        };
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    onSearch() {
        this.advancedSearchDialogRef.close(this.data);
    }
    onCancel() {
        this.advancedSearchDialogRef.close(null);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityAdvancedSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-advanced-search',
                template: "<div class=\"pop-entity-advanced-search-container\">\n  <div class=\"pop-entity-advanced-search-header\"><h3>Entity Advanced Search</h3></div>\n  <div class=\"pop-entity-advanced-search-content\" [style.height.px]=dom.height.inner>\n    <mat-list class=\"field-builder-items\">\n      <mat-list-item *ngFor=\"let field of ui.fields\">\n        {{field.model.display}}\n      </mat-list-item>\n    </mat-list>\n  </div>\n  <div class=\"pop-entity-advanced-search-buttons\">\n    <div class=\"pop-entity-advanced-search-cancel\">\n      <button class=\"pop-entity-advanced-search-button\" mat-raised-button (click)=\"onCancel()\">Cancel</button>\n    </div>\n    <button class=\"pop-entity-advanced-search-button\" mat-raised-button (click)=\"onSearch()\" color=\"accent\">Search\n    </button>\n  </div>\n</div>\n\n",
                styles: [".mat-dialog-container{padding:0!important}.pop-entity-advanced-search-container{position:relative;flex:1 1 100%;background:pink}.pop-entity-advanced-search-header{background:#00f;min-height:35px;border-bottom:1px solid var(--border)}.pop-entity-advanced-search-header h3{margin:0;font-weight:500;text-align:center;padding-bottom:5px}.pop-entity-advanced-search-content{flex:1 1 100%;background:green;overflow:hidden;overflow-y:scroll;overflow-x:hidden}.pop-entity-advanced-search-buttons{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:flex-end;background:red;height:40px;padding:10px 20px}.pop-entity-advanced-search-button{margin-left:10px}.pop-entity-advanced-search-cancel{margin-left:-10px;display:flex;flex-grow:2}:host ::ng-deep .mat-list-base{padding-top:0;margin-right:5px;margin-left:1px;margin-top:1px}:host ::ng-deep .mat-list-item{margin-bottom:1px}"]
            },] }
];
PopEntityAdvancedSearchComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: ActivatedRoute },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
PopEntityAdvancedSearchComponent.propDecorators = {
    internal_name: [{ type: Input }]
};

class PopEntityListComponent extends PopExtendComponent {
    constructor(el, route, _domRepo, APP_GLOBAL) {
        super();
        this.el = el;
        this.route = route;
        this._domRepo = _domRepo;
        this.APP_GLOBAL = APP_GLOBAL;
        this.dataFactory = null;
        this.name = 'PopEntityListComponent';
        this.table = {
            data: [],
            buttons: [
                // { id: 'custom', name: 'Custom', accessType: 'can_read', requireSelected: true },
                // { id: 'advanced_search', name: 'Advanced Search', accessType: 'can_read', requireSelected: false },
                { id: 'archive', name: 'Archive', accessType: 'can_create', requireSelected: true },
                { id: 'restore', name: 'Activate', accessType: 'can_create', requireSelected: true },
                { id: 'show_archived', name: 'Show Archived', accessType: 'can_read', requireSelected: false },
                { id: 'show_active', name: 'Show Active', accessType: 'can_read', requireSelected: false },
                { id: 'new', name: 'New', accessType: 'can_create', requireSelected: false },
            ],
            interface: undefined,
            spinner: { diameter: 0, strokeWidth: 0 },
            config: null,
        };
        this.srv = {
            action: ServiceInjector.get(PopEntityActionService),
            dialog: ServiceInjector.get(MatDialog),
            entity: ServiceInjector.get(PopEntityService),
            events: ServiceInjector.get(PopEntityEventService),
            filter: ServiceInjector.get(PopCacFilterBarService),
            pipe: ServiceInjector.get(PopPipeService),
            param: ServiceInjector.get(PopEntityUtilParamService),
            portal: ServiceInjector.get(PopEntityUtilPortalService),
            router: ServiceInjector.get(Router),
            tab: undefined
        };
        this.ui = {
            actionModal: undefined,
        };
        this.asset = {
            blueprintData: {},
            fieldKeys: undefined,
            blueprint: undefined,
            transformations: undefined,
            tableInterface: undefined,
            tabMenuSessionPath: '',
            showArchivedSessionPath: '',
            searchValueSessionPath: ''
        };
        this.dom.configure = () => {
            // this component set the outer height boundary of this view
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // Ensure that a CoreConfig exists for this component
                yield this.APP_GLOBAL.isVerified();
                yield this._setCoreConfig();
                this.id = this.core.params.internal_name;
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : {};
                yield forkJoin([
                    this._transformRouteExtension(),
                    this._setConfig(),
                    this._setSessionSettings(),
                    this._configureFilterBar(),
                    this._setCrudHandler(),
                    this._configureTable(),
                    this._setHeight(), // account for the filter bar , and determine the height of this table try to fill all vertical height
                ]);
                return resolve(true);
            }));
        };
        /**
         * This function will call after the dom registration
         */
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setTimeout(`height-adjustment-check`, () => {
                    this._setHeight().then(() => {
                        return resolve(true);
                    });
                }, 250);
            });
        };
    }
    /**
     * This component will display a list of entities that the user can interact with
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Trigger the table to reset itself
     */
    onResetTable() {
        this.dom.setTimeout('reset', () => {
            this.dom.state.loading = true;
            const overhead = (+this.core.repo.model.table.filter.active ? this.srv.filter.getHeight() : 25);
            this.dom.setHeightWithParent('sw-target-outlet', overhead, window.innerHeight - 65).then((res) => {
                if (this.table.config && typeof this.table.config.setLayout === 'function')
                    this.table.config.setLayout(this._getTableHeight());
            });
        }, 0);
    }
    /**
     * Trigger the table to reset itself
     */
    onResetHeight() {
        this._setHeight().then(() => {
            if (this.table.config && typeof this.table.config.setHeight === 'function')
                this.table.config.setHeight(this._getTableHeight());
        });
    }
    /**
     * A table will generate a slew of event and action triggers
     * @param event
     */
    onTableEvent(event) {
        //     console.log( this.name, event );
        if (event.type === 'table') {
            let ids;
            if (event && Array.isArray(event.data)) {
                ids = event.data.map((row) => row.id).join();
            }
            switch (event.name) {
                case 'search':
                    if (IsString(this.asset.searchValueSessionPath))
                        SetSessionSiteVar(this.asset.searchValueSessionPath, event.data);
                    // console.log('this.asset.searchValueSessionPath', this.asset.searchValueSessionPath);
                    break;
                case 'row_clicked':
                    this.onTableRowClicked(event.data);
                    break;
                case 'columnRouteClick':
                    this.onTableColumnClicked(event.data);
                    break;
                case 'options_save':
                    this.onSaveOptions(event.data);
                    break;
                case 'options_reset':
                    this.onOptionsReset();
                    break;
                case 'new':
                    this.onActionButtonClicked('new');
                    break;
                case 'show_archived':
                    this.onShowArchivedButtonClicked();
                    break;
                case 'show_active':
                    this.onShowArchivedButtonClicked();
                    break;
                case 'archive':
                    this.onArchiveButtonClicked(ids, true);
                    break;
                case 'restore':
                    this.onArchiveButtonClicked(ids, false);
                    break;
                case 'advanced_search':
                    this.onViewAdvancedSearch();
                    break;
                case 'column_definitions':
                    if (IsObject(event.data, true)) {
                        this.dom.setTimeout('build-columns', () => __awaiter(this, void 0, void 0, function* () {
                            this._setFieldKeys(event.data);
                            const columns = yield this._getDefaultColumns();
                            // this.table.config.columnDefinitions=columns;
                            this.table.config.updateColumnDefinitions(columns);
                        }), 0);
                    }
                    break;
                case 'ready':
                    // if( this.table.config && this.table.config.matData && !this.table.config.matData.data.length ) this._configureTable();
                    break;
                default:
                    break;
            }
            if (!['search', 'ready'].includes(event.name)) {
                // console.log('kill trigger refresh');
                this.dom.setTimeout(`lazy-load-fresh-data`, null);
            }
        }
        if (event.type === 'context_menu') {
            if (event.name === 'portal' && event.internal_name && event.id) {
                this.onViewEntityPortal(event.internal_name, +event.id);
            }
        }
    }
    /**
     * This is exploratory??? Idea is to pop a modal to make the user create an advanced search before we fetch the data for the table
     */
    onViewAdvancedSearch() {
        if (!this.dom.state.blockModal && this.srv.dialog.openDialogs.length == 0) {
            this.dom.state.blockModal = true;
            if (true) {
                const dialogRef = this.srv.dialog.open(PopEntityAdvancedSearchComponent, {
                    width: `${window.innerWidth * .50}px`,
                    height: `${window.innerHeight * .75}px`,
                    panelClass: 'sw-relative',
                    data: { test: 'yo yo' }
                });
                this.dom.subscriber.dialog = dialogRef.beforeClosed().subscribe((changed) => {
                    if (changed || this.dom.state.refresh) {
                        // this._configureTable();up
                    }
                    this.dom.state.blockModal = false;
                });
            }
        }
    }
    /**
     * A user can click on a row in a table to navigate the a view for that entity
     * @param row
     */
    onTableRowClicked(row) {
        if (!this.dom.state.blockModal && this.srv.dialog.openDialogs.length == 0) {
            // custom function
            this.onViewEntityPortal(this.core.params.internal_name, +row['id']);
        }
    }
    /**
     * A user can click on a specific column of a table and get a default action
     * @param data
     */
    onTableColumnClicked(data) {
        // placeholder
        if (!this.dom.state.blockModal && this.srv.dialog.openDialogs.length == 0) {
            this.dom.state.blockModal = true;
            if (data && data.name && data.row[data.name] && +data.row[data.name + '_id']) {
                this.onViewEntityPortal(data.row[data.name], +data.row[data.name + '_id']);
            }
        }
    }
    /**
     * A user can click a link to view a specific entity details in a modal
     * @param internal_name
     * @param id
     */
    onViewEntityPortal(internal_name, id) {
        if (!this.dom.state.blockModal && this.srv.dialog.openDialogs.length == 0) {
            this.dom.state.blockModal = true;
            if (internal_name && id) {
                this.srv.portal.view(internal_name, id).then((changed) => {
                    this.core.repo.clearCache('entity', String(id), 'PopEntityListComponent:onViewEntityPortal');
                    if (changed || this.dom.state.refresh) {
                        this.core.repo.clearAllCache('PopEntityListComponent:onViewEntityPortal');
                        this._configureTable().then(() => true);
                    }
                    this.dom.state.blockModal = false;
                });
            }
        }
    }
    /**
     * A user can save custom settings for how they want to view this table
     * @param options
     */
    onSaveOptions(options) {
        // We only want to save the current column defs and options.
        const preferences = {
            settings: {
                columns: options.currentOptions.columnDefinitions,
                options: options.currentOptions
            },
        };
        const existingID = StorageGetter(this.core.preference, ['table', 'id'], 0);
        this.dom.setSubscriber('save-preferences', this.core.repo.savePreference(+existingID, 'table', preferences).subscribe((preference) => {
            // console.log('saved-preferences', preference);
            this.srv.entity.updateBaseCoreConfig(this.core.params.internal_name, 'preference:table', preference);
            console.log('this.core', this.core);
            if (StorageGetter(this.core, ['preference'])) {
                this.core.preference.table = preference;
            }
            // console.log('this.core.preference.table', this.core.preference.table);
        }));
    }
    /**
     * A user can reset their preferences for this table to default
     */
    onOptionsReset() {
        this.dom.setTimeout(`lazy-load-fresh-data`, null);
        if (IsObject(this.core.preference, ['table']) && this.core.preference.table.id) {
            this.core.repo.deletePreference(this.core.preference.table.id, 'table').then((defaultPreference) => {
                if (defaultPreference) {
                    this.core.preference.table = defaultPreference;
                }
                else {
                    this.core.preference.table = {};
                }
                this.srv.entity.updateBaseCoreConfig(this.core.params.internal_name, 'preference:table', this.core.preference.table);
            });
        }
    }
    /**
     * A user can archive a list of entities
     * @param ids
     * @param archive
     */
    onArchiveButtonClicked(ids, archive) {
        this.table.config.loading = true;
        this.dom.setSubscriber('archive-entities', this.core.repo.archiveEntities(ids, archive).subscribe(() => {
            this.table.config.loading = false;
            this.core.repo.clearCache('table', 'data');
            this._triggerDataFetch(1);
            this.srv.events.sendEvent({
                source: this.name,
                method: 'archive',
                type: 'entity',
                name: this.core.params.name,
                internal_name: this.core.params.internal_name,
                id: ids,
                data: archive
            });
        }, err => {
            this.table.config.loading = false;
            this.dom.error.code = err.error.code;
            this.dom.error.message = err.error.message;
            this.dom.setTimeout(`reset-selected-items`, () => {
                if (typeof this.table.config.clearSelected === 'function')
                    this.table.config.clearSelected();
            }, 0);
        }));
    }
    /**
     * The user can click on a btn to show active, archived, or both?
     */
    onShowArchivedButtonClicked() {
        this.dom.state.showArchived = !this.dom.state.showArchived;
        this.core.repo.clearCache('table');
        this._configureTable().then(() => true);
        this.dom.setTimeout(`reset-selected-items`, () => {
            if (typeof this.table.config.clearSelected === 'function')
                this.table.config.clearSelected();
            this.table.config.buttons = this._buildTableButtons();
            if (IsString(this.asset.showArchivedSessionPath))
                SetSessionSiteVar(this.asset.showArchivedSessionPath, this.dom.state.showArchived);
        }, 0);
    }
    /**
     * This will open a modal to create a new entity when the user clicks on the new button
     */
    onActionButtonClicked(actionName) {
        // if( IsString( actionName, true ) ){
        //   this.srv.action.doAction( this.core, actionName, this.extension ).then( ( config: FieldItemGroupConfig ) => {
        //     console.log( 'action config', config );
        //     if( config ){
        //       this.ui.actionModal = config;
        //     }else{
        //       this.ui.actionModal = null;
        //     }
        //
        //     this.log.config( `onNewButtonClicked`, this.ui.actionModal );
        //   } );
        // }
        if (IsString(actionName, true)) {
            this.dom.setTimeout(`do-action`, () => __awaiter(this, void 0, void 0, function* () {
                yield this.srv.action.do(this.core, actionName, this.extension);
            }), 0);
        }
    }
    /**
     * When the modal for creating a new entity is closed, the config needs to be cleared
     */
    onActionModalClose() {
        this.ui.actionModal = null;
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Allow for a CoreConfig to be passed in
     * If a CoreConfig does not exits this component needs to be able to create it for itself, uses the internal_name that comes directly for the route
     * or tries to extrapolate it from the current url of the app
     *
     */
    _setCoreConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // #1: Grab Route Extension settings
            this._setRouteExtension();
            if (!this.internal_name)
                this.internal_name = this.srv.entity.getRouteInternalName(this.route, this.extension);
            if (!IsObject(this.core, true)) {
                this.srv.entity.getCoreConfig(this.internal_name, 0, this.dom.repo).then((core) => {
                    this.core = core;
                    return resolve(true);
                });
            }
            else {
                return resolve(true);
            }
        }));
    }
    /**
     * Setup basic config
     * Intended to be overridden
     * @private
     */
    _setConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            return resolve(true);
        }));
    }
    /**
     * Attach a handler to handle an crud events
     * @private
     */
    _setCrudHandler() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.dom.setSubscriber('entity', this.srv.events.events.subscribe((event) => this._crudEventHandler(event)));
            return resolve(true);
        }));
    }
    /**
     * Determine the height of the table
     * @private
     */
    _setHeight() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Determine height of the table - have to account if filter bar is enabled
            const menu = 48;
            const filterHeight = this.dom.state.filter ? this.srv.filter.getHeight() : 25;
            const overhead = 25;
            const defaultHeight = window.innerHeight - menu - filterHeight;
            this.dom.setHeight(defaultHeight, overhead);
            return resolve(true);
        }));
    }
    /**
     * Manage the sessionStorage settings
     * @private
     */
    _setSessionSettings() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Set session path for variables
            this.asset.tabMenuSessionPath = `Entity.${TitleCase(this.core.params.internal_name)}.Menu`;
            this.asset.showArchivedSessionPath = `Business.${PopBusiness.id}.Entity.${TitleCase(this.core.params.internal_name)}.Table.Main.showArchived`;
            this.asset.searchValueSessionPath = `Business.${PopBusiness.id}.Entity.${TitleCase(this.core.params.internal_name)}.Table.Main.searchValue`;
            // Set any session variables
            SetSessionSiteVar(this.asset.tabMenuSessionPath, null); // remove any menu session data for this entity
            this.dom.state.showArchived = GetSessionSiteVar(this.asset.showArchivedSessionPath, false);
            return resolve(true);
        }));
    }
    /**
     * Determine how to fetch the data for this table
     * @param update
     * @private
     */
    _fetchData(update = false) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (!update)
                this.dom.setTimeout(`lazy-load-fresh-data`, null);
            if (IsObject(this.table, ['config']) && IsObject(this.table.config, ['clearSelected']) && typeof this.table.config.clearSelected === 'function')
                this.table.config.clearSelected();
            if (this.dataFactory) {
                this.dataFactory(null, this.dom.state.showArchived ? 1 : 0).then((data) => {
                    // console.log('data', data);
                    data = this._transformData(data);
                    if (update && this.table.config && typeof this.table.config.updateData === 'function') {
                        this.table.config.updateData(data);
                    }
                    PopTemplate.clear();
                    return resolve(data);
                }, () => {
                    reject([]);
                });
            }
            else {
                this.core.repo.getEntities(Object.assign({ archived: (this.dom.state.showArchived ? 1 : 0) }, params)).then((data) => {
                    data = this._transformData(data);
                    this.core.repo.setCache('table', 'data', data, 5);
                    if (update && typeof this.table.config.updateData === 'function') {
                        this.table.config.updateData(data);
                    }
                    PopTemplate.clear();
                    return resolve(data);
                }, err => {
                    reject(err);
                });
            }
        }));
    }
    _transformData(data) {
        if (!(IsObject(this.asset.fieldKeys, true)))
            this._setFieldKeys(data[0]);
        if (!(IsObject(this.asset.transformations, true)))
            this._setFieldTableTransformations();
        data = this._prepareTableData(data);
        this.core.repo.setCache('table', 'data', data, 5);
        return data;
    }
    /**
     * Cleans the row data to remove any unwanted fields
     * @param row
     * @private
     */
    _setFieldKeys(row) {
        this.asset.fieldKeys = {};
        const Decorator = StorageGetter(this.core, ['repo', 'model', 'decorator'], null);
        if (IsCallableFunction(Decorator)) {
            row = Decorator(this.core, row);
        }
        if (IsObject(row, true)) {
            const allowedTypes = ['string', 'number', 'boolean'];
            const blacklist = StorageGetter(this.core.repo, ['model', 'table', 'blacklist'], {});
            const whitelist = StorageGetter(this.core.repo, ['model', 'table', 'whitelist'], {});
            const appendlist = StorageGetter(this.core.repo, ['model', 'table', 'appendlist'], {});
            Object.keys(row).map((key) => {
                if (!(key in blacklist)) {
                    if (key in whitelist || allowedTypes.includes(typeof row[key])) {
                        this.asset.fieldKeys[key] = 1;
                    }
                    else if (IsObject(row[key], ['id', 'name'])) {
                        this.asset.fieldKeys[key] = 1;
                    }
                }
            });
            if (IsObject(appendlist, true)) {
                Object.keys(appendlist).map((key) => {
                    this.asset.fieldKeys[key] = 1;
                });
            }
        }
    }
    /**
     * Apply the transformations to the dataset
     * @private
     */
    _setFieldTableTransformations() {
        this.asset.transformations = {};
        const fields = this.core.repo.model.field;
        Object.keys(this.asset.fieldKeys).map((key) => {
            const field = fields[key];
            if (IsObject(field, ['table', 'model'])) {
                if (field.model.name && field.table.transformation) {
                    this.asset.transformations[field.model.name] = CleanObject({
                        type: field.table.transformation.type,
                        arg1: field.table.transformation.arg1 ? field.table.transformation.arg1 : null,
                        arg2: field.table.transformation.arg2 ? field.table.transformation.arg2 : null,
                        arg3: field.table.transformation.arg3 ? field.table.transformation.arg3 : null,
                    });
                }
            }
        });
    }
    /**
     * A method that preps entity list data for tables
     * @param dataSet
     * @param fieldMap
     */
    _prepareTableData(dataSet) {
        this.log.info(`_prepareTableData: this.asset.fieldKeys`, this.asset.fieldKeys);
        const Decorator = StorageGetter(this.core, ['repo', 'model', 'decorator'], null);
        const Filter = StorageGetter(this.core, ['repo', 'model', 'filter'], null);
        const appendlist = StorageGetter(this.core.repo, ['model', 'table', 'appendlist'], {});
        if (IsArray(dataSet, true)) {
            if (Filter)
                dataSet = dataSet.filter(Filter);
            dataSet.sort(DynamicSort('id', 'desc'));
            return dataSet.map(row => {
                row = Object.keys(row).reduce((obj, k) => {
                    if (k in this.asset.fieldKeys)
                        obj[k] = row[k];
                    return obj;
                }, {});
                if (IsObject(appendlist, true)) {
                    Object.keys(appendlist).map((name) => {
                        const value = appendlist[name];
                        row[name] = ParseModelValue(value, row);
                    });
                }
                if (Decorator)
                    row = Decorator(this.core, row);
                return this.srv.pipe.transformObjectValues(row, this.asset.transformations, this.core);
            });
        }
        else {
            return dataSet;
        }
    }
    /**
     * Retrieves the data set that this view will represent
     * @param hardReset
     *
     */
    _getTableData(hardReset = false) {
        return new Promise((resolve, reject) => {
            if (this.dom.delay.data)
                clearTimeout(this.dom.delay.data);
            this.core.repo.getCache('table', 'data').then((cache) => {
                if (IsArray(cache, true)) {
                    this._triggerDataFetch();
                    return resolve({ data: cache });
                }
                else {
                    this._fetchData(false).then((data) => {
                        return resolve({ data: data });
                    });
                }
            });
        });
    }
    /**
     * Trigger the table to re-fetch the data
     * @param seconds
     * @private
     */
    _triggerDataFetch(seconds = 5) {
        this.dom.setTimeout(`lazy-load-fresh-data`, () => {
            // PopTemplate.buffer(`Loading Fresh Data`);
            this._fetchData(true).catch(() => true);
        }, (seconds * 1000)); // allows for cached data to be presented for x amount of seconds before refreshed data is triggered
    }
    /**
     * The table need to know when new entities are created or update so that they can be updated in its view
     * @param event
     *
     */
    _crudEventHandler(event) {
        this.core.repo.clearCache('table', null, `PopEntityListComponent:crudEventHandler`);
        this.core.repo.clearCache('entity', null, `PopEntityListComponent:crudEventHandler`);
        if (event.method === 'create' || event.method === 'delete') {
            this.dom.state.refresh = true;
            this.core.params.refresh = true;
        }
        else if (event.method === 'update') {
            if (event.type === 'entity') {
                if (event.name === 'archive') {
                    this._configureTable(true).then(() => true);
                }
            }
            else if (event.type === 'field' && event.name === 'patch') {
                this.dom.state.refresh = true;
                this.core.params.refresh = true;
            }
        }
        else if (event.method === 'read') {
            if (event.type === 'dialog') {
                if (event.name === 'close') {
                    this.core.repo.clearCache('table', 'data', `PopEntityListComponent:crudEventHandler`);
                    this._configureTable().then(() => true);
                }
            }
        }
    }
    /**
     * THe filter bar needs to be configured for this specific entity
     *
     */
    _configureFilterBar() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // return this.srv.filter.setActive(false);
            if (+this.core.repo.model.table.filter.active) {
                this.dom.state.filter = true;
                // this.srv.filter.setArchived(this.dom.state.showArchived);
                this.srv.filter.setView(this.core.repo.model.table.filter.view);
                this.srv.filter.setActive(true);
                this.dom.setSubscriber('filters', this.srv.filter.event.bubble.subscribe((event) => {
                    this._filterEventHandler(event);
                }));
                return resolve(true);
            }
            else {
                this.srv.filter.setActive(false);
                this.dom.state.filter = false;
                return resolve(true);
            }
        }));
    }
    /**
     * Generates a table config that will be used by the nested view component
     * @param reset
     *
     */
    _configureTable(reset = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.table.config) {
                const tableData = yield this._getTableData(reset);
                if (IsArray(tableData.data, true)) {
                    this.asset.blueprintData = tableData.data[0];
                    this.asset.blueprint = tableData.data[0];
                }
                yield this._getTableInterface();
                this.table.config = new TableConfig(Object.assign(Object.assign({}, this.asset.tableInterface), tableData));
            }
            else {
                this.table.config.loading = true;
                this._getTableData().then((result) => __awaiter(this, void 0, void 0, function* () {
                    if (IsArray(result.data, true)) {
                        this.asset.blueprintData = result.data[0];
                        this.asset.blueprint = result.data[0];
                    }
                    this.table.config.buttons = this._buildTableButtons();
                    yield Sleep(10);
                    if (reset && typeof this.table.config.reset === 'function') {
                        this.table.config.reset(result.data);
                    }
                    else {
                        if (typeof this.table.config.updateData === 'function')
                            this.table.config.updateData(result.data);
                    }
                    this.table.config.loading = false;
                    this.dom.state.refresh = false;
                    this.core.params.refresh = false;
                }));
            }
            return resolve(true);
        }));
    }
    /**
     * Allows route to have a resolvable syntax
     *
     */
    _transformRouteExtension() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!IsObject(this.extension))
                this.extension = {};
            if (IsString(this.extension.goToUrl, true)) {
                this.extension.goToUrl = ParseLinkUrl(this.extension.goToUrl, this.core.params, [':id']);
            }
            if (IsObject(this.extension.table, true)) {
                if (this.extension.table.route) {
                    this.extension.table.route = ParseLinkUrl(this.extension.table.route, this.core.params, [':id']);
                }
            }
            return resolve(true);
        }));
    }
    /**
     * Generates a table config interface to produce a config
     * @param row
     *
     */
    _getTableInterface() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // this.loading = true;
            // Clear any session for previous viewing history
            if (IsObject(this.asset.tableInterface, true)) {
                return resolve(true);
            }
            else {
                yield this._getDefaultFieldKeys();
                const defaultColumns = yield this._getDefaultColumns();
                let userColumns;
                if (IsObject(this.core.preference, ['table']) && IsObject(this.core.preference.table.columns, true)) {
                    userColumns = this.core.preference.table.columns;
                }
                if (!userColumns)
                    userColumns = defaultColumns;
                // console.log('defaultColumns', defaultColumns);
                // console.log('userColumns', userColumns);
                // console.log('get', this.asset.searchValueSessionPath);
                let baseApp = (this.core.params.app ? this.core.params.app : PopHref);
                baseApp = baseApp ? `/${baseApp}/` : '/';
                let tableInterface = {
                    id: this.core.params.internal_name,
                    internal_name: this.core.params.internal_name,
                    paginator: true,
                    height: this._getTableHeight(),
                    buttons: this._buildTableButtons(),
                    route: `${baseApp}${GetRouteAlias(this.core.params.internal_name)}/:id/general`,
                    data: [],
                    searchValue: GetSessionSiteVar(this.asset.searchValueSessionPath, ''),
                    options: new TableOptionsConfig(Object.assign({ defaultOptions: { columnDefinitions: defaultColumns } }, this.core.repo.model.table.permission)),
                    columnDefinitions: userColumns
                };
                if (this.extension.goToUrl)
                    this.extension.goToUrl = ParseModelValue(this.extension.goToUrl, this.core, true);
                if (this.extension.table && this.extension.table.route)
                    this.extension.table.route = ParseModelValue(this.extension.table.route, this.core, true);
                if (this.extension.table && Object.keys(this.extension.table).length)
                    tableInterface = Object.assign(Object.assign({}, tableInterface), this.extension.table);
                if (IsObject(this.core.preference, ['table'])) {
                    // console.log('this.core.preference.table.options', this.core.preference.table.options);
                    if (this.core.preference.table.options) {
                        tableInterface = Object.assign(Object.assign({}, tableInterface), this.core.preference.table.options);
                    }
                }
                this.asset.tableInterface = tableInterface;
                return resolve(true);
            }
        }));
    }
    /**
     * A table will have a set of actions that it will need a button set to achieve
     *
     */
    _buildTableButtons() {
        let buttons = [];
        if (IsObject(this.core.repo.model.table.button, true)) {
            buttons = this.table.buttons.filter((button) => {
                // if( button.id === 'custom' && !this.core.repo.model.table.button.custom ) return false; // allow custom actions to be performed on a set of entities
                // if( button.id === 'advanced_search' && !this.core.repo.model.table.button.advanced_search ) return false; // allow for a advanced search on the entity data set
                if (button.id === 'archive' && (!this.core.repo.model.table.button.archived || this.dom.state.showArchived))
                    return false;
                if (button.id === 'restore' && (!this.core.repo.model.table.button.archived || !this.dom.state.showArchived))
                    return false;
                if (button.id === 'show_active' && (!this.core.repo.model.table.button.archived || !this.dom.state.showArchived))
                    return false;
                if (button.id === 'show_archived' && (!this.core.repo.model.table.button.archived || this.dom.state.showArchived))
                    return false;
                if (button.id === 'new' && !this.core.repo.model.table.button.new)
                    return false;
                if (!button.accessType)
                    return true;
                if (!this.srv.entity.checkAccess(this.core.params.internal_name, button.accessType))
                    return false;
                return true;
            });
        }
        return buttons;
    }
    /**
     * The filter bar and the table view need to be in sync
     * @param event
     *
     */
    _filterEventHandler(event) {
        this.log.event(`_filterEventHandler`, event);
        if (event.type === 'filter') {
            switch (event.name) {
                case 'clear':
                case 'apply':
                    this.srv.entity.bustAllCache();
                    this.dom.setTimeout('reconfigure-table', () => {
                        this._configureTable().then(() => true);
                    }, 0);
                    break;
                case 'init':
                case 'state':
                    if (event.model === 'open') {
                        this.onResetHeight();
                    }
                    break;
                default:
                    break;
            }
        }
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Allows the route to set/override specific settings
     *
     */
    _setRouteExtension() {
        if (!this.extension)
            this.extension = {};
        if (!this.extension.table)
            this.extension.table = {};
        if (!this.extension.goToUrl)
            this.extension.goToUrl = null;
        if (this.route.snapshot.data && Object.keys(this.route.snapshot.data).length) {
            Object.keys(this.route.snapshot.data).map((key) => {
                this.extension[key] = this.route.snapshot.data[key];
            });
        }
    }
    _getDefaultFieldKeys() {
        return new Promise((resolve) => {
            if (IsObject(this.asset.fieldKeys, true)) {
                return resolve(true);
            }
            else {
                this.core.repo.getCache('table', 'fieldKeys').then((fieldKeys) => {
                    if (IsObject(fieldKeys, true)) {
                        this.asset.fieldKeys = fieldKeys;
                    }
                    else {
                        this._setFieldKeys(this.asset.blueprint);
                    }
                    return resolve(true);
                }, () => {
                    this._setFieldKeys(this.asset.blueprint);
                    return resolve(true);
                });
            }
        });
    }
    _getDefaultColumns() {
        return new Promise((resolve) => {
            let defaultColumns = {};
            this.core.repo.getCache('table', 'columns').then((columns) => {
                if (IsObject(columns, true)) {
                    return resolve(columns);
                }
                else {
                    defaultColumns = {};
                    const fields = IsObjectThrowError(this.core.repo.model.field, true, `Repo contained no field model`) ? this.core.repo.model.field : null;
                    if (IsObject(this.asset.fieldKeys, true)) {
                        Object.keys(this.asset.fieldKeys).map((fieldName) => {
                            if (fieldName in fields) {
                                const field = fields[fieldName];
                                if (IsObject(field.model, ['route'])) {
                                    field.model.route = ParseModelValue(field.model.route, this.core);
                                }
                                if (field.table.visible)
                                    defaultColumns[fieldName] = Object.assign({
                                        name: field.model.name,
                                        label: field.model.label,
                                    }, field.table);
                            }
                        });
                    }
                    else {
                        // console.log('cache redirect');
                        // console.log(this.asset.blueprintData);
                        // SetPopCacheRedirectUrl(this.srv.router.url);
                        // this.srv.router.navigateByUrl('system/cache/clear',{skipLocationChange:true});
                    }
                    if (IsObject(defaultColumns, true)) {
                        this.core.repo.setCache('table', 'columns', defaultColumns, 60);
                    }
                    return resolve(defaultColumns);
                }
            });
        });
    }
    /**
     * Helper function that sets the height of the child view
     *
     */
    _getTableHeight() {
        let height = this.dom.height.inner;
        if (this.srv.filter.isActive()) {
            height -= 20;
        }
        return height;
    }
}
PopEntityListComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-list',
                template: "<div class=\"entity-list-container\" [style.height.px]=\"dom.height.inner\" [ngStyle]=\"!dom.state.filter && {'margin-top': '25px'}\" (window:resize)=\"onResetTable();\">\n  <lib-pop-table #list *ngIf=\"table.config\" [core]=core [config]=\"table.config\" (events)=\"onTableEvent($event)\"></lib-pop-table>\n  <div class=\"entity-list-spinner-box\" *ngIf=\"dom.state.loader\">\n    <lib-main-spinner></lib-main-spinner>\n  </div>\n</div>\n<!--<lib-pop-field-item-group *ngIf=\"ui.actionModal\" [config]=\"ui.actionModal\" (close)=\"onActionModalClose()\"></lib-pop-field-item-group>-->\n<lib-pop-errors *ngIf=\"dom.error?.message\" [error]=\"dom.error\"></lib-pop-errors>\n",
                providers: [PopDomService],
                styles: [".entity-list-container{position:relative;display:flex;width:auto;height:auto;flex-direction:column;box-sizing:border-box;margin:5px 25px 0}.entity-list-container lib-pop-table{position:absolute;left:0;top:0;right:0;bottom:10px}:host ::ng-deep tr{height:48px;max-height:48px}:host ::ng-deep td,:host ::ng-deep th{min-width:50px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;height:48px;max-height:48px}:host ::ng-deep th>.mat-sort-header-container{display:flex;min-width:50px}:host ::ng-deep .checkbox-column{min-width:25px!important;width:25px!important;padding:0 5px!important;text-align:center!important}::ng-deep th[class*=fk],:host ::ng-deep td[class*=fk]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=fk]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=id],:host ::ng-deep th[class*=id]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=active]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=active],:host ::ng-deep th[class*=active]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=system]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=system],:host ::ng-deep th[class*=system]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=id]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=-name],:host ::ng-deep th[class*=-name]{text-align:left!important;padding-left:20px!important;max-width:200px}:host ::ng-deep th[class*=-name] .mat-sort-header-container{padding-left:0!important;justify-content:left!important;max-width:500px}:host ::ng-deep td[class*=-first],:host ::ng-deep th[class*=-first]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-first] .mat-sort-header-container{min-width:50px!important;padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-last],:host ::ng-deep th[class*=-last]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-last] .mat-sort-header-container{padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-display],:host ::ng-deep th[class*=-display]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-display] .mat-sort-header-container{padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-description],:host ::ng-deep th[class*=-description]{text-align:left!important;padding-left:20px!important;max-width:500px}:host ::ng-deep th[class*=-description] .mat-sort-header-container{padding-left:0!important;justify-content:left!important;max-width:500px}:host ::ng-deep td[class*=email],:host ::ng-deep th[class*=email]{min-width:50px!important;text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=email] .mat-sort-header-container{min-width:50px!important;padding-left:0!important;justify-content:left!important}.entity-list-spinner-box{height:75vh}"]
            },] }
];
PopEntityListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ActivatedRoute },
    { type: PopDomService },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];
PopEntityListComponent.propDecorators = {
    internal_name: [{ type: Input }],
    extension: [{ type: Input }],
    list: [{ type: ViewChild, args: ['list',] }],
    dataFactory: [{ type: Input }]
};

class PopEntityAccessComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.srv = GetServiceContainer();
        this.name = 'PopEntityAccessComponent';
        this.extendServiceContainer();
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.state.expansion = 'compact';
                this.core.repo.getEntity(this.core.params.entityId, { select: 'permissions' }).subscribe((res) => {
                    const entity = res.data ? res.data : res.data;
                    let appDisabled;
                    let appHasEntitiesAccess, appEntitiesWithAccess;
                    this.ui.access = IsArrayThrowError(entity.permissions, true, `${this.name}:configure: - entity.permissions`) ? DeepCopy(entity.permissions) : [];
                    this.ui.access.forEach((app) => {
                        app.expanded = false;
                        appDisabled = this.core.entity.system || !this.core.access.can_update || app.entities.length === 0 ? true : false;
                        app.can_read = { all: app.entities.length ? true : false, disabled: appDisabled, indeterminate: app.entities.length ? true : false };
                        app.can_create = { all: app.entities.length ? true : false, disabled: appDisabled, indeterminate: app.entities.length ? true : false };
                        app.can_update = { all: app.entities.length ? true : false, disabled: appDisabled, indeterminate: app.entities.length ? true : false };
                        app.can_delete = { all: app.entities.length ? true : false, disabled: appDisabled, indeterminate: app.entities.length ? true : false };
                        appHasEntitiesAccess = { can_read: 0, can_create: 0, can_update: 0, can_delete: 0 };
                        appEntitiesWithAccess = { can_read: 0, can_create: 0, can_update: 0, can_delete: 0 };
                        app.entities.forEach((entityToken) => {
                            entityToken.field = {};
                            Object.keys(entityToken.access).forEach((entityAccess) => {
                                entityToken.field[entityAccess] = new CheckboxConfig({
                                    align: 'left',
                                    // patch: { path: `admin/security-profiles/${this.tab.securityProfile.id}/entities/add`, field: access, metadata: { access: 1, entity_fk: entity.id } },
                                    bubble: true,
                                    value: +entityToken.access[entityAccess],
                                    disabled: this.core.entity.system || !entityToken[entityAccess] ? true : false,
                                    metadata: {
                                        app: app,
                                        entity: entityToken,
                                        access: entityAccess,
                                    },
                                });
                                if (entityToken[entityAccess])
                                    appHasEntitiesAccess[entityAccess]++;
                                if (entityToken.access[entityAccess])
                                    appEntitiesWithAccess[entityAccess]++;
                                if (+entityToken.access[entityAccess] === 0) {
                                    if (entityAccess in app) {
                                        app[entityAccess].all = false;
                                    }
                                }
                            });
                        });
                        // if none of the entities are able to use an access just disable the all checkbox
                        Object.keys(appHasEntitiesAccess).forEach((entityAccess) => {
                            if (!appHasEntitiesAccess[entityAccess] && entityAccess in app)
                                app[entityAccess].disabled = true;
                            if (app[entityAccess].all)
                                app[entityAccess].indeterminate = false;
                            if (appEntitiesWithAccess[entityAccess] && !app[entityAccess].all)
                                app[entityAccess].indeterminate = true;
                            if (!appEntitiesWithAccess[entityAccess] && !app[entityAccess].all)
                                app[entityAccess].indeterminate = false;
                        });
                    });
                    this.setExpansionState(this.dom.state.expansion);
                    resolve(true);
                }, err => {
                    this.dom.error = {
                        code: err.error ? err.error.code : err.status,
                        message: err.error ? err.error.message : err.statusText
                    };
                    resolve(false);
                });
            });
        };
    }
    extendServiceContainer() {
        this.srv.request = ServiceInjector.get(PopRequestService);
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    checkAll(app, access) {
        if (app && access in app) {
            let all = true, indeterminate = false;
            const entity_fks = [];
            const value = +app[access].all;
            if (app.entities.length) {
                all = +value === 1;
                app.entities.forEach((entity) => {
                    if (!this.core.entity.system && this.core.access.can_update && entity[access]) {
                        if (+entity.field[access].control.value !== value) {
                            // entity.field[ access ].patch.running = true;
                            entity.access[access] = value;
                            entity.field[access].control.setValue(value);
                            entity.field[access].message = '';
                            entity.field[access].startPatch();
                            entity_fks.push(entity.id);
                        }
                    }
                    else {
                        if (+entity.field[access].control.value !== value) {
                            indeterminate = true;
                            all = !value;
                        }
                    }
                });
                if (entity_fks.length) {
                    const patch = { access: 1, entity_fk: entity_fks.join() };
                    patch[access] = value;
                    const method = patch[access] === 1 ? 'add' : 'remove';
                    this.srv.request.doPatch(`${this.core.params.path}/${this.core.params.entityId}/entities/${method}`, patch, 1).subscribe(res => {
                        app.entities.forEach((entity) => {
                            entity.field[access]._patchSuccess();
                        });
                        setTimeout(() => {
                            app[access].all = all;
                            app[access].indeterminate = indeterminate;
                        });
                        const sendEvent = {
                            source: this.name,
                            type: 'permissions',
                            model: 'entity',
                            name: 'patch',
                            method: 'update',
                            success: true,
                            config: this.core,
                            data: app,
                            ids: entity_fks,
                            access: access,
                            value: patch[access]
                        };
                        this.sessionChanges(sendEvent);
                        if (this.log.repo.enabled('event', this.name))
                            console.log(this.log.repo.message(`${this.name}:event`), this.log.repo.color('event'), sendEvent);
                    }, err => {
                        app.entities.forEach((entity) => {
                            entity.patchFail((err.error && err.error.message) ? err.error.message : err.message);
                        });
                        setTimeout(() => {
                            app[access].all = all;
                            app[access].indeterminate = indeterminate;
                        });
                        this.dom.error = {
                            code: (err.error ? err.error.code : err.status),
                            message: (err.error ? err.error.message : err.statusText)
                        };
                    });
                }
                else {
                    setTimeout(() => {
                        // app[ access ].all = all;
                        app[access].indeterminate = true;
                    });
                }
            }
            else {
                setTimeout(() => {
                    app[access].all = false;
                    app[access].indeterminate = false;
                });
            }
        }
    }
    setExpansionState(state) {
        if (state) {
            this.dom.state.expansion = state;
        }
        switch (this.dom.state.expansion) {
            case 'none':
                this.ui.access.forEach(function (app) {
                    app.expanded = false;
                });
                break;
            case 'compact':
                this.ui.access.forEach(function (app) {
                    app.expanded = app.can_read.indeterminate || app.can_update.indeterminate || app.can_create.indeterminate || app.can_delete.indeterminate ? true : false;
                });
                break;
            case 'full':
                this.ui.access.forEach(function (app) {
                    app.expanded = true;
                });
                break;
            default:
                break;
        }
    }
    handleInputEvents(event) {
        if (event.type === 'field') {
            if (this.log.repo.enabled())
                console.log(this.log.repo.message('PopEntityAccessComponent:event'), this.log.repo.color('event'), event);
            switch (event.name) {
                case 'onChange':
                    const patch = { access: 1, entity_fk: event.config.metadata.entity.id };
                    patch[event.config.metadata.access] = +event.config.control.value;
                    const method = +event.config.control.value === 1 ? 'add' : 'remove';
                    event.config.startPatch();
                    this.srv.request.doPatch(`${this.core.params.path}/${this.core.params.entityId}/entities/${method}`, patch, 1).subscribe(() => {
                        event.config._patchSuccess();
                        this.checkAppAll(event.config.metadata.app, event.config.metadata.access, +event.config.control.value);
                        const sendEvent = {
                            source: this.name,
                            method: 'update',
                            model: 'entity',
                            type: 'permissions',
                            name: 'patch',
                            success: true,
                            config: this.core,
                            data: event.config.metadata.app,
                            ids: [event.config.metadata.entity.id],
                            access: event.config.metadata.access,
                            value: patch[event.config.metadata.access]
                        };
                        setTimeout(() => {
                            this.sessionChanges(sendEvent);
                        }, 0);
                    }, err => {
                        event.config.patchFail((err.error && err.error.message) ? err.error.message : err.message);
                    });
                    break;
                case patch:
                    if (event.success) {
                        this.checkAppAll(event.config.metadata.app, event.config.metadata.access, event.config.control.value);
                    }
                    break;
                default:
                    break;
            }
        }
    }
    checkAppAll(app, access, val) {
        val = +val;
        let indeterminate = false;
        let all = true;
        if (!val) {
            all = false;
            app.entities.some(entity => {
                if (entity.field[access].control.value) {
                    indeterminate = true;
                    return true;
                }
            });
        }
        else {
            app.entities.some(entity => {
                if (!entity.field[access].control.value) {
                    all = false;
                    indeterminate = true;
                    return true;
                }
            });
        }
        setTimeout(() => {
            app[access].all = all;
            app[access].indeterminate = indeterminate;
        });
    }
    sessionChanges(event) {
        let appId;
        let storedPermissions;
        let storedApp;
        let storedEntity;
        if (event.type === 'permissions' && event.name === 'patch' && event.success && event.config && +event.config.params.id === +this.core.entity.id) {
            if (this.log.repo.enabled('event', this.name))
                console.log(`${this.name} made an access permissions patch session`, this.log.repo.color('event'), event);
            if (this.core.entity.metadata && this.core.entity.metadata.permissions) {
                storedPermissions = this.core.entity.metadata.permissions;
                appId = event.data.id;
                const appMap = ArrayMapSetter(storedPermissions, 'id');
                if (appId in appMap) {
                    if (IsArray(storedPermissions[appMap[appId]].entities, true)) {
                        storedApp = storedPermissions[appMap[appId]];
                        const entityMap = ArrayMapSetter(storedApp.entities, 'id');
                        if (IsArray(event.ids, true)) {
                            event.ids.map((entityID) => {
                                if (entityID in entityMap) {
                                    storedEntity = storedApp.entities[entityMap[entityID]];
                                    if (storedEntity.access && event.access in storedEntity.access)
                                        storedEntity.access[event.access] = event.value;
                                }
                            });
                        }
                    }
                }
            }
            return true;
        }
    }
    toggleApp(app) {
        app.expanded = !app.expanded;
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityAccessComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-access',
                template: "<div class=\"access-permissions-container\">\n  <div class=\"sw-label-container\">\n    Access Permissions\n    <mat-form-field class=\"access-expansion-state-select\" appearance=\"outline\">\n      <mat-label>Expand</mat-label>\n      <mat-select [(ngModel)]=\"dom.state.expansion\" (selectionChange)=\"setExpansionState();\">\n        <mat-option value=\"none\">None</mat-option>\n        <mat-option value=\"compact\">Compact</mat-option>\n        <mat-option value=\"full\">Full</mat-option>\n      </mat-select>\n    </mat-form-field>\n    <!--<mat-icon class=\"admin-icon-top-right\"-->\n    <!--[ngClass]=\"{'sw-hidden': state.expansion === 'full'}\"-->\n    <!--matTooltip=\"Expand\"-->\n    <!--matTooltipPosition=\"left\"-->\n    <!--(click)=\"setExpansionState('full');\">expand_more</mat-icon>-->\n    <!--<mat-icon class=\"admin-icon-top-right\"-->\n    <!--[ngClass]=\"{'sw-hidden': state.expansion === 'compact'}\"-->\n    <!--matTooltip=\"Compact\"-->\n    <!--matTooltipPosition=\"left\"-->\n    <!--(click)=\"setExpansionState('compact');\">expand_less</mat-icon>-->\n  </div>\n  <mat-divider></mat-divider>\n  <div class=\"access-filter-bar-loader\">\n    <mat-progress-bar *ngIf=\"dom.state.loading\" mode=\"indeterminate\"></mat-progress-bar>\n  </div>\n  <div class=\"access-permissions-content\">\n    <mat-accordion *ngIf=\"ui.access\" multi=\"true\" [displayMode]=\"'flat'\">\n      <mat-expansion-panel *ngFor=\"let app of ui.access\" [ngClass]=\"{'sw-hidden':!app.entities.length}\"\n                           [expanded]=\"app.expanded\" hideToggle=\"true\">\n        <mat-expansion-panel-header>\n          <div class=\"access-app-permission-header pt-bg-1\" (click)=\"$event.stopPropagation();\">\n            <div class=\"access-app-title-container mat-h2\">\n              <div class=\"access-app-title\">{{app.name}}</div>\n              <div class=\"access-app-toggle-container\">\n                <mat-icon *ngIf=\"!app.expanded\" (click)=\"toggleApp(app);\">keyboard_arrow_right\n                </mat-icon>\n                <mat-icon *ngIf=\"app.expanded\" (click)=\"toggleApp(app);\">keyboard_arrow_down\n                </mat-icon>\n              </div>\n            </div>\n            <div class=\"access-spacer\"></div>\n            <div class=\"access-app-permission-container\">\n              <mat-checkbox [(ngModel)]=\"app.can_read.all\"\n                            [indeterminate]=\"app.can_read.indeterminate\"\n                            (change)=\"checkAll(app, 'can_read');\" [disabled]=\"app.can_read.disabled\">\n                View\n              </mat-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <mat-checkbox [(ngModel)]=\"app.can_create.all\"\n                            [indeterminate]=\"app.can_create.indeterminate\"\n                            (change)=\"checkAll(app, 'can_create');\"\n                            [disabled]=\"app.can_create.disabled\">Create\n              </mat-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <mat-checkbox [(ngModel)]=\"app.can_update.all\"\n                            [indeterminate]=\"app.can_update.indeterminate\"\n                            (change)=\"checkAll(app, 'can_update');\"\n                            [disabled]=\"app.can_update.disabled\">Edit\n              </mat-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <mat-checkbox [(ngModel)]=\"app.can_delete.all\"\n                            [indeterminate]=\"app.can_delete.indeterminate\"\n                            (change)=\"checkAll(app, 'can_delete');\"\n                            [disabled]=\"app.can_delete.disabled\">Delete\n              </mat-checkbox>\n            </div>\n          </div>\n        </mat-expansion-panel-header>\n        <div class=\"mat-expansion-panel-body\">\n          <div class=\"access-app-entity-header\" *ngFor=\"let entity of app.entities\">\n            <div class=\"access-entity-title-container mat-h2\">\n              <div class=\"access-entity-title\">{{entity.name}}</div>\n            </div>\n            <div class=\"access-spacer\"></div>\n            <div class=\"access-app-permission-container\">\n              <lib-pop-checkbox [config]=\"entity.field.can_read\"\n                                (events)=\"handleInputEvents($event)\"></lib-pop-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <lib-pop-checkbox [config]=\"entity.field.can_create\"\n                                (events)=\"handleInputEvents($event)\"></lib-pop-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <lib-pop-checkbox [config]=\"entity.field.can_update\"\n                                (events)=\"handleInputEvents($event)\"></lib-pop-checkbox>\n            </div>\n            <div class=\"access-app-permission-container\">\n              <lib-pop-checkbox [config]=\"entity.field.can_delete\"\n                                (events)=\"handleInputEvents($event)\"></lib-pop-checkbox>\n            </div>\n          </div>\n        </div>\n      </mat-expansion-panel>\n    </mat-accordion>\n  </div>\n</div>\n",
                styles: [":host{flex:1 1}.access-permissions-container{flex:1 1;padding:0 20px}.access-permissions-content{flex:1 1 100%;height:calc(100vh - 235px);clear:both;overflow-y:scroll;overflow-x:hidden;padding-top:2px}.access-expansion-state-select{position:absolute;right:5px;top:0;max-width:200px}.access-app-permission-header{flex:1 1 100%;min-height:48px;display:flex;justify-content:flex-start;flex-direction:row;align-items:center;border-top:1px solid #ccc;border-bottom:1px solid #ccc}.access-app-title-container{display:flex;height:48px;padding:0 0 0 2%;pointer-events:all;align-items:center;width:30%;max-width:30%;overflow:hidden}.access-spacer{display:flex;flex-grow:1;height:48px;padding:0 1%}.access-app-title{font-size:18px}.access-app-title,.access-entity-title{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.access-entity-title{font-size:16px}.access-app-permission-container{min-width:16%}.access-app-toggle-container{display:flex;margin-left:10px;align-items:center;height:48px}.access-app-entity-header{flex:1 1 100%;min-height:48px;display:flex;justify-content:flex-start;flex-direction:row;align-items:center;border-bottom:1px solid #ccc}.access-entity-title-container{display:flex;height:48px;padding:0 0 0 3%;pointer-events:all;align-items:center;width:30%;max-width:30%}.access-filter-bar-loader{position:relative;display:block;width:100%;height:7px;clear:both}:host ::ng-deep.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:none!important}:host ::ng-deep mat-expansion-panel{margin-bottom:40px!important;border:1px solid #ccc}:host ::ng-deep .mat-expansion-panel-body{padding:0!important}:host ::ng-deep mat-expansion-panel-header{padding:0!important;max-height:48px!important}"]
            },] }
];
PopEntityAccessComponent.ctorParameters = () => [
    { type: ElementRef }
];

class PopEntityFieldActionBtnComponent {
    constructor(env) {
        this.env = env;
        this.events = new EventEmitter();
    }
    ngOnInit() {
        if (!this.action)
            this.action = 'add';
        this.tooltip = TitleCase(this.action);
    }
    callAction() {
        this.events.emit({ source: 'PopEntityFieldActionBtnComponent', type: 'field', name: this.action, field: this.field });
    }
    ngOnDestroy() {
    }
}
PopEntityFieldActionBtnComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-field-btn',
                template: `
    <div class="field-action-btn" *ngIf="field.multiple">
      <mat-icon class="sw-pointer" matTooltip="{{tooltip}}" matTooltipPosition="above" (click)="callAction();">{{action}}</mat-icon>
    </div>
  `,
                styles: ['.field-doAction-btn {background: var(--bg-1);border-radius: 50%;width: 14px;height: 14px; mar-top:2px; color: var(--accent);border-width: 1px;border-style: solid;border-color: var(--bg-3);box-shadow: 0 2px 5px 0 var(--darken18), 0 2px 10px 0 var(--darken12) !important; } .field-doAction-btn mat-icon {position:relative; top:-2px; left:1px; width: 12px;height: 12px;font-size: 12px;line-height: 16px;}']
            },] }
];
PopEntityFieldActionBtnComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['env',] }] }
];
PopEntityFieldActionBtnComponent.propDecorators = {
    field: [{ type: Input }],
    action: [{ type: Input }],
    events: [{ type: Output }]
};

class PopEntityFieldEditIconComponent {
    constructor() {
        this.events = new EventEmitter();
    }
    ngOnInit() {
    }
    onEdit() {
        this.dom.state.open = true;
        this.field.state = 'template_edit';
        this.events.emit({ source: 'PopEntityFieldEditIconComponent', type: 'field', name: 'edit', field: this.field });
    }
}
PopEntityFieldEditIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-edit-icon',
                template: "<mat-icon class=\"sw-pointer\" (click)=\"onEdit();\" [ngClass]=\"{'sw-disabled':this.dom.state.open}\">\n  edit\n</mat-icon>\n\n",
                styles: [""]
            },] }
];
PopEntityFieldEditIconComponent.ctorParameters = () => [];
PopEntityFieldEditIconComponent.propDecorators = {
    dom: [{ type: Input }],
    field: [{ type: Input }],
    events: [{ type: Output }]
};

class PopEntityFieldDashComponent {
}
PopEntityFieldDashComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-dash',
                template: `
    <div class="entity-field-dash">
      <mat-icon>
        remove
      </mat-icon>
    </div>
  `,
                styles: [':host ::ng-deep mat-icon {width: auto; height: auto; font-size: .9em;} .entityId-field-dash { display: flex;align-items: center; justify-content: center; box-sizing: border-box; height: 100%; }']
            },] }
];

class PopEntityFieldSpacerComponent {
    constructor() {
    }
    ngOnInit() {
    }
}
PopEntityFieldSpacerComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-spacer',
                template: '<div class="entityId-field-spacer sw-clear"></div>',
                styles: ['.entityId-field-spacer { display: flex; height: 10px; clear:both; }']
            },] }
];
PopEntityFieldSpacerComponent.ctorParameters = () => [];

class PopEntityTabColumnComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.name = 'PopEntityTabColumnComponent';
        this.srv = {
            tab: undefined
        };
        this.ui = {
            tabId: undefined,
        };
        this.dom.configure = () => {
            return new Promise((resolve) => {
                //  Enforce CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:: - this.core`) ? this.core : null;
                //  Set Attributes
                this.position = +this.column.id;
                this.id = this.column.id;
                // Event Handlers
                this.trait.bubble = true; // passes bubble events up to parent
                this.dom.handler.bubble = (core, event) => {
                    this.onBubbleEvent(event);
                };
                const tab = this.srv.tab.getTab();
                if (tab && tab.id) {
                    this.ui.tabId = tab.id;
                }
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setSubscriber('name-reset', this.column.reset.subscribe((e) => this._onColumnResetEvent(e)));
                this._determineHeight();
                // Attach Template Container
                this.template.attach('container');
                //  Render the dynamic list of components
                this._templateRender();
                return resolve(true);
            });
        };
    }
    /**
     * The component should take a specific section/column of a defined tab, and dynamically render all of the components that belong in that section
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Event handler for the parent tab to tell this column to reset itself
     * @param reset
     */
    onBubbleEvent(event) {
        this.log.event(`onBubbleEvent`, event);
        if (IsValidFieldPatchEvent(this.core, event) || event.type === 'context_menu') {
            this.events.emit(event);
        }
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        this._setScrollTop();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Event handler for the parent tab to tell this column to reset itself
     * @param reset
     */
    _onColumnResetEvent(reset) {
        if (reset && typeof reset === 'boolean') {
            if (this.dom.delay.render)
                clearTimeout(this.dom.delay.render);
            this.dom.delay.render = setTimeout(() => {
                this._templateRender();
            }, 250);
        }
        else if (typeof reset === 'string') {
            if (reset === 'scrollTop') {
                this._setScrollTop();
            }
        }
    }
    /**
     * Helper function that determines what the height of this component should be
     *
     */
    _determineHeight() {
        this.dom.state.hasHeader = this.column.header ? true : false;
        const columnHeight = StorageGetter(this.dom.repo, ['position', String(this.column.id), 'height'], 650);
        this.dom.height.outer = +columnHeight;
        this.dom.height.inner = this.dom.height.outer - 30;
    }
    /**
     * Helper function that renders the list of dynamic components
     *
     */
    _templateRender() {
        const transfer = ['core', 'position'];
        if (IsObject(this.column.extension, true)) {
            this.extension = this.column.extension;
            transfer.push('extension');
        }
        const components = IsArray(this.column.components, true) ? this.column.components : [];
        this.template.render(components, transfer);
        this._applyScrollTop();
    }
    /**
     * Reaches up to the parent container and sets the current scroll position
     * The parent container component uses an *ngIf that prevents using @viewChild to do this
     */
    _applyScrollTop() {
        setTimeout(() => {
            if (this.dom.session.scroll && this.ui.tabId && this.dom.session.scroll[this.ui.tabId]) {
                this.el.nativeElement.parentElement.scrollTop = this.dom.session.scroll[this.ui.tabId];
            }
        }, 0);
    }
    /**
     * Reaches up to the parent container and stores the current scroll position
     * The parent container component uses an *ngIf that prevents using @viewChild to do this
     */
    _setScrollTop() {
        if (!this.dom.session.scroll)
            this.dom.session.scroll = {};
        if (this.ui.tabId) {
            this.dom.session.scroll[this.ui.tabId] = this.el.nativeElement.parentElement.scrollTop;
        }
    }
}
PopEntityTabColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-tab-column',
                template: '<ng-template #container></ng-template>'
            },] }
];
PopEntityTabColumnComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopTabMenuService }
];
PopEntityTabColumnComponent.propDecorators = {
    column: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    extension: [{ type: Input }]
};

class FieldInputSettingComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.name = 'FieldInputSettingComponent';
        /**
         * Configure the specifics of this component
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.ui.param = new InputConfig({
                    label: this.config.label,
                    name: this.config.name,
                    value: IsDefined(this.config.value) ? this.config.value : this.config.defaultValue,
                    readonly: this.config.readonly,
                    patch: this.config.patch
                });
                return resolve(true);
            });
        };
    }
    /**
     * This component will product an html field to capture a field item setting value
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Handle events from the data capture
     * @param event
     */
    onBubbleEvent(event) {
        this.events.emit(event);
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
FieldInputSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-asset-param',
                template: `
    <lib-pop-input (events)="onBubbleEvent($event);" [config]=ui.param></lib-pop-input><div class="sw-mar-vrt-sm sw-clear"></div>`
            },] }
];
FieldInputSettingComponent.ctorParameters = () => [
    { type: ElementRef }
];
FieldInputSettingComponent.propDecorators = {
    config: [{ type: Input }]
};

class FieldLabelSettingComponent {
    constructor(commonRepo, changeDetectorRef) {
        this.commonRepo = commonRepo;
        this.changeDetectorRef = changeDetectorRef;
        this.state = {
            selected: 0,
            system: false,
            loaded: false,
            loading: false,
            error: { code: 0, message: '' },
        };
        this.subscriber = {
            data: undefined,
        };
        this.field = {
            type: '',
            items: undefined,
            active: {},
        };
        this.active = {
            item: undefined
        };
        this.models = {};
        this.configs = {};
    }
    ngOnInit() {
    }
}
FieldLabelSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-asset-param',
                template: `
    <div class="field-builder-param-container">
      <div class="field-builder-param-title-container mat-h2">
        <div class="field-builder-param-title">{{config.name}}</div>
      </div>
    </div>`
            },] }
];
FieldLabelSettingComponent.ctorParameters = () => [
    { type: PopCommonService },
    { type: ChangeDetectorRef }
];
FieldLabelSettingComponent.propDecorators = {
    config: [{ type: Input }]
};

class FieldRadioSettingComponent {
    constructor(commonRepo, changeDetectorRef) {
        this.commonRepo = commonRepo;
        this.changeDetectorRef = changeDetectorRef;
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new RadioConfig({
            label: this.config.label,
            name: this.config.name,
            layout: 'row',
            value: this.config.value,
            patch: this.config.patch,
            options: this.config.options
        });
    }
    ngOnDestroy() {
    }
}
FieldRadioSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-radio-param',
                template: `<lib-pop-radio (events)="events.emit($event);" [config]=param></lib-pop-radio><div class="sw-mar-vrt-sm sw-clear"></div>`
            },] }
];
FieldRadioSettingComponent.ctorParameters = () => [
    { type: PopCommonService },
    { type: ChangeDetectorRef }
];
FieldRadioSettingComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldSelectSettingComponent {
    constructor() {
        this.events = new EventEmitter();
        this.state = {
            selected: 0,
            system: false,
            loaded: false,
            loading: false,
            error: { code: 0, message: '' },
        };
        this.subscriber = {
            data: undefined,
        };
        this.field = {
            type: '',
            items: undefined,
            active: {},
        };
        this.active = {
            item: undefined
        };
        this.models = {};
        this.configs = {};
    }
    ngOnInit() {
        this.param = new SelectConfig({
            label: this.config.label,
            name: this.config.name,
            value: this.config.value ? this.config.value : this.config.default,
            options: { values: ConvertArrayToOptionList(this.config.options.values) },
            patch: this.config.patch
        });
    }
}
FieldSelectSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-select-setting',
                template: `
    <lib-pop-select (events)="events.emit($event);" [config]=param></lib-pop-select><div class="sw-mar-vrt-sm sw-clear"></div>`
            },] }
];
FieldSelectSettingComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldSwitchSettingComponent {
    constructor(commonRepo, changeDetectorRef) {
        this.commonRepo = commonRepo;
        this.changeDetectorRef = changeDetectorRef;
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new SwitchConfig({
            label: this.config.label,
            name: this.config.name,
            value: this.config.value,
            patch: this.config.patch
        });
    }
}
FieldSwitchSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-switch-setting',
                template: `<lib-pop-switch (events)="events.emit($event);" [config]=param></lib-pop-switch>`
            },] }
];
FieldSwitchSettingComponent.ctorParameters = () => [
    { type: PopCommonService },
    { type: ChangeDetectorRef }
];
FieldSwitchSettingComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldTextareaSettingComponent {
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new TextareaConfig({
            label: this.config.label,
            name: this.config.name,
            value: this.config.value ? this.config.value : this.config.default,
            height: 70,
        });
    }
}
FieldTextareaSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-textarea-setting',
                template: `<lib-pop-textarea (events)="events.emit($event);" [config]=param></lib-pop-textarea>`
            },] }
];
FieldTextareaSettingComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FieldTextareaSettingComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopEntityAssetComponentModalComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = {};
        this.name = 'PopEntityAssetComponentModalComponent';
        /**
         * Configure the specifics of this component
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                resolve(true);
            });
        };
    }
    /**
     * This component should have a purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityAssetComponentModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-asset-component-modal',
                template: "<div class=\"profile-scheme-asset-container\" [style.height.px]=\"dom.height.outer\">\n  <div class=\"profile-scheme-asset-header\">\n    <div class=\"sw-label-container-sm\">Edit Component</div>\n  </div>\n\n  <div class=\"profile-scheme-asset-content\">\n    <div class=\"profile-scheme-asset-section-wrapper\">\n      <div class=\"profile-scheme-asset-header pt-02\">\n        <div>{{config.asset.name}} Attributes</div>\n        <!--<div class=\"profile-scheme-asset-item-label-helper\">-->\n        <!--<div class=\"sw-pop-icon profile-scheme-asset-section-header-helper-icon\"-->\n        <!--matTooltip=\"{{dom.asset['fieldItemHelper']}}\"-->\n        <!--matTooltipPosition=\"left\">X-->\n        <!--</div>-->\n        <!--</div>-->\n      </div>\n      <mat-divider></mat-divider>\n      Content\n      <!--<div class=\"profile-scheme-asset-item sw-pointer\" [ngClass]=\"{'profile-scheme-asset-active-selection':dom.active['item']?.entityId === item.entityId}\" (click)=\"onActiveItemSelection(item);\">-->\n        <!--<div class=\"profile-scheme-asset-item-active-selector\" (click)=\"$event.stopPropagation()\">-->\n          <!--&lt;!&ndash;<lib-pop-checkbox *ngIf=\"dom.active['items'][item.entityId]\" [config]=\"dom.active['items'][item.entityId]\" (events)=\"onItemActiveChange($event);\"></lib-pop-checkbox>&ndash;&gt;-->\n        <!--</div>-->\n        <!--<div class=\"profile-scheme-asset-item-label-name\">{{item.name}}</div>-->\n        <!--<div class=\"profile-scheme-asset-item-label-helper\">-->\n          <!--<div class=\"sw-pop-icon profile-scheme-asset-item-helper-icon\"-->\n               <!--matTooltip=\"{{item.display}}\"-->\n               <!--matTooltipPosition=\"left\">X-->\n          <!--</div>-->\n        <!--</div>-->\n      <!--</div>-->\n    </div>\n\n    <div class=\"profile-scheme-asset-section-wrapper\">\n      asDAsd\n    </div>\n\n    <div class=\"profile-scheme-asset-section-wrapper\">\n      SDAFSADF\n    </div>\n\n  </div>\n</div>\n",
                styles: [".profile-scheme-asset-container{min-width:700px;flex-direction:column}.profile-scheme-asset-container,.profile-scheme-asset-content{position:relative;display:flex;height:100%;box-sizing:border-box}.profile-scheme-asset-content{width:100%;flex-direction:row}.profile-scheme-asset-section-wrapper{flex:1;border:1px solid var(--border);width:300px;margin:15px;box-sizing:border-box}.profile-scheme-asset-item:hover{background-color:var(--darken02)}.profile-scheme-asset-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 10px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box}.profile-scheme-asset-item{justify-content:flex-start;border-bottom:1px solid var(--border);padding-left:5px}.profile-scheme-asset-item,.profile-scheme-asset-item-active-selector{display:flex;align-items:center;box-sizing:border-box;-moz-box-sizing:border-box}.profile-scheme-asset-item-active-selector{position:relative;flex-direction:row;width:15%;justify-content:center}.profile-scheme-asset-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.profile-scheme-asset-item-label-name{width:75%;align-items:center;justify-content:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.profile-scheme-asset-item-label-helper{display:flex;width:10%;align-items:center;justify-content:center;min-height:40px}.profile-scheme-asset-item-helper-icon{margin-top:10px;margin-right:2px;width:20px;height:20px;font-size:.7em;z-index:2}"]
            },] }
];
PopEntityAssetComponentModalComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopEntityAssetComponentModalComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopEntityAssetFieldModalComponent extends PopExtendDynamicComponent {
    constructor(el, dialogRef, _containerRepo, _domRepo) {
        super();
        this.el = el;
        this.dialogRef = dialogRef;
        this._containerRepo = _containerRepo;
        this._domRepo = _domRepo;
        this.config = {};
        this.name = 'PopEntityAssetFieldModalComponent';
        this.srv = {
            container: undefined,
            field: ServiceInjector.get(PopFieldEditorService),
        };
        this.asset = {
            defaultContentHeight: undefined,
            model: new Map(),
            config: new Map(),
            coreField: undefined,
            coreFields: undefined,
            coreFieldItems: undefined,
            params: undefined,
            map: {}
        };
        this.ui = {
            activeConfigs: {},
            field: undefined,
            name: undefined,
            items: [],
            sections: [],
            map: {
                items: {}
            }
        };
        this.extendServiceContainer();
        this.srv.container.onContainerCreated((container) => {
            this.template.attach(container);
            this._setActiveItemParamConfiguration();
        });
        /**
         * Configure the specifics of this component
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.internal_name = IsStringError(this.config.asset.fieldgroup.name, true, `${this.name}:configureDom - internal_name`) ? this.config.asset.fieldgroup.name : '';
                const defaultHeight = +(window.innerHeight * .75) - 60;
                this.dom.setHeight(defaultHeight, 50);
                this.dom.height.content = this.dom.height.inner - 200;
                this.dom.active.items = {};
                this.asset.defaultContentHeight = this.dom.height.content;
                this.asset.coreFields = IsArrayThrowError(this.core.resource.fields.data_values, true, `${this.name}: - this.core.entity.resource.fields`) ? ArrayKeyBy(this.core.resource.fields.data_values, 'name') : {};
                this.asset.params = this.srv.field.getViewParams();
                this.asset.coreField = IsObjectThrowError(this.asset.coreFields[this.internal_name], true, `${this.name}: - this.asset.coreFields[ this.internal_name ]`) ? this.asset.coreFields[this.internal_name] : {};
                this.asset.coreFieldItems = IsArrayThrowError(this.asset.coreField.items, true, `${this.name}: - this.asset.coreField.items`) ? ArrayKeyBy(this.asset.coreField.items, 'name') : {};
                this.ui.field = this.config.asset;
                this.ui.sections = [];
                this.ui.name = new InputConfig({
                    value: this.ui.field.name,
                    readonly: true
                });
                this.ui.map.items = {};
                const items = IsArrayThrowError(this.config.asset.items, true, `${this.name}:configureDom: - this.config.asset.items`) ? JSON.parse(JSON.stringify(this.config.asset.items)) : [];
                // const items = this.srv.common.isArray(this.config.asset.items, true, `${this.name}:configureDom - items`) ? JSON.parse(JSON.stringify(this.asset.coreField.items)) : {};
                items.map((item, index) => {
                    item = CleanObject(item, {
                        blacklist: ['entries', 'object_name', 'depth_level', 'storage']
                    });
                    const coreFieldItem = this.asset.coreFieldItems[item.name];
                    coreFieldItem.rules = ArrayKeyBy(coreFieldItem.itemrules, 'name');
                    // console.log('coreFieldItem', coreFieldItem);
                    item.required = this.srv.field.getViewRequired(this.asset.coreField.name, item.name);
                    if (item.required)
                        item.active = 1;
                    if (+item.active) {
                        item.name = SnakeToPascal(item.name);
                        item.model = {
                            id: item.id,
                            name: item.name,
                            label: item.label,
                        };
                        item.config = {
                            options: {
                                values: item.options
                            }
                        };
                        if (IsObject(item.view, ['name']))
                            item.model.form = item.view.name;
                        if (IsObject(item.rules, true))
                            item.model = Object.assign(Object.assign({}, item.model), item.rules);
                        if (IsObject(item.settings, true))
                            item.model = Object.assign(Object.assign({}, item.model), item.settings);
                        this.dom.active.items[item.name] = item.active;
                        this.asset.model.set(item.name, item.model);
                        this.asset.config.set(item.name, item.config);
                        this.ui.activeConfigs[item.name] = new CheckboxConfig({
                            id: item.id,
                            name: 'active',
                            disabled: item.required ? true : false,
                            value: +item.active,
                            // patch: column.required ? null : {
                            //   field: 'active',
                            //   path: `cis/fields/${this.config.id}/item/${column.id}`,
                            //   displayIndicator: false,
                            // }
                        });
                        this.ui.items.push(item);
                    }
                    this.ui.map.items[item.name] = index;
                });
                this.ui.sections = [
                    {
                        id: 'params',
                        name: 'Params',
                        inputs: {},
                        component: null,
                        metadata: {},
                        requireRefresh: false,
                        active: true,
                    },
                    {
                        id: 'options',
                        name: 'Options',
                        inputs: {},
                        component: null,
                        metadata: {},
                        requireRefresh: false,
                        active: true,
                    },
                    // {
                    //   id: 'defaultValues',
                    //   name: 'Default Values',
                    //   inputs: {},
                    //   component: DemoTwoComponent,
                    //   metadata: {},
                    //   requireRefresh: false,        // require an api call to refresh the entity on every load
                    // }
                ];
                if (this.ui.items[0]) {
                    // this.onSelection(this.ui.items[ 0 ]);
                    // if( this.dom.active.item ){
                    // setTimeout(() => {
                    this.onActiveItemSelection(this.ui.items[0]);
                    // });
                    // }
                }
                return resolve(true);
            });
        };
    }
    extendServiceContainer() {
        this.srv.container = this._containerRepo;
        delete this._containerRepo;
    }
    /**
     * This component will allow a user to configure custom settings for each of items that it holds
     * The CoreConfig of this component will be a specific scheme
     * The config of this component is expected to be a scheme asset that is of type field
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * The user will be able to active/deactive a specific item in the list of items for this field
     * @param item
     */
    onItemStatusChange(event) {
        if (event.type === 'field' && event.name === 'patch' && event.success) {
            this.log.event('onItemStatusChange', event);
            this.dom.active.items[event.config.id] = +event.config.control.value;
        }
    }
    /**
     * The user will be able to select from a list of item an active item in which to configure settings
     * @param item
     */
    onActiveItemSelection(item) {
        console.log('onActiveItemSelection', item);
        this.dom.active.item = item;
        if (this.dom.active.item.options)
            this._setActiveItemOptionConfiguration();
        this.dom.active.model = IsObjectThrowError(this.dom.active.item.model, true, `${this.name}:onSelection - model`) ? JSON.parse(JSON.stringify(this.dom.active.item.model)) : {};
        // this.dom.active.params = IsObjectThrowError(this.dom.active.item.config, true, `${this.name}:onSelection - config`) ? JSON.parse(JSON.stringify(this.dom.active.item.config)) : {};
        // this.dom.active.config = IsObjectThrowError(this.config.asset.items[ this.ui.map.items[ item.name ] ].config, true, `${this.name}:onSelection - config`) ? JSON.parse(JSON.stringify(this.config.asset.items[ this.ui.map.items[ item.name ] ].config)) : {};
        if (this.dom.active.item.id && this.dom.session[this.dom.active.item.id]) {
            this.onActiveItemSettingSectionSelection(this.dom.session[this.dom.active.item.id]);
        }
        else {
            this.onActiveItemSettingSectionSelection(this.ui.sections[0]); // params
        }
        this._setActiveItemParamConfiguration();
    }
    /**
     * The user needs the changes it active item options to be saved to the database
     * @param event
     */
    onSaveActiveItemOptions(event) {
        console.log('triggerSaveFieldOptions:stub', event);
    }
    /**
     * There might be multiple tab sections to the setting of this active item
     * @param section
     */
    onActiveItemSettingSectionSelection(section) {
        this.dom.active.section = section.id;
        this.dom.session[this.dom.active.item.id] = section;
    }
    /**
     * The user is able to sort the options that should be used to populate the field, if applicable
     */
    onActiveItemOptionSortDrop(event) {
        moveItemInArray(this.dom.active.options, event.previousIndex, event.currentIndex);
        this.onSaveActiveItemOptions({ name: 'onChange' });
    }
    /**
     * The user should be able to click a button to close the modal
     */
    onModalClose() {
        this.dialogRef.close(0);
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        this.template.destroy();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setActiveItemParamConfiguration() {
        if (IsObject(this.dom.active.config, true) && IsObject(this.dom.active.params, true)) {
            this._getParamConfigurationComponentList(this.dom.active.config, this.dom.active.params).then((paramComponentList) => {
                this.template.render(paramComponentList, [], true);
            });
        }
    }
    _getParamConfigurationComponentList(fieldItem, params) {
        return new Promise((resolve) => {
            const paramComponentList = [];
            let component;
            let configInterface;
            if (this.dom.active.model.form in this.asset.params) {
                Object.keys(params).map((paramKey) => {
                    if (paramKey in this.asset.params[this.dom.active.model.form]) {
                        configInterface = Object.assign({
                            name: TitleCase(SnakeToPascal(paramKey)),
                            value: fieldItem[paramKey],
                            column: paramKey,
                            readonly: ['api', 'column'].includes(paramKey) ? true : false,
                            patch: { field: paramKey, path: `${fieldItem.api_path}/config` }
                        }, params[paramKey]);
                        configInterface.patch.path = ''; // ToDo: need to be the correct path to save setting to profile_scheme setting storage????
                        // console.log('configInterface', configInterface);
                        component = {
                            type: this._determineParamSettingComponent(paramKey),
                            inputs: {
                                config: configInterface,
                            }
                        };
                        paramComponentList.push(component);
                    }
                });
            }
            resolve(paramComponentList);
        });
    }
    /**
     * Determine the correct component for the form type
     * @param form
     */
    _determineParamSettingComponent(form) {
        switch (form) {
            case 'label':
                return FieldLabelSettingComponent;
                break;
            case 'display':
            case 'api':
            case 'column':
            case 'sort_top':
            case 'sort':
            case 'helpText':
                return FieldInputSettingComponent;
                break;
            case 'select':
            case 'mask':
            case 'pattern':
            case 'maxlength':
            case 'transformation':
                return FieldSelectSettingComponent;
                break;
            case 'hidden':
            case 'visible':
            case 'disabled':
            case 'readonly':
            case 'required':
                return FieldSwitchSettingComponent;
                break;
            case 'layout':
                return FieldRadioSettingComponent;
                break;
            case 'metadata':
                return FieldTextareaSettingComponent;
                break;
            default:
                return FieldLabelSettingComponent;
        }
    }
    _setActiveItemOptionConfiguration() {
        this.dom.active.options = [];
        if (this.dom.active.item.options && Array.isArray(this.dom.active.item.options.values)) {
            this.dom.active.item.options.values.map((option, index) => {
                option.sort = index;
                if (typeof option.active !== 'boolean')
                    option.active = true;
                if (typeof option.name !== 'string')
                    option.name = '';
                if (typeof option.value !== 'string')
                    option.value = '';
                this.dom.active.options.push({
                    active: new CheckboxConfig({
                        label: null,
                        value: +option.active,
                        bubble: true,
                    }),
                    name: new InputConfig({
                        label: null,
                        value: option.name,
                        validators: [Validators.required],
                        transformation: 'title',
                        bubble: true,
                        pattern: 'AlphaNoSpaceOnlyDash',
                        maxlength: 12,
                        readonly: true
                    }),
                    value: new InputConfig({
                        label: null,
                        value: option.value || 0,
                        bubble: true,
                        pattern: 'AlphaNumeric',
                        transformation: 'lower',
                        maxlength: 128,
                        readonly: true
                    }),
                    sort: new InputConfig({
                        label: null,
                        value: option.sort || 0,
                        bubble: true,
                    }),
                });
            });
        }
        else {
            this.onActiveItemSettingSectionSelection(this.ui.sections[0]); // params
        }
    }
}
PopEntityAssetFieldModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-asset-field-modal',
                template: "<div class=\"entity-scheme-asset-container\" *ngIf=\"dom.state.loaded\" [style.height.px]=\"dom.height.inner\">\n  <div class=\"entity-scheme-asset-header\">\n    <div class=\"sw-label-container-sm\">Edit Field</div>\n  </div>\n  <div class=\"entity-scheme-asset-row sw-mar-top-md\">\n    <div class=\"entity-scheme-asset-divider sw-disabled\">\n      <h4>{{ui.field.name}}</h4>\n      <!--<lib-pop-input class=\"sw-disabled\" [config]=\"ui.name\"></lib-pop-input>-->\n    </div>\n\n    <div class=\"entity-scheme-asset-divider\"></div>\n  </div>\n  <div class=\"entity-scheme-asset-content\">\n    <div class=\"entity-scheme-asset-section-wrapper\">\n      <div class=\"entity-scheme-asset-header pt-02\">\n        <div>Attributes</div>\n        <div class=\"entity-scheme-asset-item-label-helper\">\n          <div class=\"sw-pop-icon entity-scheme-asset-section-header-helper-icon\"\n               matTooltip=\"{{ui.field.fieldgroup.description}}\"\n               matTooltipPosition=\"left\">X\n          </div>\n        </div>\n      </div>\n      <mat-divider></mat-divider>\n      <div class=\"entity-scheme-asset-item sw-pointer\" [ngClass]=\"{'entity-scheme-asset-active-selection':dom.active['item']?.id === item.id}\" *ngFor=\"let item of ui.items\" (click)=\"onActiveItemSelection(item);\">\n        <div class=\"entity-scheme-asset-item-active-selector\" (click)=\"$event.stopPropagation()\">\n          <lib-pop-checkbox *ngIf=\"ui.activeConfigs[item.name]\" [config]=\"ui.activeConfigs[item.name]\" (events)=\"onItemStatusChange($event);\"></lib-pop-checkbox>\n        </div>\n        <div class=\"entity-scheme-asset-item-label-name\">{{item.name}}</div>\n        <div class=\"entity-scheme-asset-item-label-helper\">\n          <div class=\"sw-pop-icon entity-scheme-asset-item-helper-icon\"\n               matTooltip=\"{{item.display}}\"\n               matTooltipPosition=\"left\">X\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"entity-scheme-asset-section-wrapper\">\n      <div class=\"entity-scheme-asset-header pt-02\">\n        <div>{{dom.active.item?.name}} Settings</div>\n        <div class=\"entity-field-editor-item-label-helper\">\n          <div class=\"sw-pop-icon entity-scheme-asset-section-header-helper-icon\"\n               matTooltip=\"{{dom.active.item?.description}}\"\n               matTooltipPosition=\"left\">X\n          </div>\n        </div>\n      </div>\n      <mat-divider></mat-divider>\n      <div class=\"entity-scheme-asset-setting-header\" [ngClass]=\"{'sw-hidden': !dom.active.item?.options}\">\n        <nav mat-tab-nav-bar>\n          <a mat-tab-link\n             *ngFor=\"let section of ui.sections\"\n             (click)=\"onActiveItemSettingSectionSelection(section)\"\n             [ngClass]=\"{'sw-hidden':!section.active}\"\n             [active]=\"dom.active.section === section.id\">\n            {{section.name}}\n          </a>\n        </nav>\n      </div>\n      <div class=\"entity-scheme-asset-setting-content entity-scheme-asset-setting-active-config\">\n        <div class=\"entity-scheme-asset-setting-content\" [ngClass]=\"{'sw-hidden':dom.active.section !== 'params' }\" [style.height.px]=\"dom.height.content\">\n          <ng-container libTemplateContainer></ng-container>\n        </div>\n\n        <div class=\"entity-scheme-asset-setting-content\" [ngClass]=\"{'sw-hidden': dom.active.section !== 'options'}\" [style.height.px]=\"dom.height.content\">\n          <div class=\"entity-scheme-asset-setting-options-headers\">\n            <div class=\"entity-scheme-asset-setting-options-sort\">\n              Sort\n            </div>\n            <div class=\"entity-scheme-asset-setting-options-active\">\n              Active\n            </div>\n            <div class=\"entity-scheme-asset-setting-options-input\">\n              <label>Name</label>\n            </div>\n            <div class=\"entity-scheme-asset-setting-options-input\">\n              Value\n            </div>\n            <div class=\"entity-scheme-asset-setting-options-icon \">\n              <!--<i class=\"material-icons entityId-scheme-asset-setting-options-new sw-pointer sw-hover\" matTooltip=\"Add\"-->\n              <!--(click)=\"addFieldItemOption()\" [ngClass]=\"{'sw-hidden':dom.active.item?.options.enum}\">-->\n              <!--add-->\n              <!--</i>-->\n            </div>\n          </div>\n          <mat-divider></mat-divider>\n          <div class=\"entity-scheme-asset-setting-options-container\" cdkDropList (cdkDropListDropped)=\"onActiveItemOptionSortDrop($event)\">\n            <div class=\"entity-scheme-asset-setting-options-headers\" *ngFor=\"let option of dom.active.options; let i = index;\" cdkDrag cdkDragLockAxis=\"y\" cdkDragBoundary=\".entity-scheme-asset-setting-options-container\">\n              <div class=\"entity-scheme-asset-setting-options-sort\">\n                <i class=\"entity-scheme-asset-handle material-icons\" cdkDragHandle>drag_indicator</i>\n              </div>\n              <div class=\"entity-scheme-asset-setting-options-active\">\n                <lib-pop-checkbox (events)=\"onSaveActiveItemOptions($event);\" [config]=\"option.active\"></lib-pop-checkbox>\n              </div>\n              <div class=\"entity-scheme-asset-setting-options-input sw-mar-rgt-md\">\n                <lib-pop-input [config]=\"option.name\"></lib-pop-input>\n              </div>\n              <div class=\"entity-scheme-asset-setting-options-input\" [ngClass]=\"{'sw-disabled':dom.active.item?.options?.enum}\">\n                <lib-pop-input [config]=\"option.value\"></lib-pop-input>\n              </div>\n              <div class=\"entity-scheme-asset-setting-options-icon \" matTooltip=\"Remove\">\n                <!--<i class=\"material-icons entityId-scheme-asset-setting-options-new sw-pointer sw-hover\"-->\n                <!--(click)=\"removeFieldItemOption(i)\" [ngClass]=\"{'sw-hidden':dom.active.item.options.enum}\">-->\n                <!--remove-->\n                <!--</i>-->\n              </div>\n              <div class=\"entity-scheme-asset-setting-options-headers\" *cdkDragPreview></div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <div class=\"entity-scheme-asset-row entity-scheme-asset-buttons\">\n    <!--<div class=\"in-pop-table-dialog-cancel\">-->\n    <!--<button mat-raised-button (click)=\"onCancel();\">Cancel</button>-->\n    <!--</div>-->\n\n    <div class=\"in-dialog-other\">\n      <button mat-raised-button (click)=\"onModalClose()\">Close</button>\n    </div>\n  </div>\n\n</div>\n",
                providers: [PopContainerService],
                styles: [".entity-scheme-asset-container{min-width:700px;flex-direction:column}.entity-scheme-asset-container,.entity-scheme-asset-content{position:relative;display:flex;height:100%;box-sizing:border-box}.entity-scheme-asset-content{width:100%;flex-direction:row}.entity-scheme-asset-row{position:relative;display:flex;flex-direction:row;height:40px;align-items:center;clear:both;box-sizing:border-box}.entity-scheme-asset-divider,.entity-scheme-asset-section-wrapper{flex:1;width:300px;margin:15px;box-sizing:border-box}.entity-scheme-asset-section-wrapper{border:1px solid var(--border)}.entity-scheme-asset-item:hover{background-color:var(--darken02)}.entity-scheme-asset-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 15px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box}.entity-scheme-asset-item{display:flex;align-items:center;justify-content:flex-start;border-bottom:1px solid var(--border);box-sizing:border-box;padding-left:5px;-moz-box-sizing:border-box}.entity-scheme-asset-item ::ng-deep .pop-checkbox-container{margin-top:0!important}.entity-scheme-asset-item-active-selector{position:relative;display:flex;flex-direction:row;width:15%;box-sizing:border-box;-moz-box-sizing:border-box;align-items:center;justify-content:center}.entity-scheme-asset-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.entity-scheme-asset-item-label-name{width:75%;align-items:center;justify-content:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-scheme-asset-item-label-helper{display:flex;width:10%;align-items:center;justify-content:center;min-height:40px}.entity-scheme-asset-item-helper-icon{margin-top:10px;margin-right:2px;width:20px;height:20px;font-size:.7em;z-index:2}.entity-scheme-asset-buttons{margin:0 15px 10px;display:flex;justify-content:flex-end}.entity-scheme-asset-buttons .in-dialog-cancel{order:1;flex-grow:1;display:flex;justify-content:flex-start}.entity-scheme-asset-buttons .in-dialog-other{order:2;flex-grow:2;display:flex;justify-content:flex-end;margin-left:10px}.entity-scheme-asset-setting-wrapper{position:relative;flex:1;border:1px solid var(--border);border-bottom:none;box-sizing:border-box;-moz-box-sizing:border-box;overflow-x:hidden;overflow-y:scroll}.entity-scheme-asset-setting-header{position:relative}.entity-scheme-asset-setting-content{flex:1;padding:10px 15px 10px 10px;box-sizing:border-box;min-height:100px;overflow-y:scroll;overflow-x:hidden}.entity-scheme-asset-setting-active-config{border-left:5px solid var(--primary)}.entity-scheme-asset-setting-options-headers{display:flex;align-items:center;justify-content:flex-start;margin-top:2px;height:32px}.entity-scheme-asset-setting-options-sort{display:flex;width:10%;align-items:center;justify-content:center}.entity-scheme-asset-setting-options-active{display:flex;width:75px;text-align:center;align-items:center;justify-content:center}.entity-scheme-asset-setting-options-input{display:flex;width:30%;flex-grow:1}.entity-scheme-asset-setting-options-icon{display:flex;width:50px;align-items:center;justify-content:center}.entity-scheme-asset-setting-options-new{float:right}.entity-scheme-asset-setting-options-container{position:relative;width:100%;min-height:30px;padding:5px 0;box-sizing:border-box}.entity-scheme-asset-handle{cursor:move}.entity-scheme-btm-border{border-bottom:1px solid var(--border)}:host ::ng-deep .entity-scheme-asset-setting-options-container .mat-form-field-infix{width:auto;padding:6px!important;margin-top:6px!important;border:0!important}:host ::ng-deep .entity-scheme-asset-setting-options-container .pop-input-container{margin:2px}:host ::ng-deep .entity-scheme-asset-setting-options-container .pop-input-feedback-container{margin-top:-4px}:host ::ng-deep .entity-scheme-asset-setting-reset-box{position:relative;display:block;margin:0;padding:0;width:100%}:host ::ng-deep .entity-scheme-asset-setting-box .pop-textarea-container,:host ::ng-deep .entity-scheme-asset-setting-reset-box .pop-input-container,:host ::ng-deep .entity-scheme-asset-setting-reset-box .pop-select-container{margin:2px 0}"]
            },] }
];
PopEntityAssetFieldModalComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatDialogRef },
    { type: PopContainerService },
    { type: PopDomService }
];
PopEntityAssetFieldModalComponent.propDecorators = {
    config: [{ type: Input }]
};

class EntitySchemeLayoutSectionComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _domRepo - transfer
     * @param _schemeRepo - transfer
     */
    constructor(el, _domRepo, _schemeRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._schemeRepo = _schemeRepo;
        this.section = {};
        this.name = 'EntitySchemeLayoutSectionComponent';
        this.srv = {
            scheme: undefined
        };
        this.ui = {
            header: undefined,
            primaryIds: []
        };
        this.dom.session.expanded = {};
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                this.id = this.section.position;
                this.ui.primaryIds = this.srv.scheme.ui.primaryIds;
                this._buildHeader();
                yield this.dom.setWithComponentInnerHeight('PopEntityTabColumnComponent', this.section.position, 75, 700);
                return resolve(true);
            }));
        };
    }
    /**
     * The purpose of this component is to manage a specific section of the scheme layout
     * A user should be able to drag as sort assets, and apply custom settings to an asset
     * An asset is basically refers to something that the user can position in the scheme layout, field, component, etc
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * A user can dragSort assets from one column to another in the scheme layout
     * @param event
     */
    onAssetSortDrop(event) {
        this.srv.scheme.onAssetSortDrop(event);
    }
    /**
     * A user can click on an edit button an edit the config settings of an asset
     * @param asset
     */
    onEditAsset(asset) {
        this.dom.setTimeout('edit-asset', () => __awaiter(this, void 0, void 0, function* () {
            yield this.srv.scheme.onEditAsset(asset);
            if (this.dom.session.expanded[asset.id]) {
                this.onExpandAssetContent(asset);
                this.dom.setTimeout('reset-asset', () => __awaiter(this, void 0, void 0, function* () {
                    this.onExpandAssetContent(asset);
                }), 0);
            }
        }), 0);
    }
    /**z
     * A user can click on a toggle to expand/close the content section of an asset
     * @param asset
     */
    onExpandAssetContent(asset) {
        if (asset.id) {
            this.dom.session.expanded[asset.id] = !this.dom.session.expanded[asset.id];
        }
    }
    /**
     * Triggers when user mouseleaves an asset
     * @param asset
     */
    onHideAssetMenu(asset) {
        asset.menu = false;
    }
    /**
     * Triggers when user mouseenters an asset
     * @param asset
     */
    onShowAssetMenu(asset) {
        if (asset.asset_type != 'table') {
            asset.menu = true;
        }
    }
    /**
     * A user can click a remove button to remove an asset/child from the scheme layout
     * @param position
     * @param asset
     */
    onRemoveChildFromLayout(position, child) {
        // console.log( 'onRemoveChildFromLayout', position, child );
        this.srv.scheme.onRemoveChildFromLayout(position, child).then(() => {
        });
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    _buildHeader() {
        this.ui.header = new InputConfig({
            value: this.section.name,
            label: `Column ${this.section.position}`,
            pattern: 'AlphaNumeric',
            maxlength: 24,
            // hint: true,
            // transformation: 'toTitleCase',
            // hintText: 'This text will appear as a Header',
            patch: {
                field: 'name',
                path: `profile-schemes/${this.section.id}`
            }
        });
    }
}
EntitySchemeLayoutSectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-layout-section',
                template: "<div class=\"entity-scheme-asset-layout-section\" *ngIf=\"dom.state.loaded\">\n  <mat-accordion\n    class=\"entity-scheme-asset-list\"\n    multi=\"true\"\n    [displayMode]=\"'flat'\"\n    [style.height.px]=dom.height.outer>\n    <div class=\"entity-scheme-asset-layout-section-header\">\n      <!--<div>{{section.name}}</div>-->\n      <lib-pop-input [config]=\"ui.header\"></lib-pop-input>\n    </div>\n    <div class=\"entity-scheme-asset-list-content\"\n         cdkDropList\n         id=\"column-{{section.position}}\"\n         [attr.data-position]=section.position\n         [attr.data-start-index]=section.startIndex\n         [attr.data-id]=section.id\n         [cdkDropListData]=\"section.children\"\n         (cdkDropListDropped)=\"onAssetSortDrop($event)\"\n         [cdkDropListEnterPredicate]=\"section.predicate\"\n         [style.height.px]=dom.height.inner>\n      <div class=\"sw-mar-vrt-xs sw-clear\"></div>\n      <div *ngFor=\"let child of section.children\">\n\n        <div class=\"entity-scheme-asset\" *ngIf=\"child.container\">\n          Container\n        </div>\n\n        <div class=\"entity-scheme-asset\" *ngIf=\"!child.container\"\n             [ngClass]=\"{'entity-scheme-asset-field-container': true, 'sw-disabled': child.asset_type === 'table'}\"\n             (mouseenter)=\"onShowAssetMenu(child)\"\n             (mouseleave)=\"onHideAssetMenu(child)\"\n             cdkDrag\n             (cdkDragDrop)=\"onAssetSortDrop($event)\"\n             [cdkDragData]=\"{id: child.id, asset_id: child.asset_id,asset_type: child.asset_type, position: section.position, compact: child.compact}\"\n             cdkDragBoundary=\".entity-scheme-asset-layout-container\">\n          <div class=\"import-flex-row\">\n            <div class=\"import-flex-column-break import-flex-column import-flex-start-center\" [style.maxWidth.px]=\"12\">\n              <i *ngIf=\"child.asset.required\" class=\"sw-pointer entity-scheme-required\" [matTooltip]=\"'required'\">\n                *\n              </i>\n            </div>\n            <div class=\"import-flex-column-break import-flex-column\">\n              <div class=\"entity-scheme-asset-layout-row\">\n                <div class=\"entity-scheme-asset-handle\" [ngClass]=\"{'entity-scheme-asset-handle-disabled': child.asset_type === 'table'}\" cdkDragHandle>\n                  <!--<div>-->\n                    {{child.name}}\n                  <!--</div>-->\n                </div>\n                <div class=\"entity-scheme-asset-menu\" *ngIf=\"!child.menu\" [@fadeInOut]=\"'in'\">\n                  <div class=\"entity-scheme-asset-menu-icon\" *ngIf=\"child.asset.primary\">\n                    <i class=\"material-icons sw-pointer entity-scheme-primary\" [matTooltip]=\"'Primary'\">\n                      star\n                    </i>\n                  </div>\n                </div>\n                <!--<div class=\"entity-scheme-asset-trait-container\">-->\n                  <!--<mat-icon class=\"entity-scheme-asset-trait-icon sw-pointer\" *ngFor=\"let trait of entry.traits\" matTooltip=\"{{trait.label}}\" matTooltipPosition=\"above\">{{trait.icon}}</mat-icon>-->\n                <!--</div>-->\n                <div class=\"entity-scheme-asset-menu\" *ngIf=\"child.menu\" [@fadeInOut]=\"'in'\">\n                  <div class=\"entity-scheme-asset-menu-icon\">\n                    <i class=\"material-icons sw-pointer\"\n                       (click)=\"onEditAsset(child)\">\n                      edit\n                    </i>\n                  </div>\n                  <div class=\"entity-scheme-asset-menu-icon\" *ngIf=\"!child.asset.primary\">\n                    <i class=\"material-icons sw-pointer\"\n                       (click)=\"onRemoveChildFromLayout(section.position, child)\">\n                      clear\n                    </i>\n                  </div>\n\n                </div>\n              </div>\n              <div class=\"entity-scheme-asset-layout-subrow\" [ngSwitch]=\"child.asset_type\">\n                <div *ngSwitchCase=\"'table'\">Default Column</div>\n                <div *ngSwitchCase=\"'field'\">{{child.asset?.fieldgroup?.label}} Field</div>\n                <div *ngSwitchCase=\"'component'\">Component</div>\n              </div>\n            </div>\n\n          </div>\n          <div class=\"entity-scheme-asset-layout-content-row\" *ngIf=\"dom.session.expanded[child.id]\" [ngClass]=\"{'entity-scheme-asset-layout-row-expanded': dom.session.expanded[child.id]}\" [ngSwitch]=\"child.asset_type\">\n            <lib-entity-scheme-table-content *ngSwitchCase=\"'table'\" [core]=\"core\" [config]=\"child\"></lib-entity-scheme-table-content>\n            <lib-entity-scheme-field-content *ngSwitchCase=\"'field'\" [core]=\"core\" [config]=\"child\"></lib-entity-scheme-field-content>\n            <lib-entity-scheme-component-content *ngSwitchCase=\"'component'\" [core]=\"core\" [config]=\"child\"></lib-entity-scheme-component-content>\n          </div>\n          <div class=\"entity-scheme-asset-toggle-row sw-pointer\" *ngIf=\"child.id && child.asset && child.asset.multiple && child.asset.entries && child.asset.entries.length > 1\" (click)=\"onExpandAssetContent(child)\">\n            <div class=\"material-icons sw-pointer\" [ngClass]=\"{'sw-hidden': dom.session.expanded[child.id]}\">\n              expand_more\n            </div>\n            <div class=\"material-icons sw-pointer\" [ngClass]=\"{'sw-hidden': !dom.session.expanded[child.id]}\">\n              expand_less\n            </div>\n          </div>\n\n        </div>\n\n      </div>\n\n    </div>\n  </mat-accordion>\n</div>\n",
                animations: [
                    fadeInOut,
                    slideInOut
                ],
                styles: [".entity-scheme-asset-layout-section-header{height:50px;padding:2px 5px;border-bottom:1px solid var(--border);box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host .entity-scheme-asset-layout-section-header ::ng-deep input{font-size:1.2em}:host .entity-scheme-asset-layout-section-header ::ng-deep mat-label{position:relative;top:2px;font-size:1.2em}:host .entity-scheme-asset-layout-section-header ::ng-deep .pop-input-container{margin:0!important;border:0!important}:host .entity-scheme-asset-layout-section-header ::ng-deep .mat-form-field-outline{color:transparent;display:none}"]
            },] }
];
EntitySchemeLayoutSectionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopEntitySchemeService }
];
EntitySchemeLayoutSectionComponent.propDecorators = {
    section: [{ type: Input }]
};

class EntitySchemeFieldContentComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _schemeRepo - transfer
     * @param _fieldRepo - transfer
     */
    constructor(el, _schemeRepo, _fieldRepo) {
        super();
        this.el = el;
        this._schemeRepo = _schemeRepo;
        this._fieldRepo = _fieldRepo;
        this.config = {};
        this.name = 'EntitySchemeFieldContentComponent';
        this.srv = {
            scheme: undefined,
            field: undefined,
        };
        this.asset = {
            field: undefined,
            groupName: undefined,
            mapping: undefined,
            primary: undefined,
            traits: undefined,
            traitMap: {},
            entryTraitMap: {},
        };
        this.ui = {
            entries: [],
            traits: [],
        };
        this.dom.configure = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this._setInitialConfig();
                yield this._setEntryTraitMap();
                yield this._setEntries();
                return resolve(true);
            }));
        };
    }
    /**
     * This component is responsible to render the inner contents of field asset
     * A field asset is custom field that has been created on an entity in the business unit
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Set the initial config of this component
     * @private
     */
    _setInitialConfig() {
        return new Promise((resolve) => {
            this.asset.field = this.config.asset;
            this.asset.groupName = this.config.asset.fieldgroup.name;
            this.asset.mapping = this.srv.scheme.getFieldMapping(+this.config.asset_id);
            this.asset.primary = this.srv.field.getSchemePrimary(this.core.entity);
            this.dom.state.isPrimary = +this.config.asset_id === this.asset.primary[this.asset.groupName];
            this.asset.traits = this.srv.field.getFieldTraits(this.asset.field.fieldgroup.name).sort(DynamicSort('name'));
            this.asset.traitMap = ArrayMapSetter(this.asset.traits, 'name');
            return resolve(true);
        });
    }
    /**
     * Organizes the trait that should be assigned on this field
     * @private
     */
    _setEntryTraitMap() {
        return new Promise((resolve) => {
            this.asset.entryTraitMap = {};
            if (IsArray(this.asset.traits, true) && IsObject(this.asset.mapping.trait_entry, true)) {
                Object.keys(this.asset.mapping.trait_entry).map((traitName) => {
                    const entryId = +this.asset.mapping.trait_entry[traitName];
                    if (+entryId) {
                        if (!(IsArray(this.asset.entryTraitMap[entryId]))) {
                            this.asset.entryTraitMap[entryId] = [];
                        }
                        this.asset.entryTraitMap[entryId].push(traitName);
                    }
                });
            }
            return resolve(true);
        });
    }
    /**
     * Set the entries of this field
     * @private
     */
    _setEntries() {
        return new Promise((resolve) => {
            this.ui.entries = [];
            this.ui.entries.push(...this.asset.field.entries);
            if (IsObject(this.config, ['asset'])) {
                if (IsArray(this.ui.entries, true)) {
                    this.ui.entries.map((entry) => {
                        entry.disabled = IsArray(this.asset.mapping.disabled_entries, true) && this.asset.mapping.disabled_entries.includes(+entry.id);
                        entry.traits = this._getEntryTraits(entry);
                    });
                    this.ui.entries.sort(DynamicSort('sort_order'));
                }
            }
            return resolve(true);
        });
    }
    /**
     * Set the traits that belong to a field entry
     * @param entry
     * @private
     */
    _getEntryTraits(entry) {
        const traits = [];
        if (IsObject(entry, ['id']) && IsArray(this.asset.traits, true) && this.dom.state.isPrimary) {
            if (entry.id in this.asset.entryTraitMap && IsArray(this.asset.entryTraitMap[entry.id], true)) {
                this.asset.entryTraitMap[entry.id].map((traitName) => {
                    if (traitName in this.asset.traitMap) {
                        const trait = this.asset.traits[this.asset.traitMap[traitName]];
                        if (IsObject(trait, ['icon', 'name'])) {
                            if (!trait.label)
                                trait.label = TitleCase(SnakeToPascal(trait.name));
                            traits.push(trait);
                        }
                    }
                });
            }
        }
        return traits;
    }
}
EntitySchemeFieldContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-field-content',
                template: "<div class=\"entity-scheme-asset-item-row\" *ngFor=\"let entry of ui.entries;\" [ngClass]=\"{'sw-disabled': entry.disabled}\">\n  {{entry.name}}\n  <div class=\"entity-scheme-asset-trait-container\">\n    <mat-icon class=\"entity-scheme-asset-trait-icon sw-pointer\" *ngFor=\"let trait of entry.traits\" matTooltip=\"{{trait.label}}\" matTooltipPosition=\"above\">{{trait.icon}}</mat-icon>\n  </div>\n</div>\n",
                styles: [".entity-scheme-asset-item-row{padding-left:var(--gap-m);align-items:center;justify-content:space-between!important}.entity-scheme-asset-trait-container{min-width:20px;padding-top:var(--gap-s);padding-right:var(--gap-xs)}.entity-scheme-asset-trait-icon{font-size:14px}"]
            },] }
];
EntitySchemeFieldContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopEntitySchemeService },
    { type: PopFieldEditorService }
];
EntitySchemeFieldContentComponent.propDecorators = {
    config: [{ type: Input }]
};

class EntitySchemeTableContentComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = {};
        this.name = 'EntitySchemeTableContentComponent';
        this.dom.configure = () => {
            return new Promise((resolve) => {
                return resolve(true);
            });
        };
    }
    /**
     * This component is responsible to render the inner contents of table asset
     * A table asset is basically a column that exists on the base table of an entity, ..ie: id, name, description ...
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
EntitySchemeTableContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-table-content',
                template: "<p>\n  profile-scheme-table-asset works!\n</p>\n",
                styles: [""]
            },] }
];
EntitySchemeTableContentComponent.ctorParameters = () => [
    { type: ElementRef }
];
EntitySchemeTableContentComponent.propDecorators = {
    config: [{ type: Input }]
};

class EntitySchemeComponentContentComponent extends PopExtendComponent {
    constructor(el) {
        super();
        this.el = el;
        this.config = {};
        this.name = 'EntitySchemeComponentContentComponent';
        this.dom.configure = () => {
            return new Promise((resolve) => {
                resolve(true);
            });
        };
    }
    /**
     * This component is responsible to render the inner contents of component asset
     * A component asset is custom widget that has been created for the entityId
     */
    ngOnInit() {
        super.ngOnInit();
        this.dom.configure().then(() => {
            this.dom.register();
            this.dom.ready();
        });
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
EntitySchemeComponentContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-entity-scheme-component-content',
                template: "<p>\n  profile-scheme-component-asset works!\n</p>\n",
                styles: [".entity-scheme-asset-layout-container{display:flex;flex-direction:row;border-top:1px solid var(--border);border-left:1px solid var(--border);border-bottom:1px solid var(--border);box-sizing:border-box;overflow:hidden}lib-entity-scheme-layout-section{flex:1;flex-basis:150px;border-right:1px solid var(--border)}.entity-scheme-asset-layout-section{flex:1}.entity-scheme-asset-list-content{overflow-y:auto;overflow-x:hidden}.entity-scheme-asset{box-sizing:border-box;margin:10px;border:1px solid var(--border);background:var(--bg-3);font-size:12px}.entity-scheme-asset-menu{position:absolute;justify-content:space-around;top:15px;right:5px;opacity:.8;width:55px;padding-left:5px;z-index:2}.entity-scheme-asset-menu,.entity-scheme-asset-menu-icon{display:flex;align-items:center;height:20px;background:var(--bg-3)}.entity-scheme-asset-menu-icon{justify-content:center;opacity:1!important;width:20px}.entity-scheme-asset-menu-icon .material-icons{font-size:18px}.entity-scheme-asset-handle{position:relative;box-sizing:border-box;cursor:move;width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-scheme-asset-handle-disabled{pointer-events:none;cursor:none}.entity-scheme-asset-field-container{display:flex;flex-direction:column}.entity-scheme-asset-layout-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:center;height:25px;font-size:14px;padding:0 10px;z-index:1}.entity-scheme-asset-layout-row-expanded{border-bottom:1px solid var(--border)}.entity-scheme-asset-layout-subrow{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;justify-content:flex-start;align-items:flex-start;height:20px;color:var(--disabled);padding:0 10px;font-size:12px;top:2px}.entity-scheme-asset-layout-content-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:column;min-height:30px}.entity-scheme-asset-item-row{justify-content:flex-start;height:30px;padding:0 10px;border-top:1px solid var(--border);z-index:1}.entity-scheme-asset-item-row,.entity-scheme-asset-toggle-row{position:relative;display:flex;box-sizing:border-box;width:100%;flex-direction:row;align-items:center}.entity-scheme-asset-toggle-row{justify-content:center;height:10px;margin-bottom:5px;overflow:hidden;z-index:3}.entity-scheme-asset-toggle-row .material-icons{position:relative;top:2px;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-size:18px}.entity-scheme-primary{color:var(--primary-background)}.entity-scheme-required{color:var(--error);font-size:30px;line-height:0px;margin:0;width:10px;position:relative;top:20px;z-index:2}.cdk-drag-preview{overflow:hidden;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);height:35px}.cdk-drag-preview .entity-scheme-asset-handle{box-sizing:border-box}.cdk-drag-preview .entity-scheme-asset-menu{display:none!important}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating,.entity-scheme-asset-list.cdk-drop-list-dragging .entity-scheme-asset:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.entity-scheme-asset-field-container{background:#000}"]
            },] }
];
EntitySchemeComponentContentComponent.ctorParameters = () => [
    { type: ElementRef }
];
EntitySchemeComponentContentComponent.propDecorators = {
    config: [{ type: Input }]
};

class PopEntityFieldItemsComponent extends PopExtendComponent {
    /**
     * @param el
     * @param _domRepo - transfer
     * @param _fieldRepo - transfer
     */
    constructor(el, _domRepo, _fieldRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this.scheme = null;
        this.name = 'PopEntityFieldItemsComponent';
        this.srv = {
            field: undefined
        };
        this.asset = {
            fieldgroup: undefined,
        };
        this.ui = {
            field: undefined,
            coreItems: undefined,
            items: undefined,
            fieldItemHelper: '',
            map: {},
            customSetting: {}
        };
        /**
         * This should transformValue and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, ['entity'], `${this.name}:configureDom: - this.core`) ? this.core : null;
                // Set the height boundary
                if (!this.field)
                    this.field = this.core.entity;
                this._setHeight();
                // Set event Handlers
                this.dom.handler.core = (core, event) => this._coreEventHandler(event);
                // Create a container to track the active items
                this.dom.active.items = {};
                // Transfer any resources for the entityId data
                this.asset.fieldgroup = IsObjectThrowError(this.core.entity, ['fieldgroup'], `${this.name}:: - this.core.entity.fieldgroup`) ? CleanObject(this.core.entity.fieldgroup) : null;
                // this.asset.coreRules = {};  // the settings that can be changed
                // this.asset.coreItemModels = {}; // where the settings that can be changed are stored
                this.ui.coreItems = IsArrayThrowError(this.core.resource.items.data_values, true, `${this.name}:configureDom: - this.core.resource.items`) ? this.core.resource.items.data_values.filter((item) => {
                    return !(this.srv.field.getViewIgnored(this.asset.fieldgroup.name, item.name, this.scheme));
                }).map((value) => CleanObject(value)) : [];
                this.ui.map.coreItems = ArrayMapSetter(this.ui.coreItems, 'name');
                this.ui.fieldItemHelper = `Select which attributes will be part of this ${this.asset.fieldgroup.name} field. Click on a field to edit individual field item settings.`;
                this.ui.items = IsArrayThrowError(this.core.entity.items, true, `${this.name}:: - this.core.entity.items`) ? this.core.entity.items.map((item) => CleanObject(item)) : null;
                if (IsObject(this.scheme)) {
                    this.ui.items = this.ui.items.filter((item) => {
                        return +item.active === 1;
                    });
                }
                this.ui.map.items = ArrayMapSetter(this.ui.items, 'name');
                // Build the custom settings
                this._buildCustomSettings();
                // Build the Active Items for this field
                this._buildActiveItems();
                this._selectDefaultItem();
                // Select the first field attribute item so that the view will have something to render
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                if (this.dom.active.labelSettings) {
                    this.onActiveLabelSelection();
                    setTimeout(() => {
                        this.onActiveLabelSelection();
                    });
                }
                else if (IsObject(this.dom.active.item, ['id'])) {
                    this.onActiveItemSelection(this.dom.active.item);
                    setTimeout(() => {
                        this.onActiveItemSelection(this.dom.active.item);
                    });
                }
                else if (true) {
                    this.onActiveLabelSelection();
                    setTimeout(() => {
                        this.onActiveLabelSelection();
                    });
                }
                else {
                    this._selectDefaultItem();
                }
                return resolve(true);
            });
        };
    }
    /**
     * We expect the core to represent a field
     * This component lists out all of the field attributes that this field has, and allows for the user to active/deactivate specific items.
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This handles when a user click on a checkbox to activate/deactivate a specific field attribute
     * @param event
     */
    onItemActiveChange(event) {
        // #1: Make sure that change was stored in the database
        if (event.type === 'field' && event.name === 'patch' && event.success) {
            if (this.log.repo.enabled('event', this.name))
                console.log(this.log.repo.message(`${this.name}:itemActiveHandler`), this.log.repo.color('event'), event);
            // #2: Update the change on the domRepo so other components can now about the change
            this.dom.repo.ui.activeItems[event.config.id] = +event.config.control.value;
            // #3: Send an event to the FieldBuilderPreviewComponent to update that this field attribute was activated/deactivated
            this.core.channel.next({ source: this.name, target: 'PopEntityFieldPreviewComponent', type: 'component', name: 'update' });
        }
    }
    /**
     * This handles when a user click on a checkbox to activate/deactivate a specific field attribute
     * @param event
     */
    onEditLabelChange(event) {
        console.log('onCustomSettingChange', event);
    }
    /**
     * On selection is an event when a user click on a specific field attribute to manage its settings
     * @param item
     */
    onActiveItemSelection(item) {
        this.log.info(`onActiveItemSelection`, item);
        if (!this.dom.state.saving && IsObject(item, ['id'])) {
            this.dom.active.labelSettings = false;
            // #1. Build a data package to send to the FieldBuilderItemSettingsComponent component
            this.dom.active.item = item;
            // #2: Send an event with the data package to the FieldBuilderItemSettingsComponent component
            const event = {
                type: 'component',
                name: 'active-item',
                source: this.name,
                target: 'PopEntityFieldItemParamsComponent',
                data: item
                // data: { item: item, models: itemModels, config: itemConfig }
            };
            this.dom.store('active');
            this.core.channel.emit(event); // core channel is the shared radio between all components on the core
        }
    }
    /**
     * On selection is an event when a user click on a specific field attribute to manage its settings
     * @param item
     */
    onActiveLabelSelection() {
        this.log.info(`onActiveLabelSelection`);
        this.dom.active['item'] = null;
        this.dom.active.labelSettings = true;
        const event = {
            type: 'component',
            name: 'label-settings',
            source: this.name,
            target: 'PopEntityFieldItemParamsComponent',
            data: {}
        };
        this.core.channel.emit(event); // core channel is the shared radio between all components on the core
        this.dom.store('active');
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Select the the first field item available
     */
    _selectDefaultItem() {
        if (this.ui.coreItems[0]) {
            const coreItem = this.ui.coreItems[0];
            const realItem = this.ui.items[this.ui.map.items[coreItem.name]];
            this.onActiveItemSelection(realItem);
            if (this.dom.active.item) { // seems to need a double tap  to be consistent
                setTimeout(() => {
                    this.onActiveItemSelection(realItem);
                });
            }
        }
    }
    /**
     * This handler is for managing an cross-communication between components on the core channel
     * @param event
     */
    _coreEventHandler(event) {
        this.log.event(`_coreEventHandler`, event);
        // if( IsValidFieldPatchEvent(this.core, event) ){
        //   if( event.config.name === 'multiple' && !event.config.control.value && this.dom.active.labelSettings ){
        //     this._selectDefaultItem();
        //     // this._setHeight();
        //   }
        // }
    }
    /**
     * Build configs that control the active state for each field item
     */
    _buildActiveItems() {
        this.dom.repo.ui.activeItems = {}; // stored on domRepo so that other components can use it
        const isScheme = IsObject(this.scheme, true);
        this.ui.coreItems.map((coreItem, index) => {
            const realItem = this.ui.items[this.ui.map.items[coreItem.name]];
            if (IsObject(realItem, ['id', 'name'])) {
                // item.required = typeof coreItem.required !== 'undefined' ? +coreItem.required : 1;
                // console.log('item', item);
                // console.log('coreItem', coreItem);
                // ToDo:: coreFieldItem needs to have required attribute
                // this.ui.map.items[ item.name ] = index;
                // item.name = SnakeToPascal(item.name);
                coreItem.required = this.srv.field.getViewRequired(this.asset.fieldgroup.name, realItem.name);
                if (coreItem.required)
                    realItem.active = 1;
                let itemActive = +realItem.active;
                if (isScheme) {
                    const schemeFieldItemSession = this.srv.field.getSchemeFieldItemMapping(this.scheme, +this.field.id, realItem.id);
                    console.log('schemeFieldItemSession', realItem.id, schemeFieldItemSession);
                    if (IsDefined(schemeFieldItemSession.active)) {
                        itemActive = +schemeFieldItemSession.active;
                    }
                }
                this.dom.active.items[realItem.id] = new CheckboxConfig({
                    id: realItem.id,
                    name: 'active',
                    align: 'left',
                    disabled: coreItem.required || !this.core.access.can_update ? true : false,
                    value: itemActive,
                    facade: isScheme,
                    patch: coreItem.required ? null : {
                        field: 'active',
                        path: isScheme ? null : `fields/customs/${realItem.id}`,
                        displayIndicator: true,
                        callback: isScheme ? (core, event) => __awaiter(this, void 0, void 0, function* () {
                            const session = this.srv.field.getSchemeFieldItemMapping(this.scheme, +this.field.id, realItem.id);
                            if (IsObject(session)) {
                                session.active = event.config.control.value;
                                yield this.srv.field.updateSchemeFieldMapping(this.scheme);
                            }
                        }) : null
                    },
                });
                this.dom.repo.ui.activeItems[realItem.id] = +realItem.active;
            }
        });
    }
    /**
     * Build the configs for any relevant custom settings
     * @private
     */
    _buildCustomSettings() {
        if (IsObject(this.field.custom_setting, ['edit_label'])) {
            const setting = this.field.custom_setting.edit_label;
            this.ui.customSetting['edit_label'] = new CheckboxConfig({
                id: setting.id,
                align: 'left',
                name: 'edit_label',
                disabled: true,
                value: true,
                metadata: { setting: setting },
                facade: true,
                patch: {
                    field: ``,
                    path: ``,
                    callback: (core, event) => {
                        this.dom.state.saving = true;
                        if (IsObject(this.scheme, true)) {
                            console.log('save setting to a scheme');
                            console.log('event', event);
                            console.log('setting', setting);
                        }
                        else {
                            this.srv.field.storeCustomSetting(core, event).then((res) => {
                                if (IsString(res, true)) {
                                    this.ui.customSetting['edit_label'].message = res;
                                }
                                this.dom.setTimeout('allow-save', () => {
                                    this.dom.state.saving = false;
                                }, 500);
                            });
                        }
                    }
                }
            });
        }
    }
    /**
     * Determine the layout height to control overflow
     *
     */
    _setHeight() {
        this.dom.overhead = 135;
        // this.dom.height.outer = +this.dom.repo.position[ this.position ].height - 121;
        // const field = <FieldInterface>this.core.entity;
        //
        // if( false && field.multiple ){
        //   this.dom.height.outer -= 20;
        //   this.dom.height.outer -= ( +field.multiple_min * 60 );
        // }
        // if( this.dom.height.outer < 400 ) this.dom.height.outer = 400;
        this.dom.setHeight(400, this.dom.overhead);
    }
}
PopEntityFieldItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-builder-items',
                template: "<div class=\"entity-field-items-container\" *ngIf=\"dom.state.loaded\" [style.height.px]=dom.height.outer>\n  <!--<div>-->\n    <!--<div class=\"entity-field-editor-item sw-pointer\" [ngClass]=\"{'entity-field-editor-active-selection':dom.active.labelSettings}\" (click)=\"onActiveLabelSelection();\">-->\n      <!--<div class=\"entity-field-editor-item-active-selector\" (click)=\"$event.stopPropagation()\">-->\n        <!--<lib-pop-checkbox [config]=\"ui.customSetting.edit_label\" (events)=\"onEditLabelChange($event);\"></lib-pop-checkbox>-->\n      <!--</div>-->\n      <!--<div class=\"editor-field-editor-item-label-name\">-->\n        <!--<div *ngIf=\"!field?.multiple\">Entry</div>-->\n        <!--<div *ngIf=\"field?.multiple\">Entries</div>-->\n      <!--</div>-->\n      <!--<div class=\"entityId-field-editor-item-label-helper\">-->\n        <!--&lt;!&ndash;<div class=\"sw-pop-icon entityId-field-editor-item-helper-icon\" matTooltip=\"{{realItem.view.description}}\" matTooltipPosition=\"left\">&ndash;&gt;-->\n        <!--&lt;!&ndash;X&ndash;&gt;-->\n        <!--&lt;!&ndash;</div>&ndash;&gt;-->\n      <!--</div>-->\n    <!--</div>-->\n  <!--</div>-->\n  <div *ngFor=\"let coreItem of ui.coreItems\">\n    <div class=\"entity-field-editor-item sw-pointer\" [ngClass]=\"{'entity-field-editor-active-selection':dom.active['item']?.id === realItem.id}\" *ngIf=\"ui.items[ui.map.items[coreItem.name]]; let realItem;\" (click)=\"onActiveItemSelection(realItem);\">\n      <div class=\"entity-field-editor-item-active-selector\" (click)=\"$event.stopPropagation()\">\n        <lib-pop-checkbox *ngIf=\"dom.active['items'][realItem.id]\" [config]=\"dom.active['items'][realItem.id]\" (events)=\"onItemActiveChange($event);\"></lib-pop-checkbox>\n      </div>\n      <div class=\"editor-field-editor-item-label-name\">{{coreItem.label}}</div>\n      <div class=\"entityId-field-editor-item-label-helper\">\n        <!--<div class=\"sw-pop-icon entityId-field-editor-item-helper-icon\" matTooltip=\"{{realItem.view.description}}\" matTooltipPosition=\"left\">-->\n        <!--X-->\n        <!--</div>-->\n      </div>\n    </div>\n  </div>\n\n  <div class=\"entity-field-editor-item-filler\"></div>\n</div>\n",
                styles: [".entity-field-editor-header{display:flex;flex-direction:column;height:97px}.entity-field-editor-header-section{position:relative;width:100%;box-sizing:border-box;height:30px;clear:both}.entity-field-editor-container{min-height:100px;position:relative}.entity-field-editor-border{border:1px solid var(--border)}.entity-field-editor-section-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 10px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box;background:var(--darken02)}.entity-field-editor-section-header-helper-icon{width:20px;height:20px;font-size:1em;z-index:2}.entity-field-editor-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.entity-field-editor-active-config{border-left:5px solid var(--primary)}.entity-field-items-container{display:flex;flex-direction:column;min-width:200px;overflow-x:hidden;overflow-y:auto}.entity-field-editor-item{display:flex;align-items:center;justify-content:flex-start;box-sizing:border-box;-moz-box-sizing:border-box;border:1px solid transparent;border-right:1px solid var(--border);border-bottom:none;height:40px}.entity-field-editor-item-filler{flex:1;border-right:1px solid var(--border)}.entity-field-editor-item:hover{background-color:var(--darken02)}.entity-field-editor-item-active-selector{position:relative;display:flex;flex-direction:row;width:15%;box-sizing:border-box;-moz-box-sizing:border-box;align-items:center;justify-content:center;padding-left:10px}.editor-field-editor-item-label-name{width:75%;display:flex;align-items:center;justify-content:flex-start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.entity-field-editor-item-label-helper{display:flex;width:10%;align-items:center;justify-content:center;min-height:40px}.entity-field-editor-item-helper-icon{margin-top:10px;margin-right:2px;width:20px;height:20px;font-size:.7em;z-index:2}.entity-field-editor-active-selection{border:1px solid var(--border)!important;border-right:1px solid transparent!important}:host ::ng-deep .pop-checkbox-container{margin-top:0!important}"]
            },] }
];
PopEntityFieldItemsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService }
];
PopEntityFieldItemsComponent.propDecorators = {
    field: [{ type: Input }],
    scheme: [{ type: Input }]
};

class PopEntityFieldValuesComponent extends PopExtendComponent {
    constructor(el, domRepo, fieldRepo) {
        super();
        this.el = el;
        this.domRepo = domRepo;
        this.fieldRepo = fieldRepo;
        this.name = 'PopEntityFieldValuesComponent';
        this.srv = {
            field: undefined,
            request: ServiceInjector.get(PopRequestService),
        };
        this.asset = {
            basePath: undefined,
            field: undefined,
            type: undefined,
            typeOption: undefined,
        };
        this.transformSrvContainer();
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.dom.handler.core = (core, event) => this._coreEventHandler(event);
                this.asset.field = IsObjectThrowError(this.core, true, `Invalid Core`) && IsObjectThrowError(this.core.entity, ['id', 'fieldgroup'], `Invalid Field`) ? this.core.entity : null;
                this.asset.type = this.asset.field.fieldgroup.name; // the field group name , ie.. address, phone
                this.asset.typeOption = this.srv.field.getDefaultLabelTypeOptions(); // the select options that belong to the types
                this.asset.basePath = `fields/${this.asset.field.id}/entries`; // api endpoint to hit for field entries
                this.ui.asset = {
                    entries: [], // list of configs for each entry record
                };
                this.dom.session.controls = new Map(); // store the entry configs so that changes are not lost when the tabs are changed
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => {
                this.dom.setTimeout('show-entries', () => {
                    this._showEntries();
                }, 0);
                return resolve(true);
            });
        };
    }
    /**
     * Nest all service related classes under srv
     */
    transformSrvContainer() {
        this.srv.field = this.fieldRepo;
        this.dom.repo = this.domRepo;
        delete this.fieldRepo;
        delete this.domRepo;
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * When the type of an entry is changed in the database, make sure the changes is updated locally
     * @param index
     * @param event
     */
    onEntryTypeChange(index, event) {
        if (IsValidFieldPatchEvent(this.core, event)) {
            const config = this.ui.entries[index];
            const entry = this.asset.field.entries[index];
            const session = this.dom.session.controls.get(index);
            if (entry && session) {
                entry.type = config.type.control.value;
                this._updateEntryTypeSession(session.type, entry);
                this.dom.session.controls.set(index, session);
                this.setDomSession(index, session);
            }
            setTimeout(() => {
                this._triggerFieldPreviewUpdate();
            }, 0);
        }
    }
    /**
     * When the display/label of an entry is changed in the database, make sure the changes is updated locally
     * @param index
     * @param event
     */
    onEntryDisplayChange(index, event) {
        if (IsValidFieldPatchEvent(this.core, event)) {
            const config = this.ui.entries[index];
            const entry = this.asset.field.entries[index];
            const session = this.dom.session.controls.get(index);
            if (entry && session) {
                entry.name = config.display.control.value;
                this._updateEntryDisplaySession(session.display, entry);
                this.dom.session.controls.set(index, session);
                this.setDomSession(index, session);
            }
        }
        setTimeout(() => {
            this._triggerFieldPreviewUpdate();
        }, 0);
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Listen for when the min_multiple && max_multiple values change
     * @param event
     * @private
     */
    _coreEventHandler(event) {
        this.log.info(`_coreEventHandler`, event);
        if (IsValidFieldPatchEvent(this.core, event)) {
            if (event.source === 'PopMinMaxComponent') {
                this.dom.setTimeout('show-entries', () => {
                    this._showEntries();
                }, 250);
            }
        }
    }
    /**
     * Produce a list of the entry values for this field
     * @private
     */
    _showEntries() {
        this.dom.state.pending = true;
        this._setValueEntries().then((entries) => {
            this._setEntrySessionControls(entries).then(() => {
                this._setEntries().then(() => {
                    this.dom.state.pending = false;
                    setTimeout(() => {
                        this._triggerFieldPreviewUpdate();
                    }, 0);
                });
            });
        });
    }
    /**
     * Ensure that the database records match the min/max settings
     * This will remove any excess records in the database that exceed the multiple_min
     * This will create records for an entries that are needed in the database
     * @param patch
     * @private
     */
    _setValueEntries() {
        return new Promise((resolve) => {
            const storedEntries = JSON.parse(JSON.stringify(this.asset.field.entries));
            const excess = storedEntries.splice(this.asset.field.multiple_min);
            let index = 0;
            const needed = [];
            while (index < this.asset.field.multiple_min) {
                const existing = index in storedEntries ? storedEntries[index] : null;
                if (!existing)
                    needed.push(index);
                index++;
            }
            const requests = []; // contains all the create/remove api/requests
            // delete any excess entries from database
            excess.map((entry) => {
                requests.push(this.srv.request.doDelete(`${this.asset.basePath}/${entry.id}`));
            });
            // create any needed entries in database
            needed.map((sessionIndex) => {
                const session = this.dom.session.controls.get(sessionIndex);
                requests.push(this.srv.request.doPost(`${this.asset.basePath}`, {
                    name: session ? session.display.value : null,
                    type: session ? session.type.value : this.asset.type in this.asset.typeOption ? this.asset.typeOption[this.asset.type].defaultValue : 'n/a'
                }, 1, false));
            });
            if (requests.length) { // need to update the data base to match min/max settings
                this._makeApiRequests(requests).then((serverEntries) => {
                    return resolve(serverEntries);
                });
            }
            else { // stored entries already match min/max settings
                return resolve(storedEntries);
            }
        });
    }
    /**
     * Will make all of the needed api requests
     * @param requests
     * @private
     */
    _makeApiRequests(requests) {
        return new Promise((resolve) => {
            forkJoin(requests).subscribe(() => {
                this.srv.request.doGet(this.asset.basePath).subscribe((res) => {
                    res = res.data ? res.data : res;
                    this.asset.field.entries = IsArray(res, true) ? res : [];
                    this.core.entity.entries = JSON.parse(JSON.stringify(this.asset.field.entries));
                    resolve(res);
                });
            }, (err) => {
                PopLog.error(this.name, `_makeApiRequests`, GetHttpErrorMsg(err));
                resolve([]);
            });
        });
    }
    /**
     * Store a set of controls that can store values as the user changes the settings
     * @private
     */
    _setEntrySessionControls(entries) {
        return new Promise((resolve) => {
            let index = 0;
            while (index < this.asset.field.multiple_min) {
                const entry = index in entries ? entries[index] : null;
                const session = this.dom.session.controls.has(index) ? this.dom.session.controls.get(index) : {
                    id: entry ? entry.id : null,
                    type: this._getTypeConfig(),
                    display: this._getDisplayConfig(),
                    increment: index + 1,
                };
                this._updateSessionControl(index, session, entry);
                index++;
            }
            return resolve(true);
        });
    }
    /**
     * Update the entry config to use the stored record, and update the sessions for it
     * @param index
     * @param session
     * @param entry
     * @private
     */
    _updateSessionControl(index, session, entry = null) {
        session.increment = index + 1;
        session.id = entry ? entry.id : null;
        this._updateEntryTypeSession(session.type, entry);
        this._updateEntryDisplaySession(session.display, entry);
        this.dom.session.controls.set(index, session);
        this.setDomSession(index, session);
        return session;
    }
    /**
     * Update the entry type config to use correct value and path
     * @param config
     * @param entry
     * @private
     */
    _updateEntryTypeSession(config, entry = null) {
        config.value = entry ? entry.type : this.asset.type in this.asset.typeOption ? this.asset.typeOption[this.asset.type].defaultValue : 'n/a';
        config.control.setValue(config.value, { emitEvent: false });
        config.patch.path = entry ? `${this.asset.basePath}/${entry.id}` : null;
    }
    /**
     * Update the entry display config to use correct value and path
     * @param config
     * @param entry
     * @private
     */
    _updateEntryDisplaySession(config, entry = null) {
        config.value = entry ? entry.name : '';
        config.control.setValue(config.value, { emitEvent: false });
        config.patch.path = entry ? `${this.asset.basePath}/${entry.id}` : null;
    }
    /**
     * Store each entry config in a dom session so that it can be restored when the users is switching tabs
     * @param index
     * @param session
     */
    setDomSession(index, session) {
        const domStorage = StorageGetter(this.dom.repo, ['components', this.name, this.id + '', 'session']);
        if (IsObject(domStorage, ['controls'])) {
            const controls = domStorage.controls;
            controls.set(index, session);
        }
    }
    /**
     * Set entry config objects that will be used in the html template
     * @private
     */
    _setEntries() {
        return new Promise((resolve) => {
            this.ui.entries = [];
            if (this.dom.session.controls) {
                let index = 0;
                while (index < this.asset.field.multiple_min) {
                    this.ui.entries.push(this.dom.session.controls.get(index));
                    index++;
                }
            }
            return resolve(true);
        });
    }
    /**
     * Manage the type of each entry
     * @param ind
     * @private
     */
    _getTypeConfig() {
        let disabled = false;
        let options = this.asset.type in this.asset.typeOption ? this.asset.typeOption[this.asset.type].options : [];
        if (!IsArray(options, true)) {
            options = [{ value: 'n/a', name: 'N/A' }];
            disabled = true;
        }
        return new SelectConfig({
            label: 'Type',
            options: { values: options },
            disabled: disabled,
            patch: {
                field: 'type',
                path: null,
            }
        });
    }
    /**
     * Manage the display of each entry
     * @param index
     * @private
     */
    _getDisplayConfig() {
        return new InputConfig({
            label: 'Display Name',
            patch: {
                field: 'name',
                path: null
            }
        });
    }
    _triggerFieldPreviewUpdate() {
        this.core.channel.next({ source: this.name, target: 'PopEntityFieldPreviewComponent', type: 'component', name: 'update' });
    }
}
PopEntityFieldValuesComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-values',
                template: "<mat-divider [style.width.%]=100 [style.marginTop.px]=5 [style.marginBottom.px]=5></mat-divider>\n<div class=\"entity-field-values-container\" [ngClass]=\"{'sw-disabled': dom.state.pending}\">\n  <div class=\"entity-field-values-row\" *ngFor=\"let entry of ui.entries; let index = index;\">\n    <div class=\"entity-field-values-row import-flex-item-sm import-flex-grow-xs\">\n      <div class=\"entity-field-values-section import-flex-column-break import-flex-item-xs import-flex-start-center\" [style.maxWidth.px]=30>\n        {{entry.increment}}.\n      </div>\n      <div class=\"entity-field-values-section import-flex-column-break import-flex-item-sm import-flex-grow-xs\">\n        <lib-pop-select class=\"import-flex-item-full\" [config]=\"entry.type\" (events)=\"onEntryTypeChange(index, $event)\"></lib-pop-select>\n      </div>\n    </div>\n    <div class=\"entity-field-values-row import-flex-item-sm import-flex-grow-xs\">\n      <div class=\"entity-field-values-section import-flex-column-break import-flex-item-sm import-flex-grow-xs sw-mar-lft-md\">\n        <lib-pop-input class=\"import-flex-item-full\" [config]=\"entry.display\" (events)=\"onEntryDisplayChange(index, $event)\"></lib-pop-input>\n      </div>\n    </div>\n  </div>\n</div>\n\n",
                styles: [".import-flex-row,.import-flex-row-wrap{display:flex;flex-direction:row}.import-flex-row-wrap{flex-wrap:wrap;padding:0;flex-basis:100%;box-sizing:border-box}.import-flex-row-break{flex-basis:100%;height:0}.import-flex-column-break{flex-basis:100%;width:0}.import-flex-item-icon{min-width:var(--field-icon-width);height:var(--field-icon-height);display:flex;justify-content:center;align-items:center}.import-flex-column-xs{display:flex;flex-direction:column;width:12.5%;min-height:30px}.import-flex-column-sm{flex:1;flex-direction:column;width:25%;min-height:30px}.import-flex-column-md{flex:1;flex-direction:column;width:50%}.import-flex-column-lg{flex:1;flex-direction:column;width:75%;min-height:30px}.import-flex-item-xs{flex-basis:12.5%}.import-flex-item-sm{flex-basis:25%}.import-flex-item-md{flex-basis:50%}.import-flex-item-full{flex-basis:100%}.import-flex-grow-xs{flex-grow:1}.import-flex-grow-sm{flex-grow:2}.import-flex-grow-md{flex-grow:3}.import-flex-grow-lg{flex-grow:4}.import-flex-column{display:flex;flex-direction:column}.import-flex-center{display:flex;align-items:center;justify-content:center}.import-flex-space-center{justify-content:space-around;align-items:center}.import-flex-space-between-center{justify-content:space-between;align-items:center}.import-flex-center-start{display:flex;justify-content:center;align-items:flex-start}.import-flex-start-center{display:flex;justify-content:flex-start;align-items:center}.import-flex-end-center{display:flex;justify-content:flex-end;align-items:center}.import-flex-end{display:flex;align-items:flex-end;justify-content:flex-end}.import-flex-align-end{display:flex;align-self:flex-end}.import-flex-stretch-center{display:flex;justify-content:stretch;align-items:center}.sw-mar-xs{margin:var(--xs)}.sw-mar-sm{margin:var(--sm)}.sw-mar-md{margin:var(--md)}.sw-mar-lg{margin:var(--lg)}.sw-mar-xlg{margin:var(--xlg)}.sw-mar-hrz-xs{margin-left:var(--xs);margin-right:var(--xs)}.sw-mar-hrz-md,.sw-mar-hrz-sm{margin-left:var(--md);margin-right:var(--md)}.sw-mar-hrz-lg{margin-left:var(--lg);margin-right:var(--lg)}.sw-mar-hrz-xlg{margin-left:var(--xlg);margin-right:var(--xlg)}.sw-mar-vrt-xs{margin-top:var(--xs);margin-bottom:var(--xs)}.sw-mar-vrt-md,.sw-mar-vrt-sm{margin-top:var(--md);margin-bottom:var(--md)}.sw-mar-vrt-lg{margin-top:var(--lg);margin-bottom:var(--lg)}.sw-mar-vrt-xlg{margin-top:var(--xlg);margin-bottom:var(--xlg)}.sw-mar-lft-xs{margin-left:var(--xs)}.sw-mar-lft-sm{margin-left:var(--sm)}.sw-mar-lft-md{margin-left:var(--md)}.sw-mar-lft-lg{margin-left:var(--lg)}.sw-mar-lft-xlg{margin-left:var(--xlg)}.sw-mar-rgt-xs{margin-right:var(--xs)}.sw-mar-rgt-sm{margin-right:var(--sm)}.sw-mar-rgt-md{margin-right:var(--md)}.sw-mar-rgt-lg{margin-right:var(--lg)}.sw-mar-rgt-xlg{margin-right:var(--xlg)}.sw-mar-btm-xs{margin-bottom:var(--xs)}.sw-mar-btm-sm{margin-bottom:var(--sm)}.sw-mar-btm-md{margin-bottom:var(--md)}.sw-mar-btm-lg{margin-bottom:var(--lg)}.sw-mar-btm-xlg{margin-bottom:var(--xlg)}.sw-mar-top-xs{margin-top:var(--xs)}.sw-mar-top-sm{margin-top:var(--sm)}.sw-mar-top-md{margin-top:var(--md)}.sw-mar-top-lg{margin-top:var(--lg)}.sw-mar-top-xlg{margin-top:var(--xlg)}:host{width:100%}.entity-field-values-container{display:flex;flex-direction:column;width:100%;position:relative;box-sizing:border-box;max-height:245px;overflow-x:hidden;overflow-y:auto}.entity-field-values-row{height:60px;display:flex;width:100%;box-sizing:border-box}.entity-field-values-section{display:flex;height:60px}"]
            },] }
];
PopEntityFieldValuesComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService }
];
// export interface FieldEntrySession {
//   id: number;
//   type: SelectConfig;
//   display: InputConfig;
//   increment: number;
// }

class FieldLabelParamComponent {
    /**
     * This component expects config to be a Label config
     */
    ngOnInit() {
    }
}
FieldLabelParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-label-param',
                template: `
    <div class="field-builder-param-container">
      <div class="field-builder-param-title-container mat-h2">
        <div class="field-builder-param-title">{{config.name}}</div>
      </div>
    </div>`
            },] }
];
FieldLabelParamComponent.propDecorators = {
    config: [{ type: Input }]
};

class FieldTextareaParamComponent {
    constructor() {
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new TextareaConfig({
            name: this.config.name,
            label: this.config.label,
            column: this.config.column,
            value: IsDefined(this.config.value) ? this.config.value : this.config.defaultValue,
            height: 70,
            facade: this.config.facade,
            patch: this.config.patch,
            metadata: this.config.metadata ? this.config.metadata : {}
        });
    }
}
FieldTextareaParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-textarea-param',
                template: `
    <lib-pop-textarea (events)="events.emit($event);" [config]=param></lib-pop-textarea>`
            },] }
];
FieldTextareaParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldRadioParamComponent {
    constructor(commonRepo, changeDetectorRef) {
        this.commonRepo = commonRepo;
        this.changeDetectorRef = changeDetectorRef;
        this.events = new EventEmitter();
    }
    ngOnInit() {
        this.param = new RadioConfig({
            label: (this.config.label ? this.config.label : this.config.name),
            name: this.config.name,
            layout: 'row',
            value: this.config.value ? this.config.value : this.config.defaultValue,
            patch: this.config.patch,
            options: this.config.options,
            facade: this.config.facade,
            metadata: this.config.metadata ? this.config.metadata : {}
        });
    }
    ngOnDestroy() {
    }
}
FieldRadioParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-radio-param',
                template: `<lib-pop-radio (events)="events.emit($event);" [config]=param></lib-pop-radio>`
            },] }
];
FieldRadioParamComponent.ctorParameters = () => [
    { type: PopCommonService },
    { type: ChangeDetectorRef }
];
FieldRadioParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldSelectParamComponent {
    constructor() {
        this.events = new EventEmitter();
        this.hidden = false;
    }
    ngOnInit() {
        if (IsObject(this.config, true)) {
            this.param = new SelectConfig({
                label: (this.config.label ? this.config.label : this.config.name),
                name: this.config.name,
                value: this.config.value ? this.config.value : this.config.defaultValue,
                options: {
                    values: IsObject(this.config.options, ['values']) ? ConvertArrayToOptionList(this.config.options.values) : []
                },
                facade: this.config.facade,
                patch: this.config.patch,
                metadata: this.config.metadata ? this.config.metadata : {}
            });
        }
        this.hidden = this.param.options.values.length === 0 ? true : false;
    }
}
FieldSelectParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-select-param',
                template: `
    <lib-pop-select *ngIf="param" (events)="events.emit($event);" [config]=param></lib-pop-select>`
            },] }
];
FieldSelectParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }],
    hidden: [{ type: HostBinding, args: ['class.sw-hidden',] }, { type: Input }]
};

class FieldInputParamComponent {
    constructor() {
        this.events = new EventEmitter();
    }
    ngOnInit() {
        const validators = [];
        if (this.config.required)
            validators.push(Validators.required);
        this.param = new InputConfig({
            name: this.config.name,
            label: this.config.label,
            value: this.config.value ? this.config.value : this.config.defaultValue,
            readonly: this.config.readonly,
            validators: validators,
            patch: this.config.patch,
            facade: this.config.facade,
            metadata: this.config.metadata ? this.config.metadata : {}
        });
    }
}
FieldInputParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-input-param',
                template: `
    <lib-pop-input (events)="events.emit($event);" [config]=param></lib-pop-input>`
            },] }
];
FieldInputParamComponent.ctorParameters = () => [];
FieldInputParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class FieldNumberParamComponent {
    constructor() {
        this.events = new EventEmitter();
    }
    ngOnInit() {
        const defaultValue = IsDefined(this.config.default_value) ? +this.config.default_value : 255;
        const configInterface = {
            label: this.config.label,
            name: this.config.name,
            value: this.config.value ? this.config.value : this.config.default_value,
            patch: this.config.patch,
            facade: this.config.facade,
            min: 1,
            max: defaultValue,
            metadata: this.config.metadata ? this.config.metadata : {}
        };
        if (this.config.name === 'maxlength') {
            configInterface.helpText = `Limit: ${defaultValue}`;
        }
        this.param = new NumberConfig(configInterface);
    }
    ngOnDestroy() {
    }
}
FieldNumberParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-number-param',
                template: `
    <lib-pop-number (events)="events.emit($event);" [config]=param></lib-pop-number>`
            },] }
];
FieldNumberParamComponent.ctorParameters = () => [];
FieldNumberParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopEntityFieldItemParamsComponent extends PopExtendDynamicComponent {
    constructor(el, _domRepo, _fieldRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this.scheme = null;
        this.name = 'PopEntityFieldItemParamsComponent';
        this.asset = {
            field: undefined,
            viewParams: undefined,
            viewOptions: undefined,
            viewTemplate: undefined,
        };
        this.srv = {
            entity: ServiceInjector.get(PopEntityService),
            field: undefined,
            request: ServiceInjector.get(PopRequestService),
        };
        /**
         * This should transformValue and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                // #1: Enforce a CoreConfig
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                this.field = IsObjectThrowError(this.core.entity, true, ``) ? this.core.entity : null;
                // Set the outer height boundary of the component
                this._setHeight();
                // Set the template container for the field item list
                this.template.attach('container');
                // Set event Handlers
                this.dom.handler.core = (core, event) => this.coreEventHandler(event);
                this.dom.handler.bubble = (core, event) => this.onBubbleEvent(event);
                this.dom.state.showOptions = false;
                this.asset.viewParams = this.srv.field.getViewParams();
                this.asset.viewOptions = this.srv.field.getViewOptions();
                return resolve(true);
            });
        };
    }
    /**
     * We expect the core to represent a field
     * This component allows the user to configure the settings of the specific field attribute item
     * The FieldBuilderItemsComponent is responsible to communicate which field attribute item is active
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This handler handles any events that come up from the settings fields
     * @param event
     */
    onBubbleEvent(event) {
        PopLog.event(this.name, `onBubbleEvent`, event);
        if (event.type === 'field' && event.name === 'patch' && event.success) {
            if (IsDefined(event.config.name)) {
                const field = this.dom.active.item;
                const value = event.config.control.value;
                if (event.config.name === 'active') {
                    field.active = +value;
                }
                else if (IsObject(event.config.metadata, ['session'])) {
                    if (IsArray(event.config.metadata.session)) {
                        event.config.metadata.session.map((storage) => {
                            if (IsObject(storage)) {
                                storage[event.config.name] = value;
                            }
                        });
                    }
                    else if (IsObject(event.config.metadata.session)) {
                        event.config.metadata.session[event.config.name] = value;
                    }
                }
            }
            this.dom.setTimeout('update-preview', () => {
                this.core.channel.next({ source: this.name, type: 'component', name: 'update', target: 'PopEntityFieldPreviewComponent' });
            }, 250);
        }
    }
    /**
     * This is action that initiates setting up the preview
     */
    setActiveFieldItem() {
        if (this.dom.active.item) {
            this._setFieldItemOptions();
            this._setFieldItemParams();
        }
    }
    /**
     * This is action that initiates setting up the preview
     */
    setLabelSettings() {
        this.dom.active.item = null;
        this.dom.state.showOptions = false;
        this._configureLabelList().then((paramComponentList) => {
            this.template.render(paramComponentList, [], true);
        });
    }
    /**
     * The user can add entries in to the options that this field should use
     */
    addFieldItemOption() {
        this.dom.active.options.push({
            active: new CheckboxConfig({
                label: null,
                value: 1,
                bubble: true,
            }),
            name: new InputConfig({
                label: null,
                value: '',
                pattern: 'AlphaNumeric',
                bubble: true,
                maxlength: 128,
                minimal: true,
            }),
            value: new InputConfig({
                label: null,
                value: '',
                pattern: 'AlphaNumericNoSpace',
                bubble: true,
                maxlength: 128,
                minimal: true,
            }),
            sort: new InputConfig({
                label: null,
                minimal: true,
                value: this.dom.active.options.length,
                bubble: true,
            }),
        });
    }
    /**
     * The user can remove an existing option that this field is using
     * @param index
     */
    removeFieldItemOption(index) {
        if (index in this.dom.active.options) {
            this.dom.active.options.splice(index, 1);
            this.dom.active.options.map((option, i) => {
                option.sort.control.setValue(i);
            });
        }
        this.triggerSaveFieldOptions({ name: 'onChange' });
    }
    /**
     * This will allow the user to make consecutive changes with minimal api calls
     * @param event
     */
    triggerSaveFieldOptions(event) {
        if (event && (event.name === 'onKeyUp' || event.name === 'onChange')) {
            if (this.dom.delay.saveFieldOptions) {
                clearTimeout(this.dom.delay.saveFieldOptions);
            }
            this.dom.delay.saveFieldOptions = setTimeout(() => {
                this.saveFieldItemOptions();
            }, 500);
        }
    }
    /**
     * Reset the option values with the root source
     * @param event
     */
    onOptionSourceReset(event) {
        const field = this.dom.active.item;
        if (IsArray(field.source, true)) {
            field.options.values = [];
            field.source.map((item, index) => {
                field.options.values.push({
                    active: item.active ? +item.active : 1,
                    name: item.name ? item.name : item.label ? item.label : 'Item ' + (index + 1),
                    value: item.id ? item.id : item.value ? item.value : (index + 1),
                    sort: index
                });
            });
            this._setFieldItemOptions();
            this.triggerSaveFieldOptions({ name: 'onChange' });
        }
    }
    /**
     * This will store the option changes that the user makes
     */
    saveFieldItemOptions() {
        // #1: Create the payload structure
        this.dom.state.saving = true;
        const field = this.dom.active.item;
        const json = JSON.parse(JSON.stringify(field.options));
        json.values = [];
        let opt;
        this.dom.active.options.map((option) => {
            opt = {};
            Object.keys(option).map((key) => {
                opt[key] = option[key].control.value;
            });
            json.values.push(opt);
        });
        const ignore401 = null;
        const version = 1;
        const patch = {
            'options': json
        };
        // #2: Clear/Store the subscriber so that it can be ignored if needed
        this.dom.setSubscriber('options-api-call', this.srv.request.doPatch(`/fields/customs/${field.id}`, patch, version, ignore401).subscribe(res => {
            this.dom.active.item.options.values = json.values;
            this.dom.state.saving = false;
            // #3: Inform the FieldBuilderPreviewComponent to update the new settings
            this.core.channel.next({ source: this.name, type: 'component', name: 'update', target: 'PopEntityFieldPreviewComponent' });
            if (this.dom.subscriber.api)
                this.dom.subscriber.api.unsubscribe();
        }, err => {
            this.dom.state.saving = false;
        }));
    }
    /**
     * This allows the user to sort the list of options that this field uses
     * @param event
     */
    onOptionSortDrop(event) {
        moveItemInArray(this.dom.active.options, event.previousIndex, event.currentIndex);
        this.triggerSaveFieldOptions({ name: 'onChange' });
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        this.template.destroy();
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * This handler is for managing any cross-communication between components on the core channel
     * @param event
     */
    coreEventHandler(event) {
        this.log.event(`coreEventHandler`, event);
        if (event.type === 'component') {
            if (event.source === 'PopEntityFieldItemsComponent') {
                if (event.name === 'active-item') {
                    // #1: An event has triggered that the view needs to change the active item,  debounce this trigger so that this action does not get called on top of itself
                    this.dom.setTimeout('reset-view', () => {
                        this.dom.loading();
                        // #2: Transfer in the data package from the event
                        this.dom.active.item = event.data;
                        // this.asset.viewParams = event.data.config;
                        // this.asset.model = event.data.model;
                        // #3: Render the Active Item settings that are available
                        this.setActiveFieldItem();
                        setTimeout(() => {
                            this.dom.ready();
                        }, 0);
                    }, 100);
                }
                else if (event.name === 'label-settings') {
                    // #1: An event has triggered that the view needs to change the active item,  debounce this trigger so that this action does not get called on top of itself
                    if (this.dom.delay.reset)
                        clearTimeout(this.dom.delay.reset);
                    this.dom.delay.reset = setTimeout(() => {
                        this.dom.loading();
                        this.setLabelSettings();
                        setTimeout(() => {
                            this.dom.ready();
                        }, 0);
                    }, 100);
                }
            }
        }
        else if (IsValidFieldPatchEvent(this.core, event)) {
            this._setHeight();
        }
    }
    /**
     * This handles rendering the dynamic list of  param settings into the view
     * @param form
     * @param fieldItem
     * @param params
     */
    _setFieldItemParams() {
        if (IsObject(this.dom.active.item, true)) {
            this._configureParamList().then((paramComponentList) => {
                this.template.render(paramComponentList, [], true);
            });
        }
    }
    /**
     * This will return a list of all the inputs that the settings require
     * @param fieldItem
     * @param params
     */
    _configureParamList() {
        return new Promise((resolve) => {
            const paramComponentList = [];
            let component;
            let configInterface;
            const fieldItem = this.dom.active.item;
            const view = fieldItem.view;
            const rules = fieldItem.rules.sort(DynamicSort('name')).map((rule) => CleanObject(rule));
            const allowed = this.asset.viewParams[view.name];
            const group = this.field.fieldgroup.name;
            const itemCustomSettings = fieldItem.custom_setting;
            // ToDo: Put the custom Settings into the paramList
            // console.log('itemCustomSettings', itemCustomSettings);
            const isScheme = IsObject(this.scheme, ['id']) ? true : false;
            this.log.config(`activeItem`, {
                item: fieldItem,
                rules: rules,
                group: group,
                allowed: allowed,
                settings: itemCustomSettings,
                view: view
            });
            if (this.dom.active.item.name !== 'value') {
                let labelValue = fieldItem.label;
                if (isScheme) {
                    const mapping = this.srv.field.getSchemeFieldItemMapping(this.scheme, +this.field.id, this.dom.active.item.id);
                    if (IsString(mapping.label, true)) {
                        labelValue = mapping.label;
                    }
                }
                const display = {
                    type: this._getParamComponent('display'),
                    inputs: {
                        config: configInterface = Object.assign({
                            value: labelValue,
                            defaultValue: '',
                        }, {
                            label: 'Label',
                            name: 'label',
                            readonly: false,
                            required: true,
                            metadata: {
                                session: fieldItem
                            },
                            facade: isScheme,
                            patch: {
                                field: 'label',
                                path: `fields/customs/${fieldItem.id}`,
                                callback: isScheme ? (core, event) => __awaiter(this, void 0, void 0, function* () {
                                    const session = this.srv.field.getSchemeFieldItemMapping(this.scheme, +this.field.id, this.dom.active.item.id);
                                    session.label = event.config.control.value;
                                    yield this.srv.field.updateSchemeFieldMapping(this.scheme);
                                    // console.log( 'session', session );
                                    // console.log( 'facade', event.config.name, event.config.control.value );
                                }) : null,
                            }
                        })
                    }
                };
                paramComponentList.push(display);
            }
            if (group === 'selection') {
                const display = {
                    type: this._getParamComponent('view'),
                    inputs: {
                        config: configInterface = Object.assign({
                            value: view.id,
                            defaultValue: '',
                        }, {
                            label: 'Template View',
                            name: 'field_view_id',
                            readonly: false,
                            required: true,
                            options: {
                                defaultValue: 2,
                                values: [
                                    { value: 2, name: 'Select', sort_order: 0 },
                                    { value: 10, name: 'Radio', sort_order: 1 },
                                ]
                            },
                            metadata: {
                                session: fieldItem
                            },
                            patch: {
                                field: 'field_view_id',
                                path: `fields/${fieldItem.id}`,
                                callback: (core, event) => {
                                    const session = event.config.metadata.session;
                                    session.view = FieldItemView(event.response.view);
                                }
                            }
                        })
                    }
                };
                paramComponentList.push(display);
            }
            // if(!this.field.multiple){
            //   const helpText = <DynamicComponentInterface>{
            //     type: this._getParamComponent('helpText'),
            //     inputs: {
            //       config: configInterface = {
            //         ...{
            //           value: fieldItem.helpText ? fieldItem.helpText : null,
            //           defaultValue: '',
            //         },
            //         ...{
            //           label: 'Help Text',
            //           name: 'helpText',
            //           readonly: false,
            //           metadata: {
            //             session: fieldItem
            //           },
            //           patch: { field: 'helpText', path: `fields/customs/${fieldItem.id}` }
            //         }
            //       }
            //     }
            //   };
            //   paramComponentList.push(helpText);
            // }
            if (view.name in this.asset.viewParams) {
                const ruleSchemeSession = this.srv.field.getSchemeFieldItemSection(this.scheme, +this.field.id, this.dom.active.item.id, 'rule');
                rules.map((rule) => {
                    //           console.log('rule', rule);
                    let ruleValue = rule.value;
                    if (isScheme) {
                        if (IsDefined(ruleSchemeSession[rule.name])) {
                            ruleValue = ruleSchemeSession[rule.name];
                        }
                    }
                    if (rule.name in allowed) {
                        configInterface = Object.assign(Object.assign({}, rule), {
                            value: ruleValue,
                            name: rule.name,
                            label: TitleCase(SnakeToPascal(rule.name)),
                            metadata: { rule: rule },
                            facade: true,
                            patch: {
                                duration: 0,
                                field: ``,
                                path: ``,
                                callback: (core, event) => __awaiter(this, void 0, void 0, function* () {
                                    if (IsObject(this.scheme, true)) {
                                        if (IsObject(ruleSchemeSession)) {
                                            ruleSchemeSession[rule.name] = event.config.control.value;
                                            yield this.srv.field.updateSchemeFieldMapping(this.scheme);
                                        }
                                    }
                                    else {
                                        this.srv.field.storeFieldItemRule(core, fieldItem, event).then(() => true);
                                    }
                                })
                            }
                        });
                        if (IsObject(rule.options, true)) {
                            configInterface.options = rule.options;
                        }
                        component = {
                            type: this._getParamComponent(rule.name),
                            inputs: {
                                config: configInterface,
                            }
                        };
                        paramComponentList.push(component);
                    }
                });
            }
            if (IsObject(itemCustomSettings, true)) {
                Object.keys(itemCustomSettings).map((settingName) => {
                    const setting = itemCustomSettings[settingName];
                    // console.log('setting', setting);
                    if (setting.type !== 'model') {
                        paramComponentList.push(this.srv.field.getCustomSettingComponent(this.core, this.core.entity, setting, this.scheme));
                    }
                });
            }
            resolve(paramComponentList);
        });
    }
    /**
     * This will return a list of all the inputs that the label settings require
     * @param fieldItem
     * @param params
     */
    _configureLabelList() {
        return new Promise((resolve) => {
            // const paramComponentList: DynamicComponentInterface[] = [];
            //
            // const values = <DynamicComponentInterface>{
            //   type: PopEntityFieldLabelComponent,
            //   inputs: {
            //     core: this.core
            //   }
            // };
            // paramComponentList.push(values);
            //
            //
            resolve([]);
        });
    }
    _setHeight() {
        this.dom.overhead = 125;
        // this.dom.height.outer = +this.dom.repo.position[ this.position ].height - 121;
        // const field = <FieldInterface>this.core.entity;
        // if( false && field.multiple ){
        //   this.dom.height.outer -= 20;
        //   this.dom.height.outer -= ( +field.multiple_min * 60 );
        // } // values box
        //
        // if( this.dom.height.outer < 400 ) this.dom.height.outer = 400;
        // this.dom.height.outer -= 2;
        this.dom.setHeight(399, this.dom.overhead);
    }
    /**
     * Return the the field input component that should be used for the type of setting param;
     * @param form
     */
    _getParamComponent(form) {
        switch (form) {
            case 'label':
                return FieldLabelParamComponent;
                break;
            case 'display':
            case 'api':
            case 'sort_top':
            case 'regex':
            case 'sort':
            case 'helpText':
                return FieldInputParamComponent;
                break;
            case 'select':
            case 'mask':
            case 'pattern':
            case 'validation':
            case 'transformation':
                return FieldSelectParamComponent;
                break;
            case 'hidden':
            case 'visible':
            case 'disabled':
            case 'readonly':
            case 'required':
                return FieldSwitchParamComponent;
                break;
            case 'layout':
                return FieldRadioParamComponent;
                break;
            case 'minlength':
            case 'maxlength':
                return FieldNumberParamComponent;
            case 'metadata':
                return FieldTextareaParamComponent;
                break;
            case 'view':
                return FieldRadioParamComponent;
                break;
            default:
                return FieldLabelParamComponent;
        }
    }
    /**
     * This will make sure the options will get set up properly if the active items uses them
     * @param form
     * @param options
     * @param params
     */
    _setFieldItemOptions() {
        this.dom.state.showOptions = false;
        const field = this.dom.active.item;
        const form = field.view ? field.view.name : null;
        if (!form)
            PopLog.warn(this.name, `_setFieldItemOptions: Invalid Form`, field);
        this.dom.active.options = [];
        if (form && form in this.asset.viewOptions) {
            // if( field.options.fixed ){
            //   field.options.enum = true;
            // }
            if (IsArray(field.source, true)) {
                field.options.enum = true;
                this.dom.state.isOptionSource = true;
            }
            if (!(IsObject(field.options, ['values'])) && !(field.source)) {
                field.options = this.asset.viewOptions[form];
            }
            if (IsObject(field.options, ['values']) && Array.isArray(field.options.values)) {
                field.options.values.map((option, index) => {
                    option.name = option.name ? String(option.name) : 'Item ' + (index + 1);
                    option.value = option.id ? String(option.id) : option.value ? String(option.value) : String((index + 1));
                    option.sort = index;
                    if (typeof option.active !== 'boolean')
                        option.active = true;
                    this.dom.active.options.push({
                        active: new CheckboxConfig({
                            label: null,
                            value: +option.active,
                            bubble: true,
                        }),
                        name: new InputConfig({
                            label: null,
                            value: option.name,
                            transformation: 'title',
                            bubble: this.dom.state.isOptionSource ? false : true,
                            pattern: 'AlphaNumeric',
                            validators: [Validators.required],
                            maxlength: 32,
                            readonly: this.dom.state.isOptionSource ? true : false,
                        }),
                        value: new InputConfig({
                            label: null,
                            value: option.value,
                            bubble: field.options.enum ? false : true,
                            validators: [Validators.required],
                            pattern: 'AlphaNumericNoSpace',
                            transformation: 'lower',
                            maxlength: 32,
                            readonly: field.options.enum ? true : false,
                        }),
                        sort: new InputConfig({
                            label: null,
                            value: option.sort || 0,
                            bubble: true,
                        }),
                    });
                });
                this.dom.state.showOptions = true;
            }
        }
    }
}
PopEntityFieldItemParamsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-builder-items-params',
                template: "<div class=\"entity-field-item-settings-container\" [style.height.px]=dom.height.outer>\n  <div class=\"entity-field-editor-section-wrapper\">\n    <div class=\"field-builder-config-content\" [style.height.px]=\"dom.height.outer\">\n      <ng-container #container></ng-container>\n      <div class=\"field-builder-options-content\" *ngIf=\"dom.state.showOptions\" [style.maxHeight.px]=\"dom.height.inner\">\n        <div class=\"field-builder-source-header\">\n          <label>Options</label>\n          <lib-pop-button\n            *ngIf=\"dom.state.isOptionSource\"\n            [config]=\"{value:'Reset', size: 24, text: 12, color: 'default', bubble: true, event: 'reset-source'}\"\n            (events)=\"onOptionSourceReset($event);\"\n          ></lib-pop-button>\n        </div>\n        <mat-divider *ngIf=\"dom.state.showOptions\"></mat-divider>\n        <div class=\"field-builder-item-options-headers\">\n          <div class=\"field-builder-item-options-sort\">\n            Sort\n          </div>\n          <div class=\"field-builder-item-options-active\">\n            Active\n          </div>\n          <div class=\"field-builder-item-name-input field-builder-mar-rgt\">\n            <label>Name</label>\n          </div>\n          <div class=\"field-builder-item-value-input\">\n            Value\n          </div>\n          <div class=\"field-builder-item-options-icon\" [ngClass]=\"{'sw-hidden':dom.active.item?.options.enum}\">\n            <i class=\"material-icons field-builder-item-options-new sw-pointer sw-hover\" matTooltip=\"Add\"\n               (click)=\"addFieldItemOption()\">\n              add\n            </i>\n          </div>\n        </div>\n        <mat-divider></mat-divider>\n        <div class=\"field-builder-item-options-loader\">\n          <mat-progress-bar *ngIf=\"dom.state.saving\" mode=\"indeterminate\"></mat-progress-bar>\n        </div>\n        <div class=\"field-builder-item-options-container\" cdkDropList (cdkDropListDropped)=\"onOptionSortDrop($event)\">\n          <div class=\"field-builder-item-options-headers\" *ngFor=\"let option of dom.active.options; let i = index;\" cdkDrag cdkDragLockAxis=\"y\" cdkDragBoundary=\".field-builder-item-options-container\">\n            <div class=\"field-builder-item-options-sort\" [ngClass]=\"{'sw-hidden':dom.active.item?.options.fixed}\">\n              <i class=\"material-icons\" cdkDragHandle>\n                drag_indicator\n              </i>\n            </div>\n            <div class=\"field-builder-item-options-active\" [ngClass]=\"{'sw-hidden':dom.active.item?.options.fixed}\">\n              <lib-pop-checkbox (events)=\"triggerSaveFieldOptions($event);\" [config]=\"option.active\"></lib-pop-checkbox>\n            </div>\n            <div class=\"field-builder-item-name-input field-builder-mar-rgt\">\n              <lib-pop-input [config]=\"option.name\" (events)=\"triggerSaveFieldOptions($event);\"></lib-pop-input>\n            </div>\n            <div class=\"field-builder-item-value-input\">\n              <lib-pop-input [config]=\"option.value\" (events)=\"triggerSaveFieldOptions($event);\"></lib-pop-input>\n            </div>\n            <div class=\"field-builder-item-options-icon\" matTooltip=\"Remove\" [ngClass]=\"{'sw-hidden':dom.active.item?.options.enum}\">\n              <i class=\"material-icons field-builder-item-options-new sw-pointer sw-hover\"\n                 (click)=\"removeFieldItemOption(i)\">\n                remove\n              </i>\n            </div>\n            <div class=\"field-builder-item-options-headers\" *cdkDragPreview></div>\n          </div>\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n",
                styles: [".entity-field-editor-header{display:flex;flex-direction:column;height:97px}.entity-field-editor-header-section{position:relative;width:100%;box-sizing:border-box;height:30px;clear:both}.entity-field-editor-container{min-height:100px;position:relative}.entity-field-editor-border{border:1px solid var(--border)}.entity-field-editor-section-header{position:relative;display:flex;flex-direction:row;height:40px;padding:0 5px 0 10px;align-items:center;justify-content:space-between;font-size:1em;font-weight:700;clear:both;box-sizing:border-box;background:var(--darken02)}.entity-field-editor-section-header-helper-icon{width:20px;height:20px;font-size:1em;z-index:2}.entity-field-editor-active-selection{padding-left:0!important;border-left:5px solid var(--primary)}.entity-field-editor-active-config{border-left:5px solid var(--primary)}.entity-field-item-settings-container{min-height:100px;position:relative;border:1px solid var(--border);border-left:none;min-width:200px}.field-builder-config-row{position:relative;height:30px;max-height:30px;min-width:200px;font-size:20px;line-height:20px;flex:1 1 100%;flex-direction:row;margin:4px 0 4px 10px;align-items:center;justify-content:flex-start;clear:both}.field-builder-config-content{padding:5px 15px 10px;box-sizing:border-box;display:flex;flex-flow:column;align-items:stretch;overflow-y:scroll;overflow-x:hidden}.field-builder-options-content{flex:1;flex-grow:1;flex-direction:column;box-sizing:border-box}.field-builder-source-header{position:relative;width:100%;display:flex;align-items:center;justify-content:space-between;box-sizing:border-box;height:35px;margin-top:10px;clear:both}.field-builder-item-options-new{float:right}.field-builder-item-options-headers{display:flex;align-items:center;justify-content:flex-start;margin-top:2px;height:32px}.field-builder-item-options-active{display:flex;width:55px;text-align:center;align-items:center;justify-content:center}.field-builder-item-options-loader{position:relative;display:block;width:100%;height:2px;clear:both;overflow:hidden;margin-bottom:2px}.field-builder-item-options-input{display:flex;width:25%;flex-grow:1}.field-builder-item-options-input lib-pop-input{width:100%}.field-builder-item-name-input{display:flex;width:40%;flex-grow:1}.field-builder-item-name-input lib-pop-input{width:100%}.field-builder-item-value-input{display:flex;width:20%;flex-grow:1}.field-builder-item-value-input lib-pop-input{width:100%}.field-builder-item-options-container{flex:1;flex-direction:column;padding:8px 0;box-sizing:border-box}.field-builder-item-options-sort{display:flex;width:10%;align-items:center;justify-content:center}.field-builder-item-options-sort i{margin-top:var(--gap-xs)}.field-builder-item-options-icon{display:flex;width:40px;align-items:center;justify-content:center}.field-builder-preview-content{position:relative;margin-top:5px;padding:5px}.field-builder-state-selector-wrapper{position:absolute;right:5px;top:-5px;width:50%;height:30px;font-size:12px}.field-builder-mar-rgt{margin-right:5px}:host ::ng-deep .field-builder-param-container{position:relative;display:flex;flex-direction:row;box-sizing:border-box;-moz-box-sizing:border-box;align-items:center;justify-content:flex-start;margin-bottom:4px}:host ::ng-deep .field-builder-param-title-container{display:flex;padding:0 0 0 2%;pointer-events:all;align-items:center;width:30%;max-width:30%;overflow:hidden;box-sizing:border-box;-moz-box-sizing:border-box}:host ::ng-deep .field-builder-param-title{font-size:16px;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host ::ng-deep .field-builder-param-config-container{display:flex;padding:0 5%;pointer-events:all;width:70%;max-width:70%;overflow:hidden;box-sizing:border-box;-moz-box-sizing:border-box;overflow-y:scroll;overflow-x:hidden}:host ::ng-deep .field-builder-param-reset-box{position:relative;display:block;margin:0;padding:0;width:100%}:host ::ng-deep .field-builder-param-reset-box .pop-input-container,:host ::ng-deep .field-builder-param-reset-box .pop-select-container,:host ::ng-deep .field-builder-param-reset-box .pop-textarea-container{margin:2px 0}:host ::ng-deep .field-builder-param-spacer-xs{display:flex;flex-grow:1;height:5px;padding:0 1%}:host ::ng-deep .field-builder-param-spacer-sm{display:flex;flex-grow:1;height:10px;padding:0 1%}:host ::ng-deep .field-builder-param-spacer-md{display:flex;flex-grow:1;height:20px;padding:0 1%}:host ::ng-deep .field-builder-param-spacer{display:flex;flex-grow:1;height:30px;padding:0 1%}:host ::ng-deep .field-builder-item-options-container .mat-form-field-infix{width:auto;padding:6px 0!important;margin-top:6px!important;border:0!important;font-size:.8em}:host ::ng-deep .field-builder-item-options-active .pop-checkbox-container{margin:2px;min-height:0;height:20px;margin-top:var(--gap-xs)}:host ::ng-deep .field-builder-item-options-container .pop-input-container{margin:5px 2px 0;min-height:20px}:host ::ng-deep .field-builder-item-options-container .pop-input-feedback-container{margin-top:-4px}.cdk-drag-preview{box-sizing:border-box;border-radius:4px;justify-content:center;align-items:center;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.cdk-drag-placeholder{opacity:.6;background:rgba(0,0,0,.1)}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.field-builder-settings-header{padding-top:3px;position:relative;height:35px}:host ::ng-deep .mat-tab-link{height:35px;padding:5px;min-width:100px}"]
            },] }
];
PopEntityFieldItemParamsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService }
];
PopEntityFieldItemParamsComponent.propDecorators = {
    field: [{ type: Input }],
    scheme: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }]
};

class FieldSliderParamComponent {
    constructor() {
        this.events = new EventEmitter();
        this.name = 'FieldSliderParamComponent';
    }
    /**
     * This component expects config to be a Label config
     */
    ngOnInit() {
        if (!this.config.value)
            this.config.value = this.config.defaultValue;
        this.param = new SliderConfig({
            name: this.config.name,
            label: this.config.label,
            column: this.config.column,
            value: this.config.value ? this.config.value : this.config.defaultValue,
            min: this.config.min ? this.config.min : 1,
            max: this.config.defaultValue,
            facade: this.config.facade,
            patch: this.config.patch,
            metadata: this.config.metadata ? this.config.metadata : {}
        });
        PopLog.init(this.name, `init`, this);
    }
}
FieldSliderParamComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-field-slider-param',
                template: `
    <lib-pop-slider (events)="events.emit($event);" [config]=param></lib-pop-slider>
  `
            },] }
];
FieldSliderParamComponent.propDecorators = {
    config: [{ type: Input }],
    events: [{ type: Output }]
};

class PopEntityFieldEntriesComponent extends PopExtendComponent {
    constructor(el, _domRepo, _fieldRepo, _tabRepo) {
        super();
        this.el = el;
        this._domRepo = _domRepo;
        this._fieldRepo = _fieldRepo;
        this._tabRepo = _tabRepo;
        this.scheme = null;
        this.name = 'PopEntityFieldEntriesComponent';
        this.srv = {
            action: ServiceInjector.get(PopEntityActionService),
            dialog: ServiceInjector.get(MatDialog),
            field: undefined,
            request: ServiceInjector.get(PopRequestService),
            tab: ServiceInjector.get(PopTabMenuService),
        };
        this.asset = {
            basePath: undefined,
            entries: [],
            entriesMap: {},
            schemeFieldStorage: undefined,
            type: undefined,
            typeOption: undefined,
        };
        this.ui = {
            label: undefined,
            minMax: undefined,
            editLabel: undefined,
            uniqueLabel: undefined,
            customLabel: undefined,
            entries: [],
            map: {},
            entryLimit: 4
        };
        this.extendServiceContainer();
        /**
         * This should transform and validate the data. The view should try to only use data that is stored on ui so that it is not dependent on the structure of data that comes from other sources. The ui should be the source of truth here.
         */
        this.dom.configure = () => {
            return new Promise((resolve) => {
                this.core = IsObjectThrowError(this.core, true, `${this.name}:configureDom: - this.core`) ? this.core : null;
                if (!this.field)
                    this.field = IsObjectThrowError(this.core, ['entity'], `Invalid Core`) && IsObjectThrowError(this.core.entity, ['id', 'fieldgroup'], `Invalid Field`) ? this.core.entity : null;
                this.asset.type = this.field.fieldgroup.name; // the field group name , ie.. address, phone
                this.asset.typeOption = this.srv.field.getDefaultLabelTypeOptions(); // the select options that belong to the types
                this.asset.basePath = `fields/${this.field.id}/entries`; // api endpoint to hit for field entries
                this._setCustomTraits();
                this.ui.entries = IsArrayThrowError(this.core.entity.entries, false, `Invalid Field Entries`) ? this.core.entity.entries : null;
                this.dom.session.controls = new Map(); // store the entry configs so that changes are not lost when the tabs are changed
                this._buildCustomSettings();
                return resolve(true);
            });
        };
        this.dom.proceed = () => {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (IsObject(this.scheme, true)) {
                    this.asset.schemeFieldStorage = this.srv.field.getSchemeFieldSetting(this.scheme, +this.field.id);
                    this.dom.state.hasScheme = IsObject(this.scheme, true) ? true : false;
                    const primary = this.srv.field.getSchemePrimary(this.scheme);
                    this.dom.state.isPrimary = this.field.fieldgroup.name in primary && +primary[this.field.fieldgroup.name] == this.field.id ? true : false;
                }
                else {
                    this.dom.state.hasScheme = false;
                    this.dom.state.isPrimary = false;
                }
                yield this._showEntries();
                return resolve(true);
            }));
        };
    }
    extendServiceContainer() {
        this.srv.field = this._fieldRepo;
        // delete this._fieldRepo;
    }
    /**
     * This component should have a specific purpose
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * This allows the user to sort the list of options that this field uses
     * @param event
     */
    onOptionSortDrop(event) {
        moveItemInArray(this.ui.entries, event.previousIndex, event.currentIndex);
        this.dom.setTimeout(`update-sort-order`, () => __awaiter(this, void 0, void 0, function* () {
            const requests = [];
            this.ui.entries.map((entry, index) => {
                requests.push(PopRequest.doPatch(`${this.asset.basePath}/${entry.id}`, { sort_order: index, orphaned: -1 }, 1, false));
                const session = this.field.entries.find((e) => +e.id === +entry.id);
                if (IsObject(session, true)) {
                    session.sort_order = index;
                }
                entry.increment = index + 1;
            });
            if (requests.length) {
                this.srv.tab.showAsLoading(true);
                this.dom.setSubscriber(`update-sort-order`, forkJoin(requests).subscribe((res) => {
                    this.srv.field.triggerFieldPreviewUpdate();
                    this.srv.tab.showAsLoading(false);
                }, (err) => {
                    this.dom.setError(err, true);
                    this.srv.tab.showAsLoading(false);
                }));
            }
        }), 0);
        // this.triggerSaveFieldOptions( <PopBaseEventInterface>{ name: 'onChange' } );
    }
    /**
     * When the type of an entry is changed in the database, make sure the changes is updated locally
     * This is will  be removed since we don't want to do types
     * @param index
     * @param event
     */
    onEntryTypeChange(index, event) {
        if (IsValidFieldPatchEvent(this.core, event)) {
            const config = this.ui.entries[index];
            const entry = this.field.entries[index];
            const session = this.dom.session.controls.get(index);
            if (entry && session) {
                entry.type = config.type.control.value;
                this._updateEntryTypeSession(session.type, entry);
                this.dom.session.controls.set(index, session);
                this.setDomSession(index, session);
            }
            setTimeout(() => {
                this.srv.field.triggerFieldPreviewUpdate();
            }, 0);
        }
    }
    /**
     * When the display/label of an entry is changed in the database, make sure the changes is updated locally
     * @param index
     * @param event
     */
    onEntryDisplayChange(index, event) {
        if (index === 0)
            this.ui.label.control.setValue(event.config.control.value, { emitEvent: false });
        if (IsValidFieldPatchEvent(this.core, event)) {
            // PopTemplate.buffer();
            const entry = this.field.entries[index];
            const session = this.dom.session.controls.get(index);
            if (entry && session) {
                entry.name = event.config.control.value;
                this._updateEntryDisplaySession(session.display, entry);
                this.dom.session.controls.set(index, session);
                this.setDomSession(index, session);
            }
        }
        setTimeout(() => {
            this.srv.field.triggerFieldPreviewUpdate();
        }, 0);
    }
    /**
     * When the display/label of an entry is changed in the database, make sure the changes is updated locally
     * @param index
     * @param event
     */
    onEntryActiveChange(index, event) {
        if (IsObject(this.scheme, ['id'])) {
            // here
        }
        else {
            const entry = this.field.entries[index];
            if (entry) {
                if (event.config.control.value) {
                    entry.orphaned = false;
                    entry.orphaned_at = null;
                }
                else {
                    entry.orphaned = true;
                    entry.orphaned_at = PopDate.toIso(new Date());
                }
            }
            setTimeout(() => {
                this._handleMultipleEntries();
                this.srv.field.triggerFieldPreviewUpdate();
            }, 0);
            this.log.info(`onEntryActiveChange`, event);
        }
    }
    onEntryTraitChange(index, trait) {
        this.dom.setTimeout(`entry-trait-${index}`, () => __awaiter(this, void 0, void 0, function* () {
            this.ui.entries.map((entry, entryIndex) => {
                const entryTrait = entry.traits.find((t) => t.name === trait.name);
                if (IsObject(entryTrait, true)) {
                    if (+entryIndex !== +index) {
                        entryTrait.selected = false;
                    }
                    else {
                        entryTrait.selected = true;
                        if (IsObject(this.scheme, ['mapping'])) {
                            if (IsObject(this.asset.schemeFieldStorage, ['trait_entry'])) {
                                this.asset.schemeFieldStorage.trait_entry[entryTrait.name] = entry.id;
                            }
                        }
                    }
                }
            });
            yield this.srv.field.updateSchemeFieldMapping(this.scheme);
            this.log.info(`onEntryTraitChange`);
        }));
    }
    _handleMultipleEntries() {
        this.log.info(`_handleMultipleEntries`);
        this.dom.session.multipleActiveEntries = this._isMultipleActiveEntries();
        if (!(this.dom.session.multipleActiveEntries)) {
            this._disableActiveEntries();
        }
        else {
            this._enableActiveEntries();
        }
    }
    /**
     * A User will be able to add as many labels as they like
     */
    onAddEntryValue() {
        this.dom.setTimeout(`add-entry`, () => __awaiter(this, void 0, void 0, function* () {
            const action = {
                name: 'entry',
                header: 'Add Entry',
                facade: true,
                // component: {
                //   type: DemoOneComponent
                // },
                fields: {
                    name: {
                        form: 'input',
                        pattern: 'Default',
                        name: 'name',
                        hint: true,
                        label: 'Name',
                        required: true,
                        bubble: false,
                        noInitialValue: true,
                        transformation: 'toTitleCase',
                        maxlength: 32,
                        prevent: this.ui.entries.map((entry) => {
                            return StorageGetter(entry, ['display', 'control', 'value'], 'Undefined');
                        })
                    }
                },
                // onEvent: (core: CoreConfig, event: PopBaseEventInterface):Promise<boolean>=>{
                //   return new Promise<boolean>((onEventResolver)=>{
                //     return onEventResolver(true);
                //   });
                // },
                bubbleAll: true,
                blockEntity: true
            };
            const res = yield this.srv.action.do(this.core, action);
            if (IsObject(res, ['name'])) {
                yield this._addEntry(res.name);
            }
        }), 0);
    }
    _addEntry(name) {
        return new Promise((resolve) => {
            this.srv.tab.showAsLoading(true);
            this.dom.state.pending = true;
            const sessionIndex = this.field.entries.filter((x) => x.type !== 'custom').length;
            const increment = sessionIndex + 1;
            const session = this.dom.session.controls.get(sessionIndex);
            if (!name) {
                name = session ? session.display.value : TitleCase(`${(this.field.name ? this.field.name : this.asset.type)} ${increment}`);
            }
            const entry = {
                name: name,
                type: this.asset.typeOption.defaultValue,
                orphaned_at: null,
                sort_order: sessionIndex
            };
            this._makeApiRequests([
                this.srv.request.doPost(`${this.asset.basePath}`, entry, 1, false),
                this.srv.request.doPatch(`fields/${this.field.id}`, { multiple_min: increment, multiple_max: increment }, 1, false),
            ]).then((res) => {
                this._setEntrySessionControls(this.field.entries.filter((x) => x.type !== 'custom')).then((entries) => {
                    this._setEntries(entries).then(() => {
                        this.dom.state.pending = false;
                        setTimeout(() => {
                            // For now I want the amount of field entries to dictate what min/max should be
                            this.field.multiple_min = increment;
                            this.field.multiple_max = increment;
                            this.ui.minMax.minConfig.max = this.field.entries.length;
                            this.ui.minMax.minConfig.min = this.field.entries.length;
                            this.ui.minMax.minConfig.control.setValue(this.field.entries.length);
                            this.ui.minMax.maxConfig.max = this.field.entries.length;
                            this.ui.minMax.maxConfig.min = this.field.entries.length;
                            this.ui.minMax.maxConfig.control.setValue(this.field.entries.length);
                            // this.ui.minMax.triggerOnChange();
                            this.srv.field.triggerFieldPreviewUpdate();
                            this.srv.tab.showAsLoading(false);
                            return resolve(true);
                        }, 0);
                    });
                });
            }, (err) => {
                this.dom.setError(err, true);
                this.srv.tab.showAsLoading(false);
                return resolve(false);
            });
        });
    }
    _collectNewEntryName() {
        const fields = {
            client_id: {
                form: 'select',
                name: 'client_id',
                label: 'Client',
                bubble: true,
                disabled: false,
                required: true,
                options: {
                    resource: 'clients',
                    child: 'account_id'
                },
            },
        };
        const actionConfig = {
            header: 'Add New Field Entry',
            name: 'campaign',
            fields: Object.assign({}, fields),
            submitText: 'Submit',
            postUrl: null,
            blockEntity: true, // implies that fields should not be inherited from the original field.ts file
        };
        this.dom.setTimeout(`collect-name`, () => __awaiter(this, void 0, void 0, function* () {
            const setCampaign = yield this.srv.action.do(this.core, actionConfig);
            this.log.info('setCampaign', setCampaign);
            this.srv.tab.showAsLoading(false);
        }), 0);
    }
    /**
     * A User will be able to remove labels as they like
     */
    onRemoveEntryValue(entry) {
        if (entry && entry.id) {
            this.srv.dialog.open(PopConfirmationDialogComponent, {
                width: '500px',
                data: {
                    option: null,
                    body: `Deleting ${entry.display.control.value} will result in any collected values on this entry being permanently removed.<br><br>Do you wish to continue?`,
                    align: 'left'
                }
            }).afterClosed().subscribe(res => {
                if (res && res.confirmed) {
                    // PopTemplate.buffer();
                    this.dom.state.pending = true;
                    const decrement = this.field.entries.length - 1;
                    this.srv.request.doDelete(`${this.asset.basePath}/${entry.id}`);
                    this._makeApiRequests([
                        this.srv.request.doDelete(`${this.asset.basePath}/${entry.id}`),
                        this.srv.request.doPatch(`fields/${this.field.id}`, { multiple_min: decrement, multiple_max: decrement }, 1, false),
                    ]).then(() => {
                        this._setEntrySessionControls(this.field.entries.filter((x) => x.type !== 'custom')).then((entries) => {
                            this._setEntries(entries).then(() => {
                                this.dom.state.pending = false;
                                setTimeout(() => {
                                    // For now I want the amount of field entries to dictate what min/max should be
                                    this.field.multiple_min = decrement;
                                    this.field.multiple_max = decrement;
                                    this.ui.minMax.minConfig.max = this.field.entries.length;
                                    this.ui.minMax.minConfig.min = this.field.entries.length;
                                    this.ui.minMax.minConfig.control.setValue(this.field.entries.length);
                                    this.ui.minMax.maxConfig.max = this.field.entries.length;
                                    this.ui.minMax.maxConfig.min = this.field.entries.length;
                                    this.ui.minMax.maxConfig.control.setValue(this.field.entries.length);
                                    // Tmp Block ^
                                    this.srv.field.triggerFieldPreviewUpdate();
                                }, 0);
                            });
                        });
                    });
                }
            });
        }
    }
    onMinMaxSetting(event) {
        if (IsValidFieldPatchEvent(this.core, event)) {
            this.srv.field.triggerFieldPreviewUpdate();
        }
    }
    /**
     * The dom destroy function manages all the clean up that is necessary if subscriptions, timeouts, etc are stored properly
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Private Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    _setCustomTraits() {
        this.field.trait.map((trait) => {
            if (!trait.label)
                trait.label = TitleCase(SnakeToPascal(trait.name));
        });
    }
    /**
     * Build the configs for the set of custom settings that this component uses
     * @private
     */
    _buildCustomSettings() {
        this.ui.minMax = new MinMaxConfig({
            bubble: true,
            helpText: 'Set the minimum values that this field should have, the maximum amount of values will be the total entries defined.',
            label: 'Entry Values',
            minRequired: true,
            maxRequired: true,
            minValue: this.field.entries.length,
            maxValue: this.field.entries.length,
            min: this.field.entries.length,
            max: this.field.entries.length,
            limit: 10,
            minLabel: 'Minimum',
            maxLabel: 'Maximum',
            maxColumn: 'multiple_max',
            minColumn: 'multiple_min',
            maxReadonly: true,
            patch: {
                field: 'n/a',
                path: `fields/${this.field.id}`,
                callback: (core, event) => {
                    const newValue = event.config.control.value;
                    Object.keys(newValue).map((key) => {
                        this.field[key] = newValue[key];
                    });
                }
            }
        });
        this.ui.label = new InputConfig(// Piggy back off of the first entry label
        {
            label: 'Label',
            value: this.field.entries[0].name,
            facade: false,
            maxlength: 24,
            patch: {
                field: `name`,
                path: `fields/${this.field.id}/entries/${this.field.entries[0].id}`,
                callback: (core, event) => {
                    this.onEntryDisplayChange(0, event);
                }
            }
        });
        // The edit label setting will determine if the end-user is able to change the the label
        const editLabelSetting = IsObject(this.field.custom_setting.edit_label, true) ? this.field.custom_setting.edit_label : null;
        if (editLabelSetting) {
            this.ui.editLabel = new SwitchConfig({
                name: 'edit_label',
                helpText: editLabelSetting.helpText,
                label: editLabelSetting.label,
                labelPosition: 'after',
                value: editLabelSetting.value,
                metadata: {
                    setting: editLabelSetting,
                },
                facade: true,
                patch: {
                    field: 'value',
                    path: ``,
                    callback: (core, event) => {
                        this.srv.field.storeCustomSetting(this.core, event).then((res) => {
                            if (IsString(res)) {
                                this.ui.editLabel.message = res;
                            }
                            else {
                                this.srv.field.triggerFieldPreviewUpdate();
                            }
                        });
                    }
                }
            });
        }
        // The custom label setting will allow the user to add their own custom label to fit their needs, should only show if edit label setting is true
        const customLabelSetting = IsObject(this.field.custom_setting.custom_label, true) ? this.field.custom_setting.custom_label : null;
        if (customLabelSetting) {
            this.ui.customLabel = new CheckboxConfig({
                name: 'custom_label',
                facade: true,
                helpText: customLabelSetting.helpText,
                label: customLabelSetting.label,
                labelPosition: 'after',
                value: customLabelSetting.value,
                metadata: {
                    setting: customLabelSetting,
                },
                patch: {
                    field: 'value',
                    path: ``,
                    callback: (core, event) => {
                        this.srv.field.storeCustomSetting(this.core, event).then((res) => {
                            if (IsString(res)) {
                                this.ui.customLabel.message = res;
                            }
                            else {
                                this._onCustomLabelChange(this.ui.customLabel.control.value).then(() => {
                                    this.srv.field.triggerFieldPreviewUpdate();
                                });
                            }
                        });
                    }
                }
            });
        }
        // The unique label setting will force all of the field values to use a unique label, should only show if edit label setting is true
        const uniqueLabelSetting = IsObject(this.field.custom_setting.unique_label, true) ? this.field.custom_setting.unique_label : null;
        if (uniqueLabelSetting) {
            this.ui.uniqueLabel = new CheckboxConfig({
                name: 'unique_label',
                facade: true,
                helpText: uniqueLabelSetting.helpText,
                label: uniqueLabelSetting.label,
                labelPosition: 'after',
                value: uniqueLabelSetting.value,
                metadata: {
                    setting: uniqueLabelSetting,
                },
                patch: {
                    field: 'value',
                    path: ``,
                    callback: (core, event) => {
                        this.srv.field.storeCustomSetting(this.core, event).then((res) => {
                            if (IsString(res)) {
                                this.ui.uniqueLabel.message = res;
                            }
                            else {
                                this.srv.field.triggerFieldPreviewUpdate();
                            }
                        });
                    }
                }
            });
        }
    }
    /**
     * A User will be able to add as many labels as they like
     */
    _onCustomLabelChange(value) {
        return new Promise((resolve) => {
            this.dom.state.pending = true;
            if (value) {
                let hasCustom = false;
                this.field.entries.map((item) => {
                    if (item.type == 'custom')
                        hasCustom = true;
                });
                if (!hasCustom) {
                    const entry = {
                        name: 'Custom',
                        type: 'custom'
                    };
                    this._makeApiRequests([this.srv.request.doPost(`${this.asset.basePath}`, entry, 1, false)]).then((res) => {
                        this._setEntrySessionControls(this.field.entries.filter((x) => x.type !== 'custom')).then((entries) => {
                            this._setEntries(entries).then(() => {
                                this.dom.state.pending = false;
                                setTimeout(() => {
                                    this.srv.field.triggerFieldPreviewUpdate();
                                    return resolve(true);
                                }, 0);
                            });
                        });
                    });
                }
                else {
                    setTimeout(() => {
                        this.dom.state.pending = false;
                        this.srv.field.triggerFieldPreviewUpdate();
                        return resolve(true);
                    }, 0);
                }
            }
            else {
                const requests = [];
                this.field.entries.filter((entry) => {
                    if (entry.type === 'custom') {
                        requests.push(this.srv.request.doDelete(`${this.asset.basePath}/${entry.id}`, null, 1, false));
                        return false;
                    }
                    else {
                        return true;
                    }
                });
                if (requests.length) {
                    this._makeApiRequests(requests).then((res) => {
                        this._setEntrySessionControls(this.field.entries.filter((x) => x.type !== 'custom')).then((entries) => {
                            this._setEntries(entries).then(() => {
                                this.dom.state.pending = false;
                                setTimeout(() => {
                                    this.srv.field.triggerFieldPreviewUpdate();
                                }, 0);
                            });
                        });
                    });
                }
                return resolve(true);
            }
        });
    }
    /**
     * Produce a list of the entry values for this field
     */
    _showEntries() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this._setValueEntries().then((entries) => {
                this._setEntrySessionControls(entries).then((res) => {
                    this._setEntries(res).then(() => {
                        this.dom.state.pending = false;
                        return resolve(true);
                    });
                });
            });
        }));
    }
    /**
     * Ensure that the database records match the min/max settings
     * This will remove any excess records in the database that exceed the multiple_min
     * This will create records for an entries that are needed in the database
     * @param patch
     */
    _setValueEntries() {
        return new Promise((resolve) => {
            const provided = DeepCopy(this.field.entries).filter((entry) => {
                return entry.type !== 'custom';
            });
            const entries = [...provided];
            return resolve(entries);
        });
    }
    /**
     * Will make all of the needed api requests
     * @param requests
     * @private
     */
    _makeApiRequests(requests) {
        return new Promise((resolve) => {
            // PopTemplate.buffer();
            forkJoin(requests).subscribe(() => {
                this.srv.request.doGet(this.asset.basePath).subscribe((res) => {
                    res = res.data ? res.data : res;
                    this.field.entries = IsArray(res, true) ? res : [];
                    this.core.entity.entries = JSON.parse(JSON.stringify(this.field.entries));
                    resolve(res);
                });
            }, (err) => {
                PopLog.error(this.name, `_makeApiRequests`, GetHttpErrorMsg(err));
                resolve([]);
            });
        });
    }
    /**
     * Store a set of controls that can store values as the user changes the settings
     * @private
     */
    _setEntrySessionControls(entries) {
        return new Promise((resolve) => {
            let index = 0;
            entries.map((entry) => {
                if (entry.type !== 'custom') {
                    if (!(IsDefined(entry.orphaned)))
                        entry.orphaned = IsDefined(entry.orphaned_at, false);
                    const session = this.dom.session.controls.has(index) ? this.dom.session.controls.get(index) : {
                        id: entry ? entry.id : null,
                        type: this._getEntryTypeConfig(entry),
                        display: this._getEntryDisplayConfig(entry),
                        active: this._getEntryActiveConfig(entry),
                        increment: index + 1,
                    };
                    this._updateSessionControl(index, session, entry);
                    index++;
                }
            });
            return resolve(entries);
        });
    }
    /**
     * Update the entry config to use the stored record, and update the sessions for it
     * @param index
     * @param session
     * @param entry
     * @private
     */
    _updateSessionControl(index, session, entry = null) {
        session.increment = index + 1;
        session.id = entry ? entry.id : null;
        this._updateEntryTypeSession(session.type, entry);
        this._updateEntryDisplaySession(session.display, entry);
        this.dom.session.controls.set(index, session);
        this.setDomSession(index, session);
        return session;
    }
    /**
     * Update the entry type config to use correct value and path
     * @param config
     * @param entry
     * @private
     */
    _updateEntryTypeSession(config, entry = null) {
        // config.value = entry ? entry.type : this.asset.type in this.asset.typeOption ? this.asset.typeOption[ this.asset.type ].defaultValue : 'n/a';
        // config.control.setValue( config.value, { emitEvent: false } );
        // config.patch.path = entry ? `${this.asset.basePath}/${entry.id}` : null;
    }
    /**
     * Update the entry display config to use correct value and path
     * @param config
     * @param entry
     * @private
     */
    _updateEntryDisplaySession(config, entry = null) {
        // config.value = entry ? entry.name : '';
        // config.control.setValue( config.value, { emitEvent: false } );
        // config.patch.path = entry ? `${this.asset.basePath}/${entry.id}` : null;
    }
    /**
     * Update the entry active config to use correct value and path
     * @param config
     * @param entry
     * @private
     */
    _updateEntryActiveSession(config, entry = null) {
    }
    /**
     * Store each entry config in a dom session so that it can be restored when the users is switching tabs
     * @param index
     * @param session
     */
    setDomSession(index, session) {
        const domStorage = StorageGetter(this.dom.repo, ['components', this.name, this.id + '', 'session']);
        if (IsObject(domStorage, ['controls'])) {
            const controls = domStorage.controls;
            controls.set(index, session);
        }
    }
    /**
     * Set entry config objects that will be used in the html template
     * @private
     */
    _setEntries(entries) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.ui.entries = [];
            this.asset.entries = IsArray(entries, true) ? entries.filter((e) => e.type !== 'custom') : [];
            this.asset.entriesMap = ArrayMapSetter(this.asset.entries, 'id');
            this.dom.state.hasMultipleEntries = this.asset.entries.length > 1;
            yield this._checkFieldEntryTraits();
            return resolve(true);
        }));
    }
    /**
     * Manage the type of each entry
     * @param ind
     * @private
     */
    _getEntryTypeConfig(entry) {
        let disabled = false;
        let options = this.asset.type in this.asset.typeOption ? this.asset.typeOption[this.asset.type].options : [];
        if (!IsArray(options, true)) {
            options = [{ value: 'n/a', name: 'N/A' }];
            disabled = true;
        }
        return new SelectConfig({
            label: 'Type',
            options: { values: options },
            disabled: disabled,
            patch: {
                field: 'type',
                path: entry && entry.id ? `${this.asset.basePath}/${entry.id}` : null,
            }
        });
    }
    /**
     * Manage the type of each entry
     * @param ind
     * @private
     */
    _getSessionEntryTraits(entry) {
        const traits = [];
        if (IsObject(this.scheme, ['id', 'mapping'])) {
            const traitEntryMapping = this.asset.schemeFieldStorage.trait_entry;
            const disabledEntries = this.asset.schemeFieldStorage.disabled_entries;
            if (IsObject(this.field, true) && IsArray(this.field.trait, true)) {
                this.field.trait.map((trait) => {
                    traits.push({
                        name: trait.name,
                        disabled: disabledEntries.includes(entry.id),
                        selected: +traitEntryMapping[trait.name] === entry.id
                    });
                });
            }
        }
        return traits;
    }
    _checkFieldEntryTraits() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (this.dom.state.isPrimary && IsArray(this.field.trait, true)) {
                let updateNeeded = false;
                const disabledEntries = this.asset.schemeFieldStorage.disabled_entries;
                const activeEntry = IsArray(this.asset.entries, true) ? this.asset.entries.find(entry => {
                    return !(disabledEntries.includes(entry.id)) && !entry.orphaned_at;
                }) : null;
                if (IsObject(activeEntry, ['id'])) {
                    const traitEntryMapping = this.asset.schemeFieldStorage.trait_entry;
                    this.field.trait.map((trait) => {
                        if (IsUndefined(traitEntryMapping[trait.name]) || !(traitEntryMapping[trait.name] in this.asset.entriesMap) || disabledEntries.includes(+traitEntryMapping[trait.name])) {
                            traitEntryMapping[trait.name] = activeEntry.id;
                            updateNeeded = true;
                        }
                    });
                    if (updateNeeded) {
                        yield this.srv.field.updateSchemeFieldMapping(this.scheme);
                    }
                }
                if (this.dom.session.controls) {
                    this.ui.entries = [];
                    // this.dom.setTimeout( `reset-entries`, () => {
                    this.asset.entries.map((entry, index) => {
                        const sessionEntry = this.dom.session.controls.get(index);
                        if (this.dom.state.isPrimary)
                            sessionEntry.traits = this._getSessionEntryTraits(entry);
                        if (!this.scheme || !entry.orphaned_at)
                            this.ui.entries.push(sessionEntry);
                    });
                    this._handleMultipleEntries();
                    return resolve(true);
                    // }, 0 );
                }
            }
            else {
                if (this.dom.session.controls) {
                    this.ui.entries = [];
                    this.asset.entries.map((entry, index) => {
                        const sessionEntry = this.dom.session.controls.get(index);
                        if (!this.scheme || !entry.orphaned_at)
                            this.ui.entries.push(sessionEntry);
                    });
                    this._handleMultipleEntries();
                }
                return resolve(true);
            }
        }));
    }
    /**
     * Manage the type of each entry
     * @param ind
     * @private
     */
    _getEntryActiveConfig(entry) {
        let value = !entry.orphaned;
        if (IsObject(this.scheme, true)) {
            if (this.asset.schemeFieldStorage.disabled_entries.includes(entry.id)) {
                value = false;
            }
        }
        return new SwitchConfig({
            label: '',
            value: value,
            empty: 'ConvertEmptyToNull',
            tooltip: 'Toggle Visibility',
            facade: true,
            metadata: {
                entry: entry
            },
            // disabled: this.dom.state.hasScheme ? true : false,
            patch: {
                field: 'orphaned_at',
                path: '',
                duration: 0,
                displayIndicator: false,
                callback: (core, event) => __awaiter(this, void 0, void 0, function* () {
                    this.srv.tab.showAsLoading(true);
                    if (IsObject(this.scheme, ['id'])) {
                        if (event.config.control.value) { // remove from disabled
                            this.asset.schemeFieldStorage.disabled_entries.splice(this.asset.schemeFieldStorage.disabled_entries.indexOf(+entry.id), 1);
                        }
                        else { // add to disabled
                            this.asset.schemeFieldStorage.disabled_entries.push(+entry.id);
                        }
                        console.log('here', entry.id, this.asset.schemeFieldStorage.disabled_entries);
                        yield this._checkFieldEntryTraits();
                        yield this.srv.field.updateSchemeFieldMapping(this.scheme);
                        this.srv.tab.showAsLoading(false);
                    }
                    else {
                        const orphaned = event.config.control.value ? null : true;
                        this.dom.setTimeout(`update-orphaned-at-${entry.id}`, PopRequest.doPatch(`${this.asset.basePath}/${entry.id}`, { orphaned: orphaned }, 1, false).subscribe((res) => {
                            res = GetHttpObjectResult(res);
                            this.log.info(`_getEntryActiveConfig`, res);
                            this.srv.tab.showAsLoading(false);
                        }, (err) => {
                            this.dom.setError(err, true);
                            this.srv.tab.showAsLoading(false);
                        }));
                    }
                })
            }
        });
    }
    /**
     * Manage the display of each entry
     * @param index
     * @private
     */
    _getEntryDisplayConfig(entry) {
        //     console.log( '_getEntryDisplayConfig', entry );
        return new InputConfig({
            label: 'Entry Name',
            value: entry && entry.name ? entry.name : '',
            transformation: 'toTitleCase',
            disabled: this.dom.state.hasScheme ? true : false,
            patch: {
                field: 'name',
                path: entry && entry.id ? `${this.asset.basePath}/${entry.id}` : null,
                metadata: {
                    orphaned: -1
                }
            },
            maxlength: 20,
            // validators: [ Validators.required ],
            // minimal: true
        });
    }
    _isMultipleActiveEntries() {
        let active = 0;
        this.ui.entries.map((entry) => {
            if (StorageGetter(entry, ['active', 'control', 'value'], false)) {
                active++;
            }
        });
        this.log.info(`_isMultipleActiveEntries`, active);
        return active > 1;
    }
    _disableActiveEntries() {
        this.log.info(`_disableActiveEntries`);
        this.ui.entries.map((entry) => {
            if (StorageGetter(entry, ['active', 'control', 'value'], false)) {
                entry.active.disabled = true;
                entry.active.control.disable();
            }
        });
    }
    _enableActiveEntries() {
        this.log.info(`_enableActiveEntries`);
        this.ui.entries.map((entry) => {
            if (StorageGetter(entry, ['active', 'control', 'value'], false)) {
                entry.active.disabled = false;
                entry.active.control.enable();
            }
        });
    }
}
PopEntityFieldEntriesComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-field-entries',
                template: "<div class=\"entity-field-value-container\" *ngIf=\"dom.state.loaded\">\n  <div class=\"import-flex-row\">\n    <div class=\"import-flex-column import-flex-item-md\">\n      <!--<div class=\"import-flex-row import-field-border-btm import-flex-item-full\">-->\n      <!--&lt;!&ndash;<div class=\"entity-field-value-label import-flex-item-md import-flex-grow-md\">&ndash;&gt;-->\n      <!--&lt;!&ndash;Entries&ndash;&gt;-->\n      <!--&lt;!&ndash;</div>&ndash;&gt;-->\n      <!--<div class=\"import-flex-item-xs entity-field-value-icon import-flex-center\">-->\n      <!--<i class=\"material-icons sw-pointer sw-hover\"-->\n      <!--*ngIf=\"field.multiple\"-->\n      <!--matTooltip=\"Add\"-->\n      <!--[ngClass]=\"{'sw-disabled': dom.state.pending}\"-->\n      <!--(click)=\"onAddEntryValue();\">-->\n      <!--add-->\n      <!--</i>-->\n      <!--</div>-->\n      <!--</div>-->\n      <div class=\"entity-field-value-content\" *ngIf=\"!field.multiple && ui.entries[0]; let entry;\" [ngClass]=\"{'sw-disabled': dom.state.pending}\">\n        <div class=\"entity-field-value-row\" *ngIf=\"entry && entry.display\">\n          <!--<div class=\"import-flex-item-xs entity-field-value-icon import-flex-center\">-->\n          <!--<div>{{entry.increment}}.</div>-->\n          <!--</div>-->\n          <div class=\"import-flex-item-sm import-flex-grow-xs\">\n            <lib-pop-input class=\"import-flex-item-full\" [config]=\"entry.display\" (events)=\"onEntryDisplayChange(0, $event)\"></lib-pop-input>\n          </div>\n          <div class=\"import-flex-item-sm import-flex-grow-xs\" [style.maxWidth.px]=\"100\">\n            <!--<lib-pop-switch class=\"import-flex-item-full\" [config]=\"entry.active\" (events)=\"onEntryActiveChange(0, $event)\"></lib-pop-switch>-->\n          </div>\n        </div>\n      </div>\n      <div class=\"entity-field-value-content import-flex-item-md\" *ngIf=\"field.multiple\" [ngClass]=\"{'sw-disabled': dom.state.pending}\" cdkDropList (cdkDropListDropped)=\"onOptionSortDrop($event)\">\n\n        <div class=\"import-flex-row import-flex-item-full import-flex-space-between-center field-entries-section-label\">\n          <div class=\"import-flex-item-sm  import-flex-start-center\">\n            <label>Entries</label>\n          </div>\n          <div class=\"import-flex-item-sm import-flex-grow-xs\">\n          </div>\n          <div class=\"import-flex-item-sm import-flex-grow-xs import-flex-center\" [style.maxWidth.px]=\"75\">\n          </div>\n          <div class=\"import-flex-item-sm import-flex-grow-xs import-flex-center\" [style.maxWidth.px]=\"30\">\n            <i class=\"material-icons sw-pointer sw-hover\"\n               matTooltip=\"Add Field Entry\"\n               *ngIf=\"!dom.state.hasScheme\"\n               [ngClass]=\"{'sw-disabled': dom.state.pending}\"\n               (click)=\"onAddEntryValue();\">\n              add\n            </i>\n          </div>\n        </div>\n\n        <div class=\"field-entries-item\" *ngFor=\"let entry of ui.entries; let i = index; last as isLast\" cdkDrag cdkDragLockAxis=\"y\" cdkDragBoundary=\".entity-field-value-content\">\n          <div class=\"entity-field-value-row\" *ngIf=\"entry && entry.display\">\n            <div class=\"import-flex-item-xs entity-field-value-icon import-flex-center\" [ngClass]=\"{'sw-hidden': !dom.state.hasMultipleEntries}\" [style.maxWidth.px]=\"30\">\n              <div>{{entry.increment}}.</div>\n            </div>\n            <div class=\"field-entries-sort\" [ngClass]=\"{'sw-hidden': !dom.state.hasMultipleEntries || dom.state.hasScheme}\" [style.maxWidth.px]=\"50\">\n              <i class=\"material-icons\" cdkDragHandle>\n                drag_indicator\n              </i>\n            </div>\n            <div class=\"import-flex-item-sm import-flex-grow-xs\">\n              <lib-pop-input class=\"import-flex-item-full\" [config]=\"entry.display\" (events)=\"onEntryDisplayChange(i, $event)\"></lib-pop-input>\n            </div>\n            <div class=\"import-flex-item-sm import-flex-grow-xs import-flex-center\" [style.maxWidth.px]=\"75\">\n              <lib-pop-switch [ngClass]=\"{'sw-hidden': !dom.state.hasMultipleEntries}\" class=\"import-flex-item-full\" [config]=\"entry.active\" (events)=\"onEntryActiveChange(i, $event)\"></lib-pop-switch>\n            </div>\n            <div class=\"import-flex-item-sm import-flex-grow-xs import-flex-center\" [style.maxWidth.px]=\"30\">\n              <i class=\"material-icons  sw-pointer sw-hover\"\n                 [ngClass]=\"{'sw-hidden': !dom.state.hasMultipleEntries || dom.state.hasScheme}\"\n                 matTooltip=\"Remove\"\n                 (click)=\"onRemoveEntryValue(entry);\">\n                remove\n              </i>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"entity-field-value-content import-flex-item-md\">\n      <div class=\"import-flex-row import-flex-item-md\">\n        <div class=\"import-flex-column\" *ngIf=\"dom.state.isPrimary\">\n          <div class=\"import-flex-row import-flex-item-full import-flex-space-around-center field-entries-section-label\">\n            <div class=\"import-flex-item-sm entity-field-trait\" *ngFor=\"let trait of field.trait\">\n              <label>{{trait.label}}</label>\n            </div>\n          </div>\n          <div class=\"entity-field-value-row import-flex-space-around-center field-entries-section-label\" *ngFor=\"let entry of ui.entries; let i = index; last as isLast\">\n            <div class=\"import-flex-item-sm entity-field-trait\" *ngFor=\"let trait of entry.traits;\">\n              <div class=\"entity-field-trait-radio\">\n                <mat-icon [ngClass]=\"{'sw-hidden': trait.selected,'sw-disabled': trait.disabled,'sw-pointer': !trait.disabled}\" (click)=\"onEntryTraitChange(i,trait)\">\n                  radio_button_unchecked\n                </mat-icon>\n                <mat-icon class=\"entity-field-trait-checked\" [ngClass]=\"{'sw-hidden': !trait.selected, 'sw-disabled': trait.disabled, 'sw-pointer': !trait.disabled}\" (click)=\"onEntryTraitChange(i,trait)\">\n                  radio_button_checked\n                </mat-icon>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n\n<!--<div class=\"import-flex-row import-flex-item-full\" *ngIf=\"field.multiple && field.custom_setting.edit_label\">-->\n<!--<lib-pop-checkbox [config]=\"ui.editLabel\"></lib-pop-checkbox>-->\n<!--</div>-->\n\n<!--<div class=\"import-flex-row import-flex-item-full\" *ngIf=\"field.custom_setting.unique_label && field.setting.edit_label\">-->\n<!--<lib-pop-checkbox [config]=\"ui.customLabel\"></lib-pop-checkbox>-->\n<!--</div>-->\n",
                styles: [".import-flex-row,.import-flex-row-wrap{display:flex;flex-direction:row}.import-flex-row-wrap{flex-wrap:wrap;padding:0;flex-basis:100%;box-sizing:border-box}.import-flex-row-break{flex-basis:100%;height:0}.import-flex-column-break{flex-basis:100%;width:0}.import-flex-item-icon{min-width:var(--field-icon-width);height:var(--field-icon-height);display:flex;justify-content:center;align-items:center}.import-flex-column-xs{display:flex;flex-direction:column;width:12.5%;min-height:30px}.import-flex-column-sm{flex:1;flex-direction:column;width:25%;min-height:30px}.import-flex-column-md{flex:1;flex-direction:column;width:50%}.import-flex-column-lg{flex:1;flex-direction:column;width:75%;min-height:30px}.import-flex-item-xs{flex-basis:12.5%}.import-flex-item-sm{flex-basis:25%}.import-flex-item-md{flex-basis:50%}.import-flex-item-full{flex-basis:100%}.import-flex-grow-xs{flex-grow:1}.import-flex-grow-sm{flex-grow:2}.import-flex-grow-md{flex-grow:3}.import-flex-grow-lg{flex-grow:4}.import-flex-column{display:flex;flex-direction:column}.import-flex-center{display:flex;align-items:center;justify-content:center}.import-flex-space-center{justify-content:space-around;align-items:center}.import-flex-space-between-center{justify-content:space-between;align-items:center}.import-flex-center-start{display:flex;justify-content:center;align-items:flex-start}.import-flex-start-center{display:flex;justify-content:flex-start;align-items:center}.import-flex-end-center{display:flex;justify-content:flex-end;align-items:center}.import-flex-end{display:flex;align-items:flex-end;justify-content:flex-end}.import-flex-align-end{display:flex;align-self:flex-end}.import-flex-stretch-center{display:flex;justify-content:stretch;align-items:center}.sw-mar-xs{margin:var(--xs)}.sw-mar-sm{margin:var(--sm)}.sw-mar-md{margin:var(--md)}.sw-mar-lg{margin:var(--lg)}.sw-mar-xlg{margin:var(--xlg)}.sw-mar-hrz-xs{margin-left:var(--xs);margin-right:var(--xs)}.sw-mar-hrz-md,.sw-mar-hrz-sm{margin-left:var(--md);margin-right:var(--md)}.sw-mar-hrz-lg{margin-left:var(--lg);margin-right:var(--lg)}.sw-mar-hrz-xlg{margin-left:var(--xlg);margin-right:var(--xlg)}.sw-mar-vrt-xs{margin-top:var(--xs);margin-bottom:var(--xs)}.sw-mar-vrt-md,.sw-mar-vrt-sm{margin-top:var(--md);margin-bottom:var(--md)}.sw-mar-vrt-lg{margin-top:var(--lg);margin-bottom:var(--lg)}.sw-mar-vrt-xlg{margin-top:var(--xlg);margin-bottom:var(--xlg)}.sw-mar-lft-xs{margin-left:var(--xs)}.sw-mar-lft-sm{margin-left:var(--sm)}.sw-mar-lft-md{margin-left:var(--md)}.sw-mar-lft-lg{margin-left:var(--lg)}.sw-mar-lft-xlg{margin-left:var(--xlg)}.sw-mar-rgt-xs{margin-right:var(--xs)}.sw-mar-rgt-sm{margin-right:var(--sm)}.sw-mar-rgt-md{margin-right:var(--md)}.sw-mar-rgt-lg{margin-right:var(--lg)}.sw-mar-rgt-xlg{margin-right:var(--xlg)}.sw-mar-btm-xs{margin-bottom:var(--xs)}.sw-mar-btm-sm{margin-bottom:var(--sm)}.sw-mar-btm-md{margin-bottom:var(--md)}.sw-mar-btm-lg{margin-bottom:var(--lg)}.sw-mar-btm-xlg{margin-bottom:var(--xlg)}.sw-mar-top-xs{margin-top:var(--xs)}.sw-mar-top-sm{margin-top:var(--sm)}.sw-mar-top-md{margin-top:var(--md)}.sw-mar-top-lg{margin-top:var(--lg)}.sw-mar-top-xlg{margin-top:var(--xlg)}.sw-pad-xs{padding:var(--xs)}.sw-pad-md,.sw-pad-sm{padding:var(--md)}.sw-pad-lg{padding:var(--lg)}.sw-pad-xlg{padding:var(--xlg)}.sw-pad-hrz-xs{padding-left:var(--xs);padding-right:var(--xs)}.sw-pad-hrz-sm{padding-left:var(--sm);padding-right:var(--sm)}.sw-pad-hrz-md{padding-left:var(--md);padding-right:var(--md)}.sw-pad-hrz-lg{padding-left:var(--lg);padding-right:var(--lg)}.sw-pad-hrz-xlg{padding-left:var(--xlg);padding-right:var(--xlg)}.sw-pad-vrt-xs{padding-top:var(--xs);padding-bottom:var(--xs)}.sw-pad-vrt-md,.sw-pad-vrt-sm{padding-top:var(--md);padding-bottom:var(--md)}.sw-pad-vrt-lg{padding-top:var(--lg);padding-bottom:var(--lg)}.sw-pad-vrt-xlg{padding-top:var(--xlg);padding-bottom:var(--xlg)}.sw-pad-lft-xs{padding-left:var(--xs)}.sw-pad-lft-sm{padding-left:var(--sm)}.sw-pad-lft-md{padding-left:var(--md)}.sw-pad-lft-lg{padding-left:var(--lg)}.sw-pad-lft-xlg{padding-left:var(--xlg)}.sw-pad-rgt-xs{padding-right:var(--xs)}.sw-pad-rgt-sm{padding-right:var(--sm)}.sw-pad-rgt-md{padding-right:var(--md)}.sw-pad-rgt-lg{padding-right:var(--lg)}.sw-pad-rgt-xlg{padding-right:var(--xlg)}.sw-pad-btm-xs{padding-bottom:var(--xs)}.sw-pad-btm-sm{padding-bottom:var(--sm)}.sw-pad-btm-md{padding-bottom:var(--md)}.sw-pad-btm-lg{padding-bottom:var(--lg)}.sw-pad-btm-xlg{padding-bottom:var(--xlg)}.sw-pad-top-xs{padding-top:var(--xs)}.sw-pad-top-sm{padding-top:var(--sm)}.sw-pad-top-md{padding-top:var(--md)}.sw-pad-top-lg{padding-top:var(--lg)}.sw-pad-top-xlg{padding-top:var(--xlg)}.import-field-border{border:1px solid var(--border)}.import-field-border-top{border-top:1px solid var(--border)}.import-field-border-rgt{border-right:1px solid var(--border)}.import-field-border-btm{border-bottom:1px solid var(--border)}.import-field-border-lft{border-left:1px solid var(--border)}.import-field-border-trans-top{border-top:1px solid transparent}.import-field-border-trans-rgt{border-right:1px solid transparent}.import-field-border-trans-btm{border-bottom:1px solid transparent}.import-field-border-trans-lft{border-left:1px solid transparent}.import-field-border-top-clr{border-top:0!important}.import-field-border-rgt-clr{border-right:0!important}.import-field-border-btm-clr{border-bottom:0!important}.import-field-border-lft-clr{border-left:0!important}:host{width:100%}.entity-field-value-container,.entity-field-value-content{display:flex;flex-direction:column;margin-bottom:5px}.entity-field-value-content{width:100%;position:relative;box-sizing:border-box;min-height:30px;padding-top:var(--gap-s);padding-bottom:var(--gap-s)}.entity-field-value-icon{display:flex;align-items:center;justify-content:center;height:35px;width:35px;font-size:.9em;padding-top:0}.entity-field-value-icon i{font-size:1.3em}.entity-field-value-row{display:flex;flex-direction:row;align-items:center;height:50px;margin-top:1px}.field-entries-section-label{min-height:30px}.entity-field-value-label{text-align:center}.entity-field-value-label,.field-entries-sort{display:flex;justify-content:center;align-items:center}.field-entries-sort{width:10%;cursor:move}.entity-field-trait{display:flex;justify-content:center;align-items:center;min-width:130px;text-align:center;min-height:25px}:host ::ng-deep .entity-field-trait-checked.mat-icon{color:var(--background-focused-button)!important}:host ::ng-deep .entity-field-value-row .import-field-item-container{margin:0!important}:host ::ng-deep .cdk-drag-preview .import-field-item-container{margin:0!important}"]
            },] }
];
PopEntityFieldEntriesComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PopDomService },
    { type: PopFieldEditorService },
    { type: PopTabMenuService }
];
PopEntityFieldEntriesComponent.propDecorators = {
    field: [{ type: Input }],
    scheme: [{ type: Input }]
};

class PopEntityTabListComponent extends PopEntityListComponent {
    constructor(el, route, _domRepo, _tabRepo, APP_GLOBAL) {
        super(el, route, _domRepo, APP_GLOBAL);
        this.el = el;
        this.route = route;
        this._domRepo = _domRepo;
        this._tabRepo = _tabRepo;
        this.APP_GLOBAL = APP_GLOBAL;
        this.name = 'PopEntityTabListComponent';
    }
    /**
     * This component will display a list of entities that the user can interact with
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Clean up the dom of this component
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /************************************************************************************************
     *                                                                                              *
     *                                      Under The Hood                                          *
     *                                    ( Protected Method )                                        *
     *                                                                                              *
     ************************************************************************************************/
    /**
     * Allow for a CoreConfig to be passed in
     * If a CoreConfig does not exits this component needs to be able to create it for itself, uses the internal_name that comes directly for the route
     * or tries to extrapolate it from the current url of the app
     *
     */
    _setCoreConfig() {
        // console.log(this.route);
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.srv.entity.getCoreConfig(this.internal_name, 0).then((core) => {
                this.core = core;
                this.id = `${this.parent}_${this.core.params.internal_name}`;
                this.log.info(`_setCore: initial`, core);
                return resolve(true);
            }, () => {
                return resolve(false);
            });
        }));
    }
    /**
     * Setup basic config
     * Intended to be overridden
     * @private
     */
    _setConfig() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.parentId)
                this.parentId = this.srv.entity.getRouteParentId(this.route);
            if (!this.internal_name)
                this.internal_name = this.srv.entity.getRouteInternalName(this.route);
            if (this.parent === 'client') {
                this.extension.client_id = +this.parentId;
            }
            else if (this.parent === 'account') {
                const account = this.srv.tab.getCore().entity;
                this.extension.client_id = +account.client_id;
                this.extension.account_id = +account.id;
            }
            return resolve(true);
        }));
    }
    /**
     * Manage the sessionStorage settings
     * @private
     */
    _setSessionSettings() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Set session path for variables
            this.asset.tabMenuSessionPath = `Entity.${TitleCase(this.core.params.internal_name)}.Menu`;
            this.asset.showArchivedSessionPath = `Business.${PopBusiness.id}.Entity.${TitleCase(this.parent)}.Table.${TitleCase(this.internal_name)}.showArchived`;
            this.asset.searchValueSessionPath = `Business.${PopBusiness.id}.Entity.${TitleCase(this.parent)}.Table.${TitleCase(this.internal_name)}.searchValue`;
            // Set any session variables
            // SetSessionSiteVar(this.asset.tabMenuSessionPath, null); // remove any menu session data for this entity
            this.dom.state.showArchived = GetSessionSiteVar(this.asset.showArchivedSessionPath, false);
            return resolve(true);
        }));
    }
    /**z
     * Determine the height of the table
     * @private
     */
    _setHeight() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Determine height of the table - have to account if filter bar is enabled
            const overhead = 50; // trial and error , increase to make component shorter, lower to increase height
            this.dom.setHeight(window.innerHeight - 200, overhead);
            return resolve(true);
        }));
    }
    _fetchData(update = false) {
        if (!update)
            this.dom.setTimeout(`lazy-load-fresh-data`, null);
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (this.dataFactory) {
                this.dataFactory(this.parentId, this.dom.state.showArchived ? 1 : 0).then((data) => {
                    // console.log('data', data);
                    data = this._transformData(data);
                    if (update && this.table.config && typeof this.table.config.updateData === 'function') {
                        this.table.config.updateData(data);
                    }
                    PopTemplate.clear();
                    resolve(data);
                }, () => {
                    reject([]);
                });
            }
            else {
                const params = {};
                params[`${this.parent}_id`] = this.parentId;
                // console.log(params);
                this.core.repo.getEntities(Object.assign({ archived: (this.dom.state.showArchived ? 1 : 0) }, params)).then((list) => {
                    list = this._transformData(list);
                    // this.core.repo.setCache('table', this.internal_name, data, 5);
                    if (update && this.table.config && typeof this.table.config.updateData === 'function') {
                        this.table.config.updateData(list);
                    }
                    PopTemplate.clear();
                    resolve(list);
                }, () => {
                    reject([]);
                });
            }
        }));
    }
    _transformData(data) {
        if (!(IsObject(this.asset.fieldKeys, true)))
            this._setFieldKeys(data[0]);
        if (!(IsObject(this.asset.transformations, true)))
            this._setFieldTableTransformations();
        data = this._prepareTableData(data);
        this.core.repo.setCache('table', this.parent, data, 5);
        return data;
    }
    /**
     * Retrieves the data set that this view will represent
     * @param hardReset
     *
     */
    _getTableData(hardReset = false) {
        return new Promise((resolve, reject) => {
            if (this.dom.delay.data)
                clearTimeout(this.dom.delay.data);
            this.core.repo.getCache('table', this.parent).then((cache) => {
                if (IsArray(cache, true)) {
                    this._triggerDataFetch();
                    return resolve({ data: cache });
                }
                else {
                    this._fetchData(false).then((data) => {
                        return resolve({ data: data });
                    });
                }
            });
        });
    }
    _configureFilterBar() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            this.srv.filter.setActive(false);
            return resolve(true);
        }));
    }
    /**
     * Generates a table config that will be used by the nested view component
     * @param reset
     *
     */
    _configureTable(reset = false) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.table.config) {
                this._getTableData(reset).then((tableData) => {
                    if (IsArray(tableData.data, true)) {
                        this.asset.blueprint = tableData.data[0];
                    }
                    this._getTableInterface().then(() => {
                        this.asset.tableInterface.paginator = false;
                        this.table.config = new TableConfig(Object.assign(Object.assign({}, this.asset.tableInterface), tableData));
                    });
                });
            }
            else {
                this.table.config.loading = true;
                this._getTableData().then((result) => {
                    if (IsArray(result.data, true))
                        this.asset.blueprint = result.data[0];
                    this.table.config.buttons = this._buildTableButtons();
                    if (reset) {
                        this.table.config.reset(result.data);
                    }
                    else {
                        this.table.config.updateData(result.data);
                    }
                    this.table.config.loading = false;
                    this.dom.state.refresh = false;
                    this.core.params.refresh = false;
                });
            }
            return resolve(true);
        }));
    }
}
PopEntityTabListComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-tab-list',
                template: "<div *ngIf=\"dom.state.loaded\" class=\"entity-tab-list-container\" [style.height.px]=\"dom.height.inner\">\n  <lib-pop-table #list *ngIf=\"table.config\" [core]=core [config]=\"table.config\" (events)=\"onTableEvent($event)\"></lib-pop-table>\n</div>\n<lib-pop-field-item-group *ngIf=\"ui.actionModal\" [config]=\"ui.actionModal\" (close)=\"onActionModalClose()\"></lib-pop-field-item-group>\n<lib-pop-errors *ngIf=\"dom.error?.message\" [error]=\"dom.error\"></lib-pop-errors>\n",
                styles: [".entity-tab-list-container{position:relative;display:flex;width:auto;height:auto;flex-direction:column;box-sizing:border-box}.entity-tab-list-container lib-pop-table{position:absolute;left:0;top:0;right:0;bottom:10px}:host ::ng-deep tr{height:48px;max-height:48px}:host ::ng-deep td,:host ::ng-deep th{min-width:50px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;height:48px;max-height:48px}:host ::ng-deep th>.mat-sort-header-container{display:flex;min-width:50px}:host ::ng-deep .pop-table-button-control{margin-top:6px!important}:host ::ng-deep .checkbox-column{min-width:25px!important;width:25px!important;padding:0 5px!important;text-align:center!important}::ng-deep th[class*=fk],:host ::ng-deep td[class*=fk]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=fk]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=id],:host ::ng-deep th[class*=id]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=active]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=active],:host ::ng-deep th[class*=active]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=system]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=system],:host ::ng-deep th[class*=system]{text-align:center!important;justify-content:center}:host ::ng-deep th[class*=id]>.mat-sort-header-container{justify-content:center!important;text-align:center!important}:host ::ng-deep td[class*=-name],:host ::ng-deep th[class*=-name]{text-align:left!important;padding-left:20px!important;max-width:200px}:host ::ng-deep th[class*=-name] .mat-sort-header-container{padding-left:0!important;justify-content:left!important;max-width:500px}:host ::ng-deep td[class*=-first],:host ::ng-deep th[class*=-first]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-first] .mat-sort-header-container{min-width:50px!important;padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-last],:host ::ng-deep th[class*=-last]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-last] .mat-sort-header-container{padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-display],:host ::ng-deep th[class*=-display]{text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=-display] .mat-sort-header-container{padding-left:0!important;justify-content:left!important}:host ::ng-deep td[class*=-description],:host ::ng-deep th[class*=-description]{text-align:left!important;padding-left:20px!important;max-width:500px}:host ::ng-deep th[class*=-description] .mat-sort-header-container{padding-left:0!important;justify-content:left!important;max-width:500px}:host ::ng-deep td[class*=email],:host ::ng-deep th[class*=email]{min-width:50px!important;text-align:left!important;padding-left:20px!important}:host ::ng-deep th[class*=email] .mat-sort-header-container{min-width:50px!important;padding-left:0!important;justify-content:left!important}"]
            },] }
];
PopEntityTabListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ActivatedRoute },
    { type: PopDomService },
    { type: PopTabMenuService },
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];
PopEntityTabListComponent.propDecorators = {
    internal_name: [{ type: Input }],
    parentId: [{ type: Input }],
    parent: [{ type: Input }],
    param: [{ type: Input }],
    extension: [{ type: Input }]
};

class PopEntityAddressEditComponent {
    constructor() { }
    ngOnInit() {
    }
}
PopEntityAddressEditComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-address-edit',
                template: "<p>pop-entity-address-edit works!</p>\n",
                styles: [""]
            },] }
];
PopEntityAddressEditComponent.ctorParameters = () => [];

class PopEntitySchemeCustomSettingComponent {
    constructor() { }
    ngOnInit() {
    }
}
PopEntitySchemeCustomSettingComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-pop-entity-scheme-custom-setting',
                template: "<p>pop-entity-scheme-custom-setting works!</p>\n",
                styles: [""]
            },] }
];
PopEntitySchemeCustomSettingComponent.ctorParameters = () => [];

class PopEntityModule {
}
PopEntityModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    MatFormFieldModule,
                    MatInputModule,
                    RouterModule,
                    PortalModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    DragDropModule,
                    PopErrorsModule,
                    PopFieldItemModule,
                    PopFieldItemGroupModule,
                    PopIndicatorsModule,
                    PopTableModule,
                    PopTabMenuModule,
                    MatNativeDateModule,
                    PopContextMenuModule,
                    PopDialogsModule
                ],
                declarations: [
                    PopEntityListComponent,
                    PopEntityTabListComponent,
                    PopEntityAdvancedSearchComponent,
                    PopEntityPortalMenuComponent,
                    PopEntityFieldGroupComponent,
                    PopEntityPortalMenuComponent,
                    PopEntityTabMenuComponent,
                    PopEntityTabComponent,
                    PopEntityTabColumnComponent,
                    PopEntityHistoryComponent,
                    PopEntityAssignmentsComponent,
                    PopEntityProviderDialogComponent,
                    PopEntityAccessComponent,
                    PopEntityFieldComponent,
                    PopEntityFieldActionBtnComponent,
                    PopEntityFieldEditIconComponent,
                    PopEntityFieldDashComponent,
                    PopEntityFieldSpacerComponent,
                    PopEntityFieldBoilerComponent,
                    PopEntityFieldModalComponent,
                    PopEntityEmailComponent,
                    PopEntityPhoneComponent,
                    PopEntityAddressComponent,
                    PopEntityAddressEditComponent,
                    PopEntityDatetimeComponent,
                    PopEntityInputComponent,
                    PopEntitySelectComponent,
                    PopEntitySelectMultiComponent,
                    PopEntityCheckboxComponent,
                    PopEntityRadioComponent,
                    PopEntitySwitchComponent,
                    PopEntityNameComponent,
                    PopEntityTextareaComponent,
                    PopEntityStatusComponent,
                    PopEntitySchemeComponent,
                    PopEntitySchemeDetailsComponent,
                    PopEntitySchemeAssetPoolComponent,
                    PopEntitySchemeAssetLayoutComponent,
                    EntitySchemeLayoutSectionComponent,
                    PopEntitySchemeFieldSettingComponent,
                    EntitySchemeFieldContentComponent,
                    EntitySchemeComponentContentComponent,
                    EntitySchemeTableContentComponent,
                    PopEntityAssetComponentModalComponent,
                    PopEntityAssetFieldModalComponent,
                    FieldInputSettingComponent,
                    FieldLabelSettingComponent,
                    FieldRadioSettingComponent,
                    FieldSelectSettingComponent,
                    FieldSwitchSettingComponent,
                    FieldTextareaSettingComponent,
                    PopEntitySchemeCustomComponent,
                    PopEntityFieldEditorComponent,
                    PopEntityFieldDetailsComponent,
                    PopEntityFieldSettingsComponent,
                    PopEntityFieldPreviewComponent,
                    PopEntityFieldItemsComponent,
                    PopEntityFieldValuesComponent,
                    PopEntityFieldEntriesComponent,
                    PopEntityFieldItemsComponent,
                    PopEntityFieldItemParamsComponent,
                    FieldInputParamComponent,
                    FieldSelectParamComponent,
                    FieldLabelParamComponent,
                    FieldSwitchParamComponent,
                    FieldTextareaParamComponent,
                    FieldRadioParamComponent,
                    FieldSliderParamComponent,
                    FieldNumberParamComponent,
                    PopEntitySchemeCustomSettingComponent,
                ],
                exports: [
                    PopEntityListComponent,
                    PopEntityTabListComponent,
                    PopEntityAdvancedSearchComponent,
                    PopEntityPortalMenuComponent,
                    PopEntityFieldGroupComponent,
                    PopEntityPortalMenuComponent,
                    PopEntityTabMenuComponent,
                    PopEntityTabComponent,
                    PopEntityTabColumnComponent,
                    PopEntityHistoryComponent,
                    PopEntityAssignmentsComponent,
                    PopEntityProviderDialogComponent,
                    PopEntityAccessComponent,
                    PopEntityFieldComponent,
                    PopEntityFieldActionBtnComponent,
                    PopEntityFieldEditIconComponent,
                    PopEntityFieldDashComponent,
                    PopEntityFieldSpacerComponent,
                    PopEntityEmailComponent,
                    PopEntityPhoneComponent,
                    PopEntityFieldModalComponent,
                    PopEntityAddressComponent,
                    PopEntityAddressEditComponent,
                    PopEntityDatetimeComponent,
                    PopEntityInputComponent,
                    PopEntitySelectComponent,
                    PopEntitySelectMultiComponent,
                    PopEntityCheckboxComponent,
                    PopEntityRadioComponent,
                    PopEntitySwitchComponent,
                    PopEntityNameComponent,
                    PopEntityTextareaComponent,
                    PopEntityStatusComponent,
                    PopEntitySchemeComponent,
                    PopEntitySchemeDetailsComponent,
                    PopEntitySchemeAssetPoolComponent,
                    PopEntitySchemeAssetLayoutComponent,
                    EntitySchemeLayoutSectionComponent,
                    PopEntitySchemeFieldSettingComponent,
                    EntitySchemeFieldContentComponent,
                    EntitySchemeComponentContentComponent,
                    EntitySchemeTableContentComponent,
                    PopEntityAssetComponentModalComponent,
                    PopEntityAssetFieldModalComponent,
                    FieldInputSettingComponent,
                    FieldLabelSettingComponent,
                    FieldRadioSettingComponent,
                    FieldSelectSettingComponent,
                    FieldSwitchSettingComponent,
                    FieldTextareaSettingComponent,
                    PopEntitySchemeCustomComponent,
                    PopEntityFieldEditorComponent,
                    PopEntityFieldDetailsComponent,
                    PopEntityFieldSettingsComponent,
                    PopEntityFieldPreviewComponent,
                    PopEntityFieldItemsComponent,
                    PopEntityFieldValuesComponent,
                    PopEntityFieldEntriesComponent,
                    PopEntityFieldItemsComponent,
                    PopEntityFieldItemParamsComponent,
                    PopEntityFieldItemParamsComponent,
                    FieldInputParamComponent,
                    FieldSelectParamComponent,
                    FieldLabelParamComponent,
                    FieldSwitchParamComponent,
                    FieldTextareaParamComponent,
                    FieldRadioParamComponent,
                    FieldSliderParamComponent,
                    FieldNumberParamComponent
                ],
            },] }
];

class PopAjaxDialogRequest {
    constructor(data) {
        const fields = Object.keys(data);
        for (const value of fields) {
            this[value] = data[value];
        }
        if (!data.body)
            this.body = {};
        if (!data.version)
            this.version = 1;
    }
}

class PopPreferenceService {
    constructor(http, request) {
        this.http = http;
        this.request = request;
    }
    /**
     * Get preferences at specified level.
     *  - IE: getPreferences('admin', 'users', 'table');
     *
     * @param level1
     * @param level2
     * @param level3
     * @param level4
     * @returns
     */
    getPreferences(level1, level2 = '', level3 = '', level4 = '') {
        let path = '/preferences/' + level1;
        if (level2)
            path += '/' + level2;
        if (level3)
            path += '/' + level3;
        if (level4)
            path += '/' + level4;
        return this.request.doGet(path, {}, 1);
    }
    /**
     * Saves a preferences at the specified level.
     *  - IE: savePreferences('TablePreferences', {some:object}, 'admin', 'users', 'table');
     *
     * @param name
     * @param data
     * @param level1
     * @param level2
     * @param level3
     * @param level4
     * @returns
     */
    savePreferences(name, data, level1, level2 = '', level3 = '', level4 = '') {
        let path = '/preferences/' + level1;
        if (level2)
            path += '/' + level2;
        if (level3)
            path += '/' + level3;
        if (level4)
            path += '/' + level4;
        return this.request.doPost(path, { name: name, data: data });
    }
    /**
     * Deletes a specified preference. Typically used when resetting to default.
     *  - IE: deletePreferences('TablePreferences', 'admin', 'users', 'table');
     *
     * @param name
     * @param level1
     * @param level2
     * @param level3
     * @param level4
     * @returns
     */
    deletePreferences(name, level1, level2 = '', level3 = '', level4 = '') {
        let path = '/preferences/' + level1;
        if (level2)
            path += '/' + level2;
        if (level3)
            path += '/' + level3;
        if (level4)
            path += '/' + level4;
        path += '/' + name;
        return this.request.doDelete(path);
    }
}
PopPreferenceService.prov = i0.defineInjectable({ factory: function PopPreferenceService_Factory() { return new PopPreferenceService(i0.inject(i1.HttpClient), i0.inject(PopRequestService)); }, token: PopPreferenceService, providedIn: "root" });
PopPreferenceService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopPreferenceService.ctorParameters = () => [
    { type: HttpClient },
    { type: PopRequestService }
];

class PopAuthGuardService {
    constructor(base, router) {
        this.base = base;
        this.router = router;
    }
    canActivate() {
        if (this.base.isAuthExpired()) {
            this.router.navigate(['login']).catch((e) => console.log(e));
            return false;
        }
        return true;
    }
}
PopAuthGuardService.prov = i0.defineInjectable({ factory: function PopAuthGuardService_Factory() { return new PopAuthGuardService(i0.inject(PopBaseService), i0.inject(i1$1.Router)); }, token: PopAuthGuardService, providedIn: "root" });
PopAuthGuardService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopAuthGuardService.ctorParameters = () => [
    { type: PopBaseService },
    { type: Router }
];

class PopRouteVerifiedGuard {
    constructor(APP_GLOBAL) {
        this.APP_GLOBAL = APP_GLOBAL;
    }
    canActivate(route) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const verified = yield this.APP_GLOBAL.isVerified();
            return resolve(verified);
        }));
    }
}
PopRouteVerifiedGuard.prov = i0.defineInjectable({ factory: function PopRouteVerifiedGuard_Factory() { return new PopRouteVerifiedGuard(i0.inject("APP_GLOBAL")); }, token: PopRouteVerifiedGuard, providedIn: "root" });
PopRouteVerifiedGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PopRouteVerifiedGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['APP_GLOBAL',] }] }
];

class PopAccessGuardService {
    constructor(router) {
        this.router = router;
    }
    canActivate(route) {
        var _a;
        if (IsObject(route, ['data']) && IsObject(PopEntity, true) && route.data.can_read && !(PopEntity.checkAccess(route.data.can_read, 'can_read'))) {
            this._exit();
        }
        if (IsObject(route, ['data']) && IsObject(PopEntity, true) && route.data.can_update && !(PopEntity.checkAccess(route.data.can_update, 'can_update'))) {
            this._exit();
        }
        // to check if the entity has entry access
        if (IsObject(route, ['data'])) {
            const internalName = (_a = route.data.internal_name) !== null && _a !== void 0 ? _a : route.data.can_read;
            const entityNames = PopEntity.getEntityEntryAccess(internalName);
            if (IsArray(entityNames, true)) {
                const inaccessible = [];
                entityNames.map((entityName) => {
                    if (!PopEntity.checkAccess(entityName, 'can_read')) {
                        inaccessible.push(TitleCase(entityName.split('_').join(" ")));
                    }
                });
                if (IsArray(inaccessible, true)) {
                    this._exitWithMessage(inaccessible.join(', '));
                    return false;
                }
            }
            else {
                return true;
            }
        }
        return true;
    }
    _exit() {
        SetPopMessage('Access Denied.');
        this.router.navigateByUrl('system/error/403').then(() => true);
    }
    _exitWithMessage(entityName) {
        SetPopMessage(`Access Denied. You need permission for ${entityName}`);
        this.router.navigateByUrl('system/error/403').then(() => true);
    }
}
PopAccessGuardService.prov = i0.defineInjectable({ factory: function PopAccessGuardService_Factory() { return new PopAccessGuardService(i0.inject(i1$1.Router)); }, token: PopAccessGuardService, providedIn: "root" });
PopAccessGuardService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PopAccessGuardService.ctorParameters = () => [
    { type: Router }
];

class PopEntityExtendService extends PopExtendService {
    constructor() {
        super();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
PopEntityExtendService.prov = i0.defineInjectable({ factory: function PopEntityExtendService_Factory() { return new PopEntityExtendService(); }, token: PopEntityExtendService, providedIn: "root" });
PopEntityExtendService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
PopEntityExtendService.ctorParameters = () => [];

/*
 * Public API Surface of pop-common
 */
// Pop Entity

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractDomMixin, AbstractTemplateMixin, AbstractUiMixin, AppGlobal, AppMenus, AppTheme, AppWidgets, ArrayContainsAll, ArrayGroupBy, ArrayKeyBy, ArrayMapSetter, ArrayOnlyUnique, ArrayParentSort, ArrayParentTree, ArrayParentTreeFlatten, ArrayRemoveDupliates, ArrayTreeList, ArraysMatch, ButtonConfig, Capitalize, CheckboxConfig, CleanObject, ClearEmptyValues, ConvertArrayToOptionList, ConvertDateFormat, ConvertDateToDateTimeFormat, ConvertDateToTimeFormat, ConvertObjectToUri, CoreConfig, CustomPanelComponent, DateConfig, DateRangeConfig, DateRangeExpansionItemsComponent, DateRangePanelComponent, DeepCopy, DeepMerge, DestroyComponentDom, DestroyComponentTemplate, DestroyServiceDom, DetermineEntityName, DynamicSort, EntityAssignmentTab, EntityExtendInterface, EntityGeneralTab, EntityHistoryTab, EntityMenu, EntityParams, EntitySchemeComponentContentComponent, EntitySchemeFieldContentComponent, EntitySchemeLayoutSectionComponent, EntitySchemeSectionConfig, EntitySchemeTab, EntitySchemeTableContentComponent, EvaluateWhenCondition, EvaluateWhenConditions, ExpansionItemsComponent, FIELD_CUSTOM_SETTING, FieldConfig, FieldEditorTab, FieldGroupConfig, FieldInputParamComponent, FieldInputSettingComponent, FieldItemArrayValue, FieldItemBooleanValue, FieldItemConfig, FieldItemGroupConfig, FieldItemInterface, FieldItemModel, FieldItemModelConfig, FieldItemOptionValues, FieldItemRules, FieldItemTextValue, FieldItemView, FieldLabelParamComponent, FieldLabelSettingComponent, FieldNumberParamComponent, FieldRadioParamComponent, FieldRadioSettingComponent, FieldSelectParamComponent, FieldSelectSettingComponent, FieldSliderParamComponent, FieldSwitchParamComponent, FieldSwitchSettingComponent, FieldTextareaParamComponent, FieldTextareaSettingComponent, GetAuthStorage, GetComponentAssetContainer, GetComponentDomContainer, GetComponentTemplateContainer, GetComponentTraitContainer, GetComponentUiContainer, GetCustomFieldSettings, GetEncodedSessionSiteVar, GetHttpArrayResult, GetHttpErrorMsg, GetHttpObjectResult, GetHttpResult, GetObjectTransformations, GetObjectVar, GetPatternValidator, GetRouteAlias, GetServiceAssetContainer, GetServiceContainer, GetServiceDom, GetServiceUiContainer, GetSessionSiteVar, GetSingularName, GetSiteVar, GetStringAbbrv, GetTabMenuButtons, GetTabMenuConfig, GetVerbStateTheme, HeaderInterceptor, HyphenToPascal, InputConfig, InterpolateEntityRoute, InterpolateEntityRoutes, InterpolateString, IsAliasable, IsArray, IsArrayThrowError, IsCallableFunction, IsDefined, IsEntity, IsNumber, IsObject, IsObjectThrowError, IsString, IsStringError, IsUndefined, IsValidChangeEvent, IsValidCoreSignature, IsValidFieldPatchEvent, JsonCopy, LabelConfig, LabelPipe, LibContainerDirective, LibOutsideClickDirective, LibTrackCapsLockDirective, MainSpinnerComponent, MatchEmail, MatchPassword, MaterialModule, MetadataConfig, ModelOptionValues, NumberConfig, ObjectContainsTagSearch, ObjectsMatch, ParentHeightSetter, ParseForAlias, ParseLinkUrl, ParseModelValue, ParseModuleRoutes, ParseModuleRoutesForAliases, ParseObjectDefinitions, ParseStringForEntityField, ParseStringForParams, ParseUrlForEntityFields, ParseUrlForParams, PatternValidation, PhonePipe, PopAccessGuardService, PopActionDialogComponent, PopAjaxDialogComponent, PopAjaxDialogModule, PopAjaxDialogRequest, PopAliasRouteMap, PopApp, PopAuth, PopAuthGuardService, PopBaseModule, PopBaseService, PopBusiness, PopButtonComponent, PopCacFilterComponent, PopCacFilterModule, PopCacFilterViewComponent, PopCacheRedirectUrl, PopCacheService, PopCheckboxComponent, PopCommonModule, PopCommonService, PopComponentResolver, PopConfirmationDialogComponent, PopContainerService, PopContextMenuComponent, PopContextMenuConfig, PopContextMenuModule, PopCredentialService, PopDate, PopDateComponent, PopDatePickerComponent, PopDateRangeComponent, PopDatetimeService, PopDialogsModule, PopDisplayService, PopDomService, PopEntity, PopEntityAccessComponent, PopEntityActionService, PopEntityAddressComponent, PopEntityAddressEditComponent, PopEntityAdvancedSearchComponent, PopEntityAssetComponentModalComponent, PopEntityAssetFieldModalComponent, PopEntityAssignmentsComponent, PopEntityCheckboxComponent, PopEntityDatetimeComponent, PopEntityEmailComponent, PopEntityEventService, PopEntityExtendService, PopEntityFieldActionBtnComponent, PopEntityFieldComponent, PopEntityFieldDashComponent, PopEntityFieldDetailsComponent, PopEntityFieldEditIconComponent, PopEntityFieldEditorComponent, PopEntityFieldEntriesComponent, PopEntityFieldGroupComponent, PopEntityFieldItemParamsComponent, PopEntityFieldItemsComponent, PopEntityFieldModalComponent, PopEntityFieldPreviewComponent, PopEntityFieldSettingsComponent, PopEntityFieldSpacerComponent, PopEntityFieldValuesComponent, PopEntityHistoryComponent, PopEntityInputComponent, PopEntityListComponent, PopEntityModule, PopEntityNameComponent, PopEntityPhoneComponent, PopEntityPortalMenuComponent, PopEntityProviderDialogComponent, PopEntityRadioComponent, PopEntityRepoService, PopEntitySchemeAssetLayoutComponent, PopEntitySchemeAssetPoolComponent, PopEntitySchemeComponent, PopEntitySchemeCustomComponent, PopEntitySchemeDetailsComponent, PopEntitySchemeFieldSettingComponent, PopEntitySelectComponent, PopEntitySelectMultiComponent, PopEntityService, PopEntityStatusComponent, PopEntitySwitchComponent, PopEntityTabColumnComponent, PopEntityTabComponent, PopEntityTabListComponent, PopEntityTabMenuComponent, PopEntityTextareaComponent, PopEntityUtilFieldService, PopEntityUtilParamService, PopEntityUtilPortalService, PopEnv, PopErrorsComponent, PopErrorsModule, PopExtendComponent, PopExtendDynamicComponent, PopExtendService, PopExternalApi, PopFieldEditorService, PopFieldItemComponent, PopFieldItemErrorComponent, PopFieldItemGroupComponent, PopFieldItemGroupModule, PopFieldItemHelperComponent, PopFieldItemLoaderComponent, PopFieldItemModule, PopFilter, PopHistory, PopHref, PopIndicatorsModule, PopInitializerModule, PopInputComponent, PopLabelComponent, PopLeftMenuComponent, PopLeftMenuModule, PopLog, PopLogService, PopMenuComponent, PopMenuModule, PopMessage, PopMessageDialogComponent, PopMinMaxComponent, PopNavigationDialogComponent, PopNumberComponent, PopPipe, PopPipeService, PopPortal, PopPreferenceService, PopRadioComponent, PopRequest, PopRequestExternalService, PopRequestService, PopResourceService, PopRouteAliasMap, PopRouteHistoryResolver, PopRouteVerifiedGuard, PopSchemeComponent, PopSelectComponent, PopSelectFilterComponent, PopSelectListComponent, PopSelectModalComponent, PopSelectModalDialogComponent, PopSelectMultiComponent, PopSideBySideComponent, PopSideBySideModule, PopSliderComponent, PopSuccessDialogComponent, PopSwitchComponent, PopTabMenuComponent, PopTabMenuModule, PopTabMenuSectionBarComponent, PopTabMenuService, PopTableComponent, PopTableDialogComponent$1 as PopTableDialogComponent, PopTableModule, PopTableViewComponent, PopTemplate, PopTemplateComponent, PopTemplateModule, PopTextComponent, PopTextareaComponent, PopTimeComponent, PopTransform, PopUid, PopUser, PopWidgetBarComponent, PopWidgetBarModule, RadioConfig, RandomArrayElement, RandomInt, RegexPatterns, ResourceConfig, Response401Interceptor, SchemeComponentConfig, SchemeComponentParams, SectionConfig, SelectConfig, SelectFilterConfig, SelectListConfig, SelectModalConfig, SelectMultiConfig, ServiceInjector, SessionEntityFieldUpdate, SetCoreValue, SetPopAliasRouteMap, SetPopApp, SetPopAuth, SetPopBusiness, SetPopCacheRedirectUrl, SetPopComponentResolver, SetPopDate, SetPopEntity, SetPopEnv, SetPopExternalApi, SetPopFilter, SetPopHistory, SetPopHref, SetPopLogger, SetPopMessage, SetPopPipe, SetPopPortal, SetPopRequest, SetPopRouteAliasMap, SetPopSchemeComponent, SetPopTemplate, SetPopUser, SetServiceInjector, SetSessionSiteVar, SetSiteVar, SideBySideConfig, Sleep, SnakeToPascal, SpaceToHyphenLower, SpaceToSnake, StorageGetter, StorageSetter, StringReplaceAll, SwitchConfig, TabConfig, TabMenuConfig, TabSectionBarConfig, TableConfig, TableOptionsConfig, TextConfig, TextareaConfig, TimeConfig, TitleCase, ToActiveOrArchivedPipe, ToArray, ToObject, ToYesNoPipe, TruncatePipe, ValidateAlpha, ValidateAlphaLowercaseNoSpace, ValidateAlphaNoSpace, ValidateAlphaNumeric, ValidateAlphaNumericNoSpace, ValidateAlphaNumericNoUnderscore, ValidateBlacklist, ValidateEmail, ValidateNumeric, ValidateNumericNoSpace, ValidatePassword, ValidatePhone, ValidateUrl, ValidateUsername, ValidateZip, ValidationErrorMessages, fadeInOut, slideInOut, PopMenuService as a, ClickOutsideDirective as b, PopTemplateService as c, PopCacFilterBarService as d, PopTemplateAjaxLoaderComponent as e, PopTemplateWelcomeComponent as f, PopTemplateGoodByeComponent as g, PopTemplateErrorComponent as h, PopTemplateBufferComponent as i, PopRedirectsModule as j, PopErrorRedirectComponent as k, PopCacheRedirectComponent as l, PopGuardRedirectComponent as m, PopEntitySchemeComponentService as n, CustomDateAdapter as o, PopTableDialogComponent as p, ErrorComponent as q, InDialogComponent as r, GroupComponent as s, CharacterIconPipe as t, DialogComponent as u, PopEntityFieldBoilerComponent as v, PopEntitySchemeService as w, PopEntitySchemeCustomSettingComponent as x };
//# sourceMappingURL=pop-common.js.map
